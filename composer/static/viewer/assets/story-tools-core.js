!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var o;"undefined"!=typeof window?o=window:"undefined"!=typeof global?o=global:"undefined"!=typeof self&&(o=self),(o.storytools||(o.storytools={})).core=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
exports.time = require('./time/controls');
exports.maps = require('./time/maps');
exports.maps.pins = require('./time/pins');
exports.maps.boxes = require('./time/boxes');
exports.utils = require('./time/utils');

},{"./time/boxes":2,"./time/controls":3,"./time/maps":5,"./time/pins":7,"./time/utils":9}],2:[function(require,module,exports){
var utils = require('./utils');

function Box(options) {
    this.range = options.range || null;
    this.data = options.data || null;
    this.layerIds = options.layerIds || null;
    this.center = options.center || null; // ol.Coordinate
    this.resolution = options.resolution || null;
    this.allowPan = options.allowPan;
    this.allowZoom = options.allowZoom;
    this.speed = options.speed;  // interval, seconds
    this.title = options.title || '';
    this.id = options.id || new Date().getUTCMilliseconds();
    this.zoom = options.zoom || null;
    this._offset = 0;
    if (this.range === null) {
        if(this.data) {
            this.range = utils.createRange(this.data[0], this.data[this.data.length - 1]);
        }else{
            this.range = utils.createRange(options.start_time, options.end_time);
        }
    }
    // @todo possible divide by zero if speed.interval not set!
    this._steps = this.data === null ? Math.floor(this.range.width() / this.speed.interval) + 1: this.data.length;
}
Box.prototype.getSteps = function() {
    return this._steps;
};
Box.prototype.getRange = function() {
    return this.range;
};
Box.prototype.getIndex = function(instant) {
    return this.data ? utils.find(this.data, instant) :
        Math.floor(Math.min(this.range.width(), Math.max(0, instant - this.range.start)) / this.speed.interval);
};
Box.prototype.getDate = function(idx) {
    idx = idx - this._offset;
    return this.data ? this.data[idx] : this.range.start + (idx * this.speed.interval);
};


function getTime(props, prop) {
    var val = props[prop];
    if (typeof val != 'undefined') {
        return val *= 1000;
    }
    return null;
}

/**
 * Load Box from geojson, reprojecting from 4326 to the provided
 * projection.
 * @param {Object} geojson
 * @param {String} projection
 * @returns array of Box features
 */
exports.loadFromGeoJSON = function(geojson, projection) {
    if (projection) {
        projection = ol.proj.get(projection);
    }
    return geojson.features.map(function(f) {
        var props = f.properties;
        //props.the_geom = f.geometry;
        props.id = f.id;
        props.start_time = getTime(props, 'start_time');
        props.end_time = getTime(props, 'end_time');
        return new Box(props, projection);
    });
};

function findBox(boxes, idx) {
    var i, ii;
    var box;
    for (i = 0, ii = boxes.length; i < ii; i++) {
        box = boxes[i];
        if (idx >= box._offset) {
            if (i + 1 < ii) {
                if (idx < boxes[i + 1]._offset) {
                    break;
                }
            } else {
                break;
            }
        }
    }
    return box;
}

exports.BoxModel = function(boxArray) {
    var boxes,
        range,
        steps;
    function updateBoxes(neu) {
        var offset = 0;
        boxes = neu.map(function(b) {
            var box = new Box(b);
            box._offset = offset;
            offset += box.getSteps();
            return box;
        });
        range = utils.computeRange(boxes, 'range');
        steps = offset;
    }
    updateBoxes(boxArray);
    this.getRange = function() {
        return range;
    };
    this.getSteps = function() {
        return steps;
    };
    this.getRangeAt = function(s, e) {
        var start = findBox(boxes, s);
        var end = findBox(boxes, e);
        return utils.createRange(start.getDate(s), end.getDate(e));
    };
    this.getIndex = function(instant) {
        var idx = 0, i;
        if (instant < boxes[0].getRange().start) {
            return 0;
        }
        for (i = 0; i < boxes.length; i++) {
            var box = boxes[i];
            var range = box.getRange();
            if (instant >= range.start && instant <= range.end) {
                idx += box.getIndex(instant);
                break;
            } else {
                idx += box.getSteps();
            }
        }
        return idx;
    };
    this.setRange = function(newRange) {
        if (boxes.length == 1) {
            // @todo support for range
            if (utils.isRangeLike(newRange)) {
                throw new Error('not supported yet');
            }
            boxes[0].data = newRange;
            // @todo must set here or constructor is dumb and doesn't recompute
            boxes[0].range = utils.computeRange(newRange);
        } else {
            // @todo finish
            console.log('more than one story box to update range with!');
        }
        updateBoxes(boxes);
    };
    this.update = function(options) {

    };
};

exports.findBox = findBox;
exports.Box = Box;

},{"./utils":9}],3:[function(require,module,exports){
var utils = require('./utils');
var models = require('./models');
var timeslider = require('./slider');
var line = require('./line');
var maps = require('./maps');

/**
 * Facade object and guts of slider/timeline/playback logic.
 *
 * Since playback is driven by a timeout, all other potential events
 * are fired in an async manner to ensure a uniform API.
 */
function TimeController(model, slider, timeline, controls) {
    this.model = model;
    this.slider = slider;
    this.timeline = timeline;
    this.loop = 'none';

    var self = this,
        currentTimelineWindow = getTimelineWindow(),
        isAdjusting = false,
        started = false,
        timeout = null,
        events = new utils.Events(),
        deferred = [];

    function getTimelineWindow() {
        return utils.createRange(timeline.getWindow());
    }

    function adjust(fun, a, b) {
        if (isAdjusting) {
            return;
        }
        isAdjusting = true;
        try {
            fun(a, b);
        } finally {
            isAdjusting = false;
        }
    }

    function centerTimeline(range) {
        var c = model.mode === 'cumulative' ? range.end : range.center();
        timeline.moveTo(c);
        publishRangeChange(range);
    }

    function adjustSlider(range) {
        if (timeline.isWindowMax()) {
            return;
        }

        var center = range.center();
        var idx = model.getIndex(center);
        if (model.mode === 'cumulative') {
            slider.growTo(idx);
        } else {
            slider.center(idx);
        }
        timeline.setTime(center);
        publishRangeChange(slider.getRange());
    }

    function updateSlider(range) {
        if (utils.rangesEqual(range, currentTimelineWindow)) {
            return;
        }
        range = utils.createRange(range);
        // zoom or scroll event?
        if (range.width() !== currentTimelineWindow.width()) {
            timeline.moveToCurrentTime();
        } else {
            adjustSlider(range);
        }
        currentTimelineWindow = range;
    }

    slider.on('rangeChanged', function(range) {
        clearTimeout();
        adjust(centerTimeline, range);
        schedule();
    });
    timeline.on('rangechanged', function(range) {
        adjust(updateSlider, range);
    });
    timeline.on('select', function(properties) {
        console.log("Selected items: ", properties.items);
    });
    function clearTimeout() {
        if (timeout !== null) {
            window.clearTimeout(timeout);
        }
        timeout = null;
    }

    function move(amt) {
        timeout = null;
        var atEnd;
        if (model.mode === 'cumulative') {
            atEnd = slider.grow(amt);
        } else {
            atEnd = slider.move(amt);
        }
        if (atEnd) {
            if (self.loop === 'chapter') {
                slider.jump(0);
            } else if (self.loop === 'story') {
              var currentChapter = window.location.hash.split("/")[2];
              var nextChapter = currentChapter === undefined || currentChapter === null ? 2 : parseInt(currentChapter) + 1;
              if(nextChapter <= controls.chapterCount) {
                  console.log("Going to Chapter ", nextChapter);
                  window.location.href = '#/chapter/' + nextChapter;
                  slider.jump(0);
              } else {
                console.log("Going to Chapter 1");
                window.location.href = '#/chapter/1';
                slider.jump(0);
              }
            } else {
              self.stop();
            }
        }
        centerTimeline(slider.getRange());
        if (started) {
            schedule();
        }
    }

    function schedule() {
        if (started) {
            // @todo respect playback interval options...
            var wait = model.interval;
            $.when.apply($, deferred).then(function() {
                if (started) {
                    timeout = window.setTimeout(move, wait, 1);
                }
            }, function() {
                // the deferred was rejected, if arguments provided, this
                // represents an error state so don't continue playing
                if (arguments.length === 0 && started && timeout === null) {
                    timeout = window.setTimeout(move, wait, 1);
                } else {
                    self.stop();
                }
            });
            deferred = [];
        }
    }

    function run() {
        publishStateChange("running");
        move(1);
    }

    function publishRangeChange(data) {
        if (typeof data === 'undefined') {
            data = slider.getRange();
        }
        publish("rangeChange", data);
    }

    function publishStateChange(state) {
        publish("stateChange", state);
    }

    function publish(event, data) {
        events.event(event).publish(data);
    }

    this.defer = function(defer) {
        deferred.push(defer);
    };
    this.getCurrentRange = function() {
        return slider.getRange();
    };
    this.update = function(options) {
        model.update(options);
        slider.update(model);
        timeline.update(model);
        window.setTimeout(publishRangeChange, 0);
    };
    this.start = function() {
        if (started) {
            return;
        }
        deferred = [];
        started = true;
        window.setTimeout(run, 0);
    };
    this.stop = function() {
        deferred = [];
        started = false;
        clearTimeout();
        window.setTimeout(publishStateChange, 0, 'stopped');
    };
    this.next = function() {
        clearTimeout();
        window.setTimeout(move, 0, 1);
    };
    this.prev = function() {
        clearTimeout();
        window.setTimeout(move, 0, -1);
    };
    this.isStarted = function() {
        return started;
    };
    this.isReady = function() {
        var r = model.getRange();
        return r.start !== null && r.end !== null;
    };
    this.on = function(event, f) {
        events.event(event).subscribe(f);
    };
}

/**
 * annotation model:
 * title
 * content
 * the_geom
 * start_time
 * end_time
 * in_timeline
 * in_map
 * appearance
 */
function Annotations(annotations) {
    var ann = annotations || [];
    function inTimeline() {
        return ann.filter(function(a) {
            return a.in_timeline;
        });
    }
    this.getTimeLineAnnotatons = function() {
        return inTimeline(true);
    };
    this.update = function(annotations) {
        this.ann = annotations;
    };
}

/**
 * box model:
 * title
 * content
 * the_geom
 * start_time
 * end_time
 * in_timeline
 * in_map
 * appearance
 */
function Boxes(boxes) {
    var box = boxes || [];
    function inTimeline() {
        return box.filter(function(b) {
            return true;//b.in_timeline;
        });
    }
    this.getTimeLineBoxes = function() {
        return inTimeline(true);
    };
    this.update = function(boxes) {
        this.box = boxes;
    };
}


/**
 * common lingo:
 * instant: a single point in time
 * extent, range: has property start and end
 * start, end: long values representing UTC (internal) but generally,
 *             a date
 * interval: multipier * precision
 * precision: tick, second, minute, hour, day, week, month, year
 *            note: tick implies a multipier of 1
 * speed: object with property seconds (framerate) and optional interval
 *
 * options = {
 *   annotations: [ {
 *      title,
 *      content,
 *      the_geom,
 *      start_time,
 *      end_time,
 *      in_timeline,
 *      in_map,
 *      appearance
 *      } ... ],
 *   map: ol.Map,
 *   boxes : [ {
 *      range : {
 *          start, end
 *      },
 *      center: ol.Coordinate,
 *      resolution: float,
 *      static: boolean,
 *      speed: { interval, seconds }
 *      } ... ],
 *   data : [ date ...] | rangeWithInterval,
 *   playback : {
 *      mode: instant | range | cumulative,
 *      fixed: boolean
 *   },
 *   timeLineId : element id,
 *   timeSliderId : element id,
 *   controlsId: element id
 *
 * }
 */
function create(options) {
    // @todo for layers, annotations won't exist and, intially, we won't
    //       have playback settings for layers...
    var model,
        annotations = new Annotations(options.annotations),
        boxes = options.boxes,
        controls = {'chapterCount': options.chapterCount},
        totalRange,
        slider,
        timeline,
        mapController;
    options.boxy = new Boxes(options.boxes);
    // make a default box if none provided
    if (typeof boxes == 'undefined' || boxes.length === 0) {
        var interval = 0, data = null;
        if (Array.isArray(options.data)) {
            data = options.data;
            totalRange = utils.computeRange(options.data);
        } else {
            interval = options.data.interval || utils.pickInterval(options.data);
            totalRange = options.data;
        }
        boxes = [{
                data: data,
                range: totalRange,
                speed: {
                    interval: interval,
                    seconds: 3
                }
            }];
    }

    model = new models.TimeModel(options, boxes, annotations);
    slider = new timeslider.TimeSlider(options.timeSliderId || 'slider', model);
    timeline = new line.TimeLine(options.timeLineId || 'timeline', model);

    var timeControls = new TimeController(model, slider, timeline, controls);
    mapController = new maps.MapController(options, timeControls);
    return timeControls;
}

exports.create = create;
exports.maps = maps;
exports.utils = utils;

},{"./line":4,"./maps":5,"./models":6,"./slider":8,"./utils":9}],4:[function(require,module,exports){
var Timeline = require('vis/lib/timeline/Timeline');
var utils = require('./utils');

/**
 * Display annotations or other temporal instant/extent. Allow adjusting
 * time (either instant or extent) by dragging.
 * @param {type} id
 * @param {type} model
 * @returns {_L1.TimeLine}
 */
exports.TimeLine = function(id, model) {
    var dom = $("#" + id);
    var timeline = null;
    // @revisit - internally the timeline seems to apply the offset when
    //            creating a tool tip, does this cause problems elsewhere?
    var offset = new Date().getTimezoneOffset() * 60 * 1000;

    function init(model) {
        var elements = [], layer_groups = [], groups = [], options;
        var story_pin_label = 'Annotation';
        var range = model.getRange();
        if (range.isEmpty()) {
            range = utils.createRange(Date.now());
        }
        elements = model.annotations.getTimeLineAnnotatons().map(function(ann, i) {
            /*jshint eqnull:true */
            var start = ann.start_time != null ? ann.start_time : range.start;
            var end = ann.end_time != null ? ann.end_time : range.end;
            var type = start === end ? 'box' : 'range';
            return {
                id: utils.sha1('annotation' + ann.id),
                start: start,
                end: end,
                content: ann.content || ann.title,
                title: ann.title,
                type: type,
                group: story_pin_label
            };
        });

        // Add the Group we there are elements.
        if(elements.length > 0){
            groups.push({id: story_pin_label, title: story_pin_label, time: []});
        }

        if (model.boxy.box) {
            var box_elements = model.boxy.box.map(function(box, i) {
                /*jshint eqnull:true */
                var start = box.range != null ? box.range.start : range.start;
                var end = box.range != null ? box.range.end : range.end;
                var type = 'background';
                return {
                    id: utils.sha1('box' + box.id),
                    start: start,
                    end: end,
                    content: box.content || box.title,
                    type: type
                };
            });
            elements = elements.concat(box_elements);
        }


        layer_groups = $.map(model.storyLayers, function(lyr, i) {
            var id = lyr.get('id');
            var title = lyr.get('title');
            var times = lyr.get('times') || [];
            var group = null;

            if (times.length > 0) {
                if (times.length > 1500) {
                    elements.push({
                        id: utils.sha1(id),
                        group: id,
                        content: "",
                        start: times[0],
                        end: times[times.length - 1],
                        type: 'range'
                    });
                } else {
                    for (var j = 0; j < times.length; j++) {
                        var time = times[j];
                        elements.push({
                            id: utils.sha1(id + time),
                            group: id,
                            content: "",
                            start: time,
                            type: 'box'
                        });
                    }
                }
                group = {
                id: id,
                content: title
            };

            }
            return group;
        });

        groups = groups.concat(layer_groups);

        if(elements.length > 5000){
            console.debug("%s elements is too large for the timeline to render performant, no worries we will take care of it.", elements.length);
            elements = [];

        }

        console.debug("Building the timeline from %s to %s with %s elements and %s groups.",
              new Date(range.start).toISOString(),
              new Date(range.end).toISOString(),
              elements.length,
              groups.length);

        var height = $( document ).height() * 0.35;

        options = {
            min: range.start,
            max: range.end,
            start: range.start,
            end: range.end,
            height: (height < 300)? 138: height,
            maxHeight: 400,
            showCurrentTime: false
        };
        if (timeline === null) {
            timeline = new Timeline(dom.get(0), elements, options);
            timeline.setGroups(groups);
            timeline.setCurrentTime(range.start);
            timeline.addCustomTime();
        } else {
            timeline.setOptions(options);
            timeline.setItems(elements);
            timeline.setGroups(groups);
        }
    }
    init(model);

    // updates from user dragging customtime bar
    // @todo will not update slider currently at min timeline zoom as it
    // is difficult to determine whether an event is from zooming or dragging
    // need to wrap event handling to better differentiate
    timeline.on('timechanged', function() {
        timeline.moveTo(timeline.getCustomTime(), {animate: false});
    });

    this.moveTo = function(time) {
        timeline.moveTo(time, {animate: false});
        this.setTime(time);
    };
    this.setTime = function(time) {
        timeline.setCustomTime(time + offset);
    };
    this.isWindowMax = function() {
        return utils.rangesEqual(timeline.getWindow(), model.getRange());
    };
    this.moveToCurrentTime = function() {
        var current = timeline.getCustomTime().getTime();
        var width = utils.createRange(timeline.getWindow()).width();
        var range = model.getRange();
        if (current === range.start) {
            timeline.setWindow(range.start, range.start + width, {animate: false});
        } else if (current === range.end) {
            timeline.setWindow(range.end - width, range.end, {animate: false});
        } else {
            timeline.moveTo(current, {animate: false});
        }
    };
    this.getWindow = function() {
        return timeline.getWindow();
    };
    this.on = function(ev, cb) {
        timeline.on(ev, cb);
    };
    this.update = init;
    // @todo detect click or dblclick event and position based on % of total width
};

},{"./utils":9,"vis/lib/timeline/Timeline":31}],5:[function(require,module,exports){
/*jshint loopfunc: true */
var utils = require('./utils');
var moment = require('moment');

/**
 * Read the provide ol3 WMS capabilities document
 * @param {type} caps
 * @returns an object of name->[date|interval]|interval-range mappings
 */
exports.readCapabilitiesTimeDimensions = function(caps, openlayers2) {
    var dimensions = {};
    function readRange(subparts) {
        if (subparts.length < 2) {
            throw new Error('expected 2 parts for range : ' + subparts);
        }
        var range = utils.createRange(subparts[0], subparts[1]);
        if (subparts.length == 3) {
            range.duration = subparts[2];
            range = new utils.Interval(range);
        }
        return range;
    }
    function readPart(part) {
        var subparts = part.split('/');
        if (subparts.length == 1) {
            return utils.getTime(subparts[0]);
        } else {
            return readRange(subparts);
        }
    }
    function parse(dimension) {
        var dims = openlayers2 ? dimension : dimension.split(',');
        if (dims.length == 1) {
            var read = readPart(dims[0]);
            return typeof read === 'number' ? [read] : read;
        }
        return dims.map(readPart);
    }
    if (openlayers2 === true) {
        if (caps.dimensions && caps.dimensions.time) {
            dimensions = parse(caps.dimensions.time.values);
        } else {
            dimensions = undefined;
        }
    } else {
        // @todo need to make layer scanning recursive?
        caps.value.capability.layer.layer.forEach(function(lyr) {
          for (var i = 0; i < lyr.dimension.length; i ++) {
            if (lyr.dimension[i] && lyr.dimension[i].name && lyr.dimension[i].name === 'time') {
              dimensions[lyr.name] = parse(lyr.dimension[i].value);
            }
          }
        });
    }
    return dimensions;
};

function TileLoadListener(tileStatusCallback) {
    var tilesLoading = {};
    var deferred = $.Deferred(),
          cancelled = false;
    function remainingTiles() {
        var t = 0;
        for (var i in tilesLoading) {
            t += tilesLoading[i];
        }
        return t;
    }
    var listener = {
        deferred: deferred,
        cancel: function() {
            cancelled = true;
            for (var s in tilesLoading) {
                tilesLoading[s] = 0;
            }
            if (deferred) {
                deferred.reject(); // notify we've aborted but w/out error
            }
            if (tileStatusCallback) {
                tileStatusCallback(0);
            }
        },
        tileQueued: function(source) {
            if (cancelled) {
                return;
            }
            var key;
            if (source instanceof ol.source.TileWMS) {
                key = source.getUrls()[0];
            } else if (source instanceof ol.source.ImageWMS) {
                key = source.getUrl();
            }
            tilesLoading[key] = (tilesLoading[key] || 0) + 1;
            if (tileStatusCallback) {
                tileStatusCallback(remainingTiles());
            }
        },
        tileLoaded: function(event, source) {
            if (cancelled) {
                return;
            }
            var key;
            if (source instanceof ol.source.TileWMS) {
                key = source.getUrls()[0];
            } else if (source instanceof ol.source.ImageWMS) {
                key = source.getUrl();
            }
            tilesLoading[key] -= 1;
            var remaining = remainingTiles();
            if (tileStatusCallback) {
                tileStatusCallback(remaining);
            }
            if (remaining === 0 && deferred) {
                deferred.resolve();
            }
        }
    };
    // workaround for when the tiles are cached and no events are triggered
    // this adds a constant (small) additional delay to the current play rate
    // under optimal (cached) conditions
    // @todo can this safely be shortened?
    window.setTimeout(function() {
        if (Object.keys(tilesLoading).length === 0) {
            listener.cancel();
        }
    },100);
    return listener;
}

function filterVectorLayer(storyLayer, range) {
    var timeAttr = storyLayer.get('timeAttribute'), l_features = storyLayer.get('features') || storyLayer.getLayer().get('features');
    if (timeAttr === undefined || l_features === undefined) {
        return;
    }
    range = utils.createRange(range);
    // loop over all original features and filter them
    var features = [];
    var layer = storyLayer.getLayer();
    visitAllLayerFeatureTimes(storyLayer, function(f,r) {
        if (range.intersects(r)) {
            features.push(f);
        }
    }, l_features);
    layer.getSource().clear(true);
    layer.getSource().addFeatures(features);
    return features;
}


function filterVectorBoxLayer(storyLayer, range) {
    var timeAttr = storyLayer.get('timeAttribute'), l_features = storyLayer.get('features');
    if (timeAttr === undefined || l_features === undefined) {
        return;
    }
    range = utils.createRange(range);
    // loop over all original features and filter them
    var features = [];
    visitAllLayerFeatureTimes(storyLayer, function(f,r) {
        if (range.intersects(r)) {
            features.push(f);
        }
    });

    return features;
}
/**
 * Call the provided visitor function on the specified features using the
 * configuration provided in the layer. The visitor function will be called
 * with the feature, and start and end time, if any. The features visited will
 * be, in order of priority: the provided (optional) features argument, the
 * layer property 'features', the layer's source features.
 * @param {StoryLayer} story layer
 * @param {function} visitor function(feature, start, end)
 * @param {array} features (opitonal)
 */
function visitAllLayerFeatureTimes(storyLayer, visitor, features) {
    var startAtt = storyLayer.get('timeAttribute');
    var endAtt = storyLayer.get('endTimeAttribute');
    var rangeGetter;
    var layer = storyLayer.getLayer();
    features = features || storyLayer.get('features') || layer.getSource().getFeatures();
    if (endAtt) {
        rangeGetter = function(f) {
            if(f.range){
                return f.range;
            }else {
                var start = f.get(startAtt);
                var end = f.get(endAtt);
                return utils.createRange(start, end);
            }
        };
    } else {
        rangeGetter = function(f) {
            if(f.range){
                return f.range;
            }else {
                var start = f.get(startAtt);
                return utils.createRange(start, start);
            }
        };
    }
    utils.visitRanges(features, rangeGetter, visitor);
}

/**
 * Compute the range of the provided features using the layer's configured
 * timeattributes. If the optional features array is omitted, the features
 * will come from the layer.
 * @param {StoryLayer} storyLayer
 * @param {array} features (optional)
 * @returns {storytools.core.time.Range} range of features
 */
exports.computeVectorRange = function(storyLayer, features) {
    var startAtt = storyLayer.get('timeAttribute');
    var endAtt = storyLayer.get('endTimeAttribute');
    var layer = storyLayer.getLayer();
    features = features || storyLayer.get('features') || layer.getSource().getFeatures();
    return utils.computeRange(features, function(f) {
        return utils.createRange(f.get(startAtt), f.get(endAtt));
    });
};

exports.filterVectorLayer = filterVectorLayer;
exports.filterVectorBoxLayer = filterVectorBoxLayer;

exports.MapController = function(options, timeControls) {
    var loadListener = null,
          tileStatusCallback = options.tileStatusCallback,
          storyMap = options.storyMap;
    function layerAdded(layer) {
        var source, image;
        var loaded = function(event) {
            // grab the active loadListener to avoid phantom onloads
            // when listener is cancelled
            var currentListener = loadListener;
            if (currentListener) {
                currentListener.tileLoaded(event, source);
            }
        };
        var loadstart = function() {
            // grab the active loadListener to avoid phantom onloads
            // when listener is cancelled
            var currentListener = loadListener;
            if (currentListener) {
                currentListener.tileQueued(source);
            }
        };
        if (layer instanceof ol.layer.Tile && layer.getSource() instanceof ol.source.TileWMS) {
            source = layer.getSource();
            source.on('tileloadstart', loadstart);
            source.on('tileloadend', loaded);
            // @todo handle onerror and cancel deferred with an example
            // to stop automatic playback
            source.on('tileloaderror', loaded);
        } else if (layer instanceof ol.layer.Image && layer.getSource() instanceof ol.source.ImageWMS) {
            source = layer.getSource();
            source.on('imageloadstart', loadstart);
            source.on('imageloadend', loaded);
            source.on('imageloaderror', loaded);
        }
    }
    function createLoadListener() {
        if (loadListener !== null) {
            loadListener.cancel();
        }
        loadListener = new TileLoadListener(tileStatusCallback);
        return loadListener;
    }

    function updateCenterAndZoom(range){
        var currentBoxes = filterVectorBoxLayer(storyMap.storyBoxesLayer, range);
        var currentPinFeatures = filterVectorLayer(storyMap.storyPinsLayer, range);

        if (currentPinFeatures && currentPinFeatures.length > 0) {
          return;
        } else if (currentBoxes && currentBoxes.length > 0) {
            var currentBox = currentBoxes[0];

            if (currentBox.center) {
                storyMap.animateCenterAndZoom(currentBox.center, currentBox.zoom);
            }
        } else {
            if (storyMap.returnToExtent) {
               storyMap.animateCenterAndZoom(storyMap.getCenter(), storyMap.getZoom());
            }
        }
    }

    function updateLayers(range) {
        var storyLayers = storyMap.getStoryLayers();
        var time = new Date(range.start).toISOString();
        if (range.start != range.end) {
            time += "/" + new Date(range.end).toISOString();
        }
        for (var i = 0; i < storyLayers.getLength(); i++) {
            var storyLayer = storyLayers.item(i), layer = storyLayer.getLayer();
            if ((layer instanceof ol.layer.Tile && layer.getSource() instanceof ol.source.TileWMS) ||
                  (layer instanceof ol.layer.Image && layer.getSource() instanceof ol.source.ImageWMS)) {
                if (storyLayer.get('times')) {
                    layer.getSource().updateParams({TIME: time});
                }
            } else if (layer instanceof ol.layer.Vector) {
                filterVectorLayer(storyLayer, range);
            }
        }
        // this is a non-story layer - not part of the main collection
        filterVectorLayer(storyMap.storyPinsLayer, range);
        if (storyLayers.getLength() >= 1) {
            timeControls.defer(createLoadListener().deferred);
        }
    }
    var me = this;
    me.layers = {};
    storyMap.getStoryLayers().on('add', function(ev) {
        var lyr = ev.element, id = lyr.get('id');
        if (me.layers[id] !== true) {
            layerAdded(lyr.getLayer());
            me.layers[id] = true;
        }
    });
    storyMap.getStoryLayers().forEach(function(lyr) {
        var id = lyr.get('id');
        if (id !== undefined && me.layers[id] !== true) {
            layerAdded(lyr.getLayer());
            me.layers[id] = true;
        }
    });
    timeControls.on('rangeChange', updateCenterAndZoom);
    timeControls.on('rangeChange', updateLayers);
};

},{"./utils":9,"moment":13}],6:[function(require,module,exports){
var utils = require('./utils');
var BoxModel = require('./boxes').BoxModel;

/**
 * @todo document me
 */
exports.TimeModel = function(options, boxes, annotations) {
    
    var events = new utils.Events(),
        boxModel = new BoxModel(boxes);

    this.annotations = annotations;
    this.boxes = boxes;
    this.boxy = options.boxy;
    this.storyLayers = [];
    this.fixed = false;
    this.mode = 'instant';
    this.interval = 1000;

    function init(opts) {
        if (opts.hasOwnProperty('fixed')) {
            this.fixed = opts.fixed;
        }

        if (opts.hasOwnProperty('speed') && opts.speed !== undefined) {
            this.interval = opts.speed;
        }

        if (opts.hasOwnProperty('mode') && opts.mode !== undefined) {
            this.mode = opts.mode;
        }
        if (opts.hasOwnProperty('annotations')) {
            this.annotations.update(opts.annotations);
        }
        if (opts.hasOwnProperty('boxes')) {
            this.boxy.update(opts.boxes);
        }

        if (opts.hasOwnProperty('storyLayers')) {
            this.storyLayers = opts.storyLayers;
        }

        // @todo is the best name for this
        if (opts.hasOwnProperty('data')) {
            boxModel.setRange(opts.data);
        }
    }

    init.call(this, options);
    this.getRange = function() {
        return boxModel.getRange();
    };
    this.getTotalRange = function() {
        // @todo need to access layers and cached dimension data
        //       and consider annotations?
        throw Error('not implemented');
    };
    this.update = init;
    this.getSteps = function() {
        return boxModel.getSteps();
    };
    this.getIndex = function(instant) {
        return boxModel.getIndex(instant);
    };
    this.getRangeAt = function(i, j) {
        return boxModel.getRangeAt(i, j);
    };
};

},{"./boxes":2,"./utils":9}],7:[function(require,module,exports){
var format = new ol.format.GeoJSON();


var StoryPin = function(data, projection) {
    ol.Feature.call(this, data);
    if (data) {
        if (data.the_geom) {
            var geom = data.the_geom;
            if (typeof geom === 'string' || 'type' in geom) {
                geom = format.readGeometry(geom, {
                    featureProjection: projection
                });
            }
            this.setGeometry(geom);
            delete data.the_geom;
        }
        this.setId(data.id);
    }
};
StoryPin.prototype = Object.create(ol.Feature.prototype);
StoryPin.prototype.constructor = StoryPin;
// expose these simply for the timeline - it doesn't know they're features
['id','start_time','end_time','content','title','in_timeline','in_map', 'auto_show', 'pause_playback'].forEach(function(prop) {
    Object.defineProperty(StoryPin.prototype, prop, {
        get: function() {
            var val = this.get(prop);
            return typeof val === 'undefined' ? null : val;
        },
        set: function(val) {
            this.set(prop, val);
        }
    });
});

/*
 var start = ann.start_time != null ? ann.start_time : range.start;
 var end = ann.end_time != null ? ann.end_time : range.end;
 var type = start === end ? 'box' : 'range';
 return {
 id: ann.id,
 start: start,
 end: end,
 content: ann.content || ann.title,
 title: ann.title,
 type: type
 };
 */

function getTime(props, prop) {
    var val = props[prop];
    if (typeof val != 'undefined') {
        return val *= 1000;
    }
    return null;
}

/**
 * Load StoryPins from geojson, reprojecting from 4326 to the provided
 * projection.
 * @param {Object} geojson
 * @param {String} projection
 * @returns array of StoryPin features
 */
exports.loadFromGeoJSON = function(geojson, projection) {
    if (projection) {
        projection = ol.proj.get(projection);
    }
    return geojson.features.map(function(f) {
        var props = f.properties;
        props.the_geom = f.geometry;
        props.id = f.id;
        props.start_time = getTime(props, 'start_time');
        props.end_time = getTime(props, 'end_time');
        return new StoryPin(props, projection);
    });
};

exports.StoryPin = StoryPin;

},{}],8:[function(require,module,exports){
var utils = require('./utils');
/**
 * Visual feedback of complete story line. Allow dragging of range, click
 * to position.
 *
 * Playback Modes
 * - fixed cumulative (min fixed at 0, max adjusts with tick)
 * - fixed range playback (range fixed, window adjusts with tick)
 * - fixed instant (like fixed range but range of 0)
 * - open range playback (fully adjustable min/max, window adjusts with tick)
 *
 * Internal model
 * - 0-N where N is either the number of instants or the total number of extents
 *
 * @param {type} id
 * @param {type} model
 * @returns {TimeSlider}
 */
exports.TimeSlider = function(id, model) {
    var slider = $("#" + id)[0];
    var events = new utils.Events();
    var initialized = false;
    var singleSlider;

    function init(model) {
        var options = {
            step: 1,
            start: [0, 0],
            animate: false,
            connect: true,
            range: {
                min: 0,
                max: model.getSteps() - 1
            },
            behaviour: 'drag-snap'
        };
        singleSlider = false;

        /*if (model.fixed) {
            // @todo need model interval
        }*/

        if (model.mode === 'cumulative') {
            singleSlider = true;
            options.connect = 'lower';
        } else if (model.mode === 'instant') {
            singleSlider = true;
            options.connect = false;
        } else if (model.mode === 'range') {
            if (model.fixed) {
                // ideally we'd support snap but it breaks fixed
                options.behaviour = 'drag-fixed';
            }
        } else {
            throw "invalid model mode : " + model.mode;
        }

        if (initialized) {
            // have to update values based on current state
            var range = getSliderRangeInternal();
            if (singleSlider) {
                options.start = range[0];
            } else {
                if (range[0] === range[1]) {
                    range[1] += 1;
                }
                options.start = range;
            }
        } else if (singleSlider) {
            options.start = 0;
        }

        if (!initialized) {
            if(slider)
            {
                noUiSlider.create(slider, options);
                slider.noUiSlider.on('slide', function (ev) {
                    var range = getRange();
                    events.event('rangeChanged').publish(range);
                });
                initialized = true;
            }
        }

    }

    init(model);

    function getSliderRangeInternal() {
        var range = slider.noUiSlider.get();
        if (! Array.isArray(range)) {
            range = parseInt(range, 10);
            range = [model.mode === 'cumulative' ? 0 : range, range];
        } else {
            range = range.map(function(i) { return parseInt(i, 10); });
        }
        return range;
    }

    function getRange() {
        var range = getSliderRangeInternal();
        return model.getRangeAt(range[0], range[1]);
    }

    function width() {
        var range = getSliderRangeInternal();
        return range[1] - range[0];
    }

    function isAtEnd(left) {
        var range = getSliderRangeInternal();
        if (left) {
            return range[0] === 0;
        }
        return range[1] === model.getSteps()-1;
    }

    function setValue(val) {
        // normalize nouislider.val to handle array
        if (singleSlider) {
            slider.noUiSlider.set(val[1]);
        } else {
            slider.noUiSlider.set(val);
        }
    }

    this.slider = slider;
    this.on = function(event, fn) {
        if(initialized) {
            events.event(event).subscribe(fn);
        }
    };
    this.getSliderRangeInternal = getSliderRangeInternal;
    this.center = function(index) {
        var half = Math.floor(width() / 2);
        setValue([index - half, index + half]);
    };
    this.move = function(amt) {
        var vals  = getSliderRangeInternal();
        vals[0] += amt;
        vals[1] += amt;
        setValue(vals);
        return isAtEnd(amt < 0);
    };
    this.grow = function(amt) {
        var vals = getSliderRangeInternal();
        vals[1] += amt;
        setValue(vals);
        return isAtEnd(false);
    };
    this.growTo = function(where) {
        var vals = getSliderRangeInternal();
        vals[1] = where;
        setValue(vals);
        return isAtEnd(false);
    };
    this.jump = function(to) {
        setValue([to, to + width()]);
    };
    this.getRange = getRange;
    this.update = init;
};

},{"./utils":9}],9:[function(require,module,exports){
var moment = require('moment');

/**
 * Get the number of milliseconds from the provided arg.
 * @param arg - either Date, range (returns start), string or number
 * @returns milliseconds or null if nothing provided
 */
var getTime = function(arg) {
    var type = typeof arg;
    if (type === 'number') {
        return arg;
    }
    if (arg instanceof Date) {
        return arg.getTime();
    }
    if (type === 'string') {
        return parseDate(arg).getTime();
    }
    /*jshint eqnull:true */
    if (arg == null) {
        return null;
    }
    if (isRangeLike(arg)) {
        /*jshint eqnull:true */
        return getTime(arg.start != null ? arg.start : arg.end);
    }
    throw new Error('cannot call getTime with ' + type + ", : " + arg);
};

var isRangeLike = function(object) {
    /*jshint eqnull:true */
    return object != null && (object.hasOwnProperty('start') || object.hasOwnProperty('end'));
};

exports.isRangeLike = isRangeLike;

exports.createRange = function(start, end) {
    if (arguments.length === 1) {
        var other = start;
        if (isRangeLike(other)) {
            start = other.start;
            end = other.end;
        } else {
            end = start;
        }
    }
    /*jshint eqnull:true */
    if (start != null && end != null && start > end) {
        throw new Error('start > end');
    }
    return new Range(getTime(start), getTime(end));
};

exports.rangesEqual = function(a, b) {
    return getTime(a.start) === getTime(b.start) &&
        getTime(a.end) === getTime(b.end);
};

function rangeContains(range, time) {
    /*jshint eqnull:true */
    if (time == null) {
        throw new Error('invalid time argument');
    }
    /*jshint eqnull:true */
    return ((range.start != null ? time >= range.start : true) &&
           (range.end != null ? time < range.end : true)) ||
           range.start === range.end && time === range.start;
}

exports.parseISODuration = function(duration) {
    var values = exports.isoDurationToMoment(duration);
    return moment.duration(values).asMilliseconds();
};

exports.Interval = function(start, end, duration) {
    if (typeof start === 'object') {
        var opts = start;
        start = opts.start;
        end = opts.end;
        duration = opts.duration;
    }
    if (start === end) {
        throw new Error('interval should have width');
    }
    Range.call(this, start, end);
    this.duration = duration;
    this.interval = exports.parseISODuration(this.duration);
    this.offset = exports.createOffsetter(this);
};

function Range(start, end) {
    if (isNaN(start) || isNaN(end)) {
        throw new Error('invalid start and/or end');
    }
    this.start = start;
    this.end = end;
}
/**
 * extend this Range by another. This algorithm will consider an open-ended
 * range to represent a minimum of start and maximum of end.
 * @param {type} other
 * @returns {undefined}
 */
Range.prototype.extend = function(other) {
    /*jshint eqnull:true */
    if (!isRangeLike(other)) {
        other = exports.createRange(other);
    }
    var start = getTime(other.start);
    var end = getTime(other.end);
    if (start == null) {
        start = end;
    }
    if (end == null) {
        end = start;
    }
    if (start != null) {
        if (this.start == null) {
            this.start = start;
        } else {
            this.start = Math.min(this.start, start);
        }
    }
    if (end != null) {
        if (this.end == null) {
            this.end = end;
        } else {
            this.end = Math.max(this.end, end);
        }
    }
};
Range.prototype.intersects = function(other) {
    if (isRangeLike(other)) {
        /*jshint eqnull:true */
        var es = other.start == null ? Number.MIN_VALUE : other.start;
        var ee = other.end == null ? Number.MAX_VALUE : other.end;
        // intersection if (any)
        // effective end in this range
        // effective start in this range
        // effective start before and effective end after
        return rangeContains(this, es) ||
            rangeContains(this, ee) ||
            es <= this.start && ee >= this.end;
    } else {
        return rangeContains(this, getTime(other));
    }
};
Range.prototype.toString = function() {
    return new Date(this.start).toUTCString() + " : " + new Date(this.end).toUTCString();
};
Range.prototype.center = function() {
    return Math.floor(this.start + (this.end - this.start) / 2);
};
Range.prototype.width = function() {
    return this.end - this.start;
};
Range.prototype.isEmpty = function() {
    /*jshint eqnull:true */
    return this.end == null && this.start == null;
};
exports.Range = Range;



/**
 * Compute the overall range of provided args. Args may be an array of:
 * date or long, range, object with property/function yielding range for the
 * object.
 * @param {type} args
 * @returns range will have start/end even if the same time.
 */
exports.computeRange = function(args, rangeGetter) {
    var range = new Range(null, null);
    exports.visitRanges(args, rangeGetter, function(arg, r) {
        range.extend(r);
    });
    /*jshint eqnull:true */
    if (range.start == null) {
        range.start = range.end;
    }
    if (range.end == null) {
        range.end = range.start;
    }
    return range;
};

exports.visitRanges = function(objects, rangeGetter, visitor) {
    var getRange;
    if (typeof rangeGetter == 'string') {
        getRange = function(object) {
            return object[rangeGetter];
        };
    } else if (typeof rangeGetter == 'function') {
        getRange = rangeGetter;
    } else {
        getRange = function(object) {
            return isRangeLike(object) ? object : exports.createRange(object);
        };
    }
    for (var i = 0, ii = objects.length; i < ii; i++) {
        var object = objects[i];
        visitor(object, getRange(object));
    }
};

/** for the given what, find the index in the items that what is closest
 * to. items must be sorted. The lowest closest value possible is returned.
 */
exports.binarySearch = function(items, what) {
    var start = 0;
    var stop = items.length - 1;
    var mid = stop + start / 2 | 0;
    var val;
    if (what < items[0]) {
        return 0;
    }
    if (what > items[stop]) {
        return items.length - 1;
    }
    while ((val = items[mid]) !== what && start < stop) {
        if (what > val) {
            if (what < items[mid + 1]) {
                return mid;
            }
        } else if (what < val) {
            if (what > items[mid - 1]) {
                return mid - 1;
            }
            stop = mid - 1;
        }
        mid = stop + start / 2 | 0;
    }
    return mid;
};

exports.find = function(items, what) {
    if (what < items[0]) {
        return 0;
    }
    for (var i = 0, ii = items.length - 1; i < ii; i++) {
        if (what >= items[i] && what < items[i + 1]) {
            return i;
        }
    }
    return items.length - 1;
};

exports.Events = function() {
    var topics = {};

    // @todo introduce setting topics with arguments and logging/exception
    // on un-fired event

    function event(id) {
        var callbacks, method,
                topic = id && topics[ id ];
        if (!topic) {
            callbacks = jQuery.Callbacks();
            topic = {
                publish: callbacks.fire,
                subscribe: callbacks.add,
                unsubscribe: callbacks.remove
            };
            if (id) {
                topics[ id ] = topic;
            }
        }
        return topic;
    }

    return {
        event: event
    };
};

exports.pickInterval = function(range) {
    var intervals = [
        moment.duration(1, 'seconds').asMilliseconds(),
        moment.duration(1, 'minutes').asMilliseconds(),
        moment.duration(1, 'hours').asMilliseconds(),
        moment.duration(1, 'days').asMilliseconds(),
        moment.duration(1, 'weeks').asMilliseconds(),
        moment.duration(1, 'months').asMilliseconds(),
        moment.duration(1, 'years').asMilliseconds()
    ];
    return intervals[Math.max(exports.find(intervals, range.width()) - 1, 0)];
};

exports.stringToMoment = function(date, format){
    return moment(date, format);
};

exports.getTime = getTime;

/**
 * Read an iso duration into a moment.js object.
 * @param {string} duration
 * @returns {object} with moment.js info
 */
exports.isoDurationToMoment = function(duration) {
    if (duration.charAt(0) != 'P') {
        throw new Error('expected P as starting duration : ' + duration);
    }
    var pattern = /(\d+)(\w)/g;
    var date = null, time = null, values = {};
    duration = duration.substring(1);
    if (duration.indexOf('T') >= 0) {
        var parts = duration.split('T');
        date = parts[0];
        time = parts[1];
    } else {
        date = duration;
    }
    var mapping = {
        'Y': 'years',
        'M': 'months',
        'W': 'weeks',
        'D': 'days',
        'H': 'hours',
        'm': 'minutes',
        'S': 'seconds'
    };
    function parse(chunk, time) {
        function read(amount, part) {
            if (time && part == 'M') {
                part = 'm';
            }
            var mappedTo = mapping[part];
            if (typeof mappedTo == 'undefined') {
                throw Error('unknown duration specifier : ' + part);
            }
            values[mappedTo] = parseFloat(amount);
        }
        var next;
        while ((next = pattern.exec(chunk)) !== null) {
            read(next[1], next[2]);
        }
    }
    if (date !== null) {
        parse(date, false);
    }
    if (time !== null) {
        parse(time, true);
    }
    return values;
};

/**
 * Get a function for the provided duration that computes a new timestamp based on a
 * provided date and optional multiplier (negative for reverse).
 * @param {string} iso duration
 * @returns {function} offsetter(timestamp, multiplier=1)
 */
exports.createOffsetter = function(intervalOrDuration) {
    var duration = typeof intervalOrDuration === 'string' ? intervalOrDuration: intervalOrDuration.duration;
    var values = exports.isoDurationToMoment(duration);
    // as of writing, moment assumes y=365d and m=30d resulting in slow
    // day of month shifts that break ticks from matching
    // so we take care of this using a more accurate approach
    // ** the current approach breaks down if the day of month is greater than
    // 28 and day of month will no longer be retained (will shift)
    if ('years' in values || 'months' in values) {
        var years = values.years;
        var months = values.months;
        values.years = 0;
        values.months = 0;
        var millis = moment.duration(values).asMilliseconds();
        return function(ts, mult) {
            mult = mult || 1;
            var d = new Date(ts);
            /*jshint eqnull:true */
            var y = d.getUTCFullYear();
            if (years != null) {
                y += mult * years;
            }
            var m = d.getUTCMonth();
            if (months != null) {
                m += mult * months;
            }
            d.setUTCFullYear(y, m);
            return d.getTime() + (mult * millis);
        };
    } else {
        var offset = moment.duration(values).asMilliseconds();
        return function(ts, mult) {
            mult = mult || 1;
            return ts + (mult * offset);
        };
    }
};


/**
 * Contains implementations of Date.parse and date.toISOString that match the
 *     ECMAScript 5 specification for parsing RFC 3339 dates.
 *     http://tools.ietf.org/html/rfc3339
 */


/**
 * The regex to be used for validating dates. You can provide your own
 * regex for instance for adding support for years before BC. Default
 * value is: /^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/
 */
var dateRegEx = /^(-?)(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/;


/**
 * Generate a date object from a string.  The format for the string follows
 *     the profile of ISO 8601 for date and time on the Internet (see
 *     http://tools.ietf.org/html/rfc3339).  We don't call the native
 *     Date.parse because of inconsistency between implmentations.  In
 *     Chrome, calling Date.parse with a string that doesn't contain any
 *     indication of the timezone (e.g. "2011"), the date is interpreted
 *     in local time.  On Firefox, the assumption is UTC.
 *
 * Parameters:
 * str - {String} A string representing the date (e.g.
 *     "2010", "2010-08", "2010-08-07", "2010-08-07T16:58:23.123Z",
 *     "2010-08-07T11:58:23.123-06", "-3000-08-07T16:58:23.123Z").
 *
 * Returns:
 * {Date} A date object.  If the string could not be parsed, an invalid
 *     date is returned (i.e. isNaN(date.getTime())).
 */
parseDate = function(str) {
  var date;
  var match = str.match(dateRegEx);
  if (match && (match[2] || match[8])) { // must have at least year or time
    var year = parseInt(match[2], 10) || 0;
    if (match[1]){
      year = year * -1;
    }
    var month = (parseInt(match[3], 10) - 1) || 0;
    var day = parseInt(match[4], 10) || 1;
    date = new Date(Date.UTC(year, month, day));
    // optional time
    var type = match[8];
    if (type) {
      var hours = parseInt(match[5], 10);
      var minutes = parseInt(match[6], 10);
      var secFrac = parseFloat(match[7]);
      var seconds = secFrac | 0;
      var milliseconds = Math.round(1000 * (secFrac - seconds));
      date.setUTCHours(hours, minutes, seconds, milliseconds);
      // check offset
      if (type !== "Z") {
        var hoursOffset = parseInt(type, 10);
        var minutesOffset = parseInt(match[9], 10) || 0;
        var offset = -1000 * (60 * (hoursOffset * 60) + minutesOffset * 60);
        date = new Date(date.getTime() + offset);
      }
    }
  } else {
    date = new Date("invalid");
  }
  return date;
};


//  Secure Hash Algorithm (SHA1)
//  http://www.webtoolkit.info/

exports.sha1 = function(msg) {

  var rotate_left = function(n, s) {
    return (n << s) | (n >>> (32 - s));
  };

  var cvt_hex = function(val) {
    var str = '';
    var i;
    var v;

    for (i = 7; i >= 0; i--) {
      v = (val >>> (i * 4)) & 0x0f;
      str += v.toString(16);
    }
    return str;
  };


  var utf8Encode = function(string) {
    string = string.replace(/\r\n/g, '\n');
    var utftext = '';

    for (var n = 0; n < string.length; n++) {

      var c = string.charCodeAt(n);

      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if ((c > 127) && (c < 2048)) {
        utftext += String.fromCharCode((c >> 6) | 192);
        utftext += String.fromCharCode((c & 63) | 128);
      } else {
        utftext += String.fromCharCode((c >> 12) | 224);
        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
        utftext += String.fromCharCode((c & 63) | 128);
      }

    }
    return utftext;
  };

  var blockstart;
  var i, j;
  var W = new Array(80);
  var H0 = 0x67452301;
  var H1 = 0xEFCDAB89;
  var H2 = 0x98BADCFE;
  var H3 = 0x10325476;
  var H4 = 0xC3D2E1F0;
  var A, B, C, D, E;
  var temp;

  msg = utf8Encode(msg);

  var msg_len = msg.length;

  var word_array = [];
  for (i = 0; i < msg_len - 3; i += 4) {
    j = msg.charCodeAt(i) << 24 | msg.charCodeAt(i + 1) << 16 |
        msg.charCodeAt(i + 2) << 8 | msg.charCodeAt(i + 3);
    word_array.push(j);
  }

  switch (msg_len % 4) {
    case 0:
      i = 0x080000000;
      break;
    case 1:
      i = msg.charCodeAt(msg_len - 1) << 24 | 0x0800000;
      break;

    case 2:
      i = msg.charCodeAt(msg_len - 2) << 24 | msg.charCodeAt(msg_len - 1) << 16 | 0x08000;
      break;

    case 3:
      i = msg.charCodeAt(msg_len - 3) << 24 | msg.charCodeAt(msg_len - 2) << 16 |
          msg.charCodeAt(msg_len - 1) << 8 | 0x80;
      break;
  }

  word_array.push(i);

  while ((word_array.length % 16) != 14) {
    word_array.push(0);
  }

  word_array.push(msg_len >>> 29);
  word_array.push((msg_len << 3) & 0x0ffffffff);


  for (blockstart = 0; blockstart < word_array.length; blockstart += 16) {

    for (i = 0; i < 16; i++) {
      W[i] = word_array[blockstart + i];
    }
    for (i = 16; i <= 79; i++) {
      W[i] = rotate_left(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    }

    A = H0;
    B = H1;
    C = H2;
    D = H3;
    E = H4;

    for (i = 0; i <= 19; i++) {
      temp = (rotate_left(A, 5) + ((B & C) | (~B & D)) + E + W[i] + 0x5A827999) & 0x0ffffffff;
      E = D;
      D = C;
      C = rotate_left(B, 30);
      B = A;
      A = temp;
    }

    for (i = 20; i <= 39; i++) {
      temp = (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0x6ED9EBA1) & 0x0ffffffff;
      E = D;
      D = C;
      C = rotate_left(B, 30);
      B = A;
      A = temp;
    }

    for (i = 40; i <= 59; i++) {
      temp = (rotate_left(A, 5) + ((B & C) | (B & D) | (C & D)) + E + W[i] + 0x8F1BBCDC) & 0x0ffffffff;
      E = D;
      D = C;
      C = rotate_left(B, 30);
      B = A;
      A = temp;
    }

    for (i = 60; i <= 79; i++) {
      temp = (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0xCA62C1D6) & 0x0ffffffff;
      E = D;
      D = C;
      C = rotate_left(B, 30);
      B = A;
      A = temp;
    }

    H0 = (H0 + A) & 0x0ffffffff;
    H1 = (H1 + B) & 0x0ffffffff;
    H2 = (H2 + C) & 0x0ffffffff;
    H3 = (H3 + D) & 0x0ffffffff;
    H4 = (H4 + E) & 0x0ffffffff;

  }

  var localtemp = cvt_hex(H0) + cvt_hex(H1) + cvt_hex(H2) + cvt_hex(H3) + cvt_hex(H4);

  return localtemp.toLowerCase();

};

},{"moment":13}],10:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],11:[function(require,module,exports){
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (typeof define === 'function' && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

},{}],12:[function(require,module,exports){
"use strict";
/**
 * Created by Alex on 11/6/2014.
 */

// https://github.com/umdjs/umd/blob/master/returnExports.js#L40-L60
// if the module has no dependencies, the above pattern can be simplified to
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.keycharm = factory();
  }
}(this, function () {

  function keycharm(options) {
    var preventDefault = options && options.preventDefault || false;

    var container = options && options.container || window;

    var _exportFunctions = {};
    var _bound = {keydown:{}, keyup:{}};
    var _keys = {};
    var i;

    // a - z
    for (i = 97; i <= 122; i++) {_keys[String.fromCharCode(i)] = {code:65 + (i - 97), shift: false};}
    // A - Z
    for (i = 65; i <= 90; i++) {_keys[String.fromCharCode(i)] = {code:i, shift: true};}
    // 0 - 9
    for (i = 0;  i <= 9;   i++) {_keys['' + i] = {code:48 + i, shift: false};}
    // F1 - F12
    for (i = 1;  i <= 12;   i++) {_keys['F' + i] = {code:111 + i, shift: false};}
    // num0 - num9
    for (i = 0;  i <= 9;   i++) {_keys['num' + i] = {code:96 + i, shift: false};}

    // numpad misc
    _keys['num*'] = {code:106, shift: false};
    _keys['num+'] = {code:107, shift: false};
    _keys['num-'] = {code:109, shift: false};
    _keys['num/'] = {code:111, shift: false};
    _keys['num.'] = {code:110, shift: false};
    // arrows
    _keys['left']  = {code:37, shift: false};
    _keys['up']    = {code:38, shift: false};
    _keys['right'] = {code:39, shift: false};
    _keys['down']  = {code:40, shift: false};
    // extra keys
    _keys['space'] = {code:32, shift: false};
    _keys['enter'] = {code:13, shift: false};
    _keys['shift'] = {code:16, shift: undefined};
    _keys['esc']   = {code:27, shift: false};
    _keys['backspace'] = {code:8, shift: false};
    _keys['tab']       = {code:9, shift: false};
    _keys['ctrl']      = {code:17, shift: false};
    _keys['alt']       = {code:18, shift: false};
    _keys['delete']    = {code:46, shift: false};
    _keys['pageup']    = {code:33, shift: false};
    _keys['pagedown']  = {code:34, shift: false};
    // symbols
    _keys['=']     = {code:187, shift: false};
    _keys['-']     = {code:189, shift: false};
    _keys[']']     = {code:221, shift: false};
    _keys['[']     = {code:219, shift: false};



    var down = function(event) {handleEvent(event,'keydown');};
    var up = function(event) {handleEvent(event,'keyup');};

    // handle the actualy bound key with the event
    var handleEvent = function(event,type) {
      if (_bound[type][event.keyCode] !== undefined) {
        var bound = _bound[type][event.keyCode];
        for (var i = 0; i < bound.length; i++) {
          if (bound[i].shift === undefined) {
            bound[i].fn(event);
          }
          else if (bound[i].shift == true && event.shiftKey == true) {
            bound[i].fn(event);
          }
          else if (bound[i].shift == false && event.shiftKey == false) {
            bound[i].fn(event);
          }
        }

        if (preventDefault == true) {
          event.preventDefault();
        }
      }
    };

    // bind a key to a callback
    _exportFunctions.bind = function(key, callback, type) {
      if (type === undefined) {
        type = 'keydown';
      }
      if (_keys[key] === undefined) {
        throw new Error("unsupported key: " + key);
      }
      if (_bound[type][_keys[key].code] === undefined) {
        _bound[type][_keys[key].code] = [];
      }
      _bound[type][_keys[key].code].push({fn:callback, shift:_keys[key].shift});
    };


    // bind all keys to a call back (demo purposes)
    _exportFunctions.bindAll = function(callback, type) {
      if (type === undefined) {
        type = 'keydown';
      }
      for (var key in _keys) {
        if (_keys.hasOwnProperty(key)) {
          _exportFunctions.bind(key,callback,type);
        }
      }
    };

    // get the key label from an event
    _exportFunctions.getKey = function(event) {
      for (var key in _keys) {
        if (_keys.hasOwnProperty(key)) {
          if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {
            return key;
          }
          else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {
            return key;
          }
          else if (event.keyCode == _keys[key].code && key == 'shift') {
            return key;
          }
        }
      }
      return "unknown key, currently not supported";
    };

    // unbind either a specific callback from a key or all of them (by leaving callback undefined)
    _exportFunctions.unbind = function(key, callback, type) {
      if (type === undefined) {
        type = 'keydown';
      }
      if (_keys[key] === undefined) {
        throw new Error("unsupported key: " + key);
      }
      if (callback !== undefined) {
        var newBindings = [];
        var bound = _bound[type][_keys[key].code];
        if (bound !== undefined) {
          for (var i = 0; i < bound.length; i++) {
            if (!(bound[i].fn == callback && bound[i].shift == _keys[key].shift)) {
              newBindings.push(_bound[type][_keys[key].code][i]);
            }
          }
        }
        _bound[type][_keys[key].code] = newBindings;
      }
      else {
        _bound[type][_keys[key].code] = [];
      }
    };

    // reset all bound variables.
    _exportFunctions.reset = function() {
      _bound = {keydown:{}, keyup:{}};
    };

    // unbind all listeners and reset all variables.
    _exportFunctions.destroy = function() {
      _bound = {keydown:{}, keyup:{}};
      container.removeEventListener('keydown', down, true);
      container.removeEventListener('keyup', up, true);
    };

    // create listeners.
    container.addEventListener('keydown',down,true);
    container.addEventListener('keyup',up,true);

    // return the public functions.
    return _exportFunctions;
  }

  return keycharm;
}));



},{}],13:[function(require,module,exports){
//! moment.js
//! version : 2.17.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    var k;
    for (k in obj) {
        // even if its not own property I'd still call it non-empty
        return false;
    }
    return true;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

var some$1 = some;

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

function isUndefined(input) {
    return input === void 0;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i in momentProperties) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _ordinalParseLenient.
    this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var keys$1 = keys;

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid()) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

var indexOf$1 = indexOf;

function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return this._months;
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return this._monthsShort;
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function createDate (y, m, d, h, M, s, ms) {
    //can't just apply() to create a date:
    //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
    var date = new Date(y, m, d, h, M, s, ms);

    //the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    //the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

//http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return this._weekdays;
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    ordinalParse: defaultOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            require('./locale/' + name);
            // because defineLocale currently also sets the global locale, we
            // want to undo that for lazy loaded locales
            getSetGlobalLocale(oldLocale);
        } catch (e) { }
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, parentConfig = baseConfig;
        // MERGE
        if (locales[name] != null) {
            parentConfig = locales[name]._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys$1(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
        hooks.createFromInputFallback(config);
    }
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse)) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }

    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (input === undefined) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (typeof(input) === 'object') {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
            output = output / 3;
        } else if (units === 'year') {
            output = output / 12;
        }
    } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : // 1000
            units === 'minute' ? delta / 6e4 : // 1000 * 60
            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
            delta;
    }
    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString () {
    var m = this.clone().utc();
    if (0 < m.year() && m.year() <= 9999) {
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            return this.toDate().toISOString();
        } else {
            return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    } else {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 < this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$1 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$1;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    ordinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function get$2 (units) {
    units = normalizeUnits(units);
    return this[units + 's']();
}

function makeGetter(name) {
    return function () {
        return this._data[name];
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    s: 45,  // seconds to minute
    m: 45,  // minutes to hour
    h: 22,  // hours to day
    d: 26,  // days to month
    M: 11   // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds < thresholds.s && ['s', seconds]  ||
            minutes <= 1           && ['m']           ||
            minutes < thresholds.m && ['mm', minutes] ||
            hours   <= 1           && ['h']           ||
            hours   < thresholds.h && ['hh', hours]   ||
            days    <= 1           && ['d']           ||
            days    < thresholds.d && ['dd', days]    ||
            months  <= 1           && ['M']           ||
            months  < thresholds.M && ['MM', months]  ||
            years   <= 1           && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    return true;
}

function humanize (withSuffix) {
    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    return (total < 0 ? '-' : '') +
        'P' +
        (Y ? Y + 'Y' : '') +
        (M ? M + 'M' : '') +
        (D ? D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? h + 'H' : '') +
        (m ? m + 'M' : '') +
        (s ? s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.17.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

return hooks;

})));

},{}],14:[function(require,module,exports){
'use strict';

(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    window.propagating = factory();
  }
}(function () {
  var _firstTarget = null; // singleton, will contain the target element where the touch event started

  /**
   * Extend an Hammer.js instance with event propagation.
   *
   * Features:
   * - Events emitted by hammer will propagate in order from child to parent
   *   elements.
   * - Events are extended with a function `event.stopPropagation()` to stop
   *   propagation to parent elements.
   * - An option `preventDefault` to stop all default browser behavior.
   *
   * Usage:
   *   var hammer = propagatingHammer(new Hammer(element));
   *   var hammer = propagatingHammer(new Hammer(element), {preventDefault: true});
   *
   * @param {Hammer.Manager} hammer   An hammer instance.
   * @param {Object} [options]        Available options:
   *                                  - `preventDefault: true | false | 'mouse' | 'touch' | 'pen'`.
   *                                    Enforce preventing the default browser behavior.
   *                                    Cannot be set to `false`.
   * @return {Hammer.Manager} Returns the same hammer instance with extended
   *                          functionality
   */
  return function propagating(hammer, options) {
    var _options = options || {
      preventDefault: false
    };

    if (hammer.Manager) {
      // This looks like the Hammer constructor.
      // Overload the constructors with our own.
      var Hammer = hammer;

      var PropagatingHammer = function(element, options) {
        var o = Object.create(_options);
        if (options) Hammer.assign(o, options);
        return propagating(new Hammer(element, o), o);
      };
      Hammer.assign(PropagatingHammer, Hammer);

      PropagatingHammer.Manager = function (element, options) {
        var o = Object.create(_options);
        if (options) Hammer.assign(o, options);
        return propagating(new Hammer.Manager(element, o), o);
      };

      return PropagatingHammer;
    }

    // create a wrapper object which will override the functions
    // `on`, `off`, `destroy`, and `emit` of the hammer instance
    var wrapper = Object.create(hammer);

    // attach to DOM element
    var element = hammer.element;

    if(!element.hammer) element.hammer = [];
    element.hammer.push(wrapper);

    // register an event to catch the start of a gesture and store the
    // target in a singleton
    hammer.on('hammer.input', function (event) {
      if (_options.preventDefault === true || (_options.preventDefault === event.pointerType)) {
        event.preventDefault();
      }
      if (event.isFirst) {
        _firstTarget = event.target;
      }
    });

    /** @type {Object.<String, Array.<function>>} */
    wrapper._handlers = {};

    /**
     * Register a handler for one or multiple events
     * @param {String} events    A space separated string with events
     * @param {function} handler A callback function, called as handler(event)
     * @returns {Hammer.Manager} Returns the hammer instance
     */
    wrapper.on = function (events, handler) {
      // register the handler
      split(events).forEach(function (event) {
        var _handlers = wrapper._handlers[event];
        if (!_handlers) {
          wrapper._handlers[event] = _handlers = [];

          // register the static, propagated handler
          hammer.on(event, propagatedHandler);
        }
        _handlers.push(handler);
      });

      return wrapper;
    };

    /**
     * Unregister a handler for one or multiple events
     * @param {String} events      A space separated string with events
     * @param {function} [handler] Optional. The registered handler. If not
     *                             provided, all handlers for given events
     *                             are removed.
     * @returns {Hammer.Manager}   Returns the hammer instance
     */
    wrapper.off = function (events, handler) {
      // unregister the handler
      split(events).forEach(function (event) {
        var _handlers = wrapper._handlers[event];
        if (_handlers) {
          _handlers = handler ? _handlers.filter(function (h) {
            return h !== handler;
          }) : [];

          if (_handlers.length > 0) {
            wrapper._handlers[event] = _handlers;
          }
          else {
            // remove static, propagated handler
            hammer.off(event, propagatedHandler);
            delete wrapper._handlers[event];
          }
        }
      });

      return wrapper;
    };

    /**
     * Emit to the event listeners
     * @param {string} eventType
     * @param {Event} event
     */
    wrapper.emit = function(eventType, event) {
      _firstTarget = event.target;
      hammer.emit(eventType, event);
    };

    wrapper.destroy = function () {
      // Detach from DOM element
      var hammers = hammer.element.hammer;
      var idx = hammers.indexOf(wrapper);
      if(idx !== -1) hammers.splice(idx,1);
      if(!hammers.length) delete hammer.element.hammer;

      // clear all handlers
      wrapper._handlers = {};

      // call original hammer destroy
      hammer.destroy();
    };

    // split a string with space separated words
    function split(events) {
      return events.match(/[^ ]+/g);
    }

    /**
     * A static event handler, applying event propagation.
     * @param {Object} event
     */
    function propagatedHandler(event) {
      // let only a single hammer instance handle this event
      if (event.type !== 'hammer.input') {
        // it is possible that the same srcEvent is used with multiple hammer events,
        // we keep track on which events are handled in an object _handled
        if (!event.srcEvent._handled) {
          event.srcEvent._handled = {};
        }

        if (event.srcEvent._handled[event.type]) {
          return;
        }
        else {
          event.srcEvent._handled[event.type] = true;
        }
      }

      // attach a stopPropagation function to the event
      var stopped = false;
      event.stopPropagation = function () {
        stopped = true;
      };

      //wrap the srcEvent's stopPropagation to also stop hammer propagation:
      var srcStop = event.srcEvent.stopPropagation.bind(event.srcEvent);
      if(typeof srcStop == "function") {
        event.srcEvent.stopPropagation = function(){
          srcStop();
          event.stopPropagation();
        }
      }

      // attach firstTarget property to the event
      event.firstTarget = _firstTarget;

      // propagate over all elements (until stopped)
      var elem = _firstTarget;
      while (elem && !stopped) {
        var elemHammer = elem.hammer;
        if(elemHammer){
          var _handlers;
          for(var k = 0; k < elemHammer.length; k++){
            _handlers = elemHammer[k]._handlers[event.type];
            if(_handlers) for (var i = 0; i < _handlers.length && !stopped; i++) {
              _handlers[i](event);
            }
          }
        }
        elem = elem.parentNode;
      }
    }

    return wrapper;
  };
}));

},{}],15:[function(require,module,exports){
'use strict';

var util = require('./util');
var Queue = require('./Queue');

/**
 * DataSet
 *
 * Usage:
 *     var dataSet = new DataSet({
 *         fieldId: '_id',
 *         type: {
 *             // ...
 *         }
 *     });
 *
 *     dataSet.add(item);
 *     dataSet.add(data);
 *     dataSet.update(item);
 *     dataSet.update(data);
 *     dataSet.remove(id);
 *     dataSet.remove(ids);
 *     var data = dataSet.get();
 *     var data = dataSet.get(id);
 *     var data = dataSet.get(ids);
 *     var data = dataSet.get(ids, options, data);
 *     dataSet.clear();
 *
 * A data set can:
 * - add/remove/update data
 * - gives triggers upon changes in the data
 * - can  import/export data in various data formats
 *
 * @param {Array} [data]    Optional array with initial data
 * @param {Object} [options]   Available options:
 *                             {String} fieldId Field name of the id in the
 *                                              items, 'id' by default.
 *                             {Object.<String, String} type
 *                                              A map with field names as key,
 *                                              and the field type as value.
 *                             {Object} queue   Queue changes to the DataSet,
 *                                              flush them all at once.
 *                                              Queue options:
 *                                              - {number} delay  Delay in ms, null by default
 *                                              - {number} max    Maximum number of entries in the queue, Infinity by default
 * @constructor DataSet
 */
// TODO: add a DataSet constructor DataSet(data, options)
function DataSet(data, options) {
  // correctly read optional arguments
  if (data && !Array.isArray(data)) {
    options = data;
    data = null;
  }

  this._options = options || {};
  this._data = {}; // map with data indexed by id
  this.length = 0; // number of items in the DataSet
  this._fieldId = this._options.fieldId || 'id'; // name of the field containing id
  this._type = {}; // internal field types (NOTE: this can differ from this._options.type)

  // all variants of a Date are internally stored as Date, so we can convert
  // from everything to everything (also from ISODate to Number for example)
  if (this._options.type) {
    for (var field in this._options.type) {
      if (this._options.type.hasOwnProperty(field)) {
        var value = this._options.type[field];
        if (value == 'Date' || value == 'ISODate' || value == 'ASPDate') {
          this._type[field] = 'Date';
        } else {
          this._type[field] = value;
        }
      }
    }
  }

  // TODO: deprecated since version 1.1.1 (or 2.0.0?)
  if (this._options.convert) {
    throw new Error('Option "convert" is deprecated. Use "type" instead.');
  }

  this._subscribers = {}; // event subscribers

  // add initial data when provided
  if (data) {
    this.add(data);
  }

  this.setOptions(options);
}

/**
 * @param {Object} [options]   Available options:
 *                             {Object} queue   Queue changes to the DataSet,
 *                                              flush them all at once.
 *                                              Queue options:
 *                                              - {number} delay  Delay in ms, null by default
 *                                              - {number} max    Maximum number of entries in the queue, Infinity by default
 * @param options
 */
DataSet.prototype.setOptions = function (options) {
  if (options && options.queue !== undefined) {
    if (options.queue === false) {
      // delete queue if loaded
      if (this._queue) {
        this._queue.destroy();
        delete this._queue;
      }
    } else {
      // create queue and update its options
      if (!this._queue) {
        this._queue = Queue.extend(this, {
          replace: ['add', 'update', 'remove']
        });
      }

      if (typeof options.queue === 'object') {
        this._queue.setOptions(options.queue);
      }
    }
  }
};

/**
 * Subscribe to an event, add an event listener
 * @param {String} event        Event name. Available events: 'put', 'update',
 *                              'remove'
 * @param {function} callback   Callback method. Called with three parameters:
 *                                  {String} event
 *                                  {Object | null} params
 *                                  {String | Number} senderId
 */
DataSet.prototype.on = function (event, callback) {
  var subscribers = this._subscribers[event];
  if (!subscribers) {
    subscribers = [];
    this._subscribers[event] = subscribers;
  }

  subscribers.push({
    callback: callback
  });
};

// TODO: remove this deprecated function some day (replaced with `on` since version 0.5, deprecated since v4.0)
DataSet.prototype.subscribe = function () {
  throw new Error('DataSet.subscribe is deprecated. Use DataSet.on instead.');
};

/**
 * Unsubscribe from an event, remove an event listener
 * @param {String} event
 * @param {function} callback
 */
DataSet.prototype.off = function (event, callback) {
  var subscribers = this._subscribers[event];
  if (subscribers) {
    this._subscribers[event] = subscribers.filter(function (listener) {
      return listener.callback != callback;
    });
  }
};

// TODO: remove this deprecated function some day (replaced with `on` since version 0.5, deprecated since v4.0)
DataSet.prototype.unsubscribe = function () {
  throw new Error('DataSet.unsubscribe is deprecated. Use DataSet.off instead.');
};

/**
 * Trigger an event
 * @param {String} event
 * @param {Object | null} params
 * @param {String} [senderId]       Optional id of the sender.
 * @private
 */
DataSet.prototype._trigger = function (event, params, senderId) {
  if (event == '*') {
    throw new Error('Cannot trigger event *');
  }

  var subscribers = [];
  if (event in this._subscribers) {
    subscribers = subscribers.concat(this._subscribers[event]);
  }
  if ('*' in this._subscribers) {
    subscribers = subscribers.concat(this._subscribers['*']);
  }

  for (var i = 0; i < subscribers.length; i++) {
    var subscriber = subscribers[i];
    if (subscriber.callback) {
      subscriber.callback(event, params, senderId || null);
    }
  }
};

/**
 * Add data.
 * Adding an item will fail when there already is an item with the same id.
 * @param {Object | Array} data
 * @param {String} [senderId] Optional sender id
 * @return {Array} addedIds      Array with the ids of the added items
 */
DataSet.prototype.add = function (data, senderId) {
  var addedIds = [],
      id,
      me = this;

  if (Array.isArray(data)) {
    // Array
    for (var i = 0, len = data.length; i < len; i++) {
      id = me._addItem(data[i]);
      addedIds.push(id);
    }
  } else if (data instanceof Object) {
    // Single item
    id = me._addItem(data);
    addedIds.push(id);
  } else {
    throw new Error('Unknown dataType');
  }

  if (addedIds.length) {
    this._trigger('add', { items: addedIds }, senderId);
  }

  return addedIds;
};

/**
 * Update existing items. When an item does not exist, it will be created
 * @param {Object | Array} data
 * @param {String} [senderId] Optional sender id
 * @return {Array} updatedIds     The ids of the added or updated items
 */
DataSet.prototype.update = function (data, senderId) {
  var addedIds = [];
  var updatedIds = [];
  var updatedData = [];
  var me = this;
  var fieldId = me._fieldId;

  var addOrUpdate = function addOrUpdate(item) {
    var id = item[fieldId];
    if (me._data[id]) {
      // update item
      id = me._updateItem(item);
      updatedIds.push(id);
      updatedData.push(item);
    } else {
      // add new item
      id = me._addItem(item);
      addedIds.push(id);
    }
  };

  if (Array.isArray(data)) {
    // Array
    for (var i = 0, len = data.length; i < len; i++) {
      addOrUpdate(data[i]);
    }
  } else if (data instanceof Object) {
    // Single item
    addOrUpdate(data);
  } else {
    throw new Error('Unknown dataType');
  }

  if (addedIds.length) {
    this._trigger('add', { items: addedIds }, senderId);
  }
  if (updatedIds.length) {
    this._trigger('update', { items: updatedIds, data: updatedData }, senderId);
  }

  return addedIds.concat(updatedIds);
};

/**
 * Get a data item or multiple items.
 *
 * Usage:
 *
 *     get()
 *     get(options: Object)
 *
 *     get(id: Number | String)
 *     get(id: Number | String, options: Object)
 *
 *     get(ids: Number[] | String[])
 *     get(ids: Number[] | String[], options: Object)
 *
 * Where:
 *
 * {Number | String} id         The id of an item
 * {Number[] | String{}} ids    An array with ids of items
 * {Object} options             An Object with options. Available options:
 * {String} [returnType]        Type of data to be returned.
 *                              Can be 'Array' (default) or 'Object'.
 * {Object.<String, String>} [type]
 * {String[]} [fields]          field names to be returned
 * {function} [filter]          filter items
 * {String | function} [order]  Order the items by a field name or custom sort function.
 * @throws Error
 */
DataSet.prototype.get = function (args) {
  var me = this;

  // parse the arguments
  var id, ids, options;
  var firstType = util.getType(arguments[0]);
  if (firstType == 'String' || firstType == 'Number') {
    // get(id [, options])
    id = arguments[0];
    options = arguments[1];
  } else if (firstType == 'Array') {
    // get(ids [, options])
    ids = arguments[0];
    options = arguments[1];
  } else {
    // get([, options])
    options = arguments[0];
  }

  // determine the return type
  var returnType;
  if (options && options.returnType) {
    var allowedValues = ['Array', 'Object'];
    returnType = allowedValues.indexOf(options.returnType) == -1 ? 'Array' : options.returnType;
  } else {
    returnType = 'Array';
  }

  // build options
  var type = options && options.type || this._options.type;
  var filter = options && options.filter;
  var items = [],
      item,
      itemId,
      i,
      len;

  // convert items
  if (id != undefined) {
    // return a single item
    item = me._getItem(id, type);
    if (filter && !filter(item)) {
      item = null;
    }
  } else if (ids != undefined) {
    // return a subset of items
    for (i = 0, len = ids.length; i < len; i++) {
      item = me._getItem(ids[i], type);
      if (!filter || filter(item)) {
        items.push(item);
      }
    }
  } else {
    // return all items
    for (itemId in this._data) {
      if (this._data.hasOwnProperty(itemId)) {
        item = me._getItem(itemId, type);
        if (!filter || filter(item)) {
          items.push(item);
        }
      }
    }
  }

  // order the results
  if (options && options.order && id == undefined) {
    this._sort(items, options.order);
  }

  // filter fields of the items
  if (options && options.fields) {
    var fields = options.fields;
    if (id != undefined) {
      item = this._filterFields(item, fields);
    } else {
      for (i = 0, len = items.length; i < len; i++) {
        items[i] = this._filterFields(items[i], fields);
      }
    }
  }

  // return the results
  if (returnType == 'Object') {
    var result = {};
    for (i = 0; i < items.length; i++) {
      result[items[i].id] = items[i];
    }
    return result;
  } else {
    if (id != undefined) {
      // a single item
      return item;
    } else {
      // just return our array
      return items;
    }
  }
};

/**
 * Get ids of all items or from a filtered set of items.
 * @param {Object} [options]    An Object with options. Available options:
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Array} ids
 */
DataSet.prototype.getIds = function (options) {
  var data = this._data,
      filter = options && options.filter,
      order = options && options.order,
      type = options && options.type || this._options.type,
      i,
      len,
      id,
      item,
      items,
      ids = [];

  if (filter) {
    // get filtered items
    if (order) {
      // create ordered list
      items = [];
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          item = this._getItem(id, type);
          if (filter(item)) {
            items.push(item);
          }
        }
      }

      this._sort(items, order);

      for (i = 0, len = items.length; i < len; i++) {
        ids[i] = items[i][this._fieldId];
      }
    } else {
      // create unordered list
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          item = this._getItem(id, type);
          if (filter(item)) {
            ids.push(item[this._fieldId]);
          }
        }
      }
    }
  } else {
    // get all items
    if (order) {
      // create an ordered list
      items = [];
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          items.push(data[id]);
        }
      }

      this._sort(items, order);

      for (i = 0, len = items.length; i < len; i++) {
        ids[i] = items[i][this._fieldId];
      }
    } else {
      // create unordered list
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          item = data[id];
          ids.push(item[this._fieldId]);
        }
      }
    }
  }

  return ids;
};

/**
 * Returns the DataSet itself. Is overwritten for example by the DataView,
 * which returns the DataSet it is connected to instead.
 */
DataSet.prototype.getDataSet = function () {
  return this;
};

/**
 * Execute a callback function for every item in the dataset.
 * @param {function} callback
 * @param {Object} [options]    Available options:
 *                              {Object.<String, String>} [type]
 *                              {String[]} [fields] filter fields
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 */
DataSet.prototype.forEach = function (callback, options) {
  var filter = options && options.filter,
      type = options && options.type || this._options.type,
      data = this._data,
      item,
      id;

  if (options && options.order) {
    // execute forEach on ordered list
    var items = this.get(options);

    for (var i = 0, len = items.length; i < len; i++) {
      item = items[i];
      id = item[this._fieldId];
      callback(item, id);
    }
  } else {
    // unordered
    for (id in data) {
      if (data.hasOwnProperty(id)) {
        item = this._getItem(id, type);
        if (!filter || filter(item)) {
          callback(item, id);
        }
      }
    }
  }
};

/**
 * Map every item in the dataset.
 * @param {function} callback
 * @param {Object} [options]    Available options:
 *                              {Object.<String, String>} [type]
 *                              {String[]} [fields] filter fields
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Object[]} mappedItems
 */
DataSet.prototype.map = function (callback, options) {
  var filter = options && options.filter,
      type = options && options.type || this._options.type,
      mappedItems = [],
      data = this._data,
      item;

  // convert and filter items
  for (var id in data) {
    if (data.hasOwnProperty(id)) {
      item = this._getItem(id, type);
      if (!filter || filter(item)) {
        mappedItems.push(callback(item, id));
      }
    }
  }

  // order items
  if (options && options.order) {
    this._sort(mappedItems, options.order);
  }

  return mappedItems;
};

/**
 * Filter the fields of an item
 * @param {Object | null} item
 * @param {String[]} fields     Field names
 * @return {Object | null} filteredItem or null if no item is provided
 * @private
 */
DataSet.prototype._filterFields = function (item, fields) {
  if (!item) {
    // item is null
    return item;
  }

  var filteredItem = {};

  if (Array.isArray(fields)) {
    for (var field in item) {
      if (item.hasOwnProperty(field) && fields.indexOf(field) != -1) {
        filteredItem[field] = item[field];
      }
    }
  } else {
    for (var field in item) {
      if (item.hasOwnProperty(field) && fields.hasOwnProperty(field)) {
        filteredItem[fields[field]] = item[field];
      }
    }
  }

  return filteredItem;
};

/**
 * Sort the provided array with items
 * @param {Object[]} items
 * @param {String | function} order      A field name or custom sort function.
 * @private
 */
DataSet.prototype._sort = function (items, order) {
  if (util.isString(order)) {
    // order by provided field name
    var name = order; // field name
    items.sort(function (a, b) {
      var av = a[name];
      var bv = b[name];
      return av > bv ? 1 : av < bv ? -1 : 0;
    });
  } else if (typeof order === 'function') {
    // order by sort function
    items.sort(order);
  }
  // TODO: extend order by an Object {field:String, direction:String}
  //       where direction can be 'asc' or 'desc'
  else {
      throw new TypeError('Order must be a function or a string');
    }
};

/**
 * Remove an object by pointer or by id
 * @param {String | Number | Object | Array} id Object or id, or an array with
 *                                              objects or ids to be removed
 * @param {String} [senderId] Optional sender id
 * @return {Array} removedIds
 */
DataSet.prototype.remove = function (id, senderId) {
  var removedIds = [],
      i,
      len,
      removedId;

  if (Array.isArray(id)) {
    for (i = 0, len = id.length; i < len; i++) {
      removedId = this._remove(id[i]);
      if (removedId != null) {
        removedIds.push(removedId);
      }
    }
  } else {
    removedId = this._remove(id);
    if (removedId != null) {
      removedIds.push(removedId);
    }
  }

  if (removedIds.length) {
    this._trigger('remove', { items: removedIds }, senderId);
  }

  return removedIds;
};

/**
 * Remove an item by its id
 * @param {Number | String | Object} id   id or item
 * @returns {Number | String | null} id
 * @private
 */
DataSet.prototype._remove = function (id) {
  if (util.isNumber(id) || util.isString(id)) {
    if (this._data[id]) {
      delete this._data[id];
      this.length--;
      return id;
    }
  } else if (id instanceof Object) {
    var itemId = id[this._fieldId];
    if (itemId && this._data[itemId]) {
      delete this._data[itemId];
      this.length--;
      return itemId;
    }
  }
  return null;
};

/**
 * Clear the data
 * @param {String} [senderId] Optional sender id
 * @return {Array} removedIds    The ids of all removed items
 */
DataSet.prototype.clear = function (senderId) {
  var ids = Object.keys(this._data);

  this._data = {};
  this.length = 0;

  this._trigger('remove', { items: ids }, senderId);

  return ids;
};

/**
 * Find the item with maximum value of a specified field
 * @param {String} field
 * @return {Object | null} item  Item containing max value, or null if no items
 */
DataSet.prototype.max = function (field) {
  var data = this._data,
      max = null,
      maxField = null;

  for (var id in data) {
    if (data.hasOwnProperty(id)) {
      var item = data[id];
      var itemField = item[field];
      if (itemField != null && (!max || itemField > maxField)) {
        max = item;
        maxField = itemField;
      }
    }
  }

  return max;
};

/**
 * Find the item with minimum value of a specified field
 * @param {String} field
 * @return {Object | null} item  Item containing max value, or null if no items
 */
DataSet.prototype.min = function (field) {
  var data = this._data,
      min = null,
      minField = null;

  for (var id in data) {
    if (data.hasOwnProperty(id)) {
      var item = data[id];
      var itemField = item[field];
      if (itemField != null && (!min || itemField < minField)) {
        min = item;
        minField = itemField;
      }
    }
  }

  return min;
};

/**
 * Find all distinct values of a specified field
 * @param {String} field
 * @return {Array} values  Array containing all distinct values. If data items
 *                         do not contain the specified field are ignored.
 *                         The returned array is unordered.
 */
DataSet.prototype.distinct = function (field) {
  var data = this._data;
  var values = [];
  var fieldType = this._options.type && this._options.type[field] || null;
  var count = 0;
  var i;

  for (var prop in data) {
    if (data.hasOwnProperty(prop)) {
      var item = data[prop];
      var value = item[field];
      var exists = false;
      for (i = 0; i < count; i++) {
        if (values[i] == value) {
          exists = true;
          break;
        }
      }
      if (!exists && value !== undefined) {
        values[count] = value;
        count++;
      }
    }
  }

  if (fieldType) {
    for (i = 0; i < values.length; i++) {
      values[i] = util.convert(values[i], fieldType);
    }
  }

  return values;
};

/**
 * Add a single item. Will fail when an item with the same id already exists.
 * @param {Object} item
 * @return {String} id
 * @private
 */
DataSet.prototype._addItem = function (item) {
  var id = item[this._fieldId];

  if (id != undefined) {
    // check whether this id is already taken
    if (this._data[id]) {
      // item already exists
      throw new Error('Cannot add item: item with id ' + id + ' already exists');
    }
  } else {
    // generate an id
    id = util.randomUUID();
    item[this._fieldId] = id;
  }

  var d = {};
  for (var field in item) {
    if (item.hasOwnProperty(field)) {
      var fieldType = this._type[field]; // type may be undefined
      d[field] = util.convert(item[field], fieldType);
    }
  }
  this._data[id] = d;
  this.length++;

  return id;
};

/**
 * Get an item. Fields can be converted to a specific type
 * @param {String} id
 * @param {Object.<String, String>} [types]  field types to convert
 * @return {Object | null} item
 * @private
 */
DataSet.prototype._getItem = function (id, types) {
  var field, value;

  // get the item from the dataset
  var raw = this._data[id];
  if (!raw) {
    return null;
  }

  // convert the items field types
  var converted = {};
  if (types) {
    for (field in raw) {
      if (raw.hasOwnProperty(field)) {
        value = raw[field];
        converted[field] = util.convert(value, types[field]);
      }
    }
  } else {
    // no field types specified, no converting needed
    for (field in raw) {
      if (raw.hasOwnProperty(field)) {
        value = raw[field];
        converted[field] = value;
      }
    }
  }
  return converted;
};

/**
 * Update a single item: merge with existing item.
 * Will fail when the item has no id, or when there does not exist an item
 * with the same id.
 * @param {Object} item
 * @return {String} id
 * @private
 */
DataSet.prototype._updateItem = function (item) {
  var id = item[this._fieldId];
  if (id == undefined) {
    throw new Error('Cannot update item: item has no id (item: ' + JSON.stringify(item) + ')');
  }
  var d = this._data[id];
  if (!d) {
    // item doesn't exist
    throw new Error('Cannot update item: no item with id ' + id + ' found');
  }

  // merge with current item
  for (var field in item) {
    if (item.hasOwnProperty(field)) {
      var fieldType = this._type[field]; // type may be undefined
      d[field] = util.convert(item[field], fieldType);
    }
  }

  return id;
};

module.exports = DataSet;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvRGF0YVNldC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM3QixJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZDL0IsU0FBUyxPQUFPLENBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRTs7QUFFL0IsTUFBSSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ2hDLFdBQU8sR0FBRyxJQUFJLENBQUM7QUFDZixRQUFJLEdBQUcsSUFBSSxDQUFDO0dBQ2I7O0FBRUQsTUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLElBQUksRUFBRSxDQUFDO0FBQzlCLE1BQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO0FBQ2hCLE1BQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0FBQ2hCLE1BQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDO0FBQzlDLE1BQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDOzs7O0FBSWhCLE1BQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUU7QUFDdEIsU0FBSyxJQUFJLEtBQUssSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRTtBQUNwQyxVQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsRUFBRTtBQUM1QyxZQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN0QyxZQUFJLEtBQUss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QUcsRUFBRSxHQUFHLFFBQVEsQ0FBQyxDQUFDO0dBQ3pFOzs7QUFHRCxPQUFLLElBQUksS0FBSyxJQUFJLElBQUksRUFBRTtBQUN0QixRQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDOUIsVUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNsQyxPQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7S0FDakQ7R0FDRjs7QUFFRCxTQUFPLEVBQUUsQ0FBQztDQUNYLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMiLCJmaWxlIjoiL1VzZXJzL2RhcmluL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzLXZpZXdlci9ub2RlX21vZHVsZXMvdmlzL2xpYi9EYXRhU2V0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBRdWV1ZSA9IHJlcXVpcmUoJy4vUXVldWUnKTtcblxuLyoqXG4gKiBEYXRhU2V0XG4gKlxuICogVXNhZ2U6XG4gKiAgICAgdmFyIGRhdGFTZXQgPSBuZXcgRGF0YVNldCh7XG4gKiAgICAgICAgIGZpZWxkSWQ6ICdfaWQnLFxuICogICAgICAgICB0eXBlOiB7XG4gKiAgICAgICAgICAgICAvLyAuLi5cbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqICAgICBkYXRhU2V0LmFkZChpdGVtKTtcbiAqICAgICBkYXRhU2V0LmFkZChkYXRhKTtcbiAqICAgICBkYXRhU2V0LnVwZGF0ZShpdGVtKTtcbiAqICAgICBkYXRhU2V0LnVwZGF0ZShkYXRhKTtcbiAqICAgICBkYXRhU2V0LnJlbW92ZShpZCk7XG4gKiAgICAgZGF0YVNldC5yZW1vdmUoaWRzKTtcbiAqICAgICB2YXIgZGF0YSA9IGRhdGFTZXQuZ2V0KCk7XG4gKiAgICAgdmFyIGRhdGEgPSBkYXRhU2V0LmdldChpZCk7XG4gKiAgICAgdmFyIGRhdGEgPSBkYXRhU2V0LmdldChpZHMpO1xuICogICAgIHZhciBkYXRhID0gZGF0YVNldC5nZXQoaWRzLCBvcHRpb25zLCBkYXRhKTtcbiAqICAgICBkYXRhU2V0LmNsZWFyKCk7XG4gKlxuICogQSBkYXRhIHNldCBjYW46XG4gKiAtIGFkZC9yZW1vdmUvdXBkYXRlIGRhdGFcbiAqIC0gZ2l2ZXMgdHJpZ2dlcnMgdXBvbiBjaGFuZ2VzIGluIHRoZSBkYXRhXG4gKiAtIGNhbiAgaW1wb3J0L2V4cG9ydCBkYXRhIGluIHZhcmlvdXMgZGF0YSBmb3JtYXRzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gW2RhdGFdICAgIE9wdGlvbmFsIGFycmF5IHdpdGggaW5pdGlhbCBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gZmllbGRJZCBGaWVsZCBuYW1lIG9mIHRoZSBpZCBpbiB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLCAnaWQnIGJ5IGRlZmF1bHQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdC48U3RyaW5nLCBTdHJpbmd9IHR5cGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgbWFwIHdpdGggZmllbGQgbmFtZXMgYXMga2V5LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHRoZSBmaWVsZCB0eXBlIGFzIHZhbHVlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3R9IHF1ZXVlICAgUXVldWUgY2hhbmdlcyB0byB0aGUgRGF0YVNldCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoIHRoZW0gYWxsIGF0IG9uY2UuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRdWV1ZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7bnVtYmVyfSBkZWxheSAgRGVsYXkgaW4gbXMsIG51bGwgYnkgZGVmYXVsdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7bnVtYmVyfSBtYXggICAgTWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgcXVldWUsIEluZmluaXR5IGJ5IGRlZmF1bHRcbiAqIEBjb25zdHJ1Y3RvciBEYXRhU2V0XG4gKi9cbi8vIFRPRE86IGFkZCBhIERhdGFTZXQgY29uc3RydWN0b3IgRGF0YVNldChkYXRhLCBvcHRpb25zKVxuZnVuY3Rpb24gRGF0YVNldCAoZGF0YSwgb3B0aW9ucykge1xuICAvLyBjb3JyZWN0bHkgcmVhZCBvcHRpb25hbCBhcmd1bWVudHNcbiAgaWYgKGRhdGEgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICBvcHRpb25zID0gZGF0YTtcbiAgICBkYXRhID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9kYXRhID0ge307ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFwIHdpdGggZGF0YSBpbmRleGVkIGJ5IGlkXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIERhdGFTZXRcbiAgdGhpcy5fZmllbGRJZCA9IHRoaXMuX29wdGlvbnMuZmllbGRJZCB8fCAnaWQnOyAgIC8vIG5hbWUgb2YgdGhlIGZpZWxkIGNvbnRhaW5pbmcgaWRcbiAgdGhpcy5fdHlwZSA9IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludGVybmFsIGZpZWxkIHR5cGVzIChOT1RFOiB0aGlzIGNhbiBkaWZmZXIgZnJvbSB0aGlzLl9vcHRpb25zLnR5cGUpXG5cbiAgLy8gYWxsIHZhcmlhbnRzIG9mIGEgRGF0ZSBhcmUgaW50ZXJuYWxseSBzdG9yZWQgYXMgRGF0ZSwgc28gd2UgY2FuIGNvbnZlcnRcbiAgLy8gZnJvbSBldmVyeXRoaW5nIHRvIGV2ZXJ5dGhpbmcgKGFsc28gZnJvbSBJU09EYXRlIHRvIE51bWJlciBmb3IgZXhhbXBsZSlcbiAgaWYgKHRoaXMuX29wdGlvbnMudHlwZSkge1xuICAgIGZvciAodmFyIGZpZWxkIGluIHRoaXMuX29wdGlvbnMudHlwZSkge1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMudHlwZS5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fb3B0aW9ucy50eXBlW2ZpZWxkXTtcbiAgICAgICAgaWYgKHZhbHVlID09ICdEYXRlJyB8fCB2YWx1ZSA9PSAnSVNPRGF0ZScgfHwgdmFsdWUgPT0gJ0FTUERhdGUnKSB7XG4gICAgICAgICAgdGhpcy5fdHlwZVtmaWVsZF0gPSAnRGF0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdHlwZVtmaWVsZF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjEuMSAob3IgMi4wLjA/KVxuICBpZiAodGhpcy5fb3B0aW9ucy5jb252ZXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gXCJjb252ZXJ0XCIgaXMgZGVwcmVjYXRlZC4gVXNlIFwidHlwZVwiIGluc3RlYWQuJyk7XG4gIH1cblxuICB0aGlzLl9zdWJzY3JpYmVycyA9IHt9OyAgLy8gZXZlbnQgc3Vic2NyaWJlcnNcblxuICAvLyBhZGQgaW5pdGlhbCBkYXRhIHdoZW4gcHJvdmlkZWRcbiAgaWYgKGRhdGEpIHtcbiAgICB0aGlzLmFkZChkYXRhKTtcbiAgfVxuXG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdH0gcXVldWUgICBRdWV1ZSBjaGFuZ2VzIHRvIHRoZSBEYXRhU2V0LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2ggdGhlbSBhbGwgYXQgb25jZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFF1ZXVlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHtudW1iZXJ9IGRlbGF5ICBEZWxheSBpbiBtcywgbnVsbCBieSBkZWZhdWx0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHtudW1iZXJ9IG1heCAgICBNYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBxdWV1ZSwgSW5maW5pdHkgYnkgZGVmYXVsdFxuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5xdWV1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG9wdGlvbnMucXVldWUgPT09IGZhbHNlKSB7XG4gICAgICAvLyBkZWxldGUgcXVldWUgaWYgbG9hZGVkXG4gICAgICBpZiAodGhpcy5fcXVldWUpIHtcbiAgICAgICAgdGhpcy5fcXVldWUuZGVzdHJveSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5fcXVldWU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gY3JlYXRlIHF1ZXVlIGFuZCB1cGRhdGUgaXRzIG9wdGlvbnNcbiAgICAgIGlmICghdGhpcy5fcXVldWUpIHtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBRdWV1ZS5leHRlbmQodGhpcywge1xuICAgICAgICAgIHJlcGxhY2U6IFsnYWRkJywgJ3VwZGF0ZScsICdyZW1vdmUnXVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnF1ZXVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aGlzLl9xdWV1ZS5zZXRPcHRpb25zKG9wdGlvbnMucXVldWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gYW4gZXZlbnQsIGFkZCBhbiBldmVudCBsaXN0ZW5lclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50ICAgICAgICBFdmVudCBuYW1lLiBBdmFpbGFibGUgZXZlbnRzOiAncHV0JywgJ3VwZGF0ZScsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZW1vdmUnXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrIG1ldGhvZC4gQ2FsbGVkIHdpdGggdGhyZWUgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IGV2ZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0IHwgbnVsbH0gcGFyYW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgTnVtYmVyfSBzZW5kZXJJZFxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjaykge1xuICB2YXIgc3Vic2NyaWJlcnMgPSB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF07XG4gIGlmICghc3Vic2NyaWJlcnMpIHtcbiAgICBzdWJzY3JpYmVycyA9IFtdO1xuICAgIHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XSA9IHN1YnNjcmliZXJzO1xuICB9XG5cbiAgc3Vic2NyaWJlcnMucHVzaCh7XG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLy8gVE9ETzogcmVtb3ZlIHRoaXMgZGVwcmVjYXRlZCBmdW5jdGlvbiBzb21lIGRheSAocmVwbGFjZWQgd2l0aCBgb25gIHNpbmNlIHZlcnNpb24gMC41LCBkZXByZWNhdGVkIHNpbmNlIHY0LjApXG5EYXRhU2V0LnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignRGF0YVNldC5zdWJzY3JpYmUgaXMgZGVwcmVjYXRlZC4gVXNlIERhdGFTZXQub24gaW5zdGVhZC4nKTtcbn07XG5cbi8qKlxuICogVW5zdWJzY3JpYmUgZnJvbSBhbiBldmVudCwgcmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjaykge1xuICB2YXIgc3Vic2NyaWJlcnMgPSB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF07XG4gIGlmIChzdWJzY3JpYmVycykge1xuICAgIHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XSA9IHN1YnNjcmliZXJzLmZpbHRlcihsaXN0ZW5lciA9PiBsaXN0ZW5lci5jYWxsYmFjayAhPSBjYWxsYmFjayk7XG4gIH1cbn07XG5cbi8vIFRPRE86IHJlbW92ZSB0aGlzIGRlcHJlY2F0ZWQgZnVuY3Rpb24gc29tZSBkYXkgKHJlcGxhY2VkIHdpdGggYG9uYCBzaW5jZSB2ZXJzaW9uIDAuNSwgZGVwcmVjYXRlZCBzaW5jZSB2NC4wKVxuRGF0YVNldC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignRGF0YVNldC51bnN1YnNjcmliZSBpcyBkZXByZWNhdGVkLiBVc2UgRGF0YVNldC5vZmYgaW5zdGVhZC4nKTtcbn07XG5cbi8qKlxuICogVHJpZ2dlciBhbiBldmVudFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdCB8IG51bGx9IHBhcmFtc1xuICogQHBhcmFtIHtTdHJpbmd9IFtzZW5kZXJJZF0gICAgICAgT3B0aW9uYWwgaWQgb2YgdGhlIHNlbmRlci5cbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl90cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gIGlmIChldmVudCA9PSAnKicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB0cmlnZ2VyIGV2ZW50IConKTtcbiAgfVxuXG4gIHZhciBzdWJzY3JpYmVycyA9IFtdO1xuICBpZiAoZXZlbnQgaW4gdGhpcy5fc3Vic2NyaWJlcnMpIHtcbiAgICBzdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLmNvbmNhdCh0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0pO1xuICB9XG4gIGlmICgnKicgaW4gdGhpcy5fc3Vic2NyaWJlcnMpIHtcbiAgICBzdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLmNvbmNhdCh0aGlzLl9zdWJzY3JpYmVyc1snKiddKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3Vic2NyaWJlciA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGlmIChzdWJzY3JpYmVyLmNhbGxiYWNrKSB7XG4gICAgICBzdWJzY3JpYmVyLmNhbGxiYWNrKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkIHx8IG51bGwpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBZGQgZGF0YS5cbiAqIEFkZGluZyBhbiBpdGVtIHdpbGwgZmFpbCB3aGVuIHRoZXJlIGFscmVhZHkgaXMgYW4gaXRlbSB3aXRoIHRoZSBzYW1lIGlkLlxuICogQHBhcmFtIHtPYmplY3QgfCBBcnJheX0gZGF0YVxuICogQHBhcmFtIHtTdHJpbmd9IFtzZW5kZXJJZF0gT3B0aW9uYWwgc2VuZGVyIGlkXG4gKiBAcmV0dXJuIHtBcnJheX0gYWRkZWRJZHMgICAgICBBcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlIGFkZGVkIGl0ZW1zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkYXRhLCBzZW5kZXJJZCkge1xuICB2YXIgYWRkZWRJZHMgPSBbXSxcbiAgICAgIGlkLFxuICAgICAgbWUgPSB0aGlzO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgLy8gQXJyYXlcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWQgPSBtZS5fYWRkSXRlbShkYXRhW2ldKTtcbiAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgLy8gU2luZ2xlIGl0ZW1cbiAgICBpZCA9IG1lLl9hZGRJdGVtKGRhdGEpO1xuICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBkYXRhVHlwZScpO1xuICB9XG5cbiAgaWYgKGFkZGVkSWRzLmxlbmd0aCkge1xuICAgIHRoaXMuX3RyaWdnZXIoJ2FkZCcsIHtpdGVtczogYWRkZWRJZHN9LCBzZW5kZXJJZCk7XG4gIH1cblxuICByZXR1cm4gYWRkZWRJZHM7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBleGlzdGluZyBpdGVtcy4gV2hlbiBhbiBpdGVtIGRvZXMgbm90IGV4aXN0LCBpdCB3aWxsIGJlIGNyZWF0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0IHwgQXJyYXl9IGRhdGFcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2VuZGVySWRdIE9wdGlvbmFsIHNlbmRlciBpZFxuICogQHJldHVybiB7QXJyYXl9IHVwZGF0ZWRJZHMgICAgIFRoZSBpZHMgb2YgdGhlIGFkZGVkIG9yIHVwZGF0ZWQgaXRlbXNcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIHNlbmRlcklkKSB7XG4gIHZhciBhZGRlZElkcyA9IFtdO1xuICB2YXIgdXBkYXRlZElkcyA9IFtdO1xuICB2YXIgdXBkYXRlZERhdGEgPSBbXTtcbiAgdmFyIG1lID0gdGhpcztcbiAgdmFyIGZpZWxkSWQgPSBtZS5fZmllbGRJZDtcblxuICB2YXIgYWRkT3JVcGRhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBpZCA9IGl0ZW1bZmllbGRJZF07XG4gICAgaWYgKG1lLl9kYXRhW2lkXSkge1xuICAgICAgLy8gdXBkYXRlIGl0ZW1cbiAgICAgIGlkID0gbWUuX3VwZGF0ZUl0ZW0oaXRlbSk7XG4gICAgICB1cGRhdGVkSWRzLnB1c2goaWQpO1xuICAgICAgdXBkYXRlZERhdGEucHVzaChpdGVtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBhZGQgbmV3IGl0ZW1cbiAgICAgIGlkID0gbWUuX2FkZEl0ZW0oaXRlbSk7XG4gICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAvLyBBcnJheVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhZGRPclVwZGF0ZShkYXRhW2ldKTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIC8vIFNpbmdsZSBpdGVtXG4gICAgYWRkT3JVcGRhdGUoZGF0YSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRhdGFUeXBlJyk7XG4gIH1cblxuICBpZiAoYWRkZWRJZHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fdHJpZ2dlcignYWRkJywge2l0ZW1zOiBhZGRlZElkc30sIHNlbmRlcklkKTtcbiAgfVxuICBpZiAodXBkYXRlZElkcy5sZW5ndGgpIHtcbiAgICB0aGlzLl90cmlnZ2VyKCd1cGRhdGUnLCB7aXRlbXM6IHVwZGF0ZWRJZHMsIGRhdGE6IHVwZGF0ZWREYXRhfSwgc2VuZGVySWQpO1xuICB9XG5cbiAgcmV0dXJuIGFkZGVkSWRzLmNvbmNhdCh1cGRhdGVkSWRzKTtcbn07XG5cbi8qKlxuICogR2V0IGEgZGF0YSBpdGVtIG9yIG11bHRpcGxlIGl0ZW1zLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqICAgICBnZXQoKVxuICogICAgIGdldChvcHRpb25zOiBPYmplY3QpXG4gKlxuICogICAgIGdldChpZDogTnVtYmVyIHwgU3RyaW5nKVxuICogICAgIGdldChpZDogTnVtYmVyIHwgU3RyaW5nLCBvcHRpb25zOiBPYmplY3QpXG4gKlxuICogICAgIGdldChpZHM6IE51bWJlcltdIHwgU3RyaW5nW10pXG4gKiAgICAgZ2V0KGlkczogTnVtYmVyW10gfCBTdHJpbmdbXSwgb3B0aW9uczogT2JqZWN0KVxuICpcbiAqIFdoZXJlOlxuICpcbiAqIHtOdW1iZXIgfCBTdHJpbmd9IGlkICAgICAgICAgVGhlIGlkIG9mIGFuIGl0ZW1cbiAqIHtOdW1iZXJbXSB8IFN0cmluZ3t9fSBpZHMgICAgQW4gYXJyYXkgd2l0aCBpZHMgb2YgaXRlbXNcbiAqIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgQW4gT2JqZWN0IHdpdGggb3B0aW9ucy4gQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiB7U3RyaW5nfSBbcmV0dXJuVHlwZV0gICAgICAgIFR5cGUgb2YgZGF0YSB0byBiZSByZXR1cm5lZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FuIGJlICdBcnJheScgKGRlZmF1bHQpIG9yICdPYmplY3QnLlxuICoge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbdHlwZV1cbiAqIHtTdHJpbmdbXX0gW2ZpZWxkc10gICAgICAgICAgZmllbGQgbmFtZXMgdG8gYmUgcmV0dXJuZWRcbiAqIHtmdW5jdGlvbn0gW2ZpbHRlcl0gICAgICAgICAgZmlsdGVyIGl0ZW1zXG4gKiB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gIE9yZGVyIHRoZSBpdGVtcyBieSBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gKiBAdGhyb3dzIEVycm9yXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gcGFyc2UgdGhlIGFyZ3VtZW50c1xuICB2YXIgaWQsIGlkcywgb3B0aW9ucztcbiAgdmFyIGZpcnN0VHlwZSA9IHV0aWwuZ2V0VHlwZShhcmd1bWVudHNbMF0pO1xuICBpZiAoZmlyc3RUeXBlID09ICdTdHJpbmcnIHx8IGZpcnN0VHlwZSA9PSAnTnVtYmVyJykge1xuICAgIC8vIGdldChpZCBbLCBvcHRpb25zXSlcbiAgICBpZCA9IGFyZ3VtZW50c1swXTtcbiAgICBvcHRpb25zID0gYXJndW1lbnRzWzFdO1xuICB9XG4gIGVsc2UgaWYgKGZpcnN0VHlwZSA9PSAnQXJyYXknKSB7XG4gICAgLy8gZ2V0KGlkcyBbLCBvcHRpb25zXSlcbiAgICBpZHMgPSBhcmd1bWVudHNbMF07XG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBnZXQoWywgb3B0aW9uc10pXG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB0aGUgcmV0dXJuIHR5cGVcbiAgdmFyIHJldHVyblR5cGU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmV0dXJuVHlwZSkge1xuICAgIHZhciBhbGxvd2VkVmFsdWVzID0gWydBcnJheScsICdPYmplY3QnXTtcbiAgICByZXR1cm5UeXBlID0gYWxsb3dlZFZhbHVlcy5pbmRleE9mKG9wdGlvbnMucmV0dXJuVHlwZSkgPT0gLTEgPyAnQXJyYXknIDogb3B0aW9ucy5yZXR1cm5UeXBlO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVyblR5cGUgPSAnQXJyYXknO1xuICB9XG5cbiAgLy8gYnVpbGQgb3B0aW9uc1xuICB2YXIgdHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8IHRoaXMuX29wdGlvbnMudHlwZTtcbiAgdmFyIGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXI7XG4gIHZhciBpdGVtcyA9IFtdLCBpdGVtLCBpdGVtSWQsIGksIGxlbjtcblxuICAvLyBjb252ZXJ0IGl0ZW1zXG4gIGlmIChpZCAhPSB1bmRlZmluZWQpIHtcbiAgICAvLyByZXR1cm4gYSBzaW5nbGUgaXRlbVxuICAgIGl0ZW0gPSBtZS5fZ2V0SXRlbShpZCwgdHlwZSk7XG4gICAgaWYgKGZpbHRlciAmJiAhZmlsdGVyKGl0ZW0pKSB7XG4gICAgICBpdGVtID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoaWRzICE9IHVuZGVmaW5lZCkge1xuICAgIC8vIHJldHVybiBhIHN1YnNldCBvZiBpdGVtc1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaXRlbSA9IG1lLl9nZXRJdGVtKGlkc1tpXSwgdHlwZSk7XG4gICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gcmV0dXJuIGFsbCBpdGVtc1xuICAgIGZvciAoaXRlbUlkIGluIHRoaXMuX2RhdGEpIHtcbiAgICAgIGlmICh0aGlzLl9kYXRhLmhhc093blByb3BlcnR5KGl0ZW1JZCkpIHtcbiAgICAgICAgaXRlbSA9IG1lLl9nZXRJdGVtKGl0ZW1JZCwgdHlwZSk7XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihpdGVtKSkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBvcmRlciB0aGUgcmVzdWx0c1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyICYmIGlkID09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuX3NvcnQoaXRlbXMsIG9wdGlvbnMub3JkZXIpO1xuICB9XG5cbiAgLy8gZmlsdGVyIGZpZWxkcyBvZiB0aGUgaXRlbXNcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5maWVsZHMpIHtcbiAgICB2YXIgZmllbGRzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgaWYgKGlkICE9IHVuZGVmaW5lZCkge1xuICAgICAgaXRlbSA9IHRoaXMuX2ZpbHRlckZpZWxkcyhpdGVtLCBmaWVsZHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGl0ZW1zW2ldID0gdGhpcy5fZmlsdGVyRmllbGRzKGl0ZW1zW2ldLCBmaWVsZHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHJldHVybiB0aGUgcmVzdWx0c1xuICBpZiAocmV0dXJuVHlwZSA9PSAnT2JqZWN0Jykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpdGVtc1tpXS5pZF0gPSBpdGVtc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoaWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhIHNpbmdsZSBpdGVtXG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBqdXN0IHJldHVybiBvdXIgYXJyYXlcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IGlkcyBvZiBhbGwgaXRlbXMgb3IgZnJvbSBhIGZpbHRlcmVkIHNldCBvZiBpdGVtcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgQW4gT2JqZWN0IHdpdGggb3B0aW9ucy4gQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdW5jdGlvbn0gW2ZpbHRlcl0gZmlsdGVyIGl0ZW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5fSBpZHNcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuZ2V0SWRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhLFxuICAgICAgZmlsdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcixcbiAgICAgIG9yZGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyLFxuICAgICAgdHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8IHRoaXMuX29wdGlvbnMudHlwZSxcbiAgICAgIGksXG4gICAgICBsZW4sXG4gICAgICBpZCxcbiAgICAgIGl0ZW0sXG4gICAgICBpdGVtcyxcbiAgICAgIGlkcyA9IFtdO1xuXG4gIGlmIChmaWx0ZXIpIHtcbiAgICAvLyBnZXQgZmlsdGVyZWQgaXRlbXNcbiAgICBpZiAob3JkZXIpIHtcbiAgICAgIC8vIGNyZWF0ZSBvcmRlcmVkIGxpc3RcbiAgICAgIGl0ZW1zID0gW107XG4gICAgICBmb3IgKGlkIGluIGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgaXRlbSA9IHRoaXMuX2dldEl0ZW0oaWQsIHR5cGUpO1xuICAgICAgICAgIGlmIChmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NvcnQoaXRlbXMsIG9yZGVyKTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWRzW2ldID0gaXRlbXNbaV1bdGhpcy5fZmllbGRJZF07XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gY3JlYXRlIHVub3JkZXJlZCBsaXN0XG4gICAgICBmb3IgKGlkIGluIGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgaXRlbSA9IHRoaXMuX2dldEl0ZW0oaWQsIHR5cGUpO1xuICAgICAgICAgIGlmIChmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgICAgIGlkcy5wdXNoKGl0ZW1bdGhpcy5fZmllbGRJZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBnZXQgYWxsIGl0ZW1zXG4gICAgaWYgKG9yZGVyKSB7XG4gICAgICAvLyBjcmVhdGUgYW4gb3JkZXJlZCBsaXN0XG4gICAgICBpdGVtcyA9IFtdO1xuICAgICAgZm9yIChpZCBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goZGF0YVtpZF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NvcnQoaXRlbXMsIG9yZGVyKTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWRzW2ldID0gaXRlbXNbaV1bdGhpcy5fZmllbGRJZF07XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gY3JlYXRlIHVub3JkZXJlZCBsaXN0XG4gICAgICBmb3IgKGlkIGluIGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgaXRlbSA9IGRhdGFbaWRdO1xuICAgICAgICAgIGlkcy5wdXNoKGl0ZW1bdGhpcy5fZmllbGRJZF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlkcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgRGF0YVNldCBpdHNlbGYuIElzIG92ZXJ3cml0dGVuIGZvciBleGFtcGxlIGJ5IHRoZSBEYXRhVmlldyxcbiAqIHdoaWNoIHJldHVybnMgdGhlIERhdGFTZXQgaXQgaXMgY29ubmVjdGVkIHRvIGluc3RlYWQuXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLmdldERhdGFTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGV2ZXJ5IGl0ZW0gaW4gdGhlIGRhdGFzZXQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbdHlwZV1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ1tdfSBbZmllbGRzXSBmaWx0ZXIgZmllbGRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdW5jdGlvbn0gW2ZpbHRlcl0gZmlsdGVyIGl0ZW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgZmlsdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcixcbiAgICAgIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCB0aGlzLl9vcHRpb25zLnR5cGUsXG4gICAgICBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgIGl0ZW0sXG4gICAgICBpZDtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyKSB7XG4gICAgLy8gZXhlY3V0ZSBmb3JFYWNoIG9uIG9yZGVyZWQgbGlzdFxuICAgIHZhciBpdGVtcyA9IHRoaXMuZ2V0KG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICBpZCA9IGl0ZW1bdGhpcy5fZmllbGRJZF07XG4gICAgICBjYWxsYmFjayhpdGVtLCBpZCk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIHVub3JkZXJlZFxuICAgIGZvciAoaWQgaW4gZGF0YSkge1xuICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgY2FsbGJhY2soaXRlbSwgaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1hcCBldmVyeSBpdGVtIGluIHRoZSBkYXRhc2V0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW3R5cGVdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmdbXX0gW2ZpZWxkc10gZmlsdGVyIGZpZWxkc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtPYmplY3RbXX0gbWFwcGVkSXRlbXNcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBmaWx0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyLFxuICAgICAgdHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8IHRoaXMuX29wdGlvbnMudHlwZSxcbiAgICAgIG1hcHBlZEl0ZW1zID0gW10sXG4gICAgICBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgIGl0ZW07XG5cbiAgLy8gY29udmVydCBhbmQgZmlsdGVyIGl0ZW1zXG4gIGZvciAodmFyIGlkIGluIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihpdGVtKSkge1xuICAgICAgICBtYXBwZWRJdGVtcy5wdXNoKGNhbGxiYWNrKGl0ZW0sIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gb3JkZXIgaXRlbXNcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlcikge1xuICAgIHRoaXMuX3NvcnQobWFwcGVkSXRlbXMsIG9wdGlvbnMub3JkZXIpO1xuICB9XG5cbiAgcmV0dXJuIG1hcHBlZEl0ZW1zO1xufTtcblxuLyoqXG4gKiBGaWx0ZXIgdGhlIGZpZWxkcyBvZiBhbiBpdGVtXG4gKiBAcGFyYW0ge09iamVjdCB8IG51bGx9IGl0ZW1cbiAqIEBwYXJhbSB7U3RyaW5nW119IGZpZWxkcyAgICAgRmllbGQgbmFtZXNcbiAqIEByZXR1cm4ge09iamVjdCB8IG51bGx9IGZpbHRlcmVkSXRlbSBvciBudWxsIGlmIG5vIGl0ZW0gaXMgcHJvdmlkZWRcbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl9maWx0ZXJGaWVsZHMgPSBmdW5jdGlvbiAoaXRlbSwgZmllbGRzKSB7XG4gIGlmICghaXRlbSkgeyAvLyBpdGVtIGlzIG51bGxcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIHZhciBmaWx0ZXJlZEl0ZW0gPSB7fTtcblxuICBpZihBcnJheS5pc0FycmF5KGZpZWxkcykpe1xuICAgIGZvciAodmFyIGZpZWxkIGluIGl0ZW0pIHtcbiAgICAgIGlmIChpdGVtLmhhc093blByb3BlcnR5KGZpZWxkKSAmJiAoZmllbGRzLmluZGV4T2YoZmllbGQpICE9IC0xKSkge1xuICAgICAgICBmaWx0ZXJlZEl0ZW1bZmllbGRdID0gaXRlbVtmaWVsZF07XG4gICAgICB9XG4gICAgfVxuICB9ZWxzZXtcbiAgICBmb3IgKHZhciBmaWVsZCBpbiBpdGVtKSB7XG4gICAgICBpZiAoaXRlbS5oYXNPd25Qcm9wZXJ0eShmaWVsZCkgJiYgZmllbGRzLmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgICBmaWx0ZXJlZEl0ZW1bZmllbGRzW2ZpZWxkXV0gPSBpdGVtW2ZpZWxkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmlsdGVyZWRJdGVtO1xufTtcblxuLyoqXG4gKiBTb3J0IHRoZSBwcm92aWRlZCBhcnJheSB3aXRoIGl0ZW1zXG4gKiBAcGFyYW0ge09iamVjdFtdfSBpdGVtc1xuICogQHBhcmFtIHtTdHJpbmcgfCBmdW5jdGlvbn0gb3JkZXIgICAgICBBIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fc29ydCA9IGZ1bmN0aW9uIChpdGVtcywgb3JkZXIpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcob3JkZXIpKSB7XG4gICAgLy8gb3JkZXIgYnkgcHJvdmlkZWQgZmllbGQgbmFtZVxuICAgIHZhciBuYW1lID0gb3JkZXI7IC8vIGZpZWxkIG5hbWVcbiAgICBpdGVtcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgYXYgPSBhW25hbWVdO1xuICAgICAgdmFyIGJ2ID0gYltuYW1lXTtcbiAgICAgIHJldHVybiAoYXYgPiBidikgPyAxIDogKChhdiA8IGJ2KSA/IC0xIDogMCk7XG4gICAgfSk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIG9yZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gb3JkZXIgYnkgc29ydCBmdW5jdGlvblxuICAgIGl0ZW1zLnNvcnQob3JkZXIpO1xuICB9XG4gIC8vIFRPRE86IGV4dGVuZCBvcmRlciBieSBhbiBPYmplY3Qge2ZpZWxkOlN0cmluZywgZGlyZWN0aW9uOlN0cmluZ31cbiAgLy8gICAgICAgd2hlcmUgZGlyZWN0aW9uIGNhbiBiZSAnYXNjJyBvciAnZGVzYydcbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3JkZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nJyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIG9iamVjdCBieSBwb2ludGVyIG9yIGJ5IGlkXG4gKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlciB8IE9iamVjdCB8IEFycmF5fSBpZCBPYmplY3Qgb3IgaWQsIG9yIGFuIGFycmF5IHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdHMgb3IgaWRzIHRvIGJlIHJlbW92ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2VuZGVySWRdIE9wdGlvbmFsIHNlbmRlciBpZFxuICogQHJldHVybiB7QXJyYXl9IHJlbW92ZWRJZHNcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGlkLCBzZW5kZXJJZCkge1xuICB2YXIgcmVtb3ZlZElkcyA9IFtdLFxuICAgICAgaSwgbGVuLCByZW1vdmVkSWQ7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgZm9yIChpID0gMCwgbGVuID0gaWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlbW92ZWRJZCA9IHRoaXMuX3JlbW92ZShpZFtpXSk7XG4gICAgICBpZiAocmVtb3ZlZElkICE9IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlZElkcy5wdXNoKHJlbW92ZWRJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHJlbW92ZWRJZCA9IHRoaXMuX3JlbW92ZShpZCk7XG4gICAgaWYgKHJlbW92ZWRJZCAhPSBudWxsKSB7XG4gICAgICByZW1vdmVkSWRzLnB1c2gocmVtb3ZlZElkKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmVtb3ZlZElkcy5sZW5ndGgpIHtcbiAgICB0aGlzLl90cmlnZ2VyKCdyZW1vdmUnLCB7aXRlbXM6IHJlbW92ZWRJZHN9LCBzZW5kZXJJZCk7XG4gIH1cblxuICByZXR1cm4gcmVtb3ZlZElkcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gYnkgaXRzIGlkXG4gKiBAcGFyYW0ge051bWJlciB8IFN0cmluZyB8IE9iamVjdH0gaWQgICBpZCBvciBpdGVtXG4gKiBAcmV0dXJucyB7TnVtYmVyIHwgU3RyaW5nIHwgbnVsbH0gaWRcbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWYgKHV0aWwuaXNOdW1iZXIoaWQpIHx8IHV0aWwuaXNTdHJpbmcoaWQpKSB7XG4gICAgaWYgKHRoaXMuX2RhdGFbaWRdKSB7XG4gICAgICBkZWxldGUgdGhpcy5fZGF0YVtpZF07XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChpZCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIHZhciBpdGVtSWQgPSBpZFt0aGlzLl9maWVsZElkXTtcbiAgICBpZiAoaXRlbUlkICYmIHRoaXMuX2RhdGFbaXRlbUlkXSkge1xuICAgICAgZGVsZXRlIHRoaXMuX2RhdGFbaXRlbUlkXTtcbiAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICByZXR1cm4gaXRlbUlkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIGRhdGFcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2VuZGVySWRdIE9wdGlvbmFsIHNlbmRlciBpZFxuICogQHJldHVybiB7QXJyYXl9IHJlbW92ZWRJZHMgICAgVGhlIGlkcyBvZiBhbGwgcmVtb3ZlZCBpdGVtc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIChzZW5kZXJJZCkge1xuICB2YXIgaWRzID0gT2JqZWN0LmtleXModGhpcy5fZGF0YSk7XG5cbiAgdGhpcy5fZGF0YSA9IHt9O1xuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgdGhpcy5fdHJpZ2dlcigncmVtb3ZlJywge2l0ZW1zOiBpZHN9LCBzZW5kZXJJZCk7XG5cbiAgcmV0dXJuIGlkcztcbn07XG5cbi8qKlxuICogRmluZCB0aGUgaXRlbSB3aXRoIG1heGltdW0gdmFsdWUgb2YgYSBzcGVjaWZpZWQgZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gaXRlbSAgSXRlbSBjb250YWluaW5nIG1heCB2YWx1ZSwgb3IgbnVsbCBpZiBubyBpdGVtc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhLFxuICAgICAgbWF4ID0gbnVsbCxcbiAgICAgIG1heEZpZWxkID0gbnVsbDtcblxuICBmb3IgKHZhciBpZCBpbiBkYXRhKSB7XG4gICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICB2YXIgaXRlbSA9IGRhdGFbaWRdO1xuICAgICAgdmFyIGl0ZW1GaWVsZCA9IGl0ZW1bZmllbGRdO1xuICAgICAgaWYgKGl0ZW1GaWVsZCAhPSBudWxsICYmICghbWF4IHx8IGl0ZW1GaWVsZCA+IG1heEZpZWxkKSkge1xuICAgICAgICBtYXggPSBpdGVtO1xuICAgICAgICBtYXhGaWVsZCA9IGl0ZW1GaWVsZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF4O1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBpdGVtIHdpdGggbWluaW11bSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBpdGVtICBJdGVtIGNvbnRhaW5pbmcgbWF4IHZhbHVlLCBvciBudWxsIGlmIG5vIGl0ZW1zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICBtaW4gPSBudWxsLFxuICAgICAgbWluRmllbGQgPSBudWxsO1xuXG4gIGZvciAodmFyIGlkIGluIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIHZhciBpdGVtID0gZGF0YVtpZF07XG4gICAgICB2YXIgaXRlbUZpZWxkID0gaXRlbVtmaWVsZF07XG4gICAgICBpZiAoaXRlbUZpZWxkICE9IG51bGwgJiYgKCFtaW4gfHwgaXRlbUZpZWxkIDwgbWluRmllbGQpKSB7XG4gICAgICAgIG1pbiA9IGl0ZW07XG4gICAgICAgIG1pbkZpZWxkID0gaXRlbUZpZWxkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaW47XG59O1xuXG4vKipcbiAqIEZpbmQgYWxsIGRpc3RpbmN0IHZhbHVlcyBvZiBhIHNwZWNpZmllZCBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtBcnJheX0gdmFsdWVzICBBcnJheSBjb250YWluaW5nIGFsbCBkaXN0aW5jdCB2YWx1ZXMuIElmIGRhdGEgaXRlbXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGRvIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgZmllbGQgYXJlIGlnbm9yZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgcmV0dXJuZWQgYXJyYXkgaXMgdW5vcmRlcmVkLlxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5kaXN0aW5jdCA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIGZpZWxkVHlwZSA9IHRoaXMuX29wdGlvbnMudHlwZSAmJiB0aGlzLl9vcHRpb25zLnR5cGVbZmllbGRdIHx8IG51bGw7XG4gIHZhciBjb3VudCA9IDA7XG4gIHZhciBpO1xuXG4gIGZvciAodmFyIHByb3AgaW4gZGF0YSkge1xuICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICB2YXIgaXRlbSA9IGRhdGFbcHJvcF07XG4gICAgICB2YXIgdmFsdWUgPSBpdGVtW2ZpZWxkXTtcbiAgICAgIHZhciBleGlzdHMgPSBmYWxzZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGlmICh2YWx1ZXNbaV0gPT0gdmFsdWUpIHtcbiAgICAgICAgICBleGlzdHMgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWV4aXN0cyAmJiAodmFsdWUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdmFsdWVzW2NvdW50XSA9IHZhbHVlO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChmaWVsZFR5cGUpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSB1dGlsLmNvbnZlcnQodmFsdWVzW2ldLCBmaWVsZFR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIHNpbmdsZSBpdGVtLiBXaWxsIGZhaWwgd2hlbiBhbiBpdGVtIHdpdGggdGhlIHNhbWUgaWQgYWxyZWFkeSBleGlzdHMuXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICogQHJldHVybiB7U3RyaW5nfSBpZFxuICogQHByaXZhdGVcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuX2FkZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgaWQgPSBpdGVtW3RoaXMuX2ZpZWxkSWRdO1xuXG4gIGlmIChpZCAhPSB1bmRlZmluZWQpIHtcbiAgICAvLyBjaGVjayB3aGV0aGVyIHRoaXMgaWQgaXMgYWxyZWFkeSB0YWtlblxuICAgIGlmICh0aGlzLl9kYXRhW2lkXSkge1xuICAgICAgLy8gaXRlbSBhbHJlYWR5IGV4aXN0c1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGl0ZW06IGl0ZW0gd2l0aCBpZCAnICsgaWQgKyAnIGFscmVhZHkgZXhpc3RzJyk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGdlbmVyYXRlIGFuIGlkXG4gICAgaWQgPSB1dGlsLnJhbmRvbVVVSUQoKTtcbiAgICBpdGVtW3RoaXMuX2ZpZWxkSWRdID0gaWQ7XG4gIH1cblxuICB2YXIgZCA9IHt9O1xuICBmb3IgKHZhciBmaWVsZCBpbiBpdGVtKSB7XG4gICAgaWYgKGl0ZW0uaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICB2YXIgZmllbGRUeXBlID0gdGhpcy5fdHlwZVtmaWVsZF07ICAvLyB0eXBlIG1heSBiZSB1bmRlZmluZWRcbiAgICAgIGRbZmllbGRdID0gdXRpbC5jb252ZXJ0KGl0ZW1bZmllbGRdLCBmaWVsZFR5cGUpO1xuICAgIH1cbiAgfVxuICB0aGlzLl9kYXRhW2lkXSA9IGQ7XG4gIHRoaXMubGVuZ3RoKys7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gaXRlbS4gRmllbGRzIGNhbiBiZSBjb252ZXJ0ZWQgdG8gYSBzcGVjaWZpYyB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFt0eXBlc10gIGZpZWxkIHR5cGVzIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge09iamVjdCB8IG51bGx9IGl0ZW1cbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl9nZXRJdGVtID0gZnVuY3Rpb24gKGlkLCB0eXBlcykge1xuICB2YXIgZmllbGQsIHZhbHVlO1xuXG4gIC8vIGdldCB0aGUgaXRlbSBmcm9tIHRoZSBkYXRhc2V0XG4gIHZhciByYXcgPSB0aGlzLl9kYXRhW2lkXTtcbiAgaWYgKCFyYXcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgdGhlIGl0ZW1zIGZpZWxkIHR5cGVzXG4gIHZhciBjb252ZXJ0ZWQgPSB7fTtcbiAgaWYgKHR5cGVzKSB7XG4gICAgZm9yIChmaWVsZCBpbiByYXcpIHtcbiAgICAgIGlmIChyYXcuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgIHZhbHVlID0gcmF3W2ZpZWxkXTtcbiAgICAgICAgY29udmVydGVkW2ZpZWxkXSA9IHV0aWwuY29udmVydCh2YWx1ZSwgdHlwZXNbZmllbGRdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gbm8gZmllbGQgdHlwZXMgc3BlY2lmaWVkLCBubyBjb252ZXJ0aW5nIG5lZWRlZFxuICAgIGZvciAoZmllbGQgaW4gcmF3KSB7XG4gICAgICBpZiAocmF3Lmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgICB2YWx1ZSA9IHJhd1tmaWVsZF07XG4gICAgICAgIGNvbnZlcnRlZFtmaWVsZF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRlZDtcbn07XG5cbi8qKlxuICogVXBkYXRlIGEgc2luZ2xlIGl0ZW06IG1lcmdlIHdpdGggZXhpc3RpbmcgaXRlbS5cbiAqIFdpbGwgZmFpbCB3aGVuIHRoZSBpdGVtIGhhcyBubyBpZCwgb3Igd2hlbiB0aGVyZSBkb2VzIG5vdCBleGlzdCBhbiBpdGVtXG4gKiB3aXRoIHRoZSBzYW1lIGlkLlxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAqIEByZXR1cm4ge1N0cmluZ30gaWRcbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl91cGRhdGVJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGlkID0gaXRlbVt0aGlzLl9maWVsZElkXTtcbiAgaWYgKGlkID09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVwZGF0ZSBpdGVtOiBpdGVtIGhhcyBubyBpZCAoaXRlbTogJyArIEpTT04uc3RyaW5naWZ5KGl0ZW0pICsgJyknKTtcbiAgfVxuICB2YXIgZCA9IHRoaXMuX2RhdGFbaWRdO1xuICBpZiAoIWQpIHtcbiAgICAvLyBpdGVtIGRvZXNuJ3QgZXhpc3RcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1cGRhdGUgaXRlbTogbm8gaXRlbSB3aXRoIGlkICcgKyBpZCArICcgZm91bmQnKTtcbiAgfVxuXG4gIC8vIG1lcmdlIHdpdGggY3VycmVudCBpdGVtXG4gIGZvciAodmFyIGZpZWxkIGluIGl0ZW0pIHtcbiAgICBpZiAoaXRlbS5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgIHZhciBmaWVsZFR5cGUgPSB0aGlzLl90eXBlW2ZpZWxkXTsgIC8vIHR5cGUgbWF5IGJlIHVuZGVmaW5lZFxuICAgICAgZFtmaWVsZF0gPSB1dGlsLmNvbnZlcnQoaXRlbVtmaWVsZF0sIGZpZWxkVHlwZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU2V0O1xuIl19
},{"./Queue":17,"./util":46}],16:[function(require,module,exports){
'use strict';

var util = require('./util');
var DataSet = require('./DataSet');

/**
 * DataView
 *
 * a dataview offers a filtered view on a dataset or an other dataview.
 *
 * @param {DataSet | DataView} data
 * @param {Object} [options]   Available options: see method get
 *
 * @constructor DataView
 */
function DataView(data, options) {
  this._data = null;
  this._ids = {}; // ids of the items currently in memory (just contains a boolean true)
  this.length = 0; // number of items in the DataView
  this._options = options || {};
  this._fieldId = 'id'; // name of the field containing id
  this._subscribers = {}; // event subscribers

  var me = this;
  this.listener = function () {
    me._onEvent.apply(me, arguments);
  };

  this.setData(data);
}

// TODO: implement a function .config() to dynamically update things like configured filter
// and trigger changes accordingly

/**
 * Set a data source for the view
 * @param {DataSet | DataView} data
 */
DataView.prototype.setData = function (data) {
  var ids, i, len;

  if (this._data) {
    // unsubscribe from current dataset
    if (this._data.off) {
      this._data.off('*', this.listener);
    }

    // trigger a remove of all items in memory
    ids = [];
    for (var id in this._ids) {
      if (this._ids.hasOwnProperty(id)) {
        ids.push(id);
      }
    }
    this._ids = {};
    this.length = 0;
    this._trigger('remove', { items: ids });
  }

  this._data = data;

  if (this._data) {
    // update fieldId
    this._fieldId = this._options.fieldId || this._data && this._data.options && this._data.options.fieldId || 'id';

    // trigger an add of all added items
    ids = this._data.getIds({ filter: this._options && this._options.filter });
    for (i = 0, len = ids.length; i < len; i++) {
      id = ids[i];
      this._ids[id] = true;
    }
    this.length = ids.length;
    this._trigger('add', { items: ids });

    // subscribe to new dataset
    if (this._data.on) {
      this._data.on('*', this.listener);
    }
  }
};

/**
 * Refresh the DataView. Useful when the DataView has a filter function
 * containing a variable parameter.
 */
DataView.prototype.refresh = function () {
  var id;
  var ids = this._data.getIds({ filter: this._options && this._options.filter });
  var newIds = {};
  var added = [];
  var removed = [];

  // check for additions
  for (var i = 0; i < ids.length; i++) {
    id = ids[i];
    newIds[id] = true;
    if (!this._ids[id]) {
      added.push(id);
      this._ids[id] = true;
      this.length++;
    }
  }

  // check for removals
  for (id in this._ids) {
    if (this._ids.hasOwnProperty(id)) {
      if (!newIds[id]) {
        removed.push(id);
        delete this._ids[id];
        this.length--;
      }
    }
  }

  // trigger events
  if (added.length) {
    this._trigger('add', { items: added });
  }
  if (removed.length) {
    this._trigger('remove', { items: removed });
  }
};

/**
 * Get data from the data view
 *
 * Usage:
 *
 *     get()
 *     get(options: Object)
 *     get(options: Object, data: Array | DataTable)
 *
 *     get(id: Number)
 *     get(id: Number, options: Object)
 *     get(id: Number, options: Object, data: Array | DataTable)
 *
 *     get(ids: Number[])
 *     get(ids: Number[], options: Object)
 *     get(ids: Number[], options: Object, data: Array | DataTable)
 *
 * Where:
 *
 * {Number | String} id         The id of an item
 * {Number[] | String{}} ids    An array with ids of items
 * {Object} options             An Object with options. Available options:
 *                              {String} [type] Type of data to be returned. Can
 *                                              be 'DataTable' or 'Array' (default)
 *                              {Object.<String, String>} [convert]
 *                              {String[]} [fields] field names to be returned
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * {Array | DataTable} [data]   If provided, items will be appended to this
 *                              array or table. Required in case of Google
 *                              DataTable.
 * @param args
 */
DataView.prototype.get = function (args) {
  var me = this;

  // parse the arguments
  var ids, options, data;
  var firstType = util.getType(arguments[0]);
  if (firstType == 'String' || firstType == 'Number' || firstType == 'Array') {
    // get(id(s) [, options] [, data])
    ids = arguments[0]; // can be a single id or an array with ids
    options = arguments[1];
    data = arguments[2];
  } else {
    // get([, options] [, data])
    options = arguments[0];
    data = arguments[1];
  }

  // extend the options with the default options and provided options
  var viewOptions = util.extend({}, this._options, options);

  // create a combined filter method when needed
  if (this._options.filter && options && options.filter) {
    viewOptions.filter = function (item) {
      return me._options.filter(item) && options.filter(item);
    };
  }

  // build up the call to the linked data set
  var getArguments = [];
  if (ids != undefined) {
    getArguments.push(ids);
  }
  getArguments.push(viewOptions);
  getArguments.push(data);

  return this._data && this._data.get.apply(this._data, getArguments);
};

/**
 * Get ids of all items or from a filtered set of items.
 * @param {Object} [options]    An Object with options. Available options:
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Array} ids
 */
DataView.prototype.getIds = function (options) {
  var ids;

  if (this._data) {
    var defaultFilter = this._options.filter;
    var filter;

    if (options && options.filter) {
      if (defaultFilter) {
        filter = function (item) {
          return defaultFilter(item) && options.filter(item);
        };
      } else {
        filter = options.filter;
      }
    } else {
      filter = defaultFilter;
    }

    ids = this._data.getIds({
      filter: filter,
      order: options && options.order
    });
  } else {
    ids = [];
  }

  return ids;
};

/**
 * Get the DataSet to which this DataView is connected. In case there is a chain
 * of multiple DataViews, the root DataSet of this chain is returned.
 * @return {DataSet} dataSet
 */
DataView.prototype.getDataSet = function () {
  var dataSet = this;
  while (dataSet instanceof DataView) {
    dataSet = dataSet._data;
  }
  return dataSet || null;
};

/**
 * Event listener. Will propagate all events from the connected data set to
 * the subscribers of the DataView, but will filter the items and only trigger
 * when there are changes in the filtered data set.
 * @param {String} event
 * @param {Object | null} params
 * @param {String} senderId
 * @private
 */
DataView.prototype._onEvent = function (event, params, senderId) {
  var i, len, id, item;
  var ids = params && params.items;
  var data = this._data;
  var updatedData = [];
  var added = [];
  var updated = [];
  var removed = [];

  if (ids && data) {
    switch (event) {
      case 'add':
        // filter the ids of the added items
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          item = this.get(id);
          if (item) {
            this._ids[id] = true;
            added.push(id);
          }
        }

        break;

      case 'update':
        // determine the event from the views viewpoint: an updated
        // item can be added, updated, or removed from this view.
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          item = this.get(id);

          if (item) {
            if (this._ids[id]) {
              updated.push(id);
              updatedData.push(params.data[i]);
            } else {
              this._ids[id] = true;
              added.push(id);
            }
          } else {
            if (this._ids[id]) {
              delete this._ids[id];
              removed.push(id);
            } else {
              // nothing interesting for me :-(
            }
          }
        }

        break;

      case 'remove':
        // filter the ids of the removed items
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          if (this._ids[id]) {
            delete this._ids[id];
            removed.push(id);
          }
        }

        break;
    }

    this.length += added.length - removed.length;

    if (added.length) {
      this._trigger('add', { items: added }, senderId);
    }
    if (updated.length) {
      this._trigger('update', { items: updated, data: updatedData }, senderId);
    }
    if (removed.length) {
      this._trigger('remove', { items: removed }, senderId);
    }
  }
};

// copy subscription functionality from DataSet
DataView.prototype.on = DataSet.prototype.on;
DataView.prototype.off = DataSet.prototype.off;
DataView.prototype._trigger = DataSet.prototype._trigger;

// TODO: make these functions deprecated (replaced with `on` and `off` since version 0.5)
DataView.prototype.subscribe = DataView.prototype.on;
DataView.prototype.unsubscribe = DataView.prototype.off;

module.exports = DataView;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvRGF0YVZpZXcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDN0IsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7QUFZbkMsU0FBUyxRQUFRLENBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRTtBQUNoQyxNQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztBQUNsQixNQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNmLE1BQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0FBQ2hCLE1BQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxJQUFJLEVBQUUsQ0FBQztBQUM5QixNQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztBQUNyQixNQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQzs7QUFFdkIsTUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDO0FBQ2QsTUFBSSxDQUFDLFFBQVEsR0FBRyxZQUFZO0FBQzFCLE1BQUUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQztHQUNsQyxDQUFDOztBQUVGLE1BQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDcEI7Ozs7Ozs7OztBQVNELFFBQVEsQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUFHLFVBQVUsSUFBSSxFQUFFO0FBQzNDLE1BQUksR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUM7O0FBRWhCLE1BQUksSUFBSSxDQUFDLEtBQUssRUFBRTs7QUFFZCxRQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFO0FBQ2xCLFVBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7S0FDcEM7OztBQUdELE9BQUcsR0FBRyxFQUFFLENBQUM7QUFDVCxTQUFLLElBQUksRUFBRSxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7QUFDeEIsVUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUNoQyxXQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO09BQ2Q7S0FDRjtBQUNELFFBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ2YsUUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDaEIsUUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsRUFBQyxLQUFLLEVBQUUsR0FBRyxFQUFDLENBQUMsQ0FBQztHQUN2Qzs7QUFFRCxNQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzs7QUFFbEIsTUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFOztBQUVkLFFBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLElBQ2hDLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxBQUFDLElBQ2hFLElBQUksQ0FBQzs7O0FBR1QsT0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUMsQ0FBQyxDQUFDO0FBQ3pFLFNBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzFDLFFBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDWixVQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztLQUN0QjtBQUNELFFBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQztBQUN6QixRQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFDLEtBQUssRUFBRSxHQUFHLEVBQUMsQ0FBQyxDQUFDOzs7QUFHbkMsUUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRTtBQUNqQixVQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0tBQ25DO0dBQ0Y7Q0FDRixDQUFDOzs7Ozs7QUFNRixRQUFRLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRyxZQUFZO0FBQ3ZDLE1BQUksRUFBRSxDQUFDO0FBQ1AsTUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBQyxDQUFDLENBQUM7QUFDN0UsTUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ2hCLE1BQUksS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNmLE1BQUksT0FBTyxHQUFHLEVBQUUsQ0FBQzs7O0FBR2pCLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ25DLE1BQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDWixVQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQ2xCLFFBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQ2xCLFdBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDZixVQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztBQUNyQixVQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7S0FDZjtHQUNGOzs7QUFHRCxPQUFLLEVBQUUsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO0FBQ3BCLFFBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDaEMsVUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUNmLGVBQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDakIsZUFBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3JCLFlBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztPQUNmO0tBQ0Y7R0FDRjs7O0FBR0QsTUFBSSxLQUFLLENBQUMsTUFBTSxFQUFFO0FBQ2hCLFFBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLEVBQUMsS0FBSyxFQUFFLEtBQUssRUFBQyxDQUFDLENBQUM7R0FDdEM7QUFDRCxNQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUU7QUFDbEIsUUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsRUFBQyxLQUFLLEVBQUUsT0FBTyxFQUFDLENBQUMsQ0FBQztHQUMzQztDQUNGLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9DRixRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRyxVQUFVLElBQUksRUFBRTtBQUN2QyxNQUFJLEVBQUUsR0FBRyxJQUFJLENBQUM7OztBQUdkLE1BQUksR0FBRyxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUM7QUFDdkIsTUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzQyxNQUFJLFNBQVMsSUFBSSxRQUFRLElBQUksU0FBUyxJQUFJLFFBQVEsSUFBSSxTQUFTLElBQUksT0FBTyxFQUFFOztBQUUxRSxPQUFHLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ25CLFdBQU8sR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkIsUUFBSSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUNyQixNQUNJOztBQUVILFdBQU8sR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkIsUUFBSSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUNyQjs7O0FBR0QsTUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQzs7O0FBRzFELE1BQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLElBQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUU7QUFDckQsZUFBVyxDQUFDLE1BQU0sR0FBRyxVQUFVLElBQUksRUFBRTtBQUNuQyxhQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDekQsQ0FBQTtHQUNGOzs7QUFHRCxNQUFJLFlBQVksR0FBRyxFQUFFLENBQUM7QUFDdEIsTUFBSSxHQUFHLElBQUksU0FBUyxFQUFFO0FBQ3BCLGdCQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0dBQ3hCO0FBQ0QsY0FBWSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUMvQixjQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDOztBQUV4QixTQUFPLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUM7Q0FDckUsQ0FBQzs7Ozs7Ozs7OztBQVVGLFFBQVEsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLFVBQVUsT0FBTyxFQUFFO0FBQzdDLE1BQUksR0FBRyxDQUFDOztBQUVSLE1BQUksSUFBSSxDQUFDLEtBQUssRUFBRTtBQUNkLFFBQUksYUFBYSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDO0FBQ3pDLFFBQUksTUFBTSxDQUFDOztBQUVYLFFBQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUU7QUFDN0IsVUFBSSxhQUFhLEVBQUU7QUFDakIsY0FBTSxHQUFHLFVBQVUsSUFBSSxFQUFFO0FBQ3ZCLGlCQUFPLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3BELENBQUE7T0FDRixNQUNJO0FBQ0gsY0FBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7T0FDekI7S0FDRixNQUNJO0FBQ0gsWUFBTSxHQUFHLGFBQWEsQ0FBQztLQUN4Qjs7QUFFRCxPQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7QUFDdEIsWUFBTSxFQUFFLE1BQU07QUFDZCxXQUFLLEVBQUUsT0FBTyxJQUFJLE9BQU8sQ0FBQyxLQUFLO0tBQ2hDLENBQUMsQ0FBQztHQUNKLE1BQ0k7QUFDSCxPQUFHLEdBQUcsRUFBRSxDQUFDO0dBQ1Y7O0FBRUQsU0FBTyxHQUFHLENBQUM7Q0FDWixDQUFDOzs7Ozs7O0FBT0YsUUFBUSxDQUFDLFNBQVMsQ0FBQyxVQUFVLEdBQUcsWUFBWTtBQUMxQyxNQUFJLE9BQU8sR0FBRyxJQUFJLENBQUM7QUFDbkIsU0FBTyxPQUFPLFlBQVksUUFBUSxFQUFFO0FBQ2xDLFdBQU8sR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO0dBQ3pCO0FBQ0QsU0FBTyxPQUFPLElBQUksSUFBSSxDQUFDO0NBQ3hCLENBQUM7Ozs7Ozs7Ozs7O0FBV0YsUUFBUSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsVUFBVSxLQUFLLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRTtBQUMvRCxNQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQztBQUNyQixNQUFJLEdBQUcsR0FBRyxNQUFNLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQztBQUNqQyxNQUFJLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO0FBQ3RCLE1BQUksV0FBVyxHQUFHLEVBQUUsQ0FBQztBQUNyQixNQUFJLEtBQUssR0FBRyxFQUFFLENBQUM7QUFDZixNQUFJLE9BQU8sR0FBRyxFQUFFLENBQUM7QUFDakIsTUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDOztBQUVqQixNQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUU7QUFDZixZQUFRLEtBQUs7QUFDWCxXQUFLLEtBQUs7O0FBRVIsYUFBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDMUMsWUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNaLGNBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3BCLGNBQUksSUFBSSxFQUFFO0FBQ1IsZ0JBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQ3JCLGlCQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1dBQ2hCO1NBQ0Y7O0FBRUQsY0FBTTs7QUFBQSxBQUVSLFdBQUssUUFBUTs7O0FBR1gsYUFBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDMUMsWUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNaLGNBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDOztBQUVwQixjQUFJLElBQUksRUFBRTtBQUNSLGdCQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDakIscUJBQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDakIseUJBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ2xDLE1BQ0k7QUFDSCxrQkFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDckIsbUJBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDaEI7V0FDRixNQUNJO0FBQ0gsZ0JBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUNqQixxQkFBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3JCLHFCQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ2xCLE1BQ0k7O2FBRUo7V0FDRjtTQUNGOztBQUVELGNBQU07O0FBQUEsQUFFUixXQUFLLFFBQVE7O0FBRVgsYUFBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDMUMsWUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNaLGNBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUNqQixtQkFBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3JCLG1CQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1dBQ2xCO1NBQ0Y7O0FBRUQsY0FBTTtBQUFBLEtBQ1Q7O0FBRUQsUUFBSSxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7O0FBRTdDLFFBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtBQUNoQixVQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFDLEtBQUssRUFBRSxLQUFLLEVBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztLQUNoRDtBQUNELFFBQUksT0FBTyxDQUFDLE1BQU0sRUFBRTtBQUNsQixVQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxFQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQ3hFO0FBQ0QsUUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFO0FBQ2xCLFVBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLEVBQUMsS0FBSyxFQUFFLE9BQU8sRUFBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQ3JEO0dBQ0Y7Q0FDRixDQUFDOzs7QUFHRixRQUFRLENBQUMsU0FBUyxDQUFDLEVBQUUsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztBQUM3QyxRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQztBQUMvQyxRQUFRLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQzs7O0FBR3pELFFBQVEsQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDO0FBQ3JELFFBQVEsQ0FBQyxTQUFTLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDOztBQUV4RCxNQUFNLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyIsImZpbGUiOiIvVXNlcnMvZGFyaW4vRGV2ZWxvcG1lbnQvbWFwc3Rvcnkvc3RvcnktdG9vbHMtdmlld2VyL25vZGVfbW9kdWxlcy92aXMvbGliL0RhdGFWaWV3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBEYXRhU2V0ID0gcmVxdWlyZSgnLi9EYXRhU2V0Jyk7XG5cbi8qKlxuICogRGF0YVZpZXdcbiAqXG4gKiBhIGRhdGF2aWV3IG9mZmVycyBhIGZpbHRlcmVkIHZpZXcgb24gYSBkYXRhc2V0IG9yIGFuIG90aGVyIGRhdGF2aWV3LlxuICpcbiAqIEBwYXJhbSB7RGF0YVNldCB8IERhdGFWaWV3fSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgQXZhaWxhYmxlIG9wdGlvbnM6IHNlZSBtZXRob2QgZ2V0XG4gKlxuICogQGNvbnN0cnVjdG9yIERhdGFWaWV3XG4gKi9cbmZ1bmN0aW9uIERhdGFWaWV3IChkYXRhLCBvcHRpb25zKSB7XG4gIHRoaXMuX2RhdGEgPSBudWxsO1xuICB0aGlzLl9pZHMgPSB7fTsgLy8gaWRzIG9mIHRoZSBpdGVtcyBjdXJyZW50bHkgaW4gbWVtb3J5IChqdXN0IGNvbnRhaW5zIGEgYm9vbGVhbiB0cnVlKVxuICB0aGlzLmxlbmd0aCA9IDA7IC8vIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgRGF0YVZpZXdcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX2ZpZWxkSWQgPSAnaWQnOyAvLyBuYW1lIG9mIHRoZSBmaWVsZCBjb250YWluaW5nIGlkXG4gIHRoaXMuX3N1YnNjcmliZXJzID0ge307IC8vIGV2ZW50IHN1YnNjcmliZXJzXG5cbiAgdmFyIG1lID0gdGhpcztcbiAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICBtZS5fb25FdmVudC5hcHBseShtZSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICB0aGlzLnNldERhdGEoZGF0YSk7XG59XG5cbi8vIFRPRE86IGltcGxlbWVudCBhIGZ1bmN0aW9uIC5jb25maWcoKSB0byBkeW5hbWljYWxseSB1cGRhdGUgdGhpbmdzIGxpa2UgY29uZmlndXJlZCBmaWx0ZXJcbi8vIGFuZCB0cmlnZ2VyIGNoYW5nZXMgYWNjb3JkaW5nbHlcblxuLyoqXG4gKiBTZXQgYSBkYXRhIHNvdXJjZSBmb3IgdGhlIHZpZXdcbiAqIEBwYXJhbSB7RGF0YVNldCB8IERhdGFWaWV3fSBkYXRhXG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIGlkcywgaSwgbGVuO1xuXG4gIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBjdXJyZW50IGRhdGFzZXRcbiAgICBpZiAodGhpcy5fZGF0YS5vZmYpIHtcbiAgICAgIHRoaXMuX2RhdGEub2ZmKCcqJywgdGhpcy5saXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciBhIHJlbW92ZSBvZiBhbGwgaXRlbXMgaW4gbWVtb3J5XG4gICAgaWRzID0gW107XG4gICAgZm9yICh2YXIgaWQgaW4gdGhpcy5faWRzKSB7XG4gICAgICBpZiAodGhpcy5faWRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICBpZHMucHVzaChpZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2lkcyA9IHt9O1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl90cmlnZ2VyKCdyZW1vdmUnLCB7aXRlbXM6IGlkc30pO1xuICB9XG5cbiAgdGhpcy5fZGF0YSA9IGRhdGE7XG5cbiAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAvLyB1cGRhdGUgZmllbGRJZFxuICAgIHRoaXMuX2ZpZWxkSWQgPSB0aGlzLl9vcHRpb25zLmZpZWxkSWQgfHxcbiAgICAgICAgKHRoaXMuX2RhdGEgJiYgdGhpcy5fZGF0YS5vcHRpb25zICYmIHRoaXMuX2RhdGEub3B0aW9ucy5maWVsZElkKSB8fFxuICAgICAgICAnaWQnO1xuXG4gICAgLy8gdHJpZ2dlciBhbiBhZGQgb2YgYWxsIGFkZGVkIGl0ZW1zXG4gICAgaWRzID0gdGhpcy5fZGF0YS5nZXRJZHMoe2ZpbHRlcjogdGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLmZpbHRlcn0pO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWQgPSBpZHNbaV07XG4gICAgICB0aGlzLl9pZHNbaWRdID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBpZHMubGVuZ3RoO1xuICAgIHRoaXMuX3RyaWdnZXIoJ2FkZCcsIHtpdGVtczogaWRzfSk7XG5cbiAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICBpZiAodGhpcy5fZGF0YS5vbikge1xuICAgICAgdGhpcy5fZGF0YS5vbignKicsIHRoaXMubGlzdGVuZXIpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZWZyZXNoIHRoZSBEYXRhVmlldy4gVXNlZnVsIHdoZW4gdGhlIERhdGFWaWV3IGhhcyBhIGZpbHRlciBmdW5jdGlvblxuICogY29udGFpbmluZyBhIHZhcmlhYmxlIHBhcmFtZXRlci5cbiAqL1xuRGF0YVZpZXcucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZDtcbiAgdmFyIGlkcyA9IHRoaXMuX2RhdGEuZ2V0SWRzKHtmaWx0ZXI6IHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5maWx0ZXJ9KTtcbiAgdmFyIG5ld0lkcyA9IHt9O1xuICB2YXIgYWRkZWQgPSBbXTtcbiAgdmFyIHJlbW92ZWQgPSBbXTtcblxuICAvLyBjaGVjayBmb3IgYWRkaXRpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWQgPSBpZHNbaV07XG4gICAgbmV3SWRzW2lkXSA9IHRydWU7XG4gICAgaWYgKCF0aGlzLl9pZHNbaWRdKSB7XG4gICAgICBhZGRlZC5wdXNoKGlkKTtcbiAgICAgIHRoaXMuX2lkc1tpZF0gPSB0cnVlO1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBmb3IgcmVtb3ZhbHNcbiAgZm9yIChpZCBpbiB0aGlzLl9pZHMpIHtcbiAgICBpZiAodGhpcy5faWRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgaWYgKCFuZXdJZHNbaWRdKSB7XG4gICAgICAgIHJlbW92ZWQucHVzaChpZCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9pZHNbaWRdO1xuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHRyaWdnZXIgZXZlbnRzXG4gIGlmIChhZGRlZC5sZW5ndGgpIHtcbiAgICB0aGlzLl90cmlnZ2VyKCdhZGQnLCB7aXRlbXM6IGFkZGVkfSk7XG4gIH1cbiAgaWYgKHJlbW92ZWQubGVuZ3RoKSB7XG4gICAgdGhpcy5fdHJpZ2dlcigncmVtb3ZlJywge2l0ZW1zOiByZW1vdmVkfSk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IGRhdGEgZnJvbSB0aGUgZGF0YSB2aWV3XG4gKlxuICogVXNhZ2U6XG4gKlxuICogICAgIGdldCgpXG4gKiAgICAgZ2V0KG9wdGlvbnM6IE9iamVjdClcbiAqICAgICBnZXQob3B0aW9uczogT2JqZWN0LCBkYXRhOiBBcnJheSB8IERhdGFUYWJsZSlcbiAqXG4gKiAgICAgZ2V0KGlkOiBOdW1iZXIpXG4gKiAgICAgZ2V0KGlkOiBOdW1iZXIsIG9wdGlvbnM6IE9iamVjdClcbiAqICAgICBnZXQoaWQ6IE51bWJlciwgb3B0aW9uczogT2JqZWN0LCBkYXRhOiBBcnJheSB8IERhdGFUYWJsZSlcbiAqXG4gKiAgICAgZ2V0KGlkczogTnVtYmVyW10pXG4gKiAgICAgZ2V0KGlkczogTnVtYmVyW10sIG9wdGlvbnM6IE9iamVjdClcbiAqICAgICBnZXQoaWRzOiBOdW1iZXJbXSwgb3B0aW9uczogT2JqZWN0LCBkYXRhOiBBcnJheSB8IERhdGFUYWJsZSlcbiAqXG4gKiBXaGVyZTpcbiAqXG4gKiB7TnVtYmVyIHwgU3RyaW5nfSBpZCAgICAgICAgIFRoZSBpZCBvZiBhbiBpdGVtXG4gKiB7TnVtYmVyW10gfCBTdHJpbmd7fX0gaWRzICAgIEFuIGFycmF5IHdpdGggaWRzIG9mIGl0ZW1zXG4gKiB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgIEFuIE9iamVjdCB3aXRoIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBbdHlwZV0gVHlwZSBvZiBkYXRhIHRvIGJlIHJldHVybmVkLiBDYW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlICdEYXRhVGFibGUnIG9yICdBcnJheScgKGRlZmF1bHQpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW2NvbnZlcnRdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmdbXX0gW2ZpZWxkc10gZmllbGQgbmFtZXMgdG8gYmUgcmV0dXJuZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdIE9yZGVyIHRoZSBpdGVtcyBieVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICoge0FycmF5IHwgRGF0YVRhYmxlfSBbZGF0YV0gICBJZiBwcm92aWRlZCwgaXRlbXMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5IG9yIHRhYmxlLiBSZXF1aXJlZCBpbiBjYXNlIG9mIEdvb2dsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXRhVGFibGUuXG4gKiBAcGFyYW0gYXJnc1xuICovXG5EYXRhVmlldy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICAvLyBwYXJzZSB0aGUgYXJndW1lbnRzXG4gIHZhciBpZHMsIG9wdGlvbnMsIGRhdGE7XG4gIHZhciBmaXJzdFR5cGUgPSB1dGlsLmdldFR5cGUoYXJndW1lbnRzWzBdKTtcbiAgaWYgKGZpcnN0VHlwZSA9PSAnU3RyaW5nJyB8fCBmaXJzdFR5cGUgPT0gJ051bWJlcicgfHwgZmlyc3RUeXBlID09ICdBcnJheScpIHtcbiAgICAvLyBnZXQoaWQocykgWywgb3B0aW9uc10gWywgZGF0YV0pXG4gICAgaWRzID0gYXJndW1lbnRzWzBdOyAgLy8gY2FuIGJlIGEgc2luZ2xlIGlkIG9yIGFuIGFycmF5IHdpdGggaWRzXG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICBkYXRhID0gYXJndW1lbnRzWzJdO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIGdldChbLCBvcHRpb25zXSBbLCBkYXRhXSlcbiAgICBvcHRpb25zID0gYXJndW1lbnRzWzBdO1xuICAgIGRhdGEgPSBhcmd1bWVudHNbMV07XG4gIH1cblxuICAvLyBleHRlbmQgdGhlIG9wdGlvbnMgd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zIGFuZCBwcm92aWRlZCBvcHRpb25zXG4gIHZhciB2aWV3T3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLl9vcHRpb25zLCBvcHRpb25zKTtcblxuICAvLyBjcmVhdGUgYSBjb21iaW5lZCBmaWx0ZXIgbWV0aG9kIHdoZW4gbmVlZGVkXG4gIGlmICh0aGlzLl9vcHRpb25zLmZpbHRlciAmJiBvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgdmlld09wdGlvbnMuZmlsdGVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBtZS5fb3B0aW9ucy5maWx0ZXIoaXRlbSkgJiYgb3B0aW9ucy5maWx0ZXIoaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgLy8gYnVpbGQgdXAgdGhlIGNhbGwgdG8gdGhlIGxpbmtlZCBkYXRhIHNldFxuICB2YXIgZ2V0QXJndW1lbnRzID0gW107XG4gIGlmIChpZHMgIT0gdW5kZWZpbmVkKSB7XG4gICAgZ2V0QXJndW1lbnRzLnB1c2goaWRzKTtcbiAgfVxuICBnZXRBcmd1bWVudHMucHVzaCh2aWV3T3B0aW9ucyk7XG4gIGdldEFyZ3VtZW50cy5wdXNoKGRhdGEpO1xuXG4gIHJldHVybiB0aGlzLl9kYXRhICYmIHRoaXMuX2RhdGEuZ2V0LmFwcGx5KHRoaXMuX2RhdGEsIGdldEFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIEdldCBpZHMgb2YgYWxsIGl0ZW1zIG9yIGZyb20gYSBmaWx0ZXJlZCBzZXQgb2YgaXRlbXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEFuIE9iamVjdCB3aXRoIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtBcnJheX0gaWRzXG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5nZXRJZHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgaWRzO1xuXG4gIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgdmFyIGRlZmF1bHRGaWx0ZXIgPSB0aGlzLl9vcHRpb25zLmZpbHRlcjtcbiAgICB2YXIgZmlsdGVyO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIGlmIChkZWZhdWx0RmlsdGVyKSB7XG4gICAgICAgIGZpbHRlciA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWx0ZXIoaXRlbSkgJiYgb3B0aW9ucy5maWx0ZXIoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyO1xuICAgIH1cblxuICAgIGlkcyA9IHRoaXMuX2RhdGEuZ2V0SWRzKHtcbiAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgb3JkZXI6IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlclxuICAgIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgIGlkcyA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGlkcztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBEYXRhU2V0IHRvIHdoaWNoIHRoaXMgRGF0YVZpZXcgaXMgY29ubmVjdGVkLiBJbiBjYXNlIHRoZXJlIGlzIGEgY2hhaW5cbiAqIG9mIG11bHRpcGxlIERhdGFWaWV3cywgdGhlIHJvb3QgRGF0YVNldCBvZiB0aGlzIGNoYWluIGlzIHJldHVybmVkLlxuICogQHJldHVybiB7RGF0YVNldH0gZGF0YVNldFxuICovXG5EYXRhVmlldy5wcm90b3R5cGUuZ2V0RGF0YVNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRhdGFTZXQgPSB0aGlzO1xuICB3aGlsZSAoZGF0YVNldCBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgZGF0YVNldCA9IGRhdGFTZXQuX2RhdGE7XG4gIH1cbiAgcmV0dXJuIGRhdGFTZXQgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogRXZlbnQgbGlzdGVuZXIuIFdpbGwgcHJvcGFnYXRlIGFsbCBldmVudHMgZnJvbSB0aGUgY29ubmVjdGVkIGRhdGEgc2V0IHRvXG4gKiB0aGUgc3Vic2NyaWJlcnMgb2YgdGhlIERhdGFWaWV3LCBidXQgd2lsbCBmaWx0ZXIgdGhlIGl0ZW1zIGFuZCBvbmx5IHRyaWdnZXJcbiAqIHdoZW4gdGhlcmUgYXJlIGNoYW5nZXMgaW4gdGhlIGZpbHRlcmVkIGRhdGEgc2V0LlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdCB8IG51bGx9IHBhcmFtc1xuICogQHBhcmFtIHtTdHJpbmd9IHNlbmRlcklkXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhVmlldy5wcm90b3R5cGUuX29uRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgdmFyIGksIGxlbiwgaWQsIGl0ZW07XG4gIHZhciBpZHMgPSBwYXJhbXMgJiYgcGFyYW1zLml0ZW1zO1xuICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gIHZhciB1cGRhdGVkRGF0YSA9IFtdO1xuICB2YXIgYWRkZWQgPSBbXTtcbiAgdmFyIHVwZGF0ZWQgPSBbXTtcbiAgdmFyIHJlbW92ZWQgPSBbXTtcblxuICBpZiAoaWRzICYmIGRhdGEpIHtcbiAgICBzd2l0Y2ggKGV2ZW50KSB7XG4gICAgICBjYXNlICdhZGQnOlxuICAgICAgICAvLyBmaWx0ZXIgdGhlIGlkcyBvZiB0aGUgYWRkZWQgaXRlbXNcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWQgPSBpZHNbaV07XG4gICAgICAgICAgaXRlbSA9IHRoaXMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5faWRzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICBhZGRlZC5wdXNoKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndXBkYXRlJzpcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBldmVudCBmcm9tIHRoZSB2aWV3cyB2aWV3cG9pbnQ6IGFuIHVwZGF0ZWRcbiAgICAgICAgLy8gaXRlbSBjYW4gYmUgYWRkZWQsIHVwZGF0ZWQsIG9yIHJlbW92ZWQgZnJvbSB0aGlzIHZpZXcuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLmdldChpZCk7XG5cbiAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lkc1tpZF0pIHtcbiAgICAgICAgICAgICAgdXBkYXRlZC5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgdXBkYXRlZERhdGEucHVzaChwYXJhbXMuZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5faWRzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgIGFkZGVkLnB1c2goaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pZHNbaWRdKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pZHNbaWRdO1xuICAgICAgICAgICAgICByZW1vdmVkLnB1c2goaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIG5vdGhpbmcgaW50ZXJlc3RpbmcgZm9yIG1lIDotKFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyZW1vdmUnOlxuICAgICAgICAvLyBmaWx0ZXIgdGhlIGlkcyBvZiB0aGUgcmVtb3ZlZCBpdGVtc1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZCA9IGlkc1tpXTtcbiAgICAgICAgICBpZiAodGhpcy5faWRzW2lkXSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2lkc1tpZF07XG4gICAgICAgICAgICByZW1vdmVkLnB1c2goaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoICs9IGFkZGVkLmxlbmd0aCAtIHJlbW92ZWQubGVuZ3RoO1xuXG4gICAgaWYgKGFkZGVkLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdHJpZ2dlcignYWRkJywge2l0ZW1zOiBhZGRlZH0sIHNlbmRlcklkKTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyKCd1cGRhdGUnLCB7aXRlbXM6IHVwZGF0ZWQsIGRhdGE6IHVwZGF0ZWREYXRhfSwgc2VuZGVySWQpO1xuICAgIH1cbiAgICBpZiAocmVtb3ZlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHtpdGVtczogcmVtb3ZlZH0sIHNlbmRlcklkKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGNvcHkgc3Vic2NyaXB0aW9uIGZ1bmN0aW9uYWxpdHkgZnJvbSBEYXRhU2V0XG5EYXRhVmlldy5wcm90b3R5cGUub24gPSBEYXRhU2V0LnByb3RvdHlwZS5vbjtcbkRhdGFWaWV3LnByb3RvdHlwZS5vZmYgPSBEYXRhU2V0LnByb3RvdHlwZS5vZmY7XG5EYXRhVmlldy5wcm90b3R5cGUuX3RyaWdnZXIgPSBEYXRhU2V0LnByb3RvdHlwZS5fdHJpZ2dlcjtcblxuLy8gVE9ETzogbWFrZSB0aGVzZSBmdW5jdGlvbnMgZGVwcmVjYXRlZCAocmVwbGFjZWQgd2l0aCBgb25gIGFuZCBgb2ZmYCBzaW5jZSB2ZXJzaW9uIDAuNSlcbkRhdGFWaWV3LnByb3RvdHlwZS5zdWJzY3JpYmUgPSBEYXRhVmlldy5wcm90b3R5cGUub247XG5EYXRhVmlldy5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBEYXRhVmlldy5wcm90b3R5cGUub2ZmO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3OyJdfQ==
},{"./DataSet":15,"./util":46}],17:[function(require,module,exports){
/**
 * A queue
 * @param {Object} options
 *            Available options:
 *            - delay: number    When provided, the queue will be flushed
 *                               automatically after an inactivity of this delay
 *                               in milliseconds.
 *                               Default value is null.
 *            - max: number      When the queue exceeds the given maximum number
 *                               of entries, the queue is flushed automatically.
 *                               Default value of max is Infinity.
 * @constructor
 */
'use strict';

function Queue(options) {
  // options
  this.delay = null;
  this.max = Infinity;

  // properties
  this._queue = [];
  this._timeout = null;
  this._extended = null;

  this.setOptions(options);
}

/**
 * Update the configuration of the queue
 * @param {Object} options
 *            Available options:
 *            - delay: number    When provided, the queue will be flushed
 *                               automatically after an inactivity of this delay
 *                               in milliseconds.
 *                               Default value is null.
 *            - max: number      When the queue exceeds the given maximum number
 *                               of entries, the queue is flushed automatically.
 *                               Default value of max is Infinity.
 * @param options
 */
Queue.prototype.setOptions = function (options) {
  if (options && typeof options.delay !== 'undefined') {
    this.delay = options.delay;
  }
  if (options && typeof options.max !== 'undefined') {
    this.max = options.max;
  }

  this._flushIfNeeded();
};

/**
 * Extend an object with queuing functionality.
 * The object will be extended with a function flush, and the methods provided
 * in options.replace will be replaced with queued ones.
 * @param {Object} object
 * @param {Object} options
 *            Available options:
 *            - replace: Array.<string>
 *                               A list with method names of the methods
 *                               on the object to be replaced with queued ones.
 *            - delay: number    When provided, the queue will be flushed
 *                               automatically after an inactivity of this delay
 *                               in milliseconds.
 *                               Default value is null.
 *            - max: number      When the queue exceeds the given maximum number
 *                               of entries, the queue is flushed automatically.
 *                               Default value of max is Infinity.
 * @return {Queue} Returns the created queue
 */
Queue.extend = function (object, options) {
  var queue = new Queue(options);

  if (object.flush !== undefined) {
    throw new Error('Target object already has a property flush');
  }
  object.flush = function () {
    queue.flush();
  };

  var methods = [{
    name: 'flush',
    original: undefined
  }];

  if (options && options.replace) {
    for (var i = 0; i < options.replace.length; i++) {
      var name = options.replace[i];
      methods.push({
        name: name,
        original: object[name]
      });
      queue.replace(object, name);
    }
  }

  queue._extended = {
    object: object,
    methods: methods
  };

  return queue;
};

/**
 * Destroy the queue. The queue will first flush all queued actions, and in
 * case it has extended an object, will restore the original object.
 */
Queue.prototype.destroy = function () {
  this.flush();

  if (this._extended) {
    var object = this._extended.object;
    var methods = this._extended.methods;
    for (var i = 0; i < methods.length; i++) {
      var method = methods[i];
      if (method.original) {
        object[method.name] = method.original;
      } else {
        delete object[method.name];
      }
    }
    this._extended = null;
  }
};

/**
 * Replace a method on an object with a queued version
 * @param {Object} object   Object having the method
 * @param {string} method   The method name
 */
Queue.prototype.replace = function (object, method) {
  var me = this;
  var original = object[method];
  if (!original) {
    throw new Error('Method ' + method + ' undefined');
  }

  object[method] = function () {
    // create an Array with the arguments
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    // add this call to the queue
    me.queue({
      args: args,
      fn: original,
      context: this
    });
  };
};

/**
 * Queue a call
 * @param {function | {fn: function, args: Array} | {fn: function, args: Array, context: Object}} entry
 */
Queue.prototype.queue = function (entry) {
  if (typeof entry === 'function') {
    this._queue.push({ fn: entry });
  } else {
    this._queue.push(entry);
  }

  this._flushIfNeeded();
};

/**
 * Check whether the queue needs to be flushed
 * @private
 */
Queue.prototype._flushIfNeeded = function () {
  // flush when the maximum is exceeded.
  if (this._queue.length > this.max) {
    this.flush();
  }

  // flush after a period of inactivity when a delay is configured
  clearTimeout(this._timeout);
  if (this.queue.length > 0 && typeof this.delay === 'number') {
    var me = this;
    this._timeout = setTimeout(function () {
      me.flush();
    }, this.delay);
  }
};

/**
 * Flush all queued calls
 */
Queue.prototype.flush = function () {
  while (this._queue.length > 0) {
    var entry = this._queue.shift();
    entry.fn.apply(entry.context || entry.fn, entry.args || []);
  }
};

module.exports = Queue;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvUXVldWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBYUEsU0FBUyxLQUFLLENBQUMsT0FBTyxFQUFFOztBQUV0QixNQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztBQUNsQixNQUFJLENBQUMsR0FBRyxHQUFHLFFBQVEsQ0FBQzs7O0FBR3BCLE1BQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ2pCLE1BQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO0FBQ3JCLE1BQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDOztBQUV0QixNQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0NBQzFCOzs7Ozs7Ozs7Ozs7Ozs7QUFlRCxLQUFLLENBQUMsU0FBUyxDQUFDLFVBQVUsR0FBRyxVQUFVLE9BQU8sRUFBRTtBQUM5QyxNQUFJLE9BQU8sSUFBSSxPQUFPLE9BQU8sQ0FBQyxLQUFLLEtBQUssV0FBVyxFQUFFO0FBQ25ELFFBQUksQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztHQUM1QjtBQUNELE1BQUksT0FBTyxJQUFJLE9BQU8sT0FBTyxDQUFDLEdBQUcsS0FBSyxXQUFXLEVBQUU7QUFDakQsUUFBSSxDQUFDLEdBQUcsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDO0dBQ3hCOztBQUVELE1BQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztDQUN2QixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkYsS0FBSyxDQUFDLE1BQU0sR0FBRyxVQUFVLE1BQU0sRUFBRSxPQUFPLEVBQUU7QUFDeEMsTUFBSSxLQUFLLEdBQUcsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7O0FBRS9CLE1BQUksTUFBTSxDQUFDLEtBQUssS0FBSyxTQUFTLEVBQUU7QUFDOUIs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LElBQUksRUFBRSxDQUFDLENBQUM7R0FDN0Q7Q0FDRixDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvUXVldWUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgcXVldWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAtIGRlbGF5OiBudW1iZXIgICAgV2hlbiBwcm92aWRlZCwgdGhlIHF1ZXVlIHdpbGwgYmUgZmx1c2hlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljYWxseSBhZnRlciBhbiBpbmFjdGl2aXR5IG9mIHRoaXMgZGVsYXlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIG1pbGxpc2Vjb25kcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgaXMgbnVsbC5cbiAqICAgICAgICAgICAgLSBtYXg6IG51bWJlciAgICAgIFdoZW4gdGhlIHF1ZXVlIGV4Y2VlZHMgdGhlIGdpdmVuIG1heGltdW0gbnVtYmVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBlbnRyaWVzLCB0aGUgcXVldWUgaXMgZmx1c2hlZCBhdXRvbWF0aWNhbGx5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBvZiBtYXggaXMgSW5maW5pdHkuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUXVldWUob3B0aW9ucykge1xuICAvLyBvcHRpb25zXG4gIHRoaXMuZGVsYXkgPSBudWxsO1xuICB0aGlzLm1heCA9IEluZmluaXR5O1xuXG4gIC8vIHByb3BlcnRpZXNcbiAgdGhpcy5fcXVldWUgPSBbXTtcbiAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gIHRoaXMuX2V4dGVuZGVkID0gbnVsbDtcblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBxdWV1ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgIC0gZGVsYXk6IG51bWJlciAgICBXaGVuIHByb3ZpZGVkLCB0aGUgcXVldWUgd2lsbCBiZSBmbHVzaGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGFmdGVyIGFuIGluYWN0aXZpdHkgb2YgdGhpcyBkZWxheVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gbWlsbGlzZWNvbmRzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBpcyBudWxsLlxuICogICAgICAgICAgICAtIG1heDogbnVtYmVyICAgICAgV2hlbiB0aGUgcXVldWUgZXhjZWVkcyB0aGUgZ2l2ZW4gbWF4aW11bSBudW1iZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGVudHJpZXMsIHRoZSBxdWV1ZSBpcyBmbHVzaGVkIGF1dG9tYXRpY2FsbHkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIG9mIG1heCBpcyBJbmZpbml0eS5cbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuZGVsYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5kZWxheSA9IG9wdGlvbnMuZGVsYXk7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMubWF4ID0gb3B0aW9ucy5tYXg7XG4gIH1cblxuICB0aGlzLl9mbHVzaElmTmVlZGVkKCk7XG59O1xuXG4vKipcbiAqIEV4dGVuZCBhbiBvYmplY3Qgd2l0aCBxdWV1aW5nIGZ1bmN0aW9uYWxpdHkuXG4gKiBUaGUgb2JqZWN0IHdpbGwgYmUgZXh0ZW5kZWQgd2l0aCBhIGZ1bmN0aW9uIGZsdXNoLCBhbmQgdGhlIG1ldGhvZHMgcHJvdmlkZWRcbiAqIGluIG9wdGlvbnMucmVwbGFjZSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggcXVldWVkIG9uZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgLSByZXBsYWNlOiBBcnJheS48c3RyaW5nPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBsaXN0IHdpdGggbWV0aG9kIG5hbWVzIG9mIHRoZSBtZXRob2RzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbiB0aGUgb2JqZWN0IHRvIGJlIHJlcGxhY2VkIHdpdGggcXVldWVkIG9uZXMuXG4gKiAgICAgICAgICAgIC0gZGVsYXk6IG51bWJlciAgICBXaGVuIHByb3ZpZGVkLCB0aGUgcXVldWUgd2lsbCBiZSBmbHVzaGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGFmdGVyIGFuIGluYWN0aXZpdHkgb2YgdGhpcyBkZWxheVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gbWlsbGlzZWNvbmRzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBpcyBudWxsLlxuICogICAgICAgICAgICAtIG1heDogbnVtYmVyICAgICAgV2hlbiB0aGUgcXVldWUgZXhjZWVkcyB0aGUgZ2l2ZW4gbWF4aW11bSBudW1iZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGVudHJpZXMsIHRoZSBxdWV1ZSBpcyBmbHVzaGVkIGF1dG9tYXRpY2FsbHkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIG9mIG1heCBpcyBJbmZpbml0eS5cbiAqIEByZXR1cm4ge1F1ZXVlfSBSZXR1cm5zIHRoZSBjcmVhdGVkIHF1ZXVlXG4gKi9cblF1ZXVlLmV4dGVuZCA9IGZ1bmN0aW9uIChvYmplY3QsIG9wdGlvbnMpIHtcbiAgdmFyIHF1ZXVlID0gbmV3IFF1ZXVlKG9wdGlvbnMpO1xuXG4gIGlmIChvYmplY3QuZmx1c2ggIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGFyZ2V0IG9iamVjdCBhbHJlYWR5IGhhcyBhIHByb3BlcnR5IGZsdXNoJyk7XG4gIH1cbiAgb2JqZWN0LmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHF1ZXVlLmZsdXNoKCk7XG4gIH07XG5cbiAgdmFyIG1ldGhvZHMgPSBbe1xuICAgIG5hbWU6ICdmbHVzaCcsXG4gICAgb3JpZ2luYWw6IHVuZGVmaW5lZFxuICB9XTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMucmVwbGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLnJlcGxhY2VbaV07XG4gICAgICBtZXRob2RzLnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBvcmlnaW5hbDogb2JqZWN0W25hbWVdXG4gICAgICB9KTtcbiAgICAgIHF1ZXVlLnJlcGxhY2Uob2JqZWN0LCBuYW1lKTtcbiAgICB9XG4gIH1cblxuICBxdWV1ZS5fZXh0ZW5kZWQgPSB7XG4gICAgb2JqZWN0OiBvYmplY3QsXG4gICAgbWV0aG9kczogbWV0aG9kc1xuICB9O1xuXG4gIHJldHVybiBxdWV1ZTtcbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGUgcXVldWUuIFRoZSBxdWV1ZSB3aWxsIGZpcnN0IGZsdXNoIGFsbCBxdWV1ZWQgYWN0aW9ucywgYW5kIGluXG4gKiBjYXNlIGl0IGhhcyBleHRlbmRlZCBhbiBvYmplY3QsIHdpbGwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICovXG5RdWV1ZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5mbHVzaCgpO1xuXG4gIGlmICh0aGlzLl9leHRlbmRlZCkge1xuICAgIHZhciBvYmplY3QgPSB0aGlzLl9leHRlbmRlZC5vYmplY3Q7XG4gICAgdmFyIG1ldGhvZHMgPSB0aGlzLl9leHRlbmRlZC5tZXRob2RzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG1ldGhvZCA9IG1ldGhvZHNbaV07XG4gICAgICBpZiAobWV0aG9kLm9yaWdpbmFsKSB7XG4gICAgICAgIG9iamVjdFttZXRob2QubmFtZV0gPSBtZXRob2Qub3JpZ2luYWw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIG9iamVjdFttZXRob2QubmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2V4dGVuZGVkID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXBsYWNlIGEgbWV0aG9kIG9uIGFuIG9iamVjdCB3aXRoIGEgcXVldWVkIHZlcnNpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgICBPYmplY3QgaGF2aW5nIHRoZSBtZXRob2RcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgICBUaGUgbWV0aG9kIG5hbWVcbiAqL1xuUXVldWUucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbihvYmplY3QsIG1ldGhvZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuICB2YXIgb3JpZ2luYWwgPSBvYmplY3RbbWV0aG9kXTtcbiAgaWYgKCFvcmlnaW5hbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kICcgKyBtZXRob2QgKyAnIHVuZGVmaW5lZCcpO1xuICB9XG5cbiAgb2JqZWN0W21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY3JlYXRlIGFuIEFycmF5IHdpdGggdGhlIGFyZ3VtZW50c1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgLy8gYWRkIHRoaXMgY2FsbCB0byB0aGUgcXVldWVcbiAgICBtZS5xdWV1ZSh7XG4gICAgICBhcmdzOiBhcmdzLFxuICAgICAgZm46IG9yaWdpbmFsLFxuICAgICAgY29udGV4dDogdGhpc1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBRdWV1ZSBhIGNhbGxcbiAqIEBwYXJhbSB7ZnVuY3Rpb24gfCB7Zm46IGZ1bmN0aW9uLCBhcmdzOiBBcnJheX0gfCB7Zm46IGZ1bmN0aW9uLCBhcmdzOiBBcnJheSwgY29udGV4dDogT2JqZWN0fX0gZW50cnlcbiAqL1xuUXVldWUucHJvdG90eXBlLnF1ZXVlID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX3F1ZXVlLnB1c2goe2ZuOiBlbnRyeX0pO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuX3F1ZXVlLnB1c2goZW50cnkpO1xuICB9XG5cbiAgdGhpcy5fZmx1c2hJZk5lZWRlZCgpO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBxdWV1ZSBuZWVkcyB0byBiZSBmbHVzaGVkXG4gKiBAcHJpdmF0ZVxuICovXG5RdWV1ZS5wcm90b3R5cGUuX2ZsdXNoSWZOZWVkZWQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGZsdXNoIHdoZW4gdGhlIG1heGltdW0gaXMgZXhjZWVkZWQuXG4gIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPiB0aGlzLm1heCkge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxuXG4gIC8vIGZsdXNoIGFmdGVyIGEgcGVyaW9kIG9mIGluYWN0aXZpdHkgd2hlbiBhIGRlbGF5IGlzIGNvbmZpZ3VyZWRcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiAwICYmIHR5cGVvZiB0aGlzLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgbWUuZmx1c2goKTtcbiAgICB9LCB0aGlzLmRlbGF5KTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCBhbGwgcXVldWVkIGNhbGxzXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgd2hpbGUgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgIGVudHJ5LmZuLmFwcGx5KGVudHJ5LmNvbnRleHQgfHwgZW50cnkuZm4sIGVudHJ5LmFyZ3MgfHwgW10pO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXVlO1xuIl19
},{}],18:[function(require,module,exports){
'use strict';

var Hammer = require('./module/hammer');

/**
 * Register a touch event, taking place before a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.onTouch = function (hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFirst && !isTouching) {
      callback(event);

      isTouching = true;
      setTimeout(function () {
        isTouching = false;
      }, 0);
    }
  };

  hammer.on('hammer.input', callback.inputHandler);
};

// isTouching is true while a touch action is being emitted
// this is a hack to prevent `touch` from being fired twice
var isTouching = false;

/**
 * Register a release event, taking place after a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.onRelease = function (hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFinal && !isReleasing) {
      callback(event);

      isReleasing = true;
      setTimeout(function () {
        isReleasing = false;
      }, 0);
    }
  };

  return hammer.on('hammer.input', callback.inputHandler);
};

// isReleasing is true while a release action is being emitted
// this is a hack to prevent `release` from being fired twice
var isReleasing = false;

/**
 * Unregister a touch event, taking place before a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.offTouch = function (hammer, callback) {
  hammer.off('hammer.input', callback.inputHandler);
};

/**
 * Unregister a release event, taking place before a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.offRelease = exports.offTouch;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvaGFtbWVyVXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDOzs7Ozs7O0FBT3hDLE9BQU8sQ0FBQyxPQUFPLEdBQUcsVUFBVSxNQUFNLEVBQUUsUUFBUSxFQUFFO0FBQzVDLFVBQVEsQ0FBQyxZQUFZLEdBQUcsVUFBVSxLQUFLLEVBQUU7QUFDdkMsUUFBSSxLQUFLLENBQUMsT0FBTyxJQUFJLENBQUMsVUFBVSxFQUFFO0FBQ2hDLGNBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7QUFFaEIsZ0JBQVUsR0FBRyxJQUFJLENBQUM7QUFDbEIsZ0JBQVUsQ0FBQyxZQUFZO0FBQ3JCLGtCQUFVLEdBQUcsS0FBSyxDQUFDO09BQ3BCLEVBQUUsQ0FBQyxDQUFDLENBQUM7S0FDUDtHQUNGLENBQUM7O0FBRUYsUUFBTSxDQUFDLEVBQUUsQ0FBQyxjQUFjLEVBQUUsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO0NBQ2xELENBQUM7Ozs7QUFJRixJQUFJLFVBQVUsR0FBRyxLQUFLLENBQUM7Ozs7Ozs7QUFPdkIsT0FBTyxDQUFDLFNBQVMsR0FBRyxVQUFVLE1BQU0sRUFBRSxRQUFRLEVBQUU7QUFDOUMsVUFBUSxDQUFDLFlBQVksR0FBRyxVQUFVLEtBQUssRUFBRTtBQUN2QyxRQUFJLEtBQUssQ0FBQyxPQUFPLElBQUksQ0FBQyxXQUFXLEVBQUU7QUFDakMsY0FBUSxDQUFDLEtBQUssQ0FBQyxDQUFDOztBQUVoQixpQkFBVyxHQUFHLElBQUksQ0FBQztBQUNuQixnQkFBVSxDQUFDLFlBQVk7QUFDckIsbUJBQVcsR0FBRyxLQUFLLENBQUM7T0FDckIsRUFBRSxDQUFDLENBQUMsQ0FBQztLQUNQO0dBQ0YsQ0FBQzs7QUFFRixTQUFPLE1BQU0sQ0FBQyxFQUFFLENBQUMsY0FBYyxFQUFFLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQztDQUN6RCxDQUFDOzs7O0FBS0YsSUFBSSxXQUFXLEdBQUcsS0FBSyxDQUFDOzs7Ozs7O0FBUXhCLE9BQU8sQ0FBQyxRQUFRLEdBQUcsVUFBVSxNQUFNLEVBQUUsUUFBUSxFQUFFO0FBQzdDLFFBQU0sQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQztDQUNuRCxDQUFDOzs7Ozs7O0FBT0YsT0FBTyxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvaGFtbWVyVXRpbC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBIYW1tZXIgPSByZXF1aXJlKCcuL21vZHVsZS9oYW1tZXInKTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIHRvdWNoIGV2ZW50LCB0YWtpbmcgcGxhY2UgYmVmb3JlIGEgZ2VzdHVyZVxuICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICovXG5leHBvcnRzLm9uVG91Y2ggPSBmdW5jdGlvbiAoaGFtbWVyLCBjYWxsYmFjaykge1xuICBjYWxsYmFjay5pbnB1dEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuaXNGaXJzdCAmJiAhaXNUb3VjaGluZykge1xuICAgICAgY2FsbGJhY2soZXZlbnQpO1xuXG4gICAgICBpc1RvdWNoaW5nID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpc1RvdWNoaW5nID0gZmFsc2U7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH07XG5cbiAgaGFtbWVyLm9uKCdoYW1tZXIuaW5wdXQnLCBjYWxsYmFjay5pbnB1dEhhbmRsZXIpO1xufTtcblxuLy8gaXNUb3VjaGluZyBpcyB0cnVlIHdoaWxlIGEgdG91Y2ggYWN0aW9uIGlzIGJlaW5nIGVtaXR0ZWRcbi8vIHRoaXMgaXMgYSBoYWNrIHRvIHByZXZlbnQgYHRvdWNoYCBmcm9tIGJlaW5nIGZpcmVkIHR3aWNlXG52YXIgaXNUb3VjaGluZyA9IGZhbHNlO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgcmVsZWFzZSBldmVudCwgdGFraW5nIHBsYWNlIGFmdGVyIGEgZ2VzdHVyZVxuICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICovXG5leHBvcnRzLm9uUmVsZWFzZSA9IGZ1bmN0aW9uIChoYW1tZXIsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrLmlucHV0SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5pc0ZpbmFsICYmICFpc1JlbGVhc2luZykge1xuICAgICAgY2FsbGJhY2soZXZlbnQpO1xuXG4gICAgICBpc1JlbGVhc2luZyA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXNSZWxlYXNpbmcgPSBmYWxzZTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gaGFtbWVyLm9uKCdoYW1tZXIuaW5wdXQnLCBjYWxsYmFjay5pbnB1dEhhbmRsZXIpO1xufTtcblxuXG4vLyBpc1JlbGVhc2luZyBpcyB0cnVlIHdoaWxlIGEgcmVsZWFzZSBhY3Rpb24gaXMgYmVpbmcgZW1pdHRlZFxuLy8gdGhpcyBpcyBhIGhhY2sgdG8gcHJldmVudCBgcmVsZWFzZWAgZnJvbSBiZWluZyBmaXJlZCB0d2ljZVxudmFyIGlzUmVsZWFzaW5nID0gZmFsc2U7XG5cblxuLyoqXG4gKiBVbnJlZ2lzdGVyIGEgdG91Y2ggZXZlbnQsIHRha2luZyBwbGFjZSBiZWZvcmUgYSBnZXN0dXJlXG4gKiBAcGFyYW0ge0hhbW1lcn0gaGFtbWVyICAgICAgIEEgaGFtbWVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrLCBjYWxsZWQgYXMgY2FsbGJhY2soZXZlbnQpXG4gKi9cbmV4cG9ydHMub2ZmVG91Y2ggPSBmdW5jdGlvbiAoaGFtbWVyLCBjYWxsYmFjaykge1xuICBoYW1tZXIub2ZmKCdoYW1tZXIuaW5wdXQnLCBjYWxsYmFjay5pbnB1dEhhbmRsZXIpO1xufTtcblxuLyoqXG4gKiBVbnJlZ2lzdGVyIGEgcmVsZWFzZSBldmVudCwgdGFraW5nIHBsYWNlIGJlZm9yZSBhIGdlc3R1cmVcbiAqIEBwYXJhbSB7SGFtbWVyfSBoYW1tZXIgICAgICAgQSBoYW1tZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgQ2FsbGJhY2ssIGNhbGxlZCBhcyBjYWxsYmFjayhldmVudClcbiAqL1xuZXhwb3J0cy5vZmZSZWxlYXNlID0gZXhwb3J0cy5vZmZUb3VjaDtcbiJdfQ==
},{"./module/hammer":19}],19:[function(require,module,exports){
// Only load hammer.js when in a browser environment
// (loading hammer.js in a node.js environment gives errors)
'use strict';

if (typeof window !== 'undefined') {
  var propagating = require('propagating-hammerjs');
  var Hammer = window['Hammer'] || require('hammerjs');
  module.exports = propagating(Hammer, {
    preventDefault: 'mouse'
  });
} else {
  module.exports = function () {
    throw Error('hammer.js is only available in a browser, not in node.js.');
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvbW9kdWxlL2hhbW1lci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBRUEsSUFBSSxPQUFPLE1BQU0sS0FBSyxXQUFXLEVBQUU7QUFDakMsTUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFDLHNCQUFzQixDQUFDLENBQUM7QUFDbEQsTUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNyRCxRQUFNLENBQUMsT0FBTyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEVBQUU7QUFDbkMsa0JBQWMsRUFBRSxPQUFPO0dBQ3hCLENBQUMsQ0FBQztDQUNKLE1BQ0k7QUFDSCxRQUFNLENBQUMsT0FBTyxHQUFHLFlBQVk7QUFDM0IsVUFBTSxLQUFLLENBQUMsMkRBQTJELENBQUMsQ0FBQztHQUMxRSxDQUFBO0NBQ0YiLCJmaWxlIjoiL1VzZXJzL2RhcmluL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzLXZpZXdlci9ub2RlX21vZHVsZXMvdmlzL2xpYi9tb2R1bGUvaGFtbWVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gT25seSBsb2FkIGhhbW1lci5qcyB3aGVuIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudFxuLy8gKGxvYWRpbmcgaGFtbWVyLmpzIGluIGEgbm9kZS5qcyBlbnZpcm9ubWVudCBnaXZlcyBlcnJvcnMpXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIHByb3BhZ2F0aW5nID0gcmVxdWlyZSgncHJvcGFnYXRpbmctaGFtbWVyanMnKTtcbiAgdmFyIEhhbW1lciA9IHdpbmRvd1snSGFtbWVyJ10gfHwgcmVxdWlyZSgnaGFtbWVyanMnKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9wYWdhdGluZyhIYW1tZXIsIHtcbiAgICBwcmV2ZW50RGVmYXVsdDogJ21vdXNlJ1xuICB9KTtcbn1cbmVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBFcnJvcignaGFtbWVyLmpzIGlzIG9ubHkgYXZhaWxhYmxlIGluIGEgYnJvd3Nlciwgbm90IGluIG5vZGUuanMuJyk7XG4gIH1cbn1cbiJdfQ==
},{"hammerjs":11,"propagating-hammerjs":14}],20:[function(require,module,exports){
// first check if moment.js is already loaded in the browser window, if so,
// use this instance. Else, load via commonjs.
'use strict';

module.exports = typeof window !== 'undefined' && window['moment'] || require('moment');
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvbW9kdWxlL21vbWVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBRUEsTUFBTSxDQUFDLE9BQU8sR0FBRyxBQUFDLE9BQU8sTUFBTSxLQUFLLFdBQVcsSUFBSyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvbW9kdWxlL21vbWVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGZpcnN0IGNoZWNrIGlmIG1vbWVudC5qcyBpcyBhbHJlYWR5IGxvYWRlZCBpbiB0aGUgYnJvd3NlciB3aW5kb3csIGlmIHNvLFxuLy8gdXNlIHRoaXMgaW5zdGFuY2UuIEVsc2UsIGxvYWQgdmlhIGNvbW1vbmpzLlxubW9kdWxlLmV4cG9ydHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpICYmIHdpbmRvd1snbW9tZW50J10gfHwgcmVxdWlyZSgnbW9tZW50Jyk7XG4iXX0=
},{"moment":13}],21:[function(require,module,exports){
(function (global){
'use strict';

var _rng;

var globalVar = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;

if (globalVar && globalVar.crypto && crypto.getRandomValues) {
  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
  // Moderately fast, high quality
  var _rnds8 = new Uint8Array(16);
  _rng = function whatwgRNG() {
    crypto.getRandomValues(_rnds8);
    return _rnds8;
  };
}

if (!_rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var _rnds = new Array(16);
  _rng = function () {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return _rnds;
  };
}

//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

// Unique ID creation requires a high quality random # generator.  We feature
// detect to determine the best RNG source, normalizing to a function that
// returns 128-bits of randomness, since that's what's usually required

//var _rng = require('./rng');

// Maps for number <-> hex string conversion
var _byteToHex = [];
var _hexToByte = {};
for (var i = 0; i < 256; i++) {
  _byteToHex[i] = (i + 0x100).toString(16).substr(1);
  _hexToByte[_byteToHex[i]] = i;
}

// **`parse()` - Parse a UUID into it's component bytes**
function parse(s, buf, offset) {
  var i = buf && offset || 0,
      ii = 0;

  buf = buf || [];
  s.toLowerCase().replace(/[0-9a-f]{2}/g, function (oct) {
    if (ii < 16) {
      // Don't overflow!
      buf[i + ii++] = _hexToByte[oct];
    }
  });

  // Zero out remaining bytes if string was short
  while (ii < 16) {
    buf[i + ii++] = 0;
  }

  return buf;
}

// **`unparse()` - Convert UUID byte array (ala parse()) into a string**
function unparse(buf, offset) {
  var i = offset || 0,
      bth = _byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
}

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = _rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0,
    _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; n++) {
    b[i + n] = node[n];
  }

  return buf ? buf : unparse(b);
}

// **`v4()` - Generate random UUID**

// See https://github.com/broofa/node-uuid for API details
function v4(options, buf, offset) {
  // Deprecated - 'format' argument, as supported in v1.2
  var i = buf && offset || 0;

  if (typeof options == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || _rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ii++) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || unparse(rnds);
}

// Export public API
var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
uuid.parse = parse;
uuid.unparse = unparse;

module.exports = uuid;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvbW9kdWxlL3V1aWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLElBQUksQ0FBQzs7QUFFVCxJQUFJLFNBQVMsR0FBRyxPQUFPLE1BQU0sS0FBSyxXQUFXLEdBQ3ZDLE1BQU0sR0FDTixPQUFPLE1BQU0sS0FBSyxXQUFXLEdBQUcsTUFBTSxHQUFHLElBQUksQ0FBQzs7QUFFcEQsSUFBSSxTQUFTLElBQUksU0FBUyxDQUFDLE1BQU0sSUFBSSxNQUFNLENBQUMsZUFBZSxFQUFFOzs7QUFHM0QsTUFBSSxNQUFNLEdBQUcsSUFBSSxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDaEMsTUFBSSxHQUFHLFNBQVMsU0FBUyxHQUFHO0FBQzFCLFVBQU0sQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDL0IsV0FBTyxNQUFNLENBQUM7R0FDZixDQUFDO0NBQ0g7O0FBRUQsSUFBSSxDQUFDLElBQUksRUFBRTs7Ozs7QUFLVCxNQUFJLEtBQUssR0FBRyxJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUMxQixNQUFJLEdBQUcsWUFBWTtBQUNqQixTQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUM5QixVQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQSxLQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLFdBQVcsQ0FBQztBQUN0RCxXQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQSxJQUFLLENBQUMsQ0FBQSxBQUFDLEdBQUcsSUFBSSxDQUFDO0tBQzNDOztBQUVELFdBQU8sS0FBSyxDQUFDO0dBQ2QsQ0FBQztDQUNIOzs7Ozs7Ozs7Ozs7OztBQWNELElBQUksVUFBVSxHQUFHLEVBQUUsQ0FBQztBQUNwQixJQUFJLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFDcEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUM1QixZQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFBLENBQUUsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNuRCxZQUFVLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQy9COzs7QUFHRCxTQUFTLEtBQUssQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRTtBQUM3QixNQUFJLENBQUMsR0FBRyxBQUFDLEdBQUcsSUFBSSxNQUFNLElBQUssQ0FBQztNQUFFLEVBQUUsR0FBRyxDQUFDLENBQUM7O0FBRXJDLEtBQUcsR0FBRyxHQUFHLElBQUksRUFBRSxDQUFDO0FBQ2hCLEdBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFLFVBQVUsR0FBRyxFQUFFO0FBQ3JELFFBQUksRUFBRSxHQUFHLEVBQUUsRUFBRTs7QUFDWCxTQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ2pDO0dBQ0YsQ0FBQyxDQUFDOzs7QUFHSCxTQUFPLEVBQUUsR0FBRyxFQUFFLEVBQUU7QUFDZCxPQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0dBQ25COztBQUVELFNBQU8sR0FBRyxDQUFDO0NBQ1o7OztBQUdELFNBQVMsT0FBTyxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUU7QUFDNUIsTUFBSSxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUM7TUFBRSxHQUFHLEdBQUcsVUFBVSxDQUFDO0FBQ3RDLFNBQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQ2hDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FDbkMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUNuQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQ25DLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FDbkMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQzdCLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUM3QixHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztDQUNuQzs7Ozs7Ozs7QUFRRCxJQUFJLFVBQVUsR0FBRyxJQUFJLEVBQUUsQ0FBQzs7O0FBR3hCLElBQUksT0FBTyxHQUFHLENBQ1osVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksRUFDcEIsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FDMUUsQ0FBQzs7O0FBR0YsSUFBSSxTQUFTLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQSxHQUFJLE1BQU0sQ0FBQzs7O0FBRzlELElBQUksVUFBVSxHQUFHLENBQUM7SUFBRSxVQUFVLEdBQUcsQ0FBQyxDQUFDOzs7QUFHbkMsU0FBUyxFQUFFLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUU7QUFDaEMsTUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLE1BQU0sSUFBSSxDQUFDLENBQUM7QUFDM0IsTUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLEVBQUUsQ0FBQzs7QUFFbEIsU0FBTyxHQUFHLE9BQU8sSUFBSSxFQUFFLENBQUM7O0FBRXhCLE1BQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxRQUFRLEtBQUssU0FBUyxHQUFHLE9BQU8sQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDOzs7Ozs7QUFNN0UsTUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssS0FBSyxTQUFTLEdBQUcsT0FBTyxDQUFDLEtBQUssR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDOzs7O0FBSS9FLE1BQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFLLEtBQUssU0FBUyxHQUFHLE9BQU8sQ0FBQyxLQUFLLEdBQUcsVUFBVSxHQUFHLENBQUMsQ0FBQzs7O0FBR3pFLE1BQUksRUFBRSxHQUFHLEFBQUMsS0FBSyxHQUFHLFVBQVUsR0FBSSxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUEsR0FBSSxLQUFLLENBQUM7OztBQUc3RCxNQUFJLEVBQUUsR0FBRyxDQUFDLElBQUksT0FBTyxDQUFDLFFBQVEsS0FBSyxTQUFTLEVBQUU7QUFD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QUM7OztBQUdyRCxNQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQUFBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFJLElBQUksQ0FBQztBQUNsQyxNQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQUFBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFJLElBQUksQ0FBQzs7O0FBR2xDLE1BQUksR0FBRyxFQUFFO0FBQ1AsU0FBSyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUM5QixTQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUN4QjtHQUNGOztBQUVELFNBQU8sR0FBRyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUM3Qjs7O0FBR0QsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ2QsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7QUFDYixJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQztBQUNiLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ25CLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDOztBQUV2QixNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyIsImZpbGUiOiIvVXNlcnMvZGFyaW4vRGV2ZWxvcG1lbnQvbWFwc3Rvcnkvc3RvcnktdG9vbHMtdmlld2VyL25vZGVfbW9kdWxlcy92aXMvbGliL21vZHVsZS91dWlkLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIF9ybmc7XG5cbnZhciBnbG9iYWxWYXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gd2luZG93XG4gICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IG51bGw7XG5cbmlmIChnbG9iYWxWYXIgJiYgZ2xvYmFsVmFyLmNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIC8vIFdIQVRXRyBjcnlwdG8tYmFzZWQgUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICAvLyBNb2RlcmF0ZWx5IGZhc3QsIGhpZ2ggcXVhbGl0eVxuICB2YXIgX3JuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBfcm5nID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoX3JuZHM4KTtcbiAgICByZXR1cm4gX3JuZHM4O1xuICB9O1xufVxuXG5pZiAoIV9ybmcpIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgX3JuZHMgPSBuZXcgQXJyYXkoMTYpO1xuICBfcm5nID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBfcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JuZHM7XG4gIH07XG59XG5cbi8vICAgICB1dWlkLmpzXG4vL1xuLy8gICAgIENvcHlyaWdodCAoYykgMjAxMC0yMDEyIFJvYmVydCBLaWVmZmVyXG4vLyAgICAgTUlUIExpY2Vuc2UgLSBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cbi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBXZSBmZWF0dXJlXG4vLyBkZXRlY3QgdG8gZGV0ZXJtaW5lIHRoZSBiZXN0IFJORyBzb3VyY2UsIG5vcm1hbGl6aW5nIHRvIGEgZnVuY3Rpb24gdGhhdFxuLy8gcmV0dXJucyAxMjgtYml0cyBvZiByYW5kb21uZXNzLCBzaW5jZSB0aGF0J3Mgd2hhdCdzIHVzdWFsbHkgcmVxdWlyZWRcblxuLy92YXIgX3JuZyA9IHJlcXVpcmUoJy4vcm5nJyk7XG5cbi8vIE1hcHMgZm9yIG51bWJlciA8LT4gaGV4IHN0cmluZyBjb252ZXJzaW9uXG52YXIgX2J5dGVUb0hleCA9IFtdO1xudmFyIF9oZXhUb0J5dGUgPSB7fTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgX2J5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG4gIF9oZXhUb0J5dGVbX2J5dGVUb0hleFtpXV0gPSBpO1xufVxuXG4vLyAqKmBwYXJzZSgpYCAtIFBhcnNlIGEgVVVJRCBpbnRvIGl0J3MgY29tcG9uZW50IGJ5dGVzKipcbmZ1bmN0aW9uIHBhcnNlKHMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gKGJ1ZiAmJiBvZmZzZXQpIHx8IDAsIGlpID0gMDtcblxuICBidWYgPSBidWYgfHwgW107XG4gIHMudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bMC05YS1mXXsyfS9nLCBmdW5jdGlvbiAob2N0KSB7XG4gICAgaWYgKGlpIDwgMTYpIHsgLy8gRG9uJ3Qgb3ZlcmZsb3chXG4gICAgICBidWZbaSArIGlpKytdID0gX2hleFRvQnl0ZVtvY3RdO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gWmVybyBvdXQgcmVtYWluaW5nIGJ5dGVzIGlmIHN0cmluZyB3YXMgc2hvcnRcbiAgd2hpbGUgKGlpIDwgMTYpIHtcbiAgICBidWZbaSArIGlpKytdID0gMDtcbiAgfVxuXG4gIHJldHVybiBidWY7XG59XG5cbi8vICoqYHVucGFyc2UoKWAgLSBDb252ZXJ0IFVVSUQgYnl0ZSBhcnJheSAoYWxhIHBhcnNlKCkpIGludG8gYSBzdHJpbmcqKlxuZnVuY3Rpb24gdW5wYXJzZShidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwLCBidGggPSBfYnl0ZVRvSGV4O1xuICByZXR1cm4gYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV07XG59XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxuLy8gcmFuZG9tICMncyB3ZSBuZWVkIHRvIGluaXQgbm9kZSBhbmQgY2xvY2tzZXFcbnZhciBfc2VlZEJ5dGVzID0gX3JuZygpO1xuXG4vLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbnZhciBfbm9kZUlkID0gW1xuICBfc2VlZEJ5dGVzWzBdIHwgMHgwMSxcbiAgX3NlZWRCeXRlc1sxXSwgX3NlZWRCeXRlc1syXSwgX3NlZWRCeXRlc1szXSwgX3NlZWRCeXRlc1s0XSwgX3NlZWRCeXRlc1s1XVxuXTtcblxuLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbnZhciBfY2xvY2tzZXEgPSAoX3NlZWRCeXRlc1s2XSA8PCA4IHwgX3NlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG5cbi8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxudmFyIF9sYXN0TVNlY3MgPSAwLCBfbGFzdE5TZWNzID0gMDtcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7XG5cbiAgLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gIHZhciBkdCA9IChtc2VjcyAtIF9sYXN0TVNlY3MpICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDtcblxuICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH1cblxuICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9XG5cbiAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3V1aWQudjEoKTogQ2FuXFwndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWMnKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XG5cbiAgLy8gYHRpbWVfbG93YFxuICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gIC8vIGB0aW1lX21pZGBcbiAgdmFyIHRtaCA9IChtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDApICYgMHhmZmZmZmZmO1xuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bWggJiAweGZmO1xuXG4gIC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cbiAgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDtcblxuICAvLyBgY2xvY2tfc2VxX2xvd2BcbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmO1xuXG4gIC8vIGBub2RlYFxuICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICBmb3IgKHZhciBuID0gMDsgbiA8IDY7IG4rKykge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgPyBidWYgOiB1bnBhcnNlKGIpO1xufVxuXG4vLyAqKmB2NCgpYCAtIEdlbmVyYXRlIHJhbmRvbSBVVUlEKipcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgLy8gRGVwcmVjYXRlZCAtICdmb3JtYXQnIGFyZ3VtZW50LCBhcyBzdXBwb3J0ZWQgaW4gdjEuMlxuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IF9ybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgaWkrKykge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IHVucGFyc2Uocm5kcyk7XG59XG5cbi8vIEV4cG9ydCBwdWJsaWMgQVBJXG52YXIgdXVpZCA9IHY0O1xudXVpZC52MSA9IHYxO1xudXVpZC52NCA9IHY0O1xudXVpZC5wYXJzZSA9IHBhcnNlO1xudXVpZC51bnBhcnNlID0gdW5wYXJzZTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuIl19
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],22:[function(require,module,exports){
'use strict';

var keycharm = require('keycharm');
var Emitter = require('emitter-component');
var Hammer = require('../module/hammer');
var util = require('../util');

/**
 * Turn an element into an clickToUse element.
 * When not active, the element has a transparent overlay. When the overlay is
 * clicked, the mode is changed to active.
 * When active, the element is displayed with a blue border around it, and
 * the interactive contents of the element can be used. When clicked outside
 * the element, the elements mode is changed to inactive.
 * @param {Element} container
 * @constructor
 */
function Activator(container) {
  this.active = false;

  this.dom = {
    container: container
  };

  this.dom.overlay = document.createElement('div');
  this.dom.overlay.className = 'vis-overlay';

  this.dom.container.appendChild(this.dom.overlay);

  this.hammer = Hammer(this.dom.overlay);
  this.hammer.on('tap', this._onTapOverlay.bind(this));

  // block all touch events (except tap)
  var me = this;
  var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend'];
  events.forEach(function (event) {
    me.hammer.on(event, function (event) {
      event.stopPropagation();
    });
  });

  // attach a click event to the window, in order to deactivate when clicking outside the timeline
  if (document && document.body) {
    this.onClick = function (event) {
      if (!_hasParent(event.target, container)) {
        me.deactivate();
      }
    };
    document.body.addEventListener('click', this.onClick);
  }

  if (this.keycharm !== undefined) {
    this.keycharm.destroy();
  }
  this.keycharm = keycharm();

  // keycharm listener only bounded when active)
  this.escListener = this.deactivate.bind(this);
}

// turn into an event emitter
Emitter(Activator.prototype);

// The currently active activator
Activator.current = null;

/**
 * Destroy the activator. Cleans up all created DOM and event listeners
 */
Activator.prototype.destroy = function () {
  this.deactivate();

  // remove dom
  this.dom.overlay.parentNode.removeChild(this.dom.overlay);

  // remove global event listener
  if (this.onClick) {
    document.body.removeEventListener('click', this.onClick);
  }

  // cleanup hammer instances
  this.hammer.destroy();
  this.hammer = null;
  // FIXME: cleaning up hammer instances doesn't work (Timeline not removed from memory)
};

/**
 * Activate the element
 * Overlay is hidden, element is decorated with a blue shadow border
 */
Activator.prototype.activate = function () {
  // we allow only one active activator at a time
  if (Activator.current) {
    Activator.current.deactivate();
  }
  Activator.current = this;

  this.active = true;
  this.dom.overlay.style.display = 'none';
  util.addClassName(this.dom.container, 'vis-active');

  this.emit('change');
  this.emit('activate');

  // ugly hack: bind ESC after emitting the events, as the Network rebinds all
  // keyboard events on a 'change' event
  this.keycharm.bind('esc', this.escListener);
};

/**
 * Deactivate the element
 * Overlay is displayed on top of the element
 */
Activator.prototype.deactivate = function () {
  this.active = false;
  this.dom.overlay.style.display = '';
  util.removeClassName(this.dom.container, 'vis-active');
  this.keycharm.unbind('esc', this.escListener);

  this.emit('change');
  this.emit('deactivate');
};

/**
 * Handle a tap event: activate the container
 * @param event
 * @private
 */
Activator.prototype._onTapOverlay = function (event) {
  // activate the container
  this.activate();
  event.stopPropagation();
};

/**
 * Test whether the element has the requested parent element somewhere in
 * its chain of parent nodes.
 * @param {HTMLElement} element
 * @param {HTMLElement} parent
 * @returns {boolean} Returns true when the parent is found somewhere in the
 *                    chain of parent nodes.
 * @private
 */
function _hasParent(element, parent) {
  while (element) {
    if (element === parent) {
      return true;
    }
    element = element.parentNode;
  }
  return false;
}

module.exports = Activator;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvc2hhcmVkL0FjdGl2YXRvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNuQyxJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsbUJBQW1CLENBQUMsQ0FBQztBQUMzQyxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUN6QyxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7Ozs7Ozs7Ozs7OztBQVk5QixTQUFTLFNBQVMsQ0FBQyxTQUFTLEVBQUU7QUFDNUIsTUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7O0FBRXBCLE1BQUksQ0FBQyxHQUFHLEdBQUc7QUFDVCxhQUFTLEVBQUUsU0FBUztHQUNyQixDQUFDOztBQUVGLE1BQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDakQsTUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsU0FBUyxHQUFHLGFBQWEsQ0FBQzs7QUFFM0MsTUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7O0FBRWpELE1BQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDdkMsTUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7OztBQUdyRCxNQUFJLEVBQUUsR0FBRyxJQUFJLENBQUM7QUFDZCxNQUFJLE1BQU0sR0FBRyxDQUNYLEtBQUssRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUMzQixPQUFPLEVBQ1AsS0FBSyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUN2QyxDQUFDO0FBQ0YsUUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEtBQUssRUFBRTtBQUM5QixNQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsVUFBVSxLQUFLLEVBQUU7QUFDbkMsV0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO0tBQ3pCLENBQUMsQ0FBQztHQUNKLENBQUMsQ0FBQzs7O0FBR0gsTUFBSSxRQUFRLElBQUksUUFBUSxDQUFDLElBQUksRUFBRTtBQUM3QixRQUFJLENBQUMsT0FBTyxHQUFHLFVBQVUsS0FBSyxFQUFFO0FBQzlCLFVBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsRUFBRTtBQUN4QyxVQUFFLENBQUMsVUFBVSxFQUFFLENBQUM7T0FDakI7S0FDRixDQUFDO0FBQ0YsWUFBUSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0dBQ3ZEOztBQUVELE1BQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxTQUFTLEVBQUU7QUFDL0IsUUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztHQUN6QjtBQUNELE1BQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxFQUFFLENBQUM7OztBQUczQixNQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQy9DOzs7QUFHRCxPQUFPLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDOzs7QUFHN0IsU0FBUyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7Ozs7O0FBS3pCLFNBQVMsQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUFHLFlBQVk7QUFDeEMsTUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDOzs7QUFHbEIsTUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDOzs7QUFHMUQsTUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO0FBQ2hCLFlBQVEsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztHQUMxRDs7O0FBR0QsTUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUN0QixNQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQzs7Q0FFcEIsQ0FBQzs7Ozs7O0FBTUYsU0FBUyxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsWUFBWTs7QUFFekMsTUFBSSxTQUFTLENBQUMsT0FBTyxFQUFFO0FBQ3JCLGFBQVMsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLENBQUM7R0FDaEM7QUFDRCxXQUFTLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQzs7QUFFekIsTUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7QUFDbkIsTUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7QUFDeEMsTUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxZQUFZLENBQUMsQ0FBQzs7QUFFcEQsTUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUNwQixNQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDOzs7O0FBSXRCLE1BQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7Q0FDN0MsQ0FBQzs7Ozs7O0FBTUYsU0FBUyxDQUFDLFNBQVMsQ0FBQyxVQUFVLEdBQUcsWUFBWTtBQUMzQyxNQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztBQUNwQixNQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztBQUNwQyxNQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLFlBQVksQ0FBQyxDQUFDO0FBQ3ZELE1BQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7O0FBRTlDLE1BQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDcEIsTUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztDQUN6QixDQUFDOzs7Ozs7O0FBT0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxhQUFhLEdBQUcsVUFBVSxLQUFLLEVBQUU7O0FBRW5ELE1BQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUNoQixPQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7Q0FDekIsQ0FBQzs7Ozs7Ozs7Ozs7QUFXRixTQUFTLFVBQVUsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFO0FBQ25DLFNBQU8sT0FBTyxFQUFFO0FBQ2QsUUFBSSxPQUFPLEtBQUssTUFBTSxFQUFFO0FBQ3RCLGFBQU8sSUFBSSxDQUFBO0tBQ1o7QUFDRCxXQUFPLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQztHQUM5QjtBQUNELFNBQU8sS0FBSyxDQUFDO0NBQ2Q7O0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUMiLCJmaWxlIjoiL1VzZXJzL2RhcmluL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzLXZpZXdlci9ub2RlX21vZHVsZXMvdmlzL2xpYi9zaGFyZWQvQWN0aXZhdG9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGtleWNoYXJtID0gcmVxdWlyZSgna2V5Y2hhcm0nKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnZW1pdHRlci1jb21wb25lbnQnKTtcbnZhciBIYW1tZXIgPSByZXF1aXJlKCcuLi9tb2R1bGUvaGFtbWVyJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuLyoqXG4gKiBUdXJuIGFuIGVsZW1lbnQgaW50byBhbiBjbGlja1RvVXNlIGVsZW1lbnQuXG4gKiBXaGVuIG5vdCBhY3RpdmUsIHRoZSBlbGVtZW50IGhhcyBhIHRyYW5zcGFyZW50IG92ZXJsYXkuIFdoZW4gdGhlIG92ZXJsYXkgaXNcbiAqIGNsaWNrZWQsIHRoZSBtb2RlIGlzIGNoYW5nZWQgdG8gYWN0aXZlLlxuICogV2hlbiBhY3RpdmUsIHRoZSBlbGVtZW50IGlzIGRpc3BsYXllZCB3aXRoIGEgYmx1ZSBib3JkZXIgYXJvdW5kIGl0LCBhbmRcbiAqIHRoZSBpbnRlcmFjdGl2ZSBjb250ZW50cyBvZiB0aGUgZWxlbWVudCBjYW4gYmUgdXNlZC4gV2hlbiBjbGlja2VkIG91dHNpZGVcbiAqIHRoZSBlbGVtZW50LCB0aGUgZWxlbWVudHMgbW9kZSBpcyBjaGFuZ2VkIHRvIGluYWN0aXZlLlxuICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBY3RpdmF0b3IoY29udGFpbmVyKSB7XG4gIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cbiAgdGhpcy5kb20gPSB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXJcbiAgfTtcblxuICB0aGlzLmRvbS5vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLm92ZXJsYXkuY2xhc3NOYW1lID0gJ3Zpcy1vdmVybGF5JztcblxuICB0aGlzLmRvbS5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20ub3ZlcmxheSk7XG5cbiAgdGhpcy5oYW1tZXIgPSBIYW1tZXIodGhpcy5kb20ub3ZlcmxheSk7XG4gIHRoaXMuaGFtbWVyLm9uKCd0YXAnLCB0aGlzLl9vblRhcE92ZXJsYXkuYmluZCh0aGlzKSk7XG5cbiAgLy8gYmxvY2sgYWxsIHRvdWNoIGV2ZW50cyAoZXhjZXB0IHRhcClcbiAgdmFyIG1lID0gdGhpcztcbiAgdmFyIGV2ZW50cyA9IFtcbiAgICAndGFwJywgJ2RvdWJsZXRhcCcsICdwcmVzcycsXG4gICAgJ3BpbmNoJyxcbiAgICAncGFuJywgJ3BhbnN0YXJ0JywgJ3Bhbm1vdmUnLCAncGFuZW5kJ1xuICBdO1xuICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBtZS5oYW1tZXIub24oZXZlbnQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGF0dGFjaCBhIGNsaWNrIGV2ZW50IHRvIHRoZSB3aW5kb3csIGluIG9yZGVyIHRvIGRlYWN0aXZhdGUgd2hlbiBjbGlja2luZyBvdXRzaWRlIHRoZSB0aW1lbGluZVxuICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgIHRoaXMub25DbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKCFfaGFzUGFyZW50KGV2ZW50LnRhcmdldCwgY29udGFpbmVyKSkge1xuICAgICAgICBtZS5kZWFjdGl2YXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcbiAgfVxuXG4gIGlmICh0aGlzLmtleWNoYXJtICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmtleWNoYXJtLmRlc3Ryb3koKTtcbiAgfVxuICB0aGlzLmtleWNoYXJtID0ga2V5Y2hhcm0oKTtcblxuICAvLyBrZXljaGFybSBsaXN0ZW5lciBvbmx5IGJvdW5kZWQgd2hlbiBhY3RpdmUpXG4gIHRoaXMuZXNjTGlzdGVuZXIgPSB0aGlzLmRlYWN0aXZhdGUuYmluZCh0aGlzKTtcbn1cblxuLy8gdHVybiBpbnRvIGFuIGV2ZW50IGVtaXR0ZXJcbkVtaXR0ZXIoQWN0aXZhdG9yLnByb3RvdHlwZSk7XG5cbi8vIFRoZSBjdXJyZW50bHkgYWN0aXZlIGFjdGl2YXRvclxuQWN0aXZhdG9yLmN1cnJlbnQgPSBudWxsO1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIGFjdGl2YXRvci4gQ2xlYW5zIHVwIGFsbCBjcmVhdGVkIERPTSBhbmQgZXZlbnQgbGlzdGVuZXJzXG4gKi9cbkFjdGl2YXRvci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5kZWFjdGl2YXRlKCk7XG5cbiAgLy8gcmVtb3ZlIGRvbVxuICB0aGlzLmRvbS5vdmVybGF5LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20ub3ZlcmxheSk7XG5cbiAgLy8gcmVtb3ZlIGdsb2JhbCBldmVudCBsaXN0ZW5lclxuICBpZiAodGhpcy5vbkNsaWNrKSB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gIH1cblxuICAvLyBjbGVhbnVwIGhhbW1lciBpbnN0YW5jZXNcbiAgdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICB0aGlzLmhhbW1lciA9IG51bGw7XG4gIC8vIEZJWE1FOiBjbGVhbmluZyB1cCBoYW1tZXIgaW5zdGFuY2VzIGRvZXNuJ3Qgd29yayAoVGltZWxpbmUgbm90IHJlbW92ZWQgZnJvbSBtZW1vcnkpXG59O1xuXG4vKipcbiAqIEFjdGl2YXRlIHRoZSBlbGVtZW50XG4gKiBPdmVybGF5IGlzIGhpZGRlbiwgZWxlbWVudCBpcyBkZWNvcmF0ZWQgd2l0aCBhIGJsdWUgc2hhZG93IGJvcmRlclxuICovXG5BY3RpdmF0b3IucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAvLyB3ZSBhbGxvdyBvbmx5IG9uZSBhY3RpdmUgYWN0aXZhdG9yIGF0IGEgdGltZVxuICBpZiAoQWN0aXZhdG9yLmN1cnJlbnQpIHtcbiAgICBBY3RpdmF0b3IuY3VycmVudC5kZWFjdGl2YXRlKCk7XG4gIH1cbiAgQWN0aXZhdG9yLmN1cnJlbnQgPSB0aGlzO1xuXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kb20ub3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB1dGlsLmFkZENsYXNzTmFtZSh0aGlzLmRvbS5jb250YWluZXIsICd2aXMtYWN0aXZlJyk7XG5cbiAgdGhpcy5lbWl0KCdjaGFuZ2UnKTtcbiAgdGhpcy5lbWl0KCdhY3RpdmF0ZScpO1xuXG4gIC8vIHVnbHkgaGFjazogYmluZCBFU0MgYWZ0ZXIgZW1pdHRpbmcgdGhlIGV2ZW50cywgYXMgdGhlIE5ldHdvcmsgcmViaW5kcyBhbGxcbiAgLy8ga2V5Ym9hcmQgZXZlbnRzIG9uIGEgJ2NoYW5nZScgZXZlbnRcbiAgdGhpcy5rZXljaGFybS5iaW5kKCdlc2MnLCB0aGlzLmVzY0xpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogRGVhY3RpdmF0ZSB0aGUgZWxlbWVudFxuICogT3ZlcmxheSBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIHRoZSBlbGVtZW50XG4gKi9cbkFjdGl2YXRvci5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgdGhpcy5kb20ub3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKHRoaXMuZG9tLmNvbnRhaW5lciwgJ3Zpcy1hY3RpdmUnKTtcbiAgdGhpcy5rZXljaGFybS51bmJpbmQoJ2VzYycsIHRoaXMuZXNjTGlzdGVuZXIpO1xuXG4gIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG4gIHRoaXMuZW1pdCgnZGVhY3RpdmF0ZScpO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgYSB0YXAgZXZlbnQ6IGFjdGl2YXRlIHRoZSBjb250YWluZXJcbiAqIEBwYXJhbSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuQWN0aXZhdG9yLnByb3RvdHlwZS5fb25UYXBPdmVybGF5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIGFjdGl2YXRlIHRoZSBjb250YWluZXJcbiAgdGhpcy5hY3RpdmF0ZSgpO1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIHRoZSBlbGVtZW50IGhhcyB0aGUgcmVxdWVzdGVkIHBhcmVudCBlbGVtZW50IHNvbWV3aGVyZSBpblxuICogaXRzIGNoYWluIG9mIHBhcmVudCBub2Rlcy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBwYXJlbnQgaXMgZm91bmQgc29tZXdoZXJlIGluIHRoZVxuICogICAgICAgICAgICAgICAgICAgIGNoYWluIG9mIHBhcmVudCBub2Rlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9oYXNQYXJlbnQoZWxlbWVudCwgcGFyZW50KSB7XG4gIHdoaWxlIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWN0aXZhdG9yO1xuIl19
},{"../module/hammer":19,"../util":46,"emitter-component":10,"keycharm":12}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var Hammer = require('../module/hammer');
var hammerUtil = require('../hammerUtil');
var util = require('../util');

var ColorPicker = (function () {
  function ColorPicker() {
    var pixelRatio = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

    _classCallCheck(this, ColorPicker);

    this.pixelRatio = pixelRatio;
    this.generated = false;
    this.centerCoordinates = { x: 289 / 2, y: 289 / 2 };
    this.r = 289 * 0.49;
    this.color = { r: 255, g: 255, b: 255, a: 1.0 };
    this.hueCircle = undefined;
    this.initialColor = { r: 255, g: 255, b: 255, a: 1.0 };
    this.previousColor = undefined;
    this.applied = false;

    // bound by
    this.updateCallback = function () {};

    // create all DOM elements
    this._create();
  }

  /**
   * this inserts the colorPicker into a div from the DOM
   * @param container
   */

  _createClass(ColorPicker, [{
    key: 'insertTo',
    value: function insertTo(container) {
      if (this.hammer !== undefined) {
        this.hammer.destroy();
        this.hammer = undefined;
      }
      this.container = container;
      this.container.appendChild(this.frame);
      this._bindHammer();

      this._setSize();
    }

    /**
     * the callback is executed on apply and save. Bind it to the application
     * @param callback
     */
  }, {
    key: 'setCallback',
    value: function setCallback(callback) {
      if (typeof callback === 'function') {
        this.updateCallback = callback;
      } else {
        throw new Error("Function attempted to set as colorPicker callback is not a function.");
      }
    }
  }, {
    key: '_isColorString',
    value: function _isColorString(color) {
      var htmlColors = { black: '#000000', navy: '#000080', darkblue: '#00008B', mediumblue: '#0000CD', blue: '#0000FF', darkgreen: '#006400', green: '#008000', teal: '#008080', darkcyan: '#008B8B', deepskyblue: '#00BFFF', darkturquoise: '#00CED1', mediumspringgreen: '#00FA9A', lime: '#00FF00', springgreen: '#00FF7F', aqua: '#00FFFF', cyan: '#00FFFF', midnightblue: '#191970', dodgerblue: '#1E90FF', lightseagreen: '#20B2AA', forestgreen: '#228B22', seagreen: '#2E8B57', darkslategray: '#2F4F4F', limegreen: '#32CD32', mediumseagreen: '#3CB371', turquoise: '#40E0D0', royalblue: '#4169E1', steelblue: '#4682B4', darkslateblue: '#483D8B', mediumturquoise: '#48D1CC', indigo: '#4B0082', darkolivegreen: '#556B2F', cadetblue: '#5F9EA0', cornflowerblue: '#6495ED', mediumaquamarine: '#66CDAA', dimgray: '#696969', slateblue: '#6A5ACD', olivedrab: '#6B8E23', slategray: '#708090', lightslategray: '#778899', mediumslateblue: '#7B68EE', lawngreen: '#7CFC00', chartreuse: '#7FFF00', aquamarine: '#7FFFD4', maroon: '#800000', purple: '#800080', olive: '#808000', gray: '#808080', skyblue: '#87CEEB', lightskyblue: '#87CEFA', blueviolet: '#8A2BE2', darkred: '#8B0000', darkmagenta: '#8B008B', saddlebrown: '#8B4513', darkseagreen: '#8FBC8F', lightgreen: '#90EE90', mediumpurple: '#9370D8', darkviolet: '#9400D3', palegreen: '#98FB98', darkorchid: '#9932CC', yellowgreen: '#9ACD32', sienna: '#A0522D', brown: '#A52A2A', darkgray: '#A9A9A9', lightblue: '#ADD8E6', greenyellow: '#ADFF2F', paleturquoise: '#AFEEEE', lightsteelblue: '#B0C4DE', powderblue: '#B0E0E6', firebrick: '#B22222', darkgoldenrod: '#B8860B', mediumorchid: '#BA55D3', rosybrown: '#BC8F8F', darkkhaki: '#BDB76B', silver: '#C0C0C0', mediumvioletred: '#C71585', indianred: '#CD5C5C', peru: '#CD853F', chocolate: '#D2691E', tan: '#D2B48C', lightgrey: '#D3D3D3', palevioletred: '#D87093', thistle: '#D8BFD8', orchid: '#DA70D6', goldenrod: '#DAA520', crimson: '#DC143C', gainsboro: '#DCDCDC', plum: '#DDA0DD', burlywood: '#DEB887', lightcyan: '#E0FFFF', lavender: '#E6E6FA', darksalmon: '#E9967A', violet: '#EE82EE', palegoldenrod: '#EEE8AA', lightcoral: '#F08080', khaki: '#F0E68C', aliceblue: '#F0F8FF', honeydew: '#F0FFF0', azure: '#F0FFFF', sandybrown: '#F4A460', wheat: '#F5DEB3', beige: '#F5F5DC', whitesmoke: '#F5F5F5', mintcream: '#F5FFFA', ghostwhite: '#F8F8FF', salmon: '#FA8072', antiquewhite: '#FAEBD7', linen: '#FAF0E6', lightgoldenrodyellow: '#FAFAD2', oldlace: '#FDF5E6', red: '#FF0000', fuchsia: '#FF00FF', magenta: '#FF00FF', deeppink: '#FF1493', orangered: '#FF4500', tomato: '#FF6347', hotpink: '#FF69B4', coral: '#FF7F50', darkorange: '#FF8C00', lightsalmon: '#FFA07A', orange: '#FFA500', lightpink: '#FFB6C1', pink: '#FFC0CB', gold: '#FFD700', peachpuff: '#FFDAB9', navajowhite: '#FFDEAD', moccasin: '#FFE4B5', bisque: '#FFE4C4', mistyrose: '#FFE4E1', blanchedalmond: '#FFEBCD', papayawhip: '#FFEFD5', lavenderblush: '#FFF0F5', seashell: '#FFF5EE', cornsilk: '#FFF8DC', lemonchiffon: '#FFFACD', floralwhite: '#FFFAF0', snow: '#FFFAFA', yellow: '#FFFF00', lightyellow: '#FFFFE0', ivory: '#FFFFF0', white: '#FFFFFF' };
      if (typeof color === 'string') {
        return htmlColors[color];
      }
    }

    /**
     * Set the color of the colorPicker
     * Supported formats:
     * 'red'                   --> HTML color string
     * '#ffffff'               --> hex string
     * 'rbg(255,255,255)'      --> rgb string
     * 'rgba(255,255,255,1.0)' --> rgba string
     * {r:255,g:255,b:255}     --> rgb object
     * {r:255,g:255,b:255,a:1.0} --> rgba object
     * @param color
     * @param setInitial
     */
  }, {
    key: 'setColor',
    value: function setColor(color) {
      var setInitial = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

      if (color === 'none') {
        return;
      }

      var rgba = undefined;

      // if a html color shorthand is used, convert to hex
      var htmlColor = this._isColorString(color);
      if (htmlColor !== undefined) {
        color = htmlColor;
      }

      // check format
      if (util.isString(color) === true) {
        if (util.isValidRGB(color) === true) {
          var rgbaArray = color.substr(4).substr(0, color.length - 5).split(',');
          rgba = { r: rgbaArray[0], g: rgbaArray[1], b: rgbaArray[2], a: 1.0 };
        } else if (util.isValidRGBA(color) === true) {
          var rgbaArray = color.substr(5).substr(0, color.length - 6).split(',');
          rgba = { r: rgbaArray[0], g: rgbaArray[1], b: rgbaArray[2], a: rgbaArray[3] };
        } else if (util.isValidHex(color) === true) {
          var rgbObj = util.hexToRGB(color);
          rgba = { r: rgbObj.r, g: rgbObj.g, b: rgbObj.b, a: 1.0 };
        }
      } else {
        if (color instanceof Object) {
          if (color.r !== undefined && color.g !== undefined && color.b !== undefined) {
            var alpha = color.a !== undefined ? color.a : '1.0';
            rgba = { r: color.r, g: color.g, b: color.b, a: alpha };
          }
        }
      }

      // set color
      if (rgba === undefined) {
        throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + JSON.stringify(color));
      } else {
        this._setColor(rgba, setInitial);
      }
    }

    /**
     * this shows the color picker at a location. The hue circle is constructed once and stored.
     * @param x
     * @param y
     */
  }, {
    key: 'show',
    value: function show(x, y) {
      this.applied = false;
      this.frame.style.display = 'block';
      this.frame.style.top = y + 'px';
      this.frame.style.left = x + 'px';
      this._generateHueCircle();
    }

    // ------------------------------------------ PRIVATE ----------------------------- //

    /**
     * Hide the picker. Is called by the cancel button.
     * Optional boolean to store the previous color for easy access later on.
     * @param storePrevious
     * @private
     */
  }, {
    key: '_hide',
    value: function _hide() {
      var storePrevious = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

      // store the previous color for next time;
      if (storePrevious === true) {
        this.previousColor = util.extend({}, this.color);
      }

      if (this.applied === true) {
        this.updateCallback(this.initialColor);
      }

      this.frame.style.display = 'none';
    }

    /**
     * bound to the save button. Saves and hides.
     * @private
     */
  }, {
    key: '_save',
    value: function _save() {
      this.updateCallback(this.color);
      this.applied = false;
      this._hide();
    }

    /**
     * Bound to apply button. Saves but does not close. Is undone by the cancel button.
     * @private
     */
  }, {
    key: '_apply',
    value: function _apply() {
      this.applied = true;
      this.updateCallback(this.color);
      this._updatePicker(this.color);
    }

    /**
     * load the color from the previous session.
     * @private
     */
  }, {
    key: '_loadLast',
    value: function _loadLast() {
      if (this.previousColor !== undefined) {
        this.setColor(this.previousColor, false);
      } else {
        alert("There is no last color to load...");
      }
    }

    /**
     * set the color, place the picker
     * @param rgba
     * @param setInitial
     * @private
     */
  }, {
    key: '_setColor',
    value: function _setColor(rgba) {
      var setInitial = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

      // store the initial color
      if (setInitial === true) {
        this.initialColor = util.extend({}, rgba);
      }

      this.color = rgba;
      var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);

      var angleConvert = 2 * Math.PI;
      var radius = this.r * hsv.s;
      var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
      var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);

      this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + 'px';
      this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + 'px';

      this._updatePicker(rgba);
    }

    /**
     * bound to opacity control
     * @param value
     * @private
     */
  }, {
    key: '_setOpacity',
    value: function _setOpacity(value) {
      this.color.a = value / 100;
      this._updatePicker(this.color);
    }

    /**
     * bound to brightness control
     * @param value
     * @private
     */
  }, {
    key: '_setBrightness',
    value: function _setBrightness(value) {
      var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.v = value / 100;
      var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba['a'] = this.color.a;
      this.color = rgba;
      this._updatePicker();
    }

    /**
     * update the colorpicker. A black circle overlays the hue circle to mimic the brightness decreasing.
     * @param rgba
     * @private
     */
  }, {
    key: '_updatePicker',
    value: function _updatePicker() {
      var rgba = arguments.length <= 0 || arguments[0] === undefined ? this.color : arguments[0];

      var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);
      var ctx = this.colorPickerCanvas.getContext('2d');
      if (this.pixelRation === undefined) {
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
      }
      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

      // clear the canvas
      var w = this.colorPickerCanvas.clientWidth;
      var h = this.colorPickerCanvas.clientHeight;
      ctx.clearRect(0, 0, w, h);

      ctx.putImageData(this.hueCircle, 0, 0);
      ctx.fillStyle = 'rgba(0,0,0,' + (1 - hsv.v) + ')';
      ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
      ctx.fill();

      this.brightnessRange.value = 100 * hsv.v;
      this.opacityRange.value = 100 * rgba.a;

      this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
      this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
    }

    /**
     * used by create to set the size of the canvas.
     * @private
     */
  }, {
    key: '_setSize',
    value: function _setSize() {
      this.colorPickerCanvas.style.width = '100%';
      this.colorPickerCanvas.style.height = '100%';

      this.colorPickerCanvas.width = 289 * this.pixelRatio;
      this.colorPickerCanvas.height = 289 * this.pixelRatio;
    }

    /**
     * create all dom elements
     * TODO: cleanup, lots of similar dom elements
     * @private
     */
  }, {
    key: '_create',
    value: function _create() {
      this.frame = document.createElement('div');
      this.frame.className = 'vis-color-picker';

      this.colorPickerDiv = document.createElement('div');
      this.colorPickerSelector = document.createElement('div');
      this.colorPickerSelector.className = 'vis-selector';
      this.colorPickerDiv.appendChild(this.colorPickerSelector);

      this.colorPickerCanvas = document.createElement('canvas');
      this.colorPickerDiv.appendChild(this.colorPickerCanvas);

      if (!this.colorPickerCanvas.getContext) {
        var noCanvas = document.createElement('DIV');
        noCanvas.style.color = 'red';
        noCanvas.style.fontWeight = 'bold';
        noCanvas.style.padding = '10px';
        noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';
        this.colorPickerCanvas.appendChild(noCanvas);
      } else {
        var ctx = this.colorPickerCanvas.getContext("2d");
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);

        this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
      }

      this.colorPickerDiv.className = 'vis-color';

      this.opacityDiv = document.createElement('div');
      this.opacityDiv.className = 'vis-opacity';

      this.brightnessDiv = document.createElement('div');
      this.brightnessDiv.className = 'vis-brightness';

      this.arrowDiv = document.createElement('div');
      this.arrowDiv.className = 'vis-arrow';

      this.opacityRange = document.createElement('input');
      try {
        this.opacityRange.type = 'range'; // Not supported on IE9
        this.opacityRange.min = '0';
        this.opacityRange.max = '100';
      } catch (err) {}
      this.opacityRange.value = '100';
      this.opacityRange.className = 'vis-range';

      this.brightnessRange = document.createElement('input');
      try {
        this.brightnessRange.type = 'range'; // Not supported on IE9
        this.brightnessRange.min = '0';
        this.brightnessRange.max = '100';
      } catch (err) {}
      this.brightnessRange.value = '100';
      this.brightnessRange.className = 'vis-range';

      this.opacityDiv.appendChild(this.opacityRange);
      this.brightnessDiv.appendChild(this.brightnessRange);

      var me = this;
      this.opacityRange.onchange = function () {
        me._setOpacity(this.value);
      };
      this.opacityRange.oninput = function () {
        me._setOpacity(this.value);
      };
      this.brightnessRange.onchange = function () {
        me._setBrightness(this.value);
      };
      this.brightnessRange.oninput = function () {
        me._setBrightness(this.value);
      };

      this.brightnessLabel = document.createElement("div");
      this.brightnessLabel.className = "vis-label vis-brightness";
      this.brightnessLabel.innerHTML = 'brightness:';

      this.opacityLabel = document.createElement("div");
      this.opacityLabel.className = "vis-label vis-opacity";
      this.opacityLabel.innerHTML = 'opacity:';

      this.newColorDiv = document.createElement("div");
      this.newColorDiv.className = "vis-new-color";
      this.newColorDiv.innerHTML = 'new';

      this.initialColorDiv = document.createElement("div");
      this.initialColorDiv.className = "vis-initial-color";
      this.initialColorDiv.innerHTML = 'initial';

      this.cancelButton = document.createElement("div");
      this.cancelButton.className = "vis-button vis-cancel";
      this.cancelButton.innerHTML = 'cancel';
      this.cancelButton.onclick = this._hide.bind(this, false);

      this.applyButton = document.createElement("div");
      this.applyButton.className = "vis-button vis-apply";
      this.applyButton.innerHTML = 'apply';
      this.applyButton.onclick = this._apply.bind(this);

      this.saveButton = document.createElement("div");
      this.saveButton.className = "vis-button vis-save";
      this.saveButton.innerHTML = 'save';
      this.saveButton.onclick = this._save.bind(this);

      this.loadButton = document.createElement("div");
      this.loadButton.className = "vis-button vis-load";
      this.loadButton.innerHTML = 'load last';
      this.loadButton.onclick = this._loadLast.bind(this);

      this.frame.appendChild(this.colorPickerDiv);
      this.frame.appendChild(this.arrowDiv);
      this.frame.appendChild(this.brightnessLabel);
      this.frame.appendChild(this.brightnessDiv);
      this.frame.appendChild(this.opacityLabel);
      this.frame.appendChild(this.opacityDiv);
      this.frame.appendChild(this.newColorDiv);
      this.frame.appendChild(this.initialColorDiv);

      this.frame.appendChild(this.cancelButton);
      this.frame.appendChild(this.applyButton);
      this.frame.appendChild(this.saveButton);
      this.frame.appendChild(this.loadButton);
    }

    /**
     * bind hammer to the color picker
     * @private
     */
  }, {
    key: '_bindHammer',
    value: function _bindHammer() {
      var _this = this;

      this.drag = {};
      this.pinch = {};
      this.hammer = new Hammer(this.colorPickerCanvas);
      this.hammer.get('pinch').set({ enable: true });

      hammerUtil.onTouch(this.hammer, function (event) {
        _this._moveSelector(event);
      });
      this.hammer.on('tap', function (event) {
        _this._moveSelector(event);
      });
      this.hammer.on('panstart', function (event) {
        _this._moveSelector(event);
      });
      this.hammer.on('panmove', function (event) {
        _this._moveSelector(event);
      });
      this.hammer.on('panend', function (event) {
        _this._moveSelector(event);
      });
    }

    /**
     * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
     * @private
     */
  }, {
    key: '_generateHueCircle',
    value: function _generateHueCircle() {
      if (this.generated === false) {
        var ctx = this.colorPickerCanvas.getContext('2d');
        if (this.pixelRation === undefined) {
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        }
        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

        // clear the canvas
        var w = this.colorPickerCanvas.clientWidth;
        var h = this.colorPickerCanvas.clientHeight;
        ctx.clearRect(0, 0, w, h);

        // draw hue circle
        var x = undefined,
            y = undefined,
            hue = undefined,
            sat = undefined;
        this.centerCoordinates = { x: w * 0.5, y: h * 0.5 };
        this.r = 0.49 * w;
        var angleConvert = 2 * Math.PI / 360;
        var hfac = 1 / 360;
        var sfac = 1 / this.r;
        var rgb = undefined;
        for (hue = 0; hue < 360; hue++) {
          for (sat = 0; sat < this.r; sat++) {
            x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
            y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
            rgb = util.HSVToRGB(hue * hfac, sat * sfac, 1);
            ctx.fillStyle = 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
            ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
          }
        }
        ctx.strokeStyle = 'rgba(0,0,0,1)';
        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
        ctx.stroke();

        this.hueCircle = ctx.getImageData(0, 0, w, h);
      }
      this.generated = true;
    }

    /**
     * move the selector. This is called by hammer functions.
     *
     * @param event
     * @private
     */
  }, {
    key: '_moveSelector',
    value: function _moveSelector(event) {
      var rect = this.colorPickerDiv.getBoundingClientRect();
      var left = event.center.x - rect.left;
      var top = event.center.y - rect.top;

      var centerY = 0.5 * this.colorPickerDiv.clientHeight;
      var centerX = 0.5 * this.colorPickerDiv.clientWidth;

      var x = left - centerX;
      var y = top - centerY;

      var angle = Math.atan2(x, y);
      var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);

      var newTop = Math.cos(angle) * radius + centerY;
      var newLeft = Math.sin(angle) * radius + centerX;

      this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + 'px';
      this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + 'px';

      // set color
      var h = angle / (2 * Math.PI);
      h = h < 0 ? h + 1 : h;
      var s = radius / this.r;
      var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.h = h;
      hsv.s = s;
      var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba['a'] = this.color.a;
      this.color = rgba;

      // update previews
      this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
      this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
    }
  }]);

  return ColorPicker;
})();

exports['default'] = ColorPicker;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvc2hhcmVkL0NvbG9yUGlja2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUN6QyxJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDMUMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDOztJQUV4QixXQUFXO0FBQ0osV0FEUCxXQUFXLEdBQ2E7UUFBaEIsVUFBVSx5REFBRyxDQUFDOzswQkFEdEIsV0FBVzs7QUFFYixRQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztBQUM3QixRQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztBQUN2QixRQUFJLENBQUMsaUJBQWlCLEdBQUcsRUFBQyxDQUFDLEVBQUMsR0FBRyxHQUFDLENBQUMsRUFBRSxDQUFDLEVBQUMsR0FBRyxHQUFDLENBQUMsRUFBQyxDQUFDO0FBQzVDLFFBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQztBQUNwQixRQUFJLENBQUMsS0FBSyxHQUFHLEVBQUMsQ0FBQyxFQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQyxFQUFDLEdBQUcsRUFBQyxDQUFDO0FBQ3ZDLFFBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0FBQzNCLFFBQUksQ0FBQyxZQUFZLEdBQUcsRUFBQyxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQyxFQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUM7QUFDOUMsUUFBSSxDQUFDLGFBQWEsR0FBRSxTQUFTLENBQUM7QUFDOUIsUUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7OztBQUdyQixRQUFJLENBQUMsY0FBYyxHQUFHLFlBQU0sRUFBRSxDQUFDOzs7QUFHL0IsUUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO0dBQ2hCOzs7Ozs7O2VBakJHLFdBQVc7O1dBd0JQLGtCQUFDLFNBQVMsRUFBRTtBQUNsQixVQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssU0FBUyxFQUFFO0FBQzdCLFlBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDdEIsWUFBSSxDQUFDLE1BQU0sR0FBRyxTQUFTLENBQUM7T0FDekI7QUFDRCxVQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztBQUMzQixVQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdkMsVUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDOztBQUVuQixVQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7S0FDakI7Ozs7Ozs7O1dBTVUscUJBQUMsUUFBUSxFQUFFO0FBQ3BCLFVBQUksT0FBTyxRQUFRLEtBQUssVUFBVSxFQUFFO0FBQ2xDLFlBQUksQ0FBQyxjQUFjLEdBQUcsUUFBUSxDQUFDO09BQ2hDLE1BQ0k7QUFDSCxjQUFNLElBQUksS0FBSyxDQUFDLHNFQUFzRSxDQUFDLENBQUM7T0FDekY7S0FDRjs7O1dBRWEsd0JBQUMsS0FBSyxFQUFFO0FBQ3BCLFVBQUksVUFBVSxHQUFHLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBQyxJQUFJLEVBQUUsU0FBUyxFQUFDLFFBQVEsRUFBRSxTQUFTLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBQyxJQUFJLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBQyxJQUFJLEVBQUUsU0FBUyxFQUFDLFFBQVEsRUFBRSxTQUFTLEVBQUMsV0FBVyxFQUFFLFNBQVMsRUFBQyxhQUFhLEVBQUUsU0FBUyxFQUFDLGlCQUFpQixFQUFFLFNBQVMsRUFBQyxJQUFJLEVBQUUsU0FBUyxFQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBQyxJQUFJLEVBQUUsU0FBUyxFQUFDLFlBQVksRUFBRSxTQUFTLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBQyxhQUFhLEVBQUUsU0FBUyxFQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUMsUUFBUSxFQUFFLFNBQVMsRUFBQyxhQUFhLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsY0FBYyxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxhQUFhLEVBQUUsU0FBUyxFQUFDLGVBQWUsRUFBRSxTQUFTLEVBQUMsTUFBTSxFQUFFLFNBQVMsRUFBQyxjQUFjLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsY0FBYyxFQUFFLFNBQVMsRUFBQyxnQkFBZ0IsRUFBRSxTQUFTLEVBQUMsT0FBTyxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxjQUFjLEVBQUUsU0FBUyxFQUFDLGVBQWUsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUMsTUFBTSxFQUFFLFNBQVMsRUFBQyxNQUFNLEVBQUUsU0FBUyxFQUFDLEtBQUssRUFBRSxTQUFTLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBQyxPQUFPLEVBQUUsU0FBUyxFQUFDLFlBQVksRUFBRSxTQUFTLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBQyxPQUFPLEVBQUUsU0FBUyxFQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUMsV0FBVyxFQUFFLFNBQVMsRUFBQyxZQUFZLEVBQUUsU0FBUyxFQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUMsWUFBWSxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBQyxXQUFXLEVBQUUsU0FBUyxFQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBQyxRQUFRLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsV0FBVyxFQUFFLFNBQVMsRUFBQyxhQUFhLEVBQUUsU0FBUyxFQUFDLGNBQWMsRUFBRSxTQUFTLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLGFBQWEsRUFBRSxTQUFTLEVBQUMsWUFBWSxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsTUFBTSxFQUFFLFNBQVMsRUFBQyxlQUFlLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxhQUFhLEVBQUUsU0FBUyxFQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUMsTUFBTSxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxJQUFJLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxRQUFRLEVBQUUsU0FBUyxFQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUMsTUFBTSxFQUFFLFNBQVMsRUFBQyxhQUFhLEVBQUUsU0FBUyxFQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLFFBQVEsRUFBRSxTQUFTLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLEtBQUssRUFBRSxTQUFTLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFT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QUcsR0FBRyxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDOzs7QUFHbEcsVUFBSSxDQUFDLEdBQUcsS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFBLEFBQUMsQ0FBQztBQUM5QixPQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN0QixVQUFJLENBQUMsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUN4QixVQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEUsU0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDVixTQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNWLFVBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM5QyxVQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDekIsVUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7OztBQUdsQixVQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsT0FBTyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUNySyxVQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztLQUN0STs7O1NBNWdCRyxXQUFXOzs7cUJBK2dCRixXQUFXIiwiZmlsZSI6Ii9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvc2hhcmVkL0NvbG9yUGlja2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibGV0IEhhbW1lciA9IHJlcXVpcmUoJy4uL21vZHVsZS9oYW1tZXInKTtcbmxldCBoYW1tZXJVdGlsID0gcmVxdWlyZSgnLi4vaGFtbWVyVXRpbCcpO1xubGV0IHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmNsYXNzIENvbG9yUGlja2VyIHtcbiAgY29uc3RydWN0b3IocGl4ZWxSYXRpbyA9IDEpIHtcbiAgICB0aGlzLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIHRoaXMuZ2VuZXJhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5jZW50ZXJDb29yZGluYXRlcyA9IHt4OjI4OS8yLCB5OjI4OS8yfTtcbiAgICB0aGlzLnIgPSAyODkgKiAwLjQ5O1xuICAgIHRoaXMuY29sb3IgPSB7cjoyNTUsZzoyNTUsYjoyNTUsYToxLjB9O1xuICAgIHRoaXMuaHVlQ2lyY2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5pdGlhbENvbG9yID0ge3I6MjU1LGc6MjU1LGI6MjU1LGE6MS4wfTtcbiAgICB0aGlzLnByZXZpb3VzQ29sb3I9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFwcGxpZWQgPSBmYWxzZTtcblxuICAgIC8vIGJvdW5kIGJ5XG4gICAgdGhpcy51cGRhdGVDYWxsYmFjayA9ICgpID0+IHt9O1xuXG4gICAgLy8gY3JlYXRlIGFsbCBET00gZWxlbWVudHNcbiAgICB0aGlzLl9jcmVhdGUoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIHRoaXMgaW5zZXJ0cyB0aGUgY29sb3JQaWNrZXIgaW50byBhIGRpdiBmcm9tIHRoZSBET01cbiAgICogQHBhcmFtIGNvbnRhaW5lclxuICAgKi9cbiAgaW5zZXJ0VG8oY29udGFpbmVyKSB7XG4gICAgaWYgKHRoaXMuaGFtbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuaGFtbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcbiAgICB0aGlzLl9iaW5kSGFtbWVyKCk7XG5cbiAgICB0aGlzLl9zZXRTaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogdGhlIGNhbGxiYWNrIGlzIGV4ZWN1dGVkIG9uIGFwcGx5IGFuZCBzYXZlLiBCaW5kIGl0IHRvIHRoZSBhcHBsaWNhdGlvblxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHNldENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGF0dGVtcHRlZCB0byBzZXQgYXMgY29sb3JQaWNrZXIgY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cbiAgfVxuXG4gIF9pc0NvbG9yU3RyaW5nKGNvbG9yKSB7XG4gICAgdmFyIGh0bWxDb2xvcnMgPSB7YmxhY2s6ICcjMDAwMDAwJyxuYXZ5OiAnIzAwMDA4MCcsZGFya2JsdWU6ICcjMDAwMDhCJyxtZWRpdW1ibHVlOiAnIzAwMDBDRCcsYmx1ZTogJyMwMDAwRkYnLGRhcmtncmVlbjogJyMwMDY0MDAnLGdyZWVuOiAnIzAwODAwMCcsdGVhbDogJyMwMDgwODAnLGRhcmtjeWFuOiAnIzAwOEI4QicsZGVlcHNreWJsdWU6ICcjMDBCRkZGJyxkYXJrdHVycXVvaXNlOiAnIzAwQ0VEMScsbWVkaXVtc3ByaW5nZ3JlZW46ICcjMDBGQTlBJyxsaW1lOiAnIzAwRkYwMCcsc3ByaW5nZ3JlZW46ICcjMDBGRjdGJyxhcXVhOiAnIzAwRkZGRicsY3lhbjogJyMwMEZGRkYnLG1pZG5pZ2h0Ymx1ZTogJyMxOTE5NzAnLGRvZGdlcmJsdWU6ICcjMUU5MEZGJyxsaWdodHNlYWdyZWVuOiAnIzIwQjJBQScsZm9yZXN0Z3JlZW46ICcjMjI4QjIyJyxzZWFncmVlbjogJyMyRThCNTcnLGRhcmtzbGF0ZWdyYXk6ICcjMkY0RjRGJyxsaW1lZ3JlZW46ICcjMzJDRDMyJyxtZWRpdW1zZWFncmVlbjogJyMzQ0IzNzEnLHR1cnF1b2lzZTogJyM0MEUwRDAnLHJveWFsYmx1ZTogJyM0MTY5RTEnLHN0ZWVsYmx1ZTogJyM0NjgyQjQnLGRhcmtzbGF0ZWJsdWU6ICcjNDgzRDhCJyxtZWRpdW10dXJxdW9pc2U6ICcjNDhEMUNDJyxpbmRpZ286ICcjNEIwMDgyJyxkYXJrb2xpdmVncmVlbjogJyM1NTZCMkYnLGNhZGV0Ymx1ZTogJyM1RjlFQTAnLGNvcm5mbG93ZXJibHVlOiAnIzY0OTVFRCcsbWVkaXVtYXF1YW1hcmluZTogJyM2NkNEQUEnLGRpbWdyYXk6ICcjNjk2OTY5JyxzbGF0ZWJsdWU6ICcjNkE1QUNEJyxvbGl2ZWRyYWI6ICcjNkI4RTIzJyxzbGF0ZWdyYXk6ICcjNzA4MDkwJyxsaWdodHNsYXRlZ3JheTogJyM3Nzg4OTknLG1lZGl1bXNsYXRlYmx1ZTogJyM3QjY4RUUnLGxhd25ncmVlbjogJyM3Q0ZDMDAnLGNoYXJ0cmV1c2U6ICcjN0ZGRjAwJyxhcXVhbWFyaW5lOiAnIzdGRkZENCcsbWFyb29uOiAnIzgwMDAwMCcscHVycGxlOiAnIzgwMDA4MCcsb2xpdmU6ICcjODA4MDAwJyxncmF5OiAnIzgwODA4MCcsc2t5Ymx1ZTogJyM4N0NFRUInLGxpZ2h0c2t5Ymx1ZTogJyM4N0NFRkEnLGJsdWV2aW9sZXQ6ICcjOEEyQkUyJyxkYXJrcmVkOiAnIzhCMDAwMCcsZGFya21hZ2VudGE6ICcjOEIwMDhCJyxzYWRkbGVicm93bjogJyM4QjQ1MTMnLGRhcmtzZWFncmVlbjogJyM4RkJDOEYnLGxpZ2h0Z3JlZW46ICcjOTBFRTkwJyxtZWRpdW1wdXJwbGU6ICcjOTM3MEQ4JyxkYXJrdmlvbGV0OiAnIzk0MDBEMycscGFsZWdyZWVuOiAnIzk4RkI5OCcsZGFya29yY2hpZDogJyM5OTMyQ0MnLHllbGxvd2dyZWVuOiAnIzlBQ0QzMicsc2llbm5hOiAnI0EwNTIyRCcsYnJvd246ICcjQTUyQTJBJyxkYXJrZ3JheTogJyNBOUE5QTknLGxpZ2h0Ymx1ZTogJyNBREQ4RTYnLGdyZWVueWVsbG93OiAnI0FERkYyRicscGFsZXR1cnF1b2lzZTogJyNBRkVFRUUnLGxpZ2h0c3RlZWxibHVlOiAnI0IwQzRERScscG93ZGVyYmx1ZTogJyNCMEUwRTYnLGZpcmVicmljazogJyNCMjIyMjInLGRhcmtnb2xkZW5yb2Q6ICcjQjg4NjBCJyxtZWRpdW1vcmNoaWQ6ICcjQkE1NUQzJyxyb3N5YnJvd246ICcjQkM4RjhGJyxkYXJra2hha2k6ICcjQkRCNzZCJyxzaWx2ZXI6ICcjQzBDMEMwJyxtZWRpdW12aW9sZXRyZWQ6ICcjQzcxNTg1JyxpbmRpYW5yZWQ6ICcjQ0Q1QzVDJyxwZXJ1OiAnI0NEODUzRicsY2hvY29sYXRlOiAnI0QyNjkxRScsdGFuOiAnI0QyQjQ4QycsbGlnaHRncmV5OiAnI0QzRDNEMycscGFsZXZpb2xldHJlZDogJyNEODcwOTMnLHRoaXN0bGU6ICcjRDhCRkQ4JyxvcmNoaWQ6ICcjREE3MEQ2Jyxnb2xkZW5yb2Q6ICcjREFBNTIwJyxjcmltc29uOiAnI0RDMTQzQycsZ2FpbnNib3JvOiAnI0RDRENEQycscGx1bTogJyNEREEwREQnLGJ1cmx5d29vZDogJyNERUI4ODcnLGxpZ2h0Y3lhbjogJyNFMEZGRkYnLGxhdmVuZGVyOiAnI0U2RTZGQScsZGFya3NhbG1vbjogJyNFOTk2N0EnLHZpb2xldDogJyNFRTgyRUUnLHBhbGVnb2xkZW5yb2Q6ICcjRUVFOEFBJyxsaWdodGNvcmFsOiAnI0YwODA4MCcsa2hha2k6ICcjRjBFNjhDJyxhbGljZWJsdWU6ICcjRjBGOEZGJyxob25leWRldzogJyNGMEZGRjAnLGF6dXJlOiAnI0YwRkZGRicsc2FuZHlicm93bjogJyNGNEE0NjAnLHdoZWF0OiAnI0Y1REVCMycsYmVpZ2U6ICcjRjVGNURDJyx3aGl0ZXNtb2tlOiAnI0Y1RjVGNScsbWludGNyZWFtOiAnI0Y1RkZGQScsZ2hvc3R3aGl0ZTogJyNGOEY4RkYnLHNhbG1vbjogJyNGQTgwNzInLGFudGlxdWV3aGl0ZTogJyNGQUVCRDcnLGxpbmVuOiAnI0ZBRjBFNicsbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICcjRkFGQUQyJyxvbGRsYWNlOiAnI0ZERjVFNicscmVkOiAnI0ZGMDAwMCcsZnVjaHNpYTogJyNGRjAwRkYnLG1hZ2VudGE6ICcjRkYwMEZGJyxkZWVwcGluazogJyNGRjE0OTMnLG9yYW5nZXJlZDogJyNGRjQ1MDAnLHRvbWF0bzogJyNGRjYzNDcnLGhvdHBpbms6ICcjRkY2OUI0Jyxjb3JhbDogJyNGRjdGNTAnLGRhcmtvcmFuZ2U6ICcjRkY4QzAwJyxsaWdodHNhbG1vbjogJyNGRkEwN0EnLG9yYW5nZTogJyNGRkE1MDAnLGxpZ2h0cGluazogJyNGRkI2QzEnLHBpbms6ICcjRkZDMENCJyxnb2xkOiAnI0ZGRDcwMCcscGVhY2hwdWZmOiAnI0ZGREFCOScsbmF2YWpvd2hpdGU6ICcjRkZERUFEJyxtb2NjYXNpbjogJyNGRkU0QjUnLGJpc3F1ZTogJyNGRkU0QzQnLG1pc3R5cm9zZTogJyNGRkU0RTEnLGJsYW5jaGVkYWxtb25kOiAnI0ZGRUJDRCcscGFwYXlhd2hpcDogJyNGRkVGRDUnLGxhdmVuZGVyYmx1c2g6ICcjRkZGMEY1JyxzZWFzaGVsbDogJyNGRkY1RUUnLGNvcm5zaWxrOiAnI0ZGRjhEQycsbGVtb25jaGlmZm9uOiAnI0ZGRkFDRCcsZmxvcmFsd2hpdGU6ICcjRkZGQUYwJyxzbm93OiAnI0ZGRkFGQScseWVsbG93OiAnI0ZGRkYwMCcsbGlnaHR5ZWxsb3c6ICcjRkZGRkUwJyxpdm9yeTogJyNGRkZGRjAnLHdoaXRlOiAnI0ZGRkZGRid9O1xuICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gaHRtbENvbG9yc1tjb2xvcl07XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogU2V0IHRoZSBjb2xvciBvZiB0aGUgY29sb3JQaWNrZXJcbiAgICogU3VwcG9ydGVkIGZvcm1hdHM6XG4gICAqICdyZWQnICAgICAgICAgICAgICAgICAgIC0tPiBIVE1MIGNvbG9yIHN0cmluZ1xuICAgKiAnI2ZmZmZmZicgICAgICAgICAgICAgICAtLT4gaGV4IHN0cmluZ1xuICAgKiAncmJnKDI1NSwyNTUsMjU1KScgICAgICAtLT4gcmdiIHN0cmluZ1xuICAgKiAncmdiYSgyNTUsMjU1LDI1NSwxLjApJyAtLT4gcmdiYSBzdHJpbmdcbiAgICoge3I6MjU1LGc6MjU1LGI6MjU1fSAgICAgLS0+IHJnYiBvYmplY3RcbiAgICoge3I6MjU1LGc6MjU1LGI6MjU1LGE6MS4wfSAtLT4gcmdiYSBvYmplY3RcbiAgICogQHBhcmFtIGNvbG9yXG4gICAqIEBwYXJhbSBzZXRJbml0aWFsXG4gICAqL1xuICBzZXRDb2xvcihjb2xvciwgc2V0SW5pdGlhbCA9IHRydWUpIHtcbiAgICBpZiAoY29sb3IgPT09ICdub25lJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCByZ2JhO1xuXG4gICAgLy8gaWYgYSBodG1sIGNvbG9yIHNob3J0aGFuZCBpcyB1c2VkLCBjb252ZXJ0IHRvIGhleFxuICAgIHZhciBodG1sQ29sb3IgPSB0aGlzLl9pc0NvbG9yU3RyaW5nKGNvbG9yKTtcbiAgICBpZiAoaHRtbENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbG9yID0gaHRtbENvbG9yO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvcm1hdFxuICAgIGlmICh1dGlsLmlzU3RyaW5nKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKHV0aWwuaXNWYWxpZFJHQihjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgbGV0IHJnYmFBcnJheSA9IGNvbG9yLnN1YnN0cig0KS5zdWJzdHIoMCwgY29sb3IubGVuZ3RoIC0gNSkuc3BsaXQoJywnKTtcbiAgICAgICAgcmdiYSA9IHtyOnJnYmFBcnJheVswXSwgZzpyZ2JhQXJyYXlbMV0sIGI6cmdiYUFycmF5WzJdLCBhOjEuMH07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh1dGlsLmlzVmFsaWRSR0JBKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICBsZXQgcmdiYUFycmF5ID0gY29sb3Iuc3Vic3RyKDUpLnN1YnN0cigwLCBjb2xvci5sZW5ndGggLSA2KS5zcGxpdCgnLCcpO1xuICAgICAgICByZ2JhID0ge3I6cmdiYUFycmF5WzBdLCBnOnJnYmFBcnJheVsxXSwgYjpyZ2JhQXJyYXlbMl0sIGE6cmdiYUFycmF5WzNdfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHV0aWwuaXNWYWxpZEhleChjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgbGV0IHJnYk9iaiA9IHV0aWwuaGV4VG9SR0IoY29sb3IpO1xuICAgICAgICByZ2JhID0ge3I6cmdiT2JqLnIsIGc6cmdiT2JqLmcsIGI6cmdiT2JqLmIsIGE6MS4wfTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY29sb3IgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgaWYgKGNvbG9yLnIgIT09IHVuZGVmaW5lZCAmJiBjb2xvci5nICE9PSB1bmRlZmluZWQgJiYgY29sb3IuYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGV0IGFscGhhID0gY29sb3IuYSAhPT0gdW5kZWZpbmVkID8gY29sb3IuYSA6ICcxLjAnO1xuICAgICAgICAgIHJnYmEgPSB7cjpjb2xvci5yLCBnOmNvbG9yLmcsIGI6Y29sb3IuYiwgYTphbHBoYX07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzZXQgY29sb3JcbiAgICBpZiAocmdiYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvbG9yIHBhc3NlZCB0byB0aGUgY29sb3JQaWNrZXIuIFN1cHBvcnRlZCBhcmUgc3RyaW5nczogcmdiLCBoZXgsIHJnYmEuIE9iamVjdDogcmdiICh7cjpyLGc6ZyxiOmIsW2E6YV19KS4gU3VwcGxpZWQ6IFwiICsgSlNPTi5zdHJpbmdpZnkoY29sb3IpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9zZXRDb2xvcihyZ2JhLCBzZXRJbml0aWFsKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiB0aGlzIHNob3dzIHRoZSBjb2xvciBwaWNrZXIgYXQgYSBsb2NhdGlvbi4gVGhlIGh1ZSBjaXJjbGUgaXMgY29uc3RydWN0ZWQgb25jZSBhbmQgc3RvcmVkLlxuICAgKiBAcGFyYW0geFxuICAgKiBAcGFyYW0geVxuICAgKi9cbiAgc2hvdyh4LHkpIHtcbiAgICB0aGlzLmFwcGxpZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIHRoaXMuZnJhbWUuc3R5bGUudG9wID0geSArICdweCc7XG4gICAgdGhpcy5mcmFtZS5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgdGhpcy5fZ2VuZXJhdGVIdWVDaXJjbGUoKTtcbiAgfVxuXG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFBSSVZBVEUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuICAvKipcbiAgICogSGlkZSB0aGUgcGlja2VyLiBJcyBjYWxsZWQgYnkgdGhlIGNhbmNlbCBidXR0b24uXG4gICAqIE9wdGlvbmFsIGJvb2xlYW4gdG8gc3RvcmUgdGhlIHByZXZpb3VzIGNvbG9yIGZvciBlYXN5IGFjY2VzcyBsYXRlciBvbi5cbiAgICogQHBhcmFtIHN0b3JlUHJldmlvdXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oaWRlKHN0b3JlUHJldmlvdXMgPSB0cnVlKSB7XG4gICAgLy8gc3RvcmUgdGhlIHByZXZpb3VzIGNvbG9yIGZvciBuZXh0IHRpbWU7XG4gICAgaWYgKHN0b3JlUHJldmlvdXMgPT09IHRydWUpIHtcbiAgICAgIHRoaXMucHJldmlvdXNDb2xvciA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmNvbG9yKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcHBsaWVkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMuaW5pdGlhbENvbG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBib3VuZCB0byB0aGUgc2F2ZSBidXR0b24uIFNhdmVzIGFuZCBoaWRlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zYXZlKCkge1xuICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5jb2xvcik7XG4gICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG4gICAgdGhpcy5faGlkZSgpO1xuICB9XG5cblxuICAvKipcbiAgICogQm91bmQgdG8gYXBwbHkgYnV0dG9uLiBTYXZlcyBidXQgZG9lcyBub3QgY2xvc2UuIElzIHVuZG9uZSBieSB0aGUgY2FuY2VsIGJ1dHRvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseSgpIHtcbiAgICB0aGlzLmFwcGxpZWQgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5jb2xvcik7XG4gICAgdGhpcy5fdXBkYXRlUGlja2VyKHRoaXMuY29sb3IpO1xuICB9XG5cblxuICAvKipcbiAgICogbG9hZCB0aGUgY29sb3IgZnJvbSB0aGUgcHJldmlvdXMgc2Vzc2lvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sb2FkTGFzdCgpIHtcbiAgICBpZiAodGhpcy5wcmV2aW91c0NvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0Q29sb3IodGhpcy5wcmV2aW91c0NvbG9yLCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYWxlcnQoXCJUaGVyZSBpcyBubyBsYXN0IGNvbG9yIHRvIGxvYWQuLi5cIik7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogc2V0IHRoZSBjb2xvciwgcGxhY2UgdGhlIHBpY2tlclxuICAgKiBAcGFyYW0gcmdiYVxuICAgKiBAcGFyYW0gc2V0SW5pdGlhbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldENvbG9yKHJnYmEsIHNldEluaXRpYWwgPSB0cnVlKSB7XG4gICAgLy8gc3RvcmUgdGhlIGluaXRpYWwgY29sb3JcbiAgICBpZiAoc2V0SW5pdGlhbCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3IgPSB1dGlsLmV4dGVuZCh7fSwgcmdiYSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb2xvciA9IHJnYmE7XG4gICAgbGV0IGhzdiA9IHV0aWwuUkdCVG9IU1YocmdiYS5yLCByZ2JhLmcsIHJnYmEuYik7XG5cbiAgICBsZXQgYW5nbGVDb252ZXJ0ID0gMiAqIE1hdGguUEk7XG4gICAgbGV0IHJhZGl1cyA9IHRoaXMuciAqIGhzdi5zO1xuICAgIGxldCB4ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy54ICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGVDb252ZXJ0ICogaHN2LmgpO1xuICAgIGxldCB5ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy55ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGVDb252ZXJ0ICogaHN2LmgpO1xuXG4gICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLmxlZnQgPSB4IC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudFdpZHRoICsgJ3B4JztcbiAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wID0geSAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRIZWlnaHQgKyAncHgnO1xuXG4gICAgdGhpcy5fdXBkYXRlUGlja2VyKHJnYmEpO1xuICB9XG5cblxuICAvKipcbiAgICogYm91bmQgdG8gb3BhY2l0eSBjb250cm9sXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldE9wYWNpdHkodmFsdWUpIHtcbiAgICB0aGlzLmNvbG9yLmEgPSB2YWx1ZSAvIDEwMDtcbiAgICB0aGlzLl91cGRhdGVQaWNrZXIodGhpcy5jb2xvcik7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBib3VuZCB0byBicmlnaHRuZXNzIGNvbnRyb2xcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0QnJpZ2h0bmVzcyh2YWx1ZSkge1xuICAgIGxldCBoc3YgPSB1dGlsLlJHQlRvSFNWKHRoaXMuY29sb3IuciwgdGhpcy5jb2xvci5nLCB0aGlzLmNvbG9yLmIpO1xuICAgIGhzdi52ID0gdmFsdWUgLyAxMDA7XG4gICAgbGV0IHJnYmEgPSB1dGlsLkhTVlRvUkdCKGhzdi5oLCBoc3YucywgaHN2LnYpO1xuICAgIHJnYmFbJ2EnXSA9IHRoaXMuY29sb3IuYTtcbiAgICB0aGlzLmNvbG9yID0gcmdiYTtcbiAgICB0aGlzLl91cGRhdGVQaWNrZXIoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIHVwZGF0ZSB0aGUgY29sb3JwaWNrZXIuIEEgYmxhY2sgY2lyY2xlIG92ZXJsYXlzIHRoZSBodWUgY2lyY2xlIHRvIG1pbWljIHRoZSBicmlnaHRuZXNzIGRlY3JlYXNpbmcuXG4gICAqIEBwYXJhbSByZ2JhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlUGlja2VyKHJnYmEgPSB0aGlzLmNvbG9yKSB7XG4gICAgbGV0IGhzdiA9IHV0aWwuUkdCVG9IU1YocmdiYS5yLCByZ2JhLmcsIHJnYmEuYik7XG4gICAgbGV0IGN0eCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAodGhpcy5waXhlbFJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuICAgIH1cbiAgICBjdHguc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcblxuICAgIC8vIGNsZWFyIHRoZSBjYW52YXNcbiAgICBsZXQgdyA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50V2lkdGg7XG4gICAgbGV0IGggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudEhlaWdodDtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuXG4gICAgY3R4LnB1dEltYWdlRGF0YSh0aGlzLmh1ZUNpcmNsZSwgMCwwKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsJyArICgxLSBoc3YudikgKyAnKSc7XG4gICAgY3R4LmNpcmNsZSh0aGlzLmNlbnRlckNvb3JkaW5hdGVzLngsIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSwgdGhpcy5yKTtcbiAgICBjdHguZmlsbCgpO1xuXG4gICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudmFsdWUgPSAxMDAgKiBoc3YudjtcbiAgICB0aGlzLm9wYWNpdHlSYW5nZS52YWx1ZSAgICA9IDEwMCAqIHJnYmEuYTtcblxuICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKCcgKyB0aGlzLmluaXRpYWxDb2xvci5yICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuZyArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmIgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5hICsgJyknO1xuICAgIHRoaXMubmV3Q29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoJyArIHRoaXMuY29sb3IuciArICcsJyArIHRoaXMuY29sb3IuZyArICcsJyArIHRoaXMuY29sb3IuYiArICcsJyArIHRoaXMuY29sb3IuYSArICcpJztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIHVzZWQgYnkgY3JlYXRlIHRvIHNldCB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFNpemUoKSB7XG4gICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcblxuICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMud2lkdGggPSAyODkgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5oZWlnaHQgPSAyODkgKiB0aGlzLnBpeGVsUmF0aW87XG4gIH1cblxuXG4gIC8qKlxuICAgKiBjcmVhdGUgYWxsIGRvbSBlbGVtZW50c1xuICAgKiBUT0RPOiBjbGVhbnVwLCBsb3RzIG9mIHNpbWlsYXIgZG9tIGVsZW1lbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlKCkge1xuICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtY29sb3ItcGlja2VyJztcblxuICAgIHRoaXMuY29sb3JQaWNrZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xhc3NOYW1lID0gJ3Zpcy1zZWxlY3Rvcic7XG4gICAgdGhpcy5jb2xvclBpY2tlckRpdi5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IpO1xuXG4gICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMuY29sb3JQaWNrZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy5jb2xvclBpY2tlckNhbnZhcyk7XG5cbiAgICBpZiAoIXRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dCkge1xuICAgICAgbGV0IG5vQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ0RJVicgKTtcbiAgICAgIG5vQ2FudmFzLnN0eWxlLmNvbG9yID0gJ3JlZCc7XG4gICAgICBub0NhbnZhcy5zdHlsZS5mb250V2VpZ2h0ID0gICdib2xkJyA7XG4gICAgICBub0NhbnZhcy5zdHlsZS5wYWRkaW5nID0gICcxMHB4JztcbiAgICAgIG5vQ2FudmFzLmlubmVySFRNTCA9ICAnRXJyb3I6IHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IEhUTUwgY2FudmFzJztcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuYXBwZW5kQ2hpbGQobm9DYW52YXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGxldCBjdHggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIChjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG5cbiAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgfVxuXG4gICAgdGhpcy5jb2xvclBpY2tlckRpdi5jbGFzc05hbWUgPSAndmlzLWNvbG9yJztcblxuICAgIHRoaXMub3BhY2l0eURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMub3BhY2l0eURpdi5jbGFzc05hbWUgPSAndmlzLW9wYWNpdHknO1xuXG4gICAgdGhpcy5icmlnaHRuZXNzRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5icmlnaHRuZXNzRGl2LmNsYXNzTmFtZSA9ICd2aXMtYnJpZ2h0bmVzcyc7XG5cbiAgICB0aGlzLmFycm93RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5hcnJvd0Rpdi5jbGFzc05hbWUgPSAndmlzLWFycm93JztcblxuICAgIHRoaXMub3BhY2l0eVJhbmdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UudHlwZSA9ICdyYW5nZSc7IC8vIE5vdCBzdXBwb3J0ZWQgb24gSUU5XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS5taW4gPSAnMCc7XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS5tYXggPSAnMTAwJztcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge31cbiAgICB0aGlzLm9wYWNpdHlSYW5nZS52YWx1ZSA9ICcxMDAnO1xuICAgIHRoaXMub3BhY2l0eVJhbmdlLmNsYXNzTmFtZSA9ICd2aXMtcmFuZ2UnO1xuXG4gICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS50eXBlID0gJ3JhbmdlJzsgLy8gTm90IHN1cHBvcnRlZCBvbiBJRTlcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm1pbiA9ICcwJztcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm1heCA9ICcxMDAnO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7fVxuICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLnZhbHVlID0gJzEwMCc7XG4gICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UuY2xhc3NOYW1lID0gJ3Zpcy1yYW5nZSc7XG5cbiAgICB0aGlzLm9wYWNpdHlEaXYuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5UmFuZ2UpO1xuICAgIHRoaXMuYnJpZ2h0bmVzc0Rpdi5hcHBlbmRDaGlsZCh0aGlzLmJyaWdodG5lc3NSYW5nZSk7XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMub3BhY2l0eVJhbmdlLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge21lLl9zZXRPcGFjaXR5KHRoaXMudmFsdWUpO307XG4gICAgdGhpcy5vcGFjaXR5UmFuZ2Uub25pbnB1dCAgPSBmdW5jdGlvbiAoKSB7bWUuX3NldE9wYWNpdHkodGhpcy52YWx1ZSk7fTtcbiAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHttZS5fc2V0QnJpZ2h0bmVzcyh0aGlzLnZhbHVlKTt9O1xuICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm9uaW5wdXQgID0gZnVuY3Rpb24gKCkge21lLl9zZXRCcmlnaHRuZXNzKHRoaXMudmFsdWUpO307XG5cbiAgICB0aGlzLmJyaWdodG5lc3NMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5icmlnaHRuZXNzTGFiZWwuY2xhc3NOYW1lID0gXCJ2aXMtbGFiZWwgdmlzLWJyaWdodG5lc3NcIjtcbiAgICB0aGlzLmJyaWdodG5lc3NMYWJlbC5pbm5lckhUTUwgPSAnYnJpZ2h0bmVzczonO1xuXG4gICAgdGhpcy5vcGFjaXR5TGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMub3BhY2l0eUxhYmVsLmNsYXNzTmFtZSA9IFwidmlzLWxhYmVsIHZpcy1vcGFjaXR5XCI7XG4gICAgdGhpcy5vcGFjaXR5TGFiZWwuaW5uZXJIVE1MID0gJ29wYWNpdHk6JztcblxuICAgIHRoaXMubmV3Q29sb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMubmV3Q29sb3JEaXYuY2xhc3NOYW1lID0gXCJ2aXMtbmV3LWNvbG9yXCI7XG4gICAgdGhpcy5uZXdDb2xvckRpdi5pbm5lckhUTUwgPSAnbmV3JztcblxuICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5jbGFzc05hbWUgPSBcInZpcy1pbml0aWFsLWNvbG9yXCI7XG4gICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuaW5uZXJIVE1MID0gJ2luaXRpYWwnO1xuXG4gICAgdGhpcy5jYW5jZWxCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuY2FuY2VsQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtY2FuY2VsXCI7XG4gICAgdGhpcy5jYW5jZWxCdXR0b24uaW5uZXJIVE1MID0gJ2NhbmNlbCc7XG4gICAgdGhpcy5jYW5jZWxCdXR0b24ub25jbGljayA9IHRoaXMuX2hpZGUuYmluZCh0aGlzLCBmYWxzZSk7XG5cbiAgICB0aGlzLmFwcGx5QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmFwcGx5QnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtYXBwbHlcIjtcbiAgICB0aGlzLmFwcGx5QnV0dG9uLmlubmVySFRNTCA9ICdhcHBseSc7XG4gICAgdGhpcy5hcHBseUJ1dHRvbi5vbmNsaWNrID0gdGhpcy5fYXBwbHkuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuc2F2ZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5zYXZlQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtc2F2ZVwiO1xuICAgIHRoaXMuc2F2ZUJ1dHRvbi5pbm5lckhUTUwgPSAnc2F2ZSc7XG4gICAgdGhpcy5zYXZlQnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9zYXZlLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmxvYWRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMubG9hZEJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLWxvYWRcIjtcbiAgICB0aGlzLmxvYWRCdXR0b24uaW5uZXJIVE1MID0gJ2xvYWQgbGFzdCc7XG4gICAgdGhpcy5sb2FkQnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9sb2FkTGFzdC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyRGl2KTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYXJyb3dEaXYpO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzTGFiZWwpO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzRGl2KTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMub3BhY2l0eUxhYmVsKTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMub3BhY2l0eURpdik7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm5ld0NvbG9yRGl2KTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuaW5pdGlhbENvbG9yRGl2KTtcblxuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5jYW5jZWxCdXR0b24pO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5hcHBseUJ1dHRvbik7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLnNhdmVCdXR0b24pO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5sb2FkQnV0dG9uKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGJpbmQgaGFtbWVyIHRvIHRoZSBjb2xvciBwaWNrZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9iaW5kSGFtbWVyKCkge1xuICAgIHRoaXMuZHJhZyA9IHt9O1xuICAgIHRoaXMucGluY2ggPSB7fTtcbiAgICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5jb2xvclBpY2tlckNhbnZhcyk7XG4gICAgdGhpcy5oYW1tZXIuZ2V0KCdwaW5jaCcpLnNldCh7ZW5hYmxlOiB0cnVlfSk7XG5cbiAgICBoYW1tZXJVdGlsLm9uVG91Y2godGhpcy5oYW1tZXIsIChldmVudCkgPT4ge3RoaXMuX21vdmVTZWxlY3RvcihldmVudCl9KTtcbiAgICB0aGlzLmhhbW1lci5vbigndGFwJywgICAgICAgKGV2ZW50KSA9PiB7dGhpcy5fbW92ZVNlbGVjdG9yKGV2ZW50KX0pO1xuICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5zdGFydCcsICAoZXZlbnQpID0+IHt0aGlzLl9tb3ZlU2VsZWN0b3IoZXZlbnQpfSk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3Bhbm1vdmUnLCAgIChldmVudCkgPT4ge3RoaXMuX21vdmVTZWxlY3RvcihldmVudCl9KTtcbiAgICB0aGlzLmhhbW1lci5vbigncGFuZW5kJywgICAgKGV2ZW50KSA9PiB7dGhpcy5fbW92ZVNlbGVjdG9yKGV2ZW50KX0pO1xuICB9XG5cblxuICAvKipcbiAgICogZ2VuZXJhdGUgdGhlIGh1ZSBjaXJjbGUuIFRoaXMgaXMgcmVsYXRpdmVseSBoZWF2eSAoMjAwbXMpIGFuZCBpcyBkb25lIG9ubHkgb25jZSBvbiB0aGUgZmlyc3QgdGltZSBpdCBpcyBzaG93bi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZW5lcmF0ZUh1ZUNpcmNsZSgpIHtcbiAgICBpZiAodGhpcy5nZW5lcmF0ZWQgPT09IGZhbHNlKSB7XG4gICAgICBsZXQgY3R4ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgaWYgKHRoaXMucGl4ZWxSYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICB9XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcblxuICAgICAgLy8gY2xlYXIgdGhlIGNhbnZhc1xuICAgICAgbGV0IHcgPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgbGV0IGggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudEhlaWdodDtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG5cblxuICAgICAgLy8gZHJhdyBodWUgY2lyY2xlXG4gICAgICBsZXQgeCwgeSwgaHVlLCBzYXQ7XG4gICAgICB0aGlzLmNlbnRlckNvb3JkaW5hdGVzID0ge3g6IHcgKiAwLjUsIHk6IGggKiAwLjV9O1xuICAgICAgdGhpcy5yID0gMC40OSAqIHc7XG4gICAgICBsZXQgYW5nbGVDb252ZXJ0ID0gKDIgKiBNYXRoLlBJKSAvIDM2MDtcbiAgICAgIGxldCBoZmFjID0gMSAvIDM2MDtcbiAgICAgIGxldCBzZmFjID0gMSAvIHRoaXMucjtcbiAgICAgIGxldCByZ2I7XG4gICAgICBmb3IgKGh1ZSA9IDA7IGh1ZSA8IDM2MDsgaHVlKyspIHtcbiAgICAgICAgZm9yIChzYXQgPSAwOyBzYXQgPCB0aGlzLnI7IHNhdCsrKSB7XG4gICAgICAgICAgeCA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCArIHNhdCAqIE1hdGguc2luKGFuZ2xlQ29udmVydCAqIGh1ZSk7XG4gICAgICAgICAgeSA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSArIHNhdCAqIE1hdGguY29zKGFuZ2xlQ29udmVydCAqIGh1ZSk7XG4gICAgICAgICAgcmdiID0gdXRpbC5IU1ZUb1JHQihodWUgKiBoZmFjLCBzYXQgKiBzZmFjLCAxKTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYignICsgcmdiLnIgKyAnLCcgKyByZ2IuZyArICcsJyArIHJnYi5iICsgJyknO1xuICAgICAgICAgIGN0eC5maWxsUmVjdCh4IC0gMC41LCB5IC0gMC41LCAyLCAyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwwLDAsMSknO1xuICAgICAgY3R4LmNpcmNsZSh0aGlzLmNlbnRlckNvb3JkaW5hdGVzLngsIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSwgdGhpcy5yKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgdGhpcy5odWVDaXJjbGUgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsMCx3LGgpO1xuICAgIH1cbiAgICB0aGlzLmdlbmVyYXRlZCA9IHRydWU7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBtb3ZlIHRoZSBzZWxlY3Rvci4gVGhpcyBpcyBjYWxsZWQgYnkgaGFtbWVyIGZ1bmN0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbW92ZVNlbGVjdG9yKGV2ZW50KSB7XG4gICAgbGV0IHJlY3QgPSB0aGlzLmNvbG9yUGlja2VyRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBsZWZ0ID0gZXZlbnQuY2VudGVyLnggLSByZWN0LmxlZnQ7XG4gICAgbGV0IHRvcCA9IGV2ZW50LmNlbnRlci55IC0gcmVjdC50b3A7XG5cbiAgICBsZXQgY2VudGVyWSA9IDAuNSAqIHRoaXMuY29sb3JQaWNrZXJEaXYuY2xpZW50SGVpZ2h0O1xuICAgIGxldCBjZW50ZXJYID0gMC41ICogdGhpcy5jb2xvclBpY2tlckRpdi5jbGllbnRXaWR0aDtcblxuICAgIGxldCB4ID0gbGVmdCAtIGNlbnRlclg7XG4gICAgbGV0IHkgPSB0b3AgLSBjZW50ZXJZO1xuXG4gICAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMih4LHkpO1xuICAgIGxldCByYWRpdXMgPSAwLjk4ICogTWF0aC5taW4oTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpLCBjZW50ZXJYKTtcblxuICAgIGxldCBuZXdUb3AgPSBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMgKyBjZW50ZXJZO1xuICAgIGxldCBuZXdMZWZ0ID0gTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzICsgY2VudGVyWDtcblxuICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS50b3AgPSBuZXdUb3AgLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50SGVpZ2h0ICsgJ3B4JztcbiAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUubGVmdCA9IG5ld0xlZnQgLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50V2lkdGggKyAncHgnO1xuXG4gICAgLy8gc2V0IGNvbG9yXG4gICAgbGV0IGggPSBhbmdsZSAvICgyICogTWF0aC5QSSk7XG4gICAgaCA9IGggPCAwID8gaCArIDEgOiBoO1xuICAgIGxldCBzID0gcmFkaXVzIC8gdGhpcy5yO1xuICAgIGxldCBoc3YgPSB1dGlsLlJHQlRvSFNWKHRoaXMuY29sb3IuciwgdGhpcy5jb2xvci5nLCB0aGlzLmNvbG9yLmIpO1xuICAgIGhzdi5oID0gaDtcbiAgICBoc3YucyA9IHM7XG4gICAgbGV0IHJnYmEgPSB1dGlsLkhTVlRvUkdCKGhzdi5oLCBoc3YucywgaHN2LnYpO1xuICAgIHJnYmFbJ2EnXSA9IHRoaXMuY29sb3IuYTtcbiAgICB0aGlzLmNvbG9yID0gcmdiYTtcblxuICAgIC8vIHVwZGF0ZSBwcmV2aWV3c1xuICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKCcgKyB0aGlzLmluaXRpYWxDb2xvci5yICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuZyArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmIgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5hICsgJyknO1xuICAgIHRoaXMubmV3Q29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoJyArIHRoaXMuY29sb3IuciArICcsJyArIHRoaXMuY29sb3IuZyArICcsJyArIHRoaXMuY29sb3IuYiArICcsJyArIHRoaXMuY29sb3IuYSArICcpJztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2xvclBpY2tlcjsiXX0=
},{"../hammerUtil":18,"../module/hammer":19,"../util":46}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _ColorPicker = require('./ColorPicker');

var _ColorPicker2 = _interopRequireDefault(_ColorPicker);

/**
 * The way this works is for all properties of this.possible options, you can supply the property name in any form to list the options.
 * Boolean options are recognised as Boolean
 * Number options should be written as array: [default value, min value, max value, stepsize]
 * Colors should be written as array: ['color', '#ffffff']
 * Strings with should be written as array: [option1, option2, option3, ..]
 *
 * The options are matched with their counterparts in each of the modules and the values used in the configuration are
 *
 * @param parentModule        | the location where parentModule.setOptions() can be called
 * @param defaultContainer    | the default container of the module
 * @param configureOptions    | the fully configured and predefined options set found in allOptions.js
 * @param pixelRatio          | canvas pixel ratio
 */
var util = require('../util');

var Configurator = (function () {
  function Configurator(parentModule, defaultContainer, configureOptions) {
    var pixelRatio = arguments.length <= 3 || arguments[3] === undefined ? 1 : arguments[3];

    _classCallCheck(this, Configurator);

    this.parent = parentModule;
    this.changedOptions = [];
    this.container = defaultContainer;
    this.allowCreation = false;

    this.options = {};
    this.initialized = false;
    this.popupCounter = 0;
    this.defaultOptions = {
      enabled: false,
      filter: true,
      container: undefined,
      showButton: true
    };
    util.extend(this.options, this.defaultOptions);

    this.configureOptions = configureOptions;
    this.moduleOptions = {};
    this.domElements = [];
    this.popupDiv = {};
    this.popupLimit = 5;
    this.popupHistory = {};
    this.colorPicker = new _ColorPicker2['default'](pixelRatio);
    this.wrapper = undefined;
  }

  /**
   * refresh all options.
   * Because all modules parse their options by themselves, we just use their options. We copy them here.
   *
   * @param options
   */

  _createClass(Configurator, [{
    key: 'setOptions',
    value: function setOptions(options) {
      if (options !== undefined) {
        // reset the popup history because the indices may have been changed.
        this.popupHistory = {};
        this._removePopup();

        var enabled = true;
        if (typeof options === 'string') {
          this.options.filter = options;
        } else if (options instanceof Array) {
          this.options.filter = options.join();
        } else if (typeof options === 'object') {
          if (options.container !== undefined) {
            this.options.container = options.container;
          }
          if (options.filter !== undefined) {
            this.options.filter = options.filter;
          }
          if (options.showButton !== undefined) {
            this.options.showButton = options.showButton;
          }
          if (options.enabled !== undefined) {
            enabled = options.enabled;
          }
        } else if (typeof options === 'boolean') {
          this.options.filter = true;
          enabled = options;
        } else if (typeof options === 'function') {
          this.options.filter = options;
          enabled = true;
        }
        if (this.options.filter === false) {
          enabled = false;
        }

        this.options.enabled = enabled;
      }
      this._clean();
    }
  }, {
    key: 'setModuleOptions',
    value: function setModuleOptions(moduleOptions) {
      this.moduleOptions = moduleOptions;
      if (this.options.enabled === true) {
        this._clean();
        if (this.options.container !== undefined) {
          this.container = this.options.container;
        }
        this._create();
      }
    }

    /**
     * Create all DOM elements
     * @private
     */
  }, {
    key: '_create',
    value: function _create() {
      var _this = this;

      this._clean();
      this.changedOptions = [];

      var filter = this.options.filter;
      var counter = 0;
      var show = false;
      for (var option in this.configureOptions) {
        if (this.configureOptions.hasOwnProperty(option)) {
          this.allowCreation = false;
          show = false;
          if (typeof filter === 'function') {
            show = filter(option, []);
            show = show || this._handleObject(this.configureOptions[option], [option], true);
          } else if (filter === true || filter.indexOf(option) !== -1) {
            show = true;
          }

          if (show !== false) {
            this.allowCreation = true;

            // linebreak between categories
            if (counter > 0) {
              this._makeItem([]);
            }
            // a header for the category
            this._makeHeader(option);

            // get the suboptions
            this._handleObject(this.configureOptions[option], [option]);
          }
          counter++;
        }
      }

      if (this.options.showButton === true) {
        (function () {
          var generateButton = document.createElement('div');
          generateButton.className = 'vis-configuration vis-config-button';
          generateButton.innerHTML = 'generate options';
          generateButton.onclick = function () {
            _this._printOptions();
          };
          generateButton.onmouseover = function () {
            generateButton.className = 'vis-configuration vis-config-button hover';
          };
          generateButton.onmouseout = function () {
            generateButton.className = 'vis-configuration vis-config-button';
          };

          _this.optionsContainer = document.createElement('div');
          _this.optionsContainer.className = 'vis-configuration vis-config-option-container';

          _this.domElements.push(_this.optionsContainer);
          _this.domElements.push(generateButton);
        })();
      }

      this._push();
      this.colorPicker.insertTo(this.container);
    }

    /**
     * draw all DOM elements on the screen
     * @private
     */
  }, {
    key: '_push',
    value: function _push() {
      this.wrapper = document.createElement('div');
      this.wrapper.className = 'vis-configuration-wrapper';
      this.container.appendChild(this.wrapper);
      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.appendChild(this.domElements[i]);
      }

      this._showPopupIfNeeded();
    }

    /**
     * delete all DOM elements
     * @private
     */
  }, {
    key: '_clean',
    value: function _clean() {
      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.removeChild(this.domElements[i]);
      }

      if (this.wrapper !== undefined) {
        this.container.removeChild(this.wrapper);
        this.wrapper = undefined;
      }
      this.domElements = [];

      this._removePopup();
    }

    /**
     * get the value from the actualOptions if it exists
     * @param {array} path    | where to look for the actual option
     * @returns {*}
     * @private
     */
  }, {
    key: '_getValue',
    value: function _getValue(path) {
      var base = this.moduleOptions;
      for (var i = 0; i < path.length; i++) {
        if (base[path[i]] !== undefined) {
          base = base[path[i]];
        } else {
          base = undefined;
          break;
        }
      }
      return base;
    }

    /**
     * all option elements are wrapped in an item
     * @param path
     * @param domElements
     * @private
     */
  }, {
    key: '_makeItem',
    value: function _makeItem(path) {
      var _arguments = arguments,
          _this2 = this;

      if (this.allowCreation === true) {
        var _len, domElements, _key;

        var _ret2 = (function () {
          var item = document.createElement('div');
          item.className = 'vis-configuration vis-config-item vis-config-s' + path.length;

          for (_len = _arguments.length, domElements = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            domElements[_key - 1] = _arguments[_key];
          }

          domElements.forEach(function (element) {
            item.appendChild(element);
          });
          _this2.domElements.push(item);
          return {
            v: _this2.domElements.length
          };
        })();

        if (typeof _ret2 === 'object') return _ret2.v;
      }
      return 0;
    }

    /**
     * header for major subjects
     * @param name
     * @private
     */
  }, {
    key: '_makeHeader',
    value: function _makeHeader(name) {
      var div = document.createElement('div');
      div.className = 'vis-configuration vis-config-header';
      div.innerHTML = name;
      this._makeItem([], div);
    }

    /**
     * make a label, if it is an object label, it gets different styling.
     * @param name
     * @param path
     * @param objectLabel
     * @returns {HTMLElement}
     * @private
     */
  }, {
    key: '_makeLabel',
    value: function _makeLabel(name, path) {
      var objectLabel = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var div = document.createElement('div');
      div.className = 'vis-configuration vis-config-label vis-config-s' + path.length;
      if (objectLabel === true) {
        div.innerHTML = '<i><b>' + name + ':</b></i>';
      } else {
        div.innerHTML = name + ':';
      }
      return div;
    }

    /**
     * make a dropdown list for multiple possible string optoins
     * @param arr
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeDropdown',
    value: function _makeDropdown(arr, value, path) {
      var select = document.createElement('select');
      select.className = 'vis-configuration vis-config-select';
      var selectedValue = 0;
      if (value !== undefined) {
        if (arr.indexOf(value) !== -1) {
          selectedValue = arr.indexOf(value);
        }
      }

      for (var i = 0; i < arr.length; i++) {
        var option = document.createElement('option');
        option.value = arr[i];
        if (i === selectedValue) {
          option.selected = 'selected';
        }
        option.innerHTML = arr[i];
        select.appendChild(option);
      }

      var me = this;
      select.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, select);
    }

    /**
     * make a range object for numeric options
     * @param arr
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeRange',
    value: function _makeRange(arr, value, path) {
      var defaultValue = arr[0];
      var min = arr[1];
      var max = arr[2];
      var step = arr[3];
      var range = document.createElement('input');
      range.className = 'vis-configuration vis-config-range';
      try {
        range.type = 'range'; // not supported on IE9
        range.min = min;
        range.max = max;
      } catch (err) {}
      range.step = step;

      // set up the popup settings in case they are needed.
      var popupString = '';
      var popupValue = 0;

      if (value !== undefined) {
        var factor = 1.20;
        if (value < 0 && value * factor < min) {
          range.min = Math.ceil(value * factor);
          popupValue = range.min;
          popupString = 'range increased';
        } else if (value / factor < min) {
          range.min = Math.ceil(value / factor);
          popupValue = range.min;
          popupString = 'range increased';
        }
        if (value * factor > max && max !== 1) {
          range.max = Math.ceil(value * factor);
          popupValue = range.max;
          popupString = 'range increased';
        }
        range.value = value;
      } else {
        range.value = defaultValue;
      }

      var input = document.createElement('input');
      input.className = 'vis-configuration vis-config-rangeinput';
      input.value = range.value;

      var me = this;
      range.onchange = function () {
        input.value = this.value;me._update(Number(this.value), path);
      };
      range.oninput = function () {
        input.value = this.value;
      };

      var label = this._makeLabel(path[path.length - 1], path);
      var itemIndex = this._makeItem(path, label, range, input);

      // if a popup is needed AND it has not been shown for this value, show it.
      if (popupString !== '' && this.popupHistory[itemIndex] !== popupValue) {
        this.popupHistory[itemIndex] = popupValue;
        this._setupPopup(popupString, itemIndex);
      }
    }

    /**
     * prepare the popup
     * @param string
     * @param index
     * @private
     */
  }, {
    key: '_setupPopup',
    value: function _setupPopup(string, index) {
      var _this3 = this;

      if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
        var div = document.createElement("div");
        div.id = "vis-configuration-popup";
        div.className = "vis-configuration-popup";
        div.innerHTML = string;
        div.onclick = function () {
          _this3._removePopup();
        };
        this.popupCounter += 1;
        this.popupDiv = { html: div, index: index };
      }
    }

    /**
     * remove the popup from the dom
     * @private
     */
  }, {
    key: '_removePopup',
    value: function _removePopup() {
      if (this.popupDiv.html !== undefined) {
        this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
        clearTimeout(this.popupDiv.hideTimeout);
        clearTimeout(this.popupDiv.deleteTimeout);
        this.popupDiv = {};
      }
    }

    /**
     * Show the popup if it is needed.
     * @private
     */
  }, {
    key: '_showPopupIfNeeded',
    value: function _showPopupIfNeeded() {
      var _this4 = this;

      if (this.popupDiv.html !== undefined) {
        var correspondingElement = this.domElements[this.popupDiv.index];
        var rect = correspondingElement.getBoundingClientRect();
        this.popupDiv.html.style.left = rect.left + "px";
        this.popupDiv.html.style.top = rect.top - 30 + "px"; // 30 is the height;
        document.body.appendChild(this.popupDiv.html);
        this.popupDiv.hideTimeout = setTimeout(function () {
          _this4.popupDiv.html.style.opacity = 0;
        }, 1500);
        this.popupDiv.deleteTimeout = setTimeout(function () {
          _this4._removePopup();
        }, 1800);
      }
    }

    /**
     * make a checkbox for boolean options.
     * @param defaultValue
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeCheckbox',
    value: function _makeCheckbox(defaultValue, value, path) {
      var checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'vis-configuration vis-config-checkbox';
      checkbox.checked = defaultValue;
      if (value !== undefined) {
        checkbox.checked = value;
        if (value !== defaultValue) {
          if (typeof defaultValue === 'object') {
            if (value !== defaultValue.enabled) {
              this.changedOptions.push({ path: path, value: value });
            }
          } else {
            this.changedOptions.push({ path: path, value: value });
          }
        }
      }

      var me = this;
      checkbox.onchange = function () {
        me._update(this.checked, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, checkbox);
    }

    /**
     * make a text input field for string options.
     * @param defaultValue
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeTextInput',
    value: function _makeTextInput(defaultValue, value, path) {
      var checkbox = document.createElement('input');
      checkbox.type = 'text';
      checkbox.className = 'vis-configuration vis-config-text';
      checkbox.value = value;
      if (value !== defaultValue) {
        this.changedOptions.push({ path: path, value: value });
      }

      var me = this;
      checkbox.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, checkbox);
    }

    /**
     * make a color field with a color picker for color fields
     * @param arr
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeColorField',
    value: function _makeColorField(arr, value, path) {
      var _this5 = this;

      var defaultColor = arr[1];
      var div = document.createElement('div');
      value = value === undefined ? defaultColor : value;

      if (value !== 'none') {
        div.className = 'vis-configuration vis-config-colorBlock';
        div.style.backgroundColor = value;
      } else {
        div.className = 'vis-configuration vis-config-colorBlock none';
      }

      value = value === undefined ? defaultColor : value;
      div.onclick = function () {
        _this5._showColorPicker(value, div, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, div);
    }

    /**
     * used by the color buttons to call the color picker.
     * @param event
     * @param value
     * @param div
     * @param path
     * @private
     */
  }, {
    key: '_showColorPicker',
    value: function _showColorPicker(value, div, path) {
      var _this6 = this;

      var rect = div.getBoundingClientRect();
      var bodyRect = document.body.getBoundingClientRect();
      var pickerX = rect.left + rect.width + 5;
      var pickerY = rect.top - bodyRect.top + rect.height + 2;
      this.colorPicker.show(pickerX, pickerY);
      this.colorPicker.setColor(value);
      this.colorPicker.setCallback(function (color) {
        var colorString = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + color.a + ')';
        div.style.backgroundColor = colorString;
        _this6._update(colorString, path);
      });
    }

    /**
     * parse an object and draw the correct items
     * @param obj
     * @param path
     * @private
     */
  }, {
    key: '_handleObject',
    value: function _handleObject(obj) {
      var path = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
      var checkOnly = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var show = false;
      var filter = this.options.filter;
      var visibleInSet = false;
      for (var subObj in obj) {
        if (obj.hasOwnProperty(subObj)) {
          show = true;
          var item = obj[subObj];
          var newPath = util.copyAndExtendArray(path, subObj);
          if (typeof filter === 'function') {
            show = filter(subObj, path);

            // if needed we must go deeper into the object.
            if (show === false) {
              if (!(item instanceof Array) && typeof item !== 'string' && typeof item !== 'boolean' && item instanceof Object) {
                this.allowCreation = false;
                show = this._handleObject(item, newPath, true);
                this.allowCreation = checkOnly === false;
              }
            }
          }

          if (show !== false) {
            visibleInSet = true;
            var value = this._getValue(newPath);

            if (item instanceof Array) {
              this._handleArray(item, value, newPath);
            } else if (typeof item === 'string') {
              this._makeTextInput(item, value, newPath);
            } else if (typeof item === 'boolean') {
              this._makeCheckbox(item, value, newPath);
            } else if (item instanceof Object) {
              // collapse the physics options that are not enabled
              var draw = true;
              if (path.indexOf('physics') !== -1) {
                if (this.moduleOptions.physics.solver !== subObj) {
                  draw = false;
                }
              }

              if (draw === true) {
                // initially collapse options with an disabled enabled option.
                if (item.enabled !== undefined) {
                  var enabledPath = util.copyAndExtendArray(newPath, 'enabled');
                  var enabledValue = this._getValue(enabledPath);
                  if (enabledValue === true) {
                    var label = this._makeLabel(subObj, newPath, true);
                    this._makeItem(newPath, label);
                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                  } else {
                    this._makeCheckbox(item, enabledValue, newPath);
                  }
                } else {
                  var label = this._makeLabel(subObj, newPath, true);
                  this._makeItem(newPath, label);
                  visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                }
              }
            } else {
              console.error('dont know how to handle', item, subObj, newPath);
            }
          }
        }
      }
      return visibleInSet;
    }

    /**
     * handle the array type of option
     * @param optionName
     * @param arr
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_handleArray',
    value: function _handleArray(arr, value, path) {
      if (typeof arr[0] === 'string' && arr[0] === 'color') {
        this._makeColorField(arr, value, path);
        if (arr[1] !== value) {
          this.changedOptions.push({ path: path, value: value });
        }
      } else if (typeof arr[0] === 'string') {
        this._makeDropdown(arr, value, path);
        if (arr[0] !== value) {
          this.changedOptions.push({ path: path, value: value });
        }
      } else if (typeof arr[0] === 'number') {
        this._makeRange(arr, value, path);
        if (arr[0] !== value) {
          this.changedOptions.push({ path: path, value: Number(value) });
        }
      }
    }

    /**
     * called to update the network with the new settings.
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_update',
    value: function _update(value, path) {
      var options = this._constructOptions(value, path);

      if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
        this.parent.body.emitter.emit("configChange", options);
      }
      this.initialized = true;
      this.parent.setOptions(options);
    }
  }, {
    key: '_constructOptions',
    value: function _constructOptions(value, path) {
      var optionsObj = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      var pointer = optionsObj;

      // when dropdown boxes can be string or boolean, we typecast it into correct types
      value = value === 'true' ? true : value;
      value = value === 'false' ? false : value;

      for (var i = 0; i < path.length; i++) {
        if (path[i] !== 'global') {
          if (pointer[path[i]] === undefined) {
            pointer[path[i]] = {};
          }
          if (i !== path.length - 1) {
            pointer = pointer[path[i]];
          } else {
            pointer[path[i]] = value;
          }
        }
      }
      return optionsObj;
    }
  }, {
    key: '_printOptions',
    value: function _printOptions() {
      var options = this.getOptions();
      this.optionsContainer.innerHTML = '<pre>var options = ' + JSON.stringify(options, null, 2) + '</pre>';
    }
  }, {
    key: 'getOptions',
    value: function getOptions() {
      var options = {};
      for (var i = 0; i < this.changedOptions.length; i++) {
        this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);
      }
      return options;
    }
  }]);

  return Configurator;
})();

exports['default'] = Configurator;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvc2hhcmVkL0NvbmZpZ3VyYXRvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7MkJBRXdCLGVBQWU7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUZ2QyxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7O0lBa0J4QixZQUFZO0FBQ0wsV0FEUCxZQUFZLENBQ0osWUFBWSxFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixFQUFrQjtRQUFoQixVQUFVLHlEQUFHLENBQUM7OzBCQUR4RSxZQUFZOztBQUVkLFFBQUksQ0FBQyxNQUFNLEdBQUcsWUFBWSxDQUFDO0FBQzNCLFFBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxDQUFDO0FBQ3pCLFFBQUksQ0FBQyxTQUFTLEdBQUcsZ0JBQWdCLENBQUM7QUFDbEMsUUFBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7O0FBRTNCLFFBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO0FBQ2xCLFFBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO0FBQ3pCLFFBQUksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDO0FBQ3RCLFFBQUksQ0FBQyxjQUFjLEdBQUc7QUFDcEIsYUFBTyxFQUFFLEtBQUs7QUFDZCxZQUFNLEVBQUUsSUFBSTtBQUNaLGVBQVMsRUFBRSxTQUFTO0FBQ3BCLGdCQUFVLEVBQUUsSUFBSTtLQUNqQixDQUFDO0FBQ0YsUUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQzs7QUFFL0MsUUFBSSxDQUFDLGdCQUFnQixHQUFHLGdCQUFnQixDQUFDO0FBQ3pDLFFBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDO0FBQ3hCLFFBQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDO0FBQ3RC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O0tBQ2hCOzs7U0E3cUJHLFlBQVk7OztxQkFpckJILFlBQVkiLCJmaWxlIjoiL1VzZXJzL2RhcmluL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzLXZpZXdlci9ub2RlX21vZHVsZXMvdmlzL2xpYi9zaGFyZWQvQ29uZmlndXJhdG9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmltcG9ydCBDb2xvclBpY2tlciBmcm9tICcuL0NvbG9yUGlja2VyJ1xuXG4vKipcbiAqIFRoZSB3YXkgdGhpcyB3b3JrcyBpcyBmb3IgYWxsIHByb3BlcnRpZXMgb2YgdGhpcy5wb3NzaWJsZSBvcHRpb25zLCB5b3UgY2FuIHN1cHBseSB0aGUgcHJvcGVydHkgbmFtZSBpbiBhbnkgZm9ybSB0byBsaXN0IHRoZSBvcHRpb25zLlxuICogQm9vbGVhbiBvcHRpb25zIGFyZSByZWNvZ25pc2VkIGFzIEJvb2xlYW5cbiAqIE51bWJlciBvcHRpb25zIHNob3VsZCBiZSB3cml0dGVuIGFzIGFycmF5OiBbZGVmYXVsdCB2YWx1ZSwgbWluIHZhbHVlLCBtYXggdmFsdWUsIHN0ZXBzaXplXVxuICogQ29sb3JzIHNob3VsZCBiZSB3cml0dGVuIGFzIGFycmF5OiBbJ2NvbG9yJywgJyNmZmZmZmYnXVxuICogU3RyaW5ncyB3aXRoIHNob3VsZCBiZSB3cml0dGVuIGFzIGFycmF5OiBbb3B0aW9uMSwgb3B0aW9uMiwgb3B0aW9uMywgLi5dXG4gKlxuICogVGhlIG9wdGlvbnMgYXJlIG1hdGNoZWQgd2l0aCB0aGVpciBjb3VudGVycGFydHMgaW4gZWFjaCBvZiB0aGUgbW9kdWxlcyBhbmQgdGhlIHZhbHVlcyB1c2VkIGluIHRoZSBjb25maWd1cmF0aW9uIGFyZVxuICpcbiAqIEBwYXJhbSBwYXJlbnRNb2R1bGUgICAgICAgIHwgdGhlIGxvY2F0aW9uIHdoZXJlIHBhcmVudE1vZHVsZS5zZXRPcHRpb25zKCkgY2FuIGJlIGNhbGxlZFxuICogQHBhcmFtIGRlZmF1bHRDb250YWluZXIgICAgfCB0aGUgZGVmYXVsdCBjb250YWluZXIgb2YgdGhlIG1vZHVsZVxuICogQHBhcmFtIGNvbmZpZ3VyZU9wdGlvbnMgICAgfCB0aGUgZnVsbHkgY29uZmlndXJlZCBhbmQgcHJlZGVmaW5lZCBvcHRpb25zIHNldCBmb3VuZCBpbiBhbGxPcHRpb25zLmpzXG4gKiBAcGFyYW0gcGl4ZWxSYXRpbyAgICAgICAgICB8IGNhbnZhcyBwaXhlbCByYXRpb1xuICovXG5jbGFzcyBDb25maWd1cmF0b3Ige1xuICBjb25zdHJ1Y3RvcihwYXJlbnRNb2R1bGUsIGRlZmF1bHRDb250YWluZXIsIGNvbmZpZ3VyZU9wdGlvbnMsIHBpeGVsUmF0aW8gPSAxKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRNb2R1bGU7XG4gICAgdGhpcy5jaGFuZ2VkT3B0aW9ucyA9IFtdO1xuICAgIHRoaXMuY29udGFpbmVyID0gZGVmYXVsdENvbnRhaW5lcjtcbiAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBmYWxzZTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBvcHVwQ291bnRlciA9IDA7XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgZmlsdGVyOiB0cnVlLFxuICAgICAgY29udGFpbmVyOiB1bmRlZmluZWQsXG4gICAgICBzaG93QnV0dG9uOiB0cnVlXG4gICAgfTtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5jb25maWd1cmVPcHRpb25zID0gY29uZmlndXJlT3B0aW9ucztcbiAgICB0aGlzLm1vZHVsZU9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRvbUVsZW1lbnRzID0gW107XG4gICAgdGhpcy5wb3B1cERpdiA9IHt9O1xuICAgIHRoaXMucG9wdXBMaW1pdCA9IDU7XG4gICAgdGhpcy5wb3B1cEhpc3RvcnkgPSB7fTtcbiAgICB0aGlzLmNvbG9yUGlja2VyID0gbmV3IENvbG9yUGlja2VyKHBpeGVsUmF0aW8pO1xuICAgIHRoaXMud3JhcHBlciA9IHVuZGVmaW5lZDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIHJlZnJlc2ggYWxsIG9wdGlvbnMuXG4gICAqIEJlY2F1c2UgYWxsIG1vZHVsZXMgcGFyc2UgdGhlaXIgb3B0aW9ucyBieSB0aGVtc2VsdmVzLCB3ZSBqdXN0IHVzZSB0aGVpciBvcHRpb25zLiBXZSBjb3B5IHRoZW0gaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJlc2V0IHRoZSBwb3B1cCBoaXN0b3J5IGJlY2F1c2UgdGhlIGluZGljZXMgbWF5IGhhdmUgYmVlbiBjaGFuZ2VkLlxuICAgICAgdGhpcy5wb3B1cEhpc3RvcnkgPSB7fTtcbiAgICAgIHRoaXMuX3JlbW92ZVBvcHVwKCk7XG5cbiAgICAgIGxldCBlbmFibGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcHRpb25zIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IG9wdGlvbnMuam9pbigpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNob3dCdXR0b24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5zaG93QnV0dG9uID0gb3B0aW9ucy5zaG93QnV0dG9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVuYWJsZWQgPSBvcHRpb25zLmVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IHRydWU7XG4gICAgICAgIGVuYWJsZWQgPSBvcHRpb25zO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IG9wdGlvbnM7XG4gICAgICAgIGVuYWJsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5maWx0ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgIGVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgIH1cbiAgICB0aGlzLl9jbGVhbigpO1xuICB9XG5cblxuICBzZXRNb2R1bGVPcHRpb25zKG1vZHVsZU9wdGlvbnMpIHtcbiAgICB0aGlzLm1vZHVsZU9wdGlvbnMgPSBtb2R1bGVPcHRpb25zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgfVxuICAgICAgdGhpcy5fY3JlYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbGwgRE9NIGVsZW1lbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlKCkge1xuICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgdGhpcy5jaGFuZ2VkT3B0aW9ucyA9IFtdO1xuXG4gICAgbGV0IGZpbHRlciA9IHRoaXMub3B0aW9ucy5maWx0ZXI7XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGxldCBzaG93ID0gZmFsc2U7XG4gICAgZm9yIChsZXQgb3B0aW9uIGluIHRoaXMuY29uZmlndXJlT3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuY29uZmlndXJlT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuICAgICAgICBzaG93ID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc2hvdyA9IGZpbHRlcihvcHRpb24sW10pO1xuICAgICAgICAgIHNob3cgPSBzaG93IHx8IHRoaXMuX2hhbmRsZU9iamVjdCh0aGlzLmNvbmZpZ3VyZU9wdGlvbnNbb3B0aW9uXSwgW29wdGlvbl0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbHRlciA9PT0gdHJ1ZSB8fCBmaWx0ZXIuaW5kZXhPZihvcHRpb24pICE9PSAtMSkge1xuICAgICAgICAgIHNob3cgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3cgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIGxpbmVicmVhayBiZXR3ZWVuIGNhdGVnb3JpZXNcbiAgICAgICAgICBpZiAoY291bnRlciA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX21ha2VJdGVtKFtdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gYSBoZWFkZXIgZm9yIHRoZSBjYXRlZ29yeVxuICAgICAgICAgIHRoaXMuX21ha2VIZWFkZXIob3B0aW9uKTtcblxuICAgICAgICAgIC8vIGdldCB0aGUgc3Vib3B0aW9uc1xuICAgICAgICAgIHRoaXMuX2hhbmRsZU9iamVjdCh0aGlzLmNvbmZpZ3VyZU9wdGlvbnNbb3B0aW9uXSwgW29wdGlvbl0pO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dCdXR0b24gPT09IHRydWUpIHtcbiAgICAgIGxldCBnZW5lcmF0ZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZ2VuZXJhdGVCdXR0b24uY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uJztcbiAgICAgIGdlbmVyYXRlQnV0dG9uLmlubmVySFRNTCA9ICdnZW5lcmF0ZSBvcHRpb25zJztcbiAgICAgIGdlbmVyYXRlQnV0dG9uLm9uY2xpY2sgPSAgICAgKCkgPT4ge3RoaXMuX3ByaW50T3B0aW9ucygpO307XG4gICAgICBnZW5lcmF0ZUJ1dHRvbi5vbm1vdXNlb3ZlciA9ICgpID0+IHtnZW5lcmF0ZUJ1dHRvbi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b24gaG92ZXInO307XG4gICAgICBnZW5lcmF0ZUJ1dHRvbi5vbm1vdXNlb3V0ID0gICgpID0+IHtnZW5lcmF0ZUJ1dHRvbi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b24nO307XG5cbiAgICAgIHRoaXMub3B0aW9uc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5vcHRpb25zQ29udGFpbmVyLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLW9wdGlvbi1jb250YWluZXInO1xuXG4gICAgICB0aGlzLmRvbUVsZW1lbnRzLnB1c2godGhpcy5vcHRpb25zQ29udGFpbmVyKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudHMucHVzaChnZW5lcmF0ZUJ1dHRvbik7XG4gICAgfVxuXG4gICAgdGhpcy5fcHVzaCgpO1xuICAgIHRoaXMuY29sb3JQaWNrZXIuaW5zZXJ0VG8odGhpcy5jb250YWluZXIpO1xuICB9XG5cblxuICAvKipcbiAgICogZHJhdyBhbGwgRE9NIGVsZW1lbnRzIG9uIHRoZSBzY3JlZW5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wdXNoKCkge1xuICAgIHRoaXMud3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMud3JhcHBlci5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24td3JhcHBlcic7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy53cmFwcGVyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZG9tRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zaG93UG9wdXBJZk5lZWRlZCgpXG4gIH1cblxuXG4gIC8qKlxuICAgKiBkZWxldGUgYWxsIERPTSBlbGVtZW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NsZWFuKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kb21FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudHNbaV0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndyYXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy53cmFwcGVyKTtcbiAgICAgIHRoaXMud3JhcHBlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5kb21FbGVtZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fcmVtb3ZlUG9wdXAoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgYWN0dWFsT3B0aW9ucyBpZiBpdCBleGlzdHNcbiAgICogQHBhcmFtIHthcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFZhbHVlKHBhdGgpIHtcbiAgICBsZXQgYmFzZSA9IHRoaXMubW9kdWxlT3B0aW9ucztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChiYXNlW3BhdGhbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYmFzZSA9IGJhc2VbcGF0aFtpXV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYmFzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xuICB9XG5cblxuICAvKipcbiAgICogYWxsIG9wdGlvbiBlbGVtZW50cyBhcmUgd3JhcHBlZCBpbiBhbiBpdGVtXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwYXJhbSBkb21FbGVtZW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21ha2VJdGVtKHBhdGgsIC4uLmRvbUVsZW1lbnRzKSB7XG4gICAgaWYgKHRoaXMuYWxsb3dDcmVhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgbGV0IGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGl0ZW0uY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctaXRlbSB2aXMtY29uZmlnLXMnICsgcGF0aC5sZW5ndGg7XG4gICAgICBkb21FbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudHMucHVzaChpdGVtKTtcbiAgICAgIHJldHVybiB0aGlzLmRvbUVsZW1lbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBoZWFkZXIgZm9yIG1ham9yIHN1YmplY3RzXG4gICAqIEBwYXJhbSBuYW1lXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFrZUhlYWRlcihuYW1lKSB7XG4gICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1oZWFkZXInO1xuICAgIGRpdi5pbm5lckhUTUwgPSBuYW1lO1xuICAgIHRoaXMuX21ha2VJdGVtKFtdLGRpdik7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBtYWtlIGEgbGFiZWwsIGlmIGl0IGlzIGFuIG9iamVjdCBsYWJlbCwgaXQgZ2V0cyBkaWZmZXJlbnQgc3R5bGluZy5cbiAgICogQHBhcmFtIG5hbWVcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIG9iamVjdExhYmVsXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYWtlTGFiZWwobmFtZSwgcGF0aCwgb2JqZWN0TGFiZWwgPSBmYWxzZSkge1xuICAgIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctbGFiZWwgdmlzLWNvbmZpZy1zJyArIHBhdGgubGVuZ3RoO1xuICAgIGlmIChvYmplY3RMYWJlbCA9PT0gdHJ1ZSkge1xuICAgICAgZGl2LmlubmVySFRNTCA9ICc8aT48Yj4nICsgbmFtZSArICc6PC9iPjwvaT4nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGRpdi5pbm5lckhUTUwgPSBuYW1lICsgJzonO1xuICAgIH1cbiAgICByZXR1cm4gZGl2O1xuICB9XG5cblxuICAvKipcbiAgICogbWFrZSBhIGRyb3Bkb3duIGxpc3QgZm9yIG11bHRpcGxlIHBvc3NpYmxlIHN0cmluZyBvcHRvaW5zXG4gICAqIEBwYXJhbSBhcnJcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFrZURyb3Bkb3duKGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICBsZXQgc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgc2VsZWN0LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXNlbGVjdCc7XG4gICAgbGV0IHNlbGVjdGVkVmFsdWUgPSAwO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoYXJyLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICBzZWxlY3RlZFZhbHVlID0gYXJyLmluZGV4T2YodmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICBvcHRpb24udmFsdWUgPSBhcnJbaV07XG4gICAgICBpZiAoaSA9PT0gc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSAnc2VsZWN0ZWQnO1xuICAgICAgfVxuICAgICAgb3B0aW9uLmlubmVySFRNTCA9IGFycltpXTtcbiAgICAgIHNlbGVjdC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgIH1cblxuICAgIGxldCBtZSA9IHRoaXM7XG4gICAgc2VsZWN0Lm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge21lLl91cGRhdGUodGhpcy52YWx1ZSwgcGF0aCk7fTtcblxuICAgIGxldCBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoLTFdLCBwYXRoKTtcbiAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgc2VsZWN0KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIG1ha2UgYSByYW5nZSBvYmplY3QgZm9yIG51bWVyaWMgb3B0aW9uc1xuICAgKiBAcGFyYW0gYXJyXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21ha2VSYW5nZShhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgbGV0IGRlZmF1bHRWYWx1ZSA9IGFyclswXTtcbiAgICBsZXQgbWluID0gYXJyWzFdO1xuICAgIGxldCBtYXggPSBhcnJbMl07XG4gICAgbGV0IHN0ZXAgPSBhcnJbM107XG4gICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICByYW5nZS5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1yYW5nZSc7XG4gICAgdHJ5IHtcbiAgICAgIHJhbmdlLnR5cGUgPSAncmFuZ2UnOyAvLyBub3Qgc3VwcG9ydGVkIG9uIElFOVxuICAgICAgcmFuZ2UubWluID0gbWluO1xuICAgICAgcmFuZ2UubWF4ID0gbWF4O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7fVxuICAgIHJhbmdlLnN0ZXAgPSBzdGVwO1xuXG4gICAgLy8gc2V0IHVwIHRoZSBwb3B1cCBzZXR0aW5ncyBpbiBjYXNlIHRoZXkgYXJlIG5lZWRlZC5cbiAgICBsZXQgcG9wdXBTdHJpbmcgPSAnJztcbiAgICBsZXQgcG9wdXBWYWx1ZSA9IDA7XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IGZhY3RvciA9IDEuMjA7XG4gICAgICBpZiAodmFsdWUgPCAwICYmIHZhbHVlICogZmFjdG9yIDwgbWluKSB7XG4gICAgICAgIHJhbmdlLm1pbiA9IE1hdGguY2VpbCh2YWx1ZSAqIGZhY3Rvcik7XG4gICAgICAgIHBvcHVwVmFsdWUgPSByYW5nZS5taW47XG4gICAgICAgIHBvcHVwU3RyaW5nID0gJ3JhbmdlIGluY3JlYXNlZCc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2YWx1ZSAvIGZhY3RvciA8IG1pbikge1xuICAgICAgICByYW5nZS5taW4gPSBNYXRoLmNlaWwodmFsdWUgLyBmYWN0b3IpO1xuICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWluO1xuICAgICAgICBwb3B1cFN0cmluZyA9ICdyYW5nZSBpbmNyZWFzZWQnO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICogZmFjdG9yID4gbWF4ICYmIG1heCAhPT0gMSkge1xuICAgICAgICByYW5nZS5tYXggPSBNYXRoLmNlaWwodmFsdWUgKiBmYWN0b3IpO1xuICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWF4O1xuICAgICAgICBwb3B1cFN0cmluZyA9ICdyYW5nZSBpbmNyZWFzZWQnO1xuICAgICAgfVxuICAgICAgcmFuZ2UudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByYW5nZS52YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICBsZXQgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGlucHV0LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXJhbmdlaW5wdXQnO1xuICAgIGlucHV0LnZhbHVlID0gcmFuZ2UudmFsdWU7XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHJhbmdlLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge2lucHV0LnZhbHVlID0gdGhpcy52YWx1ZTsgbWUuX3VwZGF0ZShOdW1iZXIodGhpcy52YWx1ZSksIHBhdGgpO307XG4gICAgcmFuZ2Uub25pbnB1dCAgPSBmdW5jdGlvbiAoKSB7aW5wdXQudmFsdWUgPSB0aGlzLnZhbHVlOyB9O1xuXG4gICAgbGV0IGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGgtMV0sIHBhdGgpO1xuICAgIGxldCBpdGVtSW5kZXggPSB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgcmFuZ2UsIGlucHV0KTtcblxuICAgIC8vIGlmIGEgcG9wdXAgaXMgbmVlZGVkIEFORCBpdCBoYXMgbm90IGJlZW4gc2hvd24gZm9yIHRoaXMgdmFsdWUsIHNob3cgaXQuXG4gICAgaWYgKHBvcHVwU3RyaW5nICE9PSAnJyAmJiB0aGlzLnBvcHVwSGlzdG9yeVtpdGVtSW5kZXhdICE9PSBwb3B1cFZhbHVlKSB7XG4gICAgICB0aGlzLnBvcHVwSGlzdG9yeVtpdGVtSW5kZXhdID0gcG9wdXBWYWx1ZTtcbiAgICAgIHRoaXMuX3NldHVwUG9wdXAocG9wdXBTdHJpbmcsIGl0ZW1JbmRleCk7XG4gICAgfVxuXG4gIH1cblxuXG4gIC8qKlxuICAgKiBwcmVwYXJlIHRoZSBwb3B1cFxuICAgKiBAcGFyYW0gc3RyaW5nXG4gICAqIEBwYXJhbSBpbmRleFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldHVwUG9wdXAoc3RyaW5nLCBpbmRleCkge1xuICAgIGlmICh0aGlzLmluaXRpYWxpemVkID09PSB0cnVlICYmIHRoaXMuYWxsb3dDcmVhdGlvbiA9PT0gdHJ1ZSAmJiB0aGlzLnBvcHVwQ291bnRlciA8IHRoaXMucG9wdXBMaW1pdCkge1xuICAgICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYuaWQgPSBcInZpcy1jb25maWd1cmF0aW9uLXBvcHVwXCI7XG4gICAgICBkaXYuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbi1wb3B1cFwiO1xuICAgICAgZGl2LmlubmVySFRNTCA9IHN0cmluZztcbiAgICAgIGRpdi5vbmNsaWNrID0gKCkgPT4ge3RoaXMuX3JlbW92ZVBvcHVwKCl9O1xuICAgICAgdGhpcy5wb3B1cENvdW50ZXIgKz0gMTtcbiAgICAgIHRoaXMucG9wdXBEaXYgPSB7aHRtbDpkaXYsIGluZGV4OmluZGV4fTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiByZW1vdmUgdGhlIHBvcHVwIGZyb20gdGhlIGRvbVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbW92ZVBvcHVwKCkge1xuICAgIGlmICh0aGlzLnBvcHVwRGl2Lmh0bWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5wb3B1cERpdi5odG1sLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3B1cERpdi5odG1sKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBvcHVwRGl2LmhpZGVUaW1lb3V0KTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBvcHVwRGl2LmRlbGV0ZVRpbWVvdXQpO1xuICAgICAgdGhpcy5wb3B1cERpdiA9IHt9O1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIHBvcHVwIGlmIGl0IGlzIG5lZWRlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zaG93UG9wdXBJZk5lZWRlZCgpIHtcbiAgICBpZiAodGhpcy5wb3B1cERpdi5odG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBjb3JyZXNwb25kaW5nRWxlbWVudCA9IHRoaXMuZG9tRWxlbWVudHNbdGhpcy5wb3B1cERpdi5pbmRleF07XG4gICAgICBsZXQgcmVjdCA9IGNvcnJlc3BvbmRpbmdFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGhpcy5wb3B1cERpdi5odG1sLnN0eWxlLmxlZnQgPSByZWN0LmxlZnQgKyBcInB4XCI7XG4gICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwuc3R5bGUudG9wID0gcmVjdC50b3AgLSAzMCArIFwicHhcIjsgLy8gMzAgaXMgdGhlIGhlaWdodDtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wb3B1cERpdi5odG1sKVxuICAgICAgdGhpcy5wb3B1cERpdi5oaWRlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB9LDE1MDApO1xuICAgICAgdGhpcy5wb3B1cERpdi5kZWxldGVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVBvcHVwKCk7XG4gICAgICB9LDE4MDApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIG1ha2UgYSBjaGVja2JveCBmb3IgYm9vbGVhbiBvcHRpb25zLlxuICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21ha2VDaGVja2JveChkZWZhdWx0VmFsdWUsIHZhbHVlLCBwYXRoKSB7XG4gICAgdmFyIGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBjaGVja2JveC50eXBlID0gJ2NoZWNrYm94JztcbiAgICBjaGVja2JveC5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1jaGVja2JveCc7XG4gICAgY2hlY2tib3guY2hlY2tlZCA9IGRlZmF1bHRWYWx1ZTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHZhbHVlO1xuICAgICAgaWYgKHZhbHVlICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBkZWZhdWx0VmFsdWUuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtwYXRoOnBhdGgsIHZhbHVlOnZhbHVlfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7cGF0aDpwYXRoLCB2YWx1ZTp2YWx1ZX0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG1lID0gdGhpcztcbiAgICBjaGVja2JveC5vbmNoYW5nZSA9IGZ1bmN0aW9uKCkge21lLl91cGRhdGUodGhpcy5jaGVja2VkLCBwYXRoKX07XG5cbiAgICBsZXQgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aC0xXSwgcGF0aCk7XG4gICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIGNoZWNrYm94KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBtYWtlIGEgdGV4dCBpbnB1dCBmaWVsZCBmb3Igc3RyaW5nIG9wdGlvbnMuXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWVcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFrZVRleHRJbnB1dChkZWZhdWx0VmFsdWUsIHZhbHVlLCBwYXRoKSB7XG4gICAgdmFyIGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBjaGVja2JveC50eXBlID0gJ3RleHQnO1xuICAgIGNoZWNrYm94LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXRleHQnO1xuICAgIGNoZWNrYm94LnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHZhbHVlICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7cGF0aDpwYXRoLCB2YWx1ZTp2YWx1ZX0pO1xuICAgIH1cblxuICAgIGxldCBtZSA9IHRoaXM7XG4gICAgY2hlY2tib3gub25jaGFuZ2UgPSBmdW5jdGlvbigpIHttZS5fdXBkYXRlKHRoaXMudmFsdWUsIHBhdGgpfTtcblxuICAgIGxldCBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoLTFdLCBwYXRoKTtcbiAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgY2hlY2tib3gpO1xuICB9XG5cblxuICAvKipcbiAgICogbWFrZSBhIGNvbG9yIGZpZWxkIHdpdGggYSBjb2xvciBwaWNrZXIgZm9yIGNvbG9yIGZpZWxkc1xuICAgKiBAcGFyYW0gYXJyXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21ha2VDb2xvckZpZWxkKGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICBsZXQgZGVmYXVsdENvbG9yID0gYXJyWzFdO1xuICAgIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YWx1ZSA9IHZhbHVlID09PSB1bmRlZmluZWQgPyBkZWZhdWx0Q29sb3IgOiB2YWx1ZTtcblxuICAgIGlmICh2YWx1ZSAhPT0gJ25vbmUnKSB7XG4gICAgICBkaXYuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctY29sb3JCbG9jayc7XG4gICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZGl2LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNvbG9yQmxvY2sgbm9uZSc7XG4gICAgfVxuXG4gICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbG9yIDogdmFsdWU7XG4gICAgZGl2Lm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9zaG93Q29sb3JQaWNrZXIodmFsdWUsZGl2LHBhdGgpO1xuICAgIH07XG5cbiAgICBsZXQgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aC0xXSwgcGF0aCk7XG4gICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCxsYWJlbCwgZGl2KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIHVzZWQgYnkgdGhlIGNvbG9yIGJ1dHRvbnMgdG8gY2FsbCB0aGUgY29sb3IgcGlja2VyLlxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwYXJhbSBkaXZcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zaG93Q29sb3JQaWNrZXIodmFsdWUsIGRpdiwgcGF0aCkge1xuICAgIGxldCByZWN0ID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBib2R5UmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHBpY2tlclggPSByZWN0LmxlZnQgKyByZWN0LndpZHRoICsgNTtcbiAgICBsZXQgcGlja2VyWSA9IHJlY3QudG9wIC0gYm9keVJlY3QudG9wICsgcmVjdC5oZWlnaHQgKzI7XG4gICAgdGhpcy5jb2xvclBpY2tlci5zaG93KHBpY2tlclgscGlja2VyWSk7XG4gICAgdGhpcy5jb2xvclBpY2tlci5zZXRDb2xvcih2YWx1ZSk7XG4gICAgdGhpcy5jb2xvclBpY2tlci5zZXRDYWxsYmFjaygoY29sb3IpID0+IHtcbiAgICAgIGxldCBjb2xvclN0cmluZyA9ICdyZ2JhKCcgKyBjb2xvci5yICsgJywnICsgY29sb3IuZyArICcsJyArIGNvbG9yLmIgKyAnLCcgKyBjb2xvci5hICsgJyknO1xuICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yU3RyaW5nO1xuICAgICAgdGhpcy5fdXBkYXRlKGNvbG9yU3RyaW5nLHBhdGgpO1xuICAgIH0pXG4gIH1cblxuXG4gIC8qKlxuICAgKiBwYXJzZSBhbiBvYmplY3QgYW5kIGRyYXcgdGhlIGNvcnJlY3QgaXRlbXNcbiAgICogQHBhcmFtIG9ialxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZU9iamVjdChvYmosIHBhdGggPSBbXSwgY2hlY2tPbmx5ID0gZmFsc2UpIHtcbiAgICBsZXQgc2hvdyA9IGZhbHNlO1xuICAgIGxldCBmaWx0ZXIgPSB0aGlzLm9wdGlvbnMuZmlsdGVyO1xuICAgIGxldCB2aXNpYmxlSW5TZXQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBzdWJPYmogaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHN1Yk9iaikpIHtcbiAgICAgICAgc2hvdyA9IHRydWU7XG4gICAgICAgIGxldCBpdGVtID0gb2JqW3N1Yk9ial07XG4gICAgICAgIGxldCBuZXdQYXRoID0gdXRpbC5jb3B5QW5kRXh0ZW5kQXJyYXkocGF0aCwgc3ViT2JqKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzaG93ID0gZmlsdGVyKHN1Yk9iaixwYXRoKTtcblxuICAgICAgICAgIC8vIGlmIG5lZWRlZCB3ZSBtdXN0IGdvIGRlZXBlciBpbnRvIHRoZSBvYmplY3QuXG4gICAgICAgICAgaWYgKHNob3cgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgQXJyYXkpICYmIHR5cGVvZiBpdGVtICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgaXRlbSAhPT0gJ2Jvb2xlYW4nICYmIGl0ZW0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgIHNob3cgPSB0aGlzLl9oYW5kbGVPYmplY3QoaXRlbSwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGNoZWNrT25seSA9PT0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3cgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdmlzaWJsZUluU2V0ID0gdHJ1ZTtcbiAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLl9nZXRWYWx1ZShuZXdQYXRoKTtcblxuICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUFycmF5KGl0ZW0sIHZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl9tYWtlVGV4dElucHV0KGl0ZW0sIHZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy5fbWFrZUNoZWNrYm94KGl0ZW0sIHZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgLy8gY29sbGFwc2UgdGhlIHBoeXNpY3Mgb3B0aW9ucyB0aGF0IGFyZSBub3QgZW5hYmxlZFxuICAgICAgICAgICAgbGV0IGRyYXcgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHBhdGguaW5kZXhPZigncGh5c2ljcycpICE9PSAtMSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5tb2R1bGVPcHRpb25zLnBoeXNpY3Muc29sdmVyICE9PSBzdWJPYmopIHtcbiAgICAgICAgICAgICAgICBkcmF3ID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRyYXcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgLy8gaW5pdGlhbGx5IGNvbGxhcHNlIG9wdGlvbnMgd2l0aCBhbiBkaXNhYmxlZCBlbmFibGVkIG9wdGlvbi5cbiAgICAgICAgICAgICAgaWYgKGl0ZW0uZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuYWJsZWRQYXRoID0gdXRpbC5jb3B5QW5kRXh0ZW5kQXJyYXkobmV3UGF0aCwgJ2VuYWJsZWQnKTtcbiAgICAgICAgICAgICAgICBsZXQgZW5hYmxlZFZhbHVlID0gdGhpcy5fZ2V0VmFsdWUoZW5hYmxlZFBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChlbmFibGVkVmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChzdWJPYmosIG5ld1BhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZUl0ZW0obmV3UGF0aCwgbGFiZWwpO1xuICAgICAgICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgpIHx8IHZpc2libGVJblNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlQ2hlY2tib3goaXRlbSwgZW5hYmxlZFZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHN1Yk9iaiwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFrZUl0ZW0obmV3UGF0aCwgbGFiZWwpO1xuICAgICAgICAgICAgICAgIHZpc2libGVJblNldCA9IHRoaXMuX2hhbmRsZU9iamVjdChpdGVtLCBuZXdQYXRoKSB8fCB2aXNpYmxlSW5TZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdkb250IGtub3cgaG93IHRvIGhhbmRsZScsIGl0ZW0sIHN1Yk9iaiwgbmV3UGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2aXNpYmxlSW5TZXQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBoYW5kbGUgdGhlIGFycmF5IHR5cGUgb2Ygb3B0aW9uXG4gICAqIEBwYXJhbSBvcHRpb25OYW1lXG4gICAqIEBwYXJhbSBhcnJcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFuZGxlQXJyYXkoYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgIGlmICh0eXBlb2YgYXJyWzBdID09PSAnc3RyaW5nJyAmJiBhcnJbMF0gPT09ICdjb2xvcicpIHtcbiAgICAgIHRoaXMuX21ha2VDb2xvckZpZWxkKGFyciwgdmFsdWUsIHBhdGgpO1xuICAgICAgaWYgKGFyclsxXSAhPT0gdmFsdWUpIHt0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe3BhdGg6cGF0aCwgdmFsdWU6dmFsdWV9KTt9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBhcnJbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9tYWtlRHJvcGRvd24oYXJyLCB2YWx1ZSwgcGF0aCk7XG4gICAgICBpZiAoYXJyWzBdICE9PSB2YWx1ZSkge3RoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7cGF0aDpwYXRoLCB2YWx1ZTp2YWx1ZX0pO31cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGFyclswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuX21ha2VSYW5nZShhcnIsIHZhbHVlLCBwYXRoKTtcbiAgICAgIGlmIChhcnJbMF0gIT09IHZhbHVlKSB7dGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtwYXRoOnBhdGgsIHZhbHVlOk51bWJlcih2YWx1ZSl9KTt9XG4gICAgfVxuICB9XG5cblxuXG4gIC8qKlxuICAgKiBjYWxsZWQgdG8gdXBkYXRlIHRoZSBuZXR3b3JrIHdpdGggdGhlIG5ldyBzZXR0aW5ncy5cbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlKHZhbHVlLCBwYXRoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB0aGlzLl9jb25zdHJ1Y3RPcHRpb25zKHZhbHVlLHBhdGgpO1xuXG4gICAgaWYgKHRoaXMucGFyZW50LmJvZHkgJiYgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyICYmIHRoaXMucGFyZW50LmJvZHkuZW1pdHRlci5lbWl0KSB7XG4gICAgICB0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXIuZW1pdChcImNvbmZpZ0NoYW5nZVwiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5wYXJlbnQuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIF9jb25zdHJ1Y3RPcHRpb25zKHZhbHVlLCBwYXRoLCBvcHRpb25zT2JqID0ge30pIHtcbiAgICBsZXQgcG9pbnRlciA9IG9wdGlvbnNPYmo7XG5cbiAgICAvLyB3aGVuIGRyb3Bkb3duIGJveGVzIGNhbiBiZSBzdHJpbmcgb3IgYm9vbGVhbiwgd2UgdHlwZWNhc3QgaXQgaW50byBjb3JyZWN0IHR5cGVzXG4gICAgdmFsdWUgPSB2YWx1ZSA9PT0gJ3RydWUnICA/IHRydWUgIDogdmFsdWU7XG4gICAgdmFsdWUgPSB2YWx1ZSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdmFsdWU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwYXRoW2ldICE9PSAnZ2xvYmFsJykge1xuICAgICAgICBpZiAocG9pbnRlcltwYXRoW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcG9pbnRlcltwYXRoW2ldXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpICE9PSBwYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBwb2ludGVyID0gcG9pbnRlcltwYXRoW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBwb2ludGVyW3BhdGhbaV1dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnNPYmo7XG5cbiAgfVxuXG4gIF9wcmludE9wdGlvbnMoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICB0aGlzLm9wdGlvbnNDb250YWluZXIuaW5uZXJIVE1MID0gJzxwcmU+dmFyIG9wdGlvbnMgPSAnICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucywgbnVsbCwgMikgKyAnPC9wcmU+JztcbiAgfVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hhbmdlZE9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2NvbnN0cnVjdE9wdGlvbnModGhpcy5jaGFuZ2VkT3B0aW9uc1tpXS52YWx1ZSwgdGhpcy5jaGFuZ2VkT3B0aW9uc1tpXS5wYXRoLCBvcHRpb25zKVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ3VyYXRvcjsiXX0=
},{"../util":46,"./ColorPicker":23}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var util = require('../util');

var errorFound = false;
var allOptions = undefined;
var printStyle = 'background: #FFeeee; color: #dd0000';
/**
 *  Used to validate options.
 */

var Validator = (function () {
  function Validator() {
    _classCallCheck(this, Validator);
  }

  /**
   * Main function to be called
   * @param options
   * @param subObject
   * @returns {boolean}
   */

  _createClass(Validator, null, [{
    key: 'validate',
    value: function validate(options, referenceOptions, subObject) {
      errorFound = false;
      allOptions = referenceOptions;
      var usedOptions = referenceOptions;
      if (subObject !== undefined) {
        usedOptions = referenceOptions[subObject];
      }
      Validator.parse(options, usedOptions, []);
      return errorFound;
    }

    /**
     * Will traverse an object recursively and check every value
     * @param options
     * @param referenceOptions
     * @param path
     */
  }, {
    key: 'parse',
    value: function parse(options, referenceOptions, path) {
      for (var option in options) {
        if (options.hasOwnProperty(option)) {
          Validator.check(option, options, referenceOptions, path);
        }
      }
    }

    /**
     * Check every value. If the value is an object, call the parse function on that object.
     * @param option
     * @param options
     * @param referenceOptions
     * @param path
     */
  }, {
    key: 'check',
    value: function check(option, options, referenceOptions, path) {
      if (referenceOptions[option] === undefined && referenceOptions.__any__ === undefined) {
        Validator.getSuggestion(option, referenceOptions, path);
      } else if (referenceOptions[option] === undefined && referenceOptions.__any__ !== undefined) {
        // __any__ is a wildcard. Any value is accepted and will be further analysed by reference.
        if (Validator.getType(options[option]) === 'object' && referenceOptions['__any__'].__type__ !== undefined) {
          // if the any subgroup is not a predefined object int he configurator we do not look deeper into the object.
          Validator.checkFields(option, options, referenceOptions, '__any__', referenceOptions['__any__'].__type__, path);
        } else {
          Validator.checkFields(option, options, referenceOptions, '__any__', referenceOptions['__any__'], path);
        }
      } else {
        // Since all options in the reference are objects, we can check whether they are supposed to be object to look for the __type__ field.
        if (referenceOptions[option].__type__ !== undefined) {
          // if this should be an object, we check if the correct type has been supplied to account for shorthand options.
          Validator.checkFields(option, options, referenceOptions, option, referenceOptions[option].__type__, path);
        } else {
          Validator.checkFields(option, options, referenceOptions, option, referenceOptions[option], path);
        }
      }
    }

    /**
     *
     * @param {String}  option     | the option property
     * @param {Object}  options    | The supplied options object
     * @param {Object}  referenceOptions    | The reference options containing all options and their allowed formats
     * @param {String}  referenceOption     | Usually this is the same as option, except when handling an __any__ tag.
     * @param {String}  refOptionType       | This is the type object from the reference options
     * @param {Array}   path      | where in the object is the option
     */
  }, {
    key: 'checkFields',
    value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {
      var optionType = Validator.getType(options[option]);
      var refOptionType = refOptionObj[optionType];
      if (refOptionType !== undefined) {
        // if the type is correct, we check if it is supposed to be one of a few select values
        if (Validator.getType(refOptionType) === 'array') {
          if (refOptionType.indexOf(options[option]) === -1) {
            console.log('%cInvalid option detected in "' + option + '".' + ' Allowed values are:' + Validator.print(refOptionType) + ' not "' + options[option] + '". ' + Validator.printLocation(path, option), printStyle);
            errorFound = true;
          } else if (optionType === 'object' && referenceOption !== "__any__") {
            path = util.copyAndExtendArray(path, option);
            Validator.parse(options[option], referenceOptions[referenceOption], path);
          }
        } else if (optionType === 'object' && referenceOption !== "__any__") {
          path = util.copyAndExtendArray(path, option);
          Validator.parse(options[option], referenceOptions[referenceOption], path);
        }
      } else if (refOptionObj['any'] === undefined) {
        // type of the field is incorrect and the field cannot be any
        console.log('%cInvalid type received for "' + option + '". Expected: ' + Validator.print(Object.keys(refOptionObj)) + '. Received [' + optionType + '] "' + options[option] + '"' + Validator.printLocation(path, option), printStyle);
        errorFound = true;
      }
    }
  }, {
    key: 'getType',
    value: function getType(object) {
      var type = typeof object;

      if (type === 'object') {
        if (object === null) {
          return 'null';
        }
        if (object instanceof Boolean) {
          return 'boolean';
        }
        if (object instanceof Number) {
          return 'number';
        }
        if (object instanceof String) {
          return 'string';
        }
        if (Array.isArray(object)) {
          return 'array';
        }
        if (object instanceof Date) {
          return 'date';
        }
        if (object.nodeType !== undefined) {
          return 'dom';
        }
        if (object._isAMomentObject === true) {
          return 'moment';
        }
        return 'object';
      } else if (type === 'number') {
        return 'number';
      } else if (type === 'boolean') {
        return 'boolean';
      } else if (type === 'string') {
        return 'string';
      } else if (type === undefined) {
        return 'undefined';
      }
      return type;
    }
  }, {
    key: 'getSuggestion',
    value: function getSuggestion(option, options, path) {
      var localSearch = Validator.findInOptions(option, options, path, false);
      var globalSearch = Validator.findInOptions(option, allOptions, [], true);

      var localSearchThreshold = 8;
      var globalSearchThreshold = 4;

      if (localSearch.indexMatch !== undefined) {
        console.log('%cUnknown option detected: "' + option + '" in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n', printStyle);
      } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
        console.log('%cUnknown option detected: "' + option + '" in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was misplaced? Matching option found at: ' + Validator.printLocation(globalSearch.path, globalSearch.closestMatch, ''), printStyle);
      } else if (localSearch.distance <= localSearchThreshold) {
        console.log('%cUnknown option detected: "' + option + '". Did you mean "' + localSearch.closestMatch + '"?' + Validator.printLocation(localSearch.path, option), printStyle);
      } else {
        console.log('%cUnknown option detected: "' + option + '". Did you mean one of these: ' + Validator.print(Object.keys(options)) + Validator.printLocation(path, option), printStyle);
      }

      errorFound = true;
    }

    /**
     * traverse the options in search for a match.
     * @param option
     * @param options
     * @param path
     * @param recursive
     * @returns {{closestMatch: string, path: Array, distance: number}}
     */
  }, {
    key: 'findInOptions',
    value: function findInOptions(option, options, path) {
      var recursive = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

      var min = 1e9;
      var closestMatch = '';
      var closestMatchPath = [];
      var lowerCaseOption = option.toLowerCase();
      var indexMatch = undefined;
      for (var op in options) {
        var distance = undefined;
        if (options[op].__type__ !== undefined && recursive === true) {
          var result = Validator.findInOptions(option, options[op], util.copyAndExtendArray(path, op));
          if (min > result.distance) {
            closestMatch = result.closestMatch;
            closestMatchPath = result.path;
            min = result.distance;
            indexMatch = result.indexMatch;
          }
        } else {
          if (op.toLowerCase().indexOf(lowerCaseOption) !== -1) {
            indexMatch = op;
          }
          distance = Validator.levenshteinDistance(option, op);
          if (min > distance) {
            closestMatch = op;
            closestMatchPath = util.copyArray(path);
            min = distance;
          }
        }
      }
      return { closestMatch: closestMatch, path: closestMatchPath, distance: min, indexMatch: indexMatch };
    }
  }, {
    key: 'printLocation',
    value: function printLocation(path, option) {
      var prefix = arguments.length <= 2 || arguments[2] === undefined ? 'Problem value found at: \n' : arguments[2];

      var str = '\n\n' + prefix + 'options = {\n';
      for (var i = 0; i < path.length; i++) {
        for (var j = 0; j < i + 1; j++) {
          str += '  ';
        }
        str += path[i] + ': {\n';
      }
      for (var j = 0; j < path.length + 1; j++) {
        str += '  ';
      }
      str += option + '\n';
      for (var i = 0; i < path.length + 1; i++) {
        for (var j = 0; j < path.length - i; j++) {
          str += '  ';
        }
        str += '}\n';
      }
      return str + '\n\n';
    }
  }, {
    key: 'print',
    value: function print(options) {
      return JSON.stringify(options).replace(/(\")|(\[)|(\])|(,"__type__")/g, "").replace(/(\,)/g, ', ');
    }

    // Compute the edit distance between the two given strings
    // http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
    /*
     Copyright (c) 2011 Andrei Mackenzie
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
  }, {
    key: 'levenshteinDistance',
    value: function levenshteinDistance(a, b) {
      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;

      var matrix = [];

      // increment along the first column of each row
      var i;
      for (i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      }

      // increment each column in the first row
      var j;
      for (j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      }

      // Fill in the rest of the matrix
      for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) == a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
            Math.min(matrix[i][j - 1] + 1, // insertion
            matrix[i - 1][j] + 1)); // deletion
          }
        }
      }

      return matrix[b.length][a.length];
    }
  }]);

  return Validator;
})();

exports['default'] = Validator;
exports.printStyle = printStyle;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvc2hhcmVkL1ZhbGlkYXRvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDOztBQUU5QixJQUFJLFVBQVUsR0FBRyxLQUFLLENBQUM7QUFDdkIsSUFBSSxVQUFVLFlBQUEsQ0FBQztBQUNmLElBQUksVUFBVSxHQUFHLHFDQUFxQyxDQUFDOzs7OztJQUlqRCxTQUFTO0FBQ0YsV0FEUCxTQUFTLEdBQ0M7MEJBRFYsU0FBUztHQUVaOzs7Ozs7Ozs7ZUFGRyxTQUFTOztXQVVFLGtCQUFDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxTQUFTLEVBQUU7QUFDcEQsZ0JBQVUsR0FBRyxLQUFLLENBQUM7QUFDbkIsZ0JBQVUsR0FBRyxnQkFBZ0IsQ0FBQztBQUM5QixVQUFJLFdBQVcsR0FBRyxnQkFBZ0IsQ0FBQztBQUNuQyxVQUFJLFNBQVMsS0FBSyxTQUFTLEVBQUU7QUFDM0IsbUJBQVcsR0FBRyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztPQUMzQztBQUNELGVBQVMsQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLFdBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUMxQyxhQUFPLFVBQVUsQ0FBQztLQUNuQjs7Ozs7Ozs7OztXQVNXLGVBQUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLElBQUksRUFBRTtBQUM1QyxXQUFLLElBQUksTUFBTSxJQUFJLE9BQU8sRUFBRTtBQUMxQixZQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLEVBQUU7QUFDbEMsbUJBQVMsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUMxRDtPQUNGO0tBQ0Y7Ozs7Ozs7Ozs7O1dBVVcsZUFB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QUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDOUIsY0FBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtBQUN0QyxrQkFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1dBQ3JDLE1BQU07QUFDTCxrQkFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUM5QyxnQkFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDM0Isa0JBQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztXQUM1QjtTQUNGO09BQ0Y7O0FBRUQsYUFBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUNuQzs7O1NBN1JHLFNBQVM7OztxQkFtU0EsU0FBUztRQUNoQixVQUFVLEdBQVYsVUFBVSIsImZpbGUiOiIvVXNlcnMvZGFyaW4vRGV2ZWxvcG1lbnQvbWFwc3Rvcnkvc3RvcnktdG9vbHMtdmlld2VyL25vZGVfbW9kdWxlcy92aXMvbGliL3NoYXJlZC9WYWxpZGF0b3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxubGV0IGVycm9yRm91bmQgPSBmYWxzZTtcbmxldCBhbGxPcHRpb25zO1xubGV0IHByaW50U3R5bGUgPSAnYmFja2dyb3VuZDogI0ZGZWVlZTsgY29sb3I6ICNkZDAwMDAnO1xuLyoqXG4gKiAgVXNlZCB0byB2YWxpZGF0ZSBvcHRpb25zLlxuICovXG5jbGFzcyBWYWxpZGF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWluIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcGFyYW0gc3ViT2JqZWN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlKG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHN1Yk9iamVjdCkge1xuICAgIGVycm9yRm91bmQgPSBmYWxzZTtcbiAgICBhbGxPcHRpb25zID0gcmVmZXJlbmNlT3B0aW9ucztcbiAgICBsZXQgdXNlZE9wdGlvbnMgPSByZWZlcmVuY2VPcHRpb25zO1xuICAgIGlmIChzdWJPYmplY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdXNlZE9wdGlvbnMgPSByZWZlcmVuY2VPcHRpb25zW3N1Yk9iamVjdF07XG4gICAgfVxuICAgIFZhbGlkYXRvci5wYXJzZShvcHRpb25zLCB1c2VkT3B0aW9ucywgW10pO1xuICAgIHJldHVybiBlcnJvckZvdW5kO1xuICB9XG5cblxuICAvKipcbiAgICogV2lsbCB0cmF2ZXJzZSBhbiBvYmplY3QgcmVjdXJzaXZlbHkgYW5kIGNoZWNrIGV2ZXJ5IHZhbHVlXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBwYXJhbSByZWZlcmVuY2VPcHRpb25zXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqL1xuICBzdGF0aWMgcGFyc2Uob3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCkge1xuICAgIGZvciAobGV0IG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICAgIFZhbGlkYXRvci5jaGVjayhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIENoZWNrIGV2ZXJ5IHZhbHVlLiBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0LCBjYWxsIHRoZSBwYXJzZSBmdW5jdGlvbiBvbiB0aGF0IG9iamVjdC5cbiAgICogQHBhcmFtIG9wdGlvblxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcGFyYW0gcmVmZXJlbmNlT3B0aW9uc1xuICAgKiBAcGFyYW0gcGF0aFxuICAgKi9cbiAgc3RhdGljIGNoZWNrKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCkge1xuICAgIGlmIChyZWZlcmVuY2VPcHRpb25zW29wdGlvbl0gPT09IHVuZGVmaW5lZCAmJiByZWZlcmVuY2VPcHRpb25zLl9fYW55X18gPT09IHVuZGVmaW5lZCkge1xuICAgICAgVmFsaWRhdG9yLmdldFN1Z2dlc3Rpb24ob3B0aW9uLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dID09PSB1bmRlZmluZWQgJiYgcmVmZXJlbmNlT3B0aW9ucy5fX2FueV9fICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIF9fYW55X18gaXMgYSB3aWxkY2FyZC4gQW55IHZhbHVlIGlzIGFjY2VwdGVkIGFuZCB3aWxsIGJlIGZ1cnRoZXIgYW5hbHlzZWQgYnkgcmVmZXJlbmNlLlxuICAgICAgaWYgKFZhbGlkYXRvci5nZXRUeXBlKG9wdGlvbnNbb3B0aW9uXSkgPT09ICdvYmplY3QnICYmIHJlZmVyZW5jZU9wdGlvbnNbJ19fYW55X18nXS5fX3R5cGVfXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGlmIHRoZSBhbnkgc3ViZ3JvdXAgaXMgbm90IGEgcHJlZGVmaW5lZCBvYmplY3QgaW50IGhlIGNvbmZpZ3VyYXRvciB3ZSBkbyBub3QgbG9vayBkZWVwZXIgaW50byB0aGUgb2JqZWN0LlxuICAgICAgICBWYWxpZGF0b3IuY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCAnX19hbnlfXycsIHJlZmVyZW5jZU9wdGlvbnNbJ19fYW55X18nXS5fX3R5cGVfXywgcGF0aCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgVmFsaWRhdG9yLmNoZWNrRmllbGRzKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgJ19fYW55X18nLCByZWZlcmVuY2VPcHRpb25zWydfX2FueV9fJ10sIHBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIFNpbmNlIGFsbCBvcHRpb25zIGluIHRoZSByZWZlcmVuY2UgYXJlIG9iamVjdHMsIHdlIGNhbiBjaGVjayB3aGV0aGVyIHRoZXkgYXJlIHN1cHBvc2VkIHRvIGJlIG9iamVjdCB0byBsb29rIGZvciB0aGUgX190eXBlX18gZmllbGQuXG4gICAgICBpZiAocmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dLl9fdHlwZV9fICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gaWYgdGhpcyBzaG91bGQgYmUgYW4gb2JqZWN0LCB3ZSBjaGVjayBpZiB0aGUgY29ycmVjdCB0eXBlIGhhcyBiZWVuIHN1cHBsaWVkIHRvIGFjY291bnQgZm9yIHNob3J0aGFuZCBvcHRpb25zLlxuICAgICAgICBWYWxpZGF0b3IuY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBvcHRpb24sIHJlZmVyZW5jZU9wdGlvbnNbb3B0aW9uXS5fX3R5cGVfXywgcGF0aCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgVmFsaWRhdG9yLmNoZWNrRmllbGRzKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgb3B0aW9uLCByZWZlcmVuY2VPcHRpb25zW29wdGlvbl0sIHBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gIG9wdGlvbiAgICAgfCB0aGUgb3B0aW9uIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgb3B0aW9ucyAgICB8IFRoZSBzdXBwbGllZCBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gIHJlZmVyZW5jZU9wdGlvbnMgICAgfCBUaGUgcmVmZXJlbmNlIG9wdGlvbnMgY29udGFpbmluZyBhbGwgb3B0aW9ucyBhbmQgdGhlaXIgYWxsb3dlZCBmb3JtYXRzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAgcmVmZXJlbmNlT3B0aW9uICAgICB8IFVzdWFsbHkgdGhpcyBpcyB0aGUgc2FtZSBhcyBvcHRpb24sIGV4Y2VwdCB3aGVuIGhhbmRsaW5nIGFuIF9fYW55X18gdGFnLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gIHJlZk9wdGlvblR5cGUgICAgICAgfCBUaGlzIGlzIHRoZSB0eXBlIG9iamVjdCBmcm9tIHRoZSByZWZlcmVuY2Ugb3B0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fSAgIHBhdGggICAgICB8IHdoZXJlIGluIHRoZSBvYmplY3QgaXMgdGhlIG9wdGlvblxuICAgKi9cbiAgc3RhdGljIGNoZWNrRmllbGRzKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcmVmZXJlbmNlT3B0aW9uLCByZWZPcHRpb25PYmosIHBhdGgpIHtcbiAgICBsZXQgb3B0aW9uVHlwZSA9IFZhbGlkYXRvci5nZXRUeXBlKG9wdGlvbnNbb3B0aW9uXSk7XG4gICAgbGV0IHJlZk9wdGlvblR5cGUgPSByZWZPcHRpb25PYmpbb3B0aW9uVHlwZV07XG4gICAgaWYgKHJlZk9wdGlvblR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgd2UgY2hlY2sgaWYgaXQgaXMgc3VwcG9zZWQgdG8gYmUgb25lIG9mIGEgZmV3IHNlbGVjdCB2YWx1ZXNcbiAgICAgIGlmIChWYWxpZGF0b3IuZ2V0VHlwZShyZWZPcHRpb25UeXBlKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICBpZiAocmVmT3B0aW9uVHlwZS5pbmRleE9mKG9wdGlvbnNbb3B0aW9uXSkgPT09IC0xKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJyVjSW52YWxpZCBvcHRpb24gZGV0ZWN0ZWQgaW4gXCInICsgb3B0aW9uICsgJ1wiLicgK1xuICAgICAgICAgICAgJyBBbGxvd2VkIHZhbHVlcyBhcmU6JyArIFZhbGlkYXRvci5wcmludChyZWZPcHRpb25UeXBlKSArICcgbm90IFwiJyArIG9wdGlvbnNbb3B0aW9uXSArICdcIi4gJyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKHBhdGgsIG9wdGlvbiksIHByaW50U3R5bGUpO1xuICAgICAgICAgIGVycm9yRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvblR5cGUgPT09ICdvYmplY3QnICYmIHJlZmVyZW5jZU9wdGlvbiAhPT0gXCJfX2FueV9fXCIpIHtcbiAgICAgICAgICBwYXRoID0gdXRpbC5jb3B5QW5kRXh0ZW5kQXJyYXkocGF0aCwgb3B0aW9uKTtcbiAgICAgICAgICBWYWxpZGF0b3IucGFyc2Uob3B0aW9uc1tvcHRpb25dLCByZWZlcmVuY2VPcHRpb25zW3JlZmVyZW5jZU9wdGlvbl0sIHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcHRpb25UeXBlID09PSAnb2JqZWN0JyAmJiByZWZlcmVuY2VPcHRpb24gIT09IFwiX19hbnlfX1wiKSB7XG4gICAgICAgIHBhdGggPSB1dGlsLmNvcHlBbmRFeHRlbmRBcnJheShwYXRoLCBvcHRpb24pO1xuICAgICAgICBWYWxpZGF0b3IucGFyc2Uob3B0aW9uc1tvcHRpb25dLCByZWZlcmVuY2VPcHRpb25zW3JlZmVyZW5jZU9wdGlvbl0sIHBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyZWZPcHRpb25PYmpbJ2FueSddID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHR5cGUgb2YgdGhlIGZpZWxkIGlzIGluY29ycmVjdCBhbmQgdGhlIGZpZWxkIGNhbm5vdCBiZSBhbnlcbiAgICAgIGNvbnNvbGUubG9nKCclY0ludmFsaWQgdHlwZSByZWNlaXZlZCBmb3IgXCInICsgb3B0aW9uICsgJ1wiLiBFeHBlY3RlZDogJyArIFZhbGlkYXRvci5wcmludChPYmplY3Qua2V5cyhyZWZPcHRpb25PYmopKSArICcuIFJlY2VpdmVkIFsnICsgb3B0aW9uVHlwZSArICddIFwiJyArIG9wdGlvbnNbb3B0aW9uXSArICdcIicgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24pLCBwcmludFN0eWxlKTtcbiAgICAgIGVycm9yRm91bmQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG5cbiAgc3RhdGljIGdldFR5cGUob2JqZWN0KSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqZWN0O1xuXG4gICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAob2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5ub2RlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAnZG9tJztcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuX2lzQU1vbWVudE9iamVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gJ21vbWVudCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuICdib29sZWFuJztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3RhdGljIGdldFN1Z2dlc3Rpb24ob3B0aW9uLCBvcHRpb25zLCBwYXRoKSB7XG4gICAgbGV0IGxvY2FsU2VhcmNoID0gVmFsaWRhdG9yLmZpbmRJbk9wdGlvbnMob3B0aW9uLG9wdGlvbnMscGF0aCxmYWxzZSk7XG4gICAgbGV0IGdsb2JhbFNlYXJjaCA9IFZhbGlkYXRvci5maW5kSW5PcHRpb25zKG9wdGlvbixhbGxPcHRpb25zLFtdLHRydWUpO1xuXG4gICAgbGV0IGxvY2FsU2VhcmNoVGhyZXNob2xkID0gODtcbiAgICBsZXQgZ2xvYmFsU2VhcmNoVGhyZXNob2xkID0gNDtcblxuICAgIGlmIChsb2NhbFNlYXJjaC5pbmRleE1hdGNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCclY1Vua25vd24gb3B0aW9uIGRldGVjdGVkOiBcIicgKyBvcHRpb24gKyAnXCIgaW4gJyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiwnJykgKyAnUGVyaGFwcyBpdCB3YXMgaW5jb21wbGV0ZT8gRGlkIHlvdSBtZWFuOiBcIicgKyBsb2NhbFNlYXJjaC5pbmRleE1hdGNoICsgJ1wiP1xcblxcbicsIHByaW50U3R5bGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChnbG9iYWxTZWFyY2guZGlzdGFuY2UgPD0gZ2xvYmFsU2VhcmNoVGhyZXNob2xkICYmIGxvY2FsU2VhcmNoLmRpc3RhbmNlID4gZ2xvYmFsU2VhcmNoLmRpc3RhbmNlKSB7XG4gICAgICBjb25zb2xlLmxvZygnJWNVbmtub3duIG9wdGlvbiBkZXRlY3RlZDogXCInICsgb3B0aW9uICsgJ1wiIGluICcgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihsb2NhbFNlYXJjaC5wYXRoLCBvcHRpb24sJycpICsgJ1BlcmhhcHMgaXQgd2FzIG1pc3BsYWNlZD8gTWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGF0OiAnICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24oZ2xvYmFsU2VhcmNoLnBhdGgsIGdsb2JhbFNlYXJjaC5jbG9zZXN0TWF0Y2gsJycpLCBwcmludFN0eWxlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobG9jYWxTZWFyY2guZGlzdGFuY2UgPD0gbG9jYWxTZWFyY2hUaHJlc2hvbGQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCclY1Vua25vd24gb3B0aW9uIGRldGVjdGVkOiBcIicgKyBvcHRpb24gKyAnXCIuIERpZCB5b3UgbWVhbiBcIicgKyBsb2NhbFNlYXJjaC5jbG9zZXN0TWF0Y2ggKyAnXCI/JyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiksIHByaW50U3R5bGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCclY1Vua25vd24gb3B0aW9uIGRldGVjdGVkOiBcIicgKyBvcHRpb24gKyAnXCIuIERpZCB5b3UgbWVhbiBvbmUgb2YgdGhlc2U6ICcgKyBWYWxpZGF0b3IucHJpbnQoT2JqZWN0LmtleXMob3B0aW9ucykpICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKSwgcHJpbnRTdHlsZSk7XG4gICAgfVxuXG4gICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogdHJhdmVyc2UgdGhlIG9wdGlvbnMgaW4gc2VhcmNoIGZvciBhIG1hdGNoLlxuICAgKiBAcGFyYW0gb3B0aW9uXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwYXJhbSByZWN1cnNpdmVcbiAgICogQHJldHVybnMge3tjbG9zZXN0TWF0Y2g6IHN0cmluZywgcGF0aDogQXJyYXksIGRpc3RhbmNlOiBudW1iZXJ9fVxuICAgKi9cbiAgc3RhdGljIGZpbmRJbk9wdGlvbnMob3B0aW9uLCBvcHRpb25zLCBwYXRoLCByZWN1cnNpdmUgPSBmYWxzZSkge1xuICAgIGxldCBtaW4gPSAxZTk7XG4gICAgbGV0IGNsb3Nlc3RNYXRjaCA9ICcnO1xuICAgIGxldCBjbG9zZXN0TWF0Y2hQYXRoID0gW107XG4gICAgbGV0IGxvd2VyQ2FzZU9wdGlvbiA9IG9wdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCBpbmRleE1hdGNoID0gdW5kZWZpbmVkO1xuICAgIGZvciAobGV0IG9wIGluIG9wdGlvbnMpIHtcbiAgICAgIGxldCBkaXN0YW5jZTtcbiAgICAgIGlmIChvcHRpb25zW29wXS5fX3R5cGVfXyAhPT0gdW5kZWZpbmVkICYmIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gVmFsaWRhdG9yLmZpbmRJbk9wdGlvbnMob3B0aW9uLCBvcHRpb25zW29wXSwgdXRpbC5jb3B5QW5kRXh0ZW5kQXJyYXkocGF0aCxvcCkpO1xuICAgICAgICBpZiAobWluID4gcmVzdWx0LmRpc3RhbmNlKSB7XG4gICAgICAgICAgY2xvc2VzdE1hdGNoID0gcmVzdWx0LmNsb3Nlc3RNYXRjaDtcbiAgICAgICAgICBjbG9zZXN0TWF0Y2hQYXRoID0gcmVzdWx0LnBhdGg7XG4gICAgICAgICAgbWluID0gcmVzdWx0LmRpc3RhbmNlO1xuICAgICAgICAgIGluZGV4TWF0Y2ggPSByZXN1bHQuaW5kZXhNYXRjaDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChvcC50b0xvd2VyQ2FzZSgpLmluZGV4T2YobG93ZXJDYXNlT3B0aW9uKSAhPT0gLTEpIHtcbiAgICAgICAgICBpbmRleE1hdGNoID0gb3A7XG4gICAgICAgIH1cbiAgICAgICAgZGlzdGFuY2UgPSBWYWxpZGF0b3IubGV2ZW5zaHRlaW5EaXN0YW5jZShvcHRpb24sIG9wKTtcbiAgICAgICAgaWYgKG1pbiA+IGRpc3RhbmNlKSB7XG4gICAgICAgICAgY2xvc2VzdE1hdGNoID0gb3A7XG4gICAgICAgICAgY2xvc2VzdE1hdGNoUGF0aCA9IHV0aWwuY29weUFycmF5KHBhdGgpO1xuICAgICAgICAgIG1pbiA9IGRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7Y2xvc2VzdE1hdGNoOmNsb3Nlc3RNYXRjaCwgcGF0aDpjbG9zZXN0TWF0Y2hQYXRoLCBkaXN0YW5jZTptaW4sIGluZGV4TWF0Y2g6IGluZGV4TWF0Y2h9O1xuICB9XG5cbiAgc3RhdGljIHByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uLCBwcmVmaXggPSAnUHJvYmxlbSB2YWx1ZSBmb3VuZCBhdDogXFxuJykge1xuICAgIGxldCBzdHIgPSAnXFxuXFxuJyArIHByZWZpeCArICdvcHRpb25zID0ge1xcbic7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGkgKyAxOyBqKyspIHtcbiAgICAgICAgc3RyICs9ICcgICc7XG4gICAgICB9XG4gICAgICBzdHIgKz0gcGF0aFtpXSArICc6IHtcXG4nXG4gICAgfVxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGF0aC5sZW5ndGggKyAxOyBqKyspIHtcbiAgICAgIHN0ciArPSAnICAnO1xuICAgIH1cbiAgICBzdHIgKz0gb3B0aW9uICsgJ1xcbic7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCArIDE7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXRoLmxlbmd0aCAtIGk7IGorKykge1xuICAgICAgICBzdHIgKz0gJyAgJztcbiAgICAgIH1cbiAgICAgIHN0ciArPSAnfVxcbidcbiAgICB9XG4gICAgcmV0dXJuIHN0ciArICdcXG5cXG4nO1xuICB9XG5cbiAgc3RhdGljIHByaW50KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob3B0aW9ucykucmVwbGFjZSgvKFxcXCIpfChcXFspfChcXF0pfCgsXCJfX3R5cGVfX1wiKS9nLCBcIlwiKS5yZXBsYWNlKC8oXFwsKS9nLCAnLCAnKVxuICB9XG5cblxuICAvLyBDb21wdXRlIHRoZSBlZGl0IGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBnaXZlbiBzdHJpbmdzXG4gIC8vIGh0dHA6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQWxnb3JpdGhtX0ltcGxlbWVudGF0aW9uL1N0cmluZ3MvTGV2ZW5zaHRlaW5fZGlzdGFuY2UjSmF2YVNjcmlwdFxuICAvKlxuICAgQ29weXJpZ2h0IChjKSAyMDExIEFuZHJlaSBNYWNrZW56aWVcblxuICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICAgKi9cbiAgc3RhdGljIGxldmVuc2h0ZWluRGlzdGFuY2UoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGIubGVuZ3RoO1xuICAgIGlmIChiLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGEubGVuZ3RoO1xuXG4gICAgdmFyIG1hdHJpeCA9IFtdO1xuXG4gICAgLy8gaW5jcmVtZW50IGFsb25nIHRoZSBmaXJzdCBjb2x1bW4gb2YgZWFjaCByb3dcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDw9IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hdHJpeFtpXSA9IFtpXTtcbiAgICB9XG5cbiAgICAvLyBpbmNyZW1lbnQgZWFjaCBjb2x1bW4gaW4gdGhlIGZpcnN0IHJvd1xuICAgIHZhciBqO1xuICAgIGZvciAoaiA9IDA7IGogPD0gYS5sZW5ndGg7IGorKykge1xuICAgICAgbWF0cml4WzBdW2pdID0gajtcbiAgICB9XG5cbiAgICAvLyBGaWxsIGluIHRoZSByZXN0IG9mIHRoZSBtYXRyaXhcbiAgICBmb3IgKGkgPSAxOyBpIDw9IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAoaiA9IDE7IGogPD0gYS5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoYi5jaGFyQXQoaSAtIDEpID09IGEuY2hhckF0KGogLSAxKSkge1xuICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IG1hdHJpeFtpIC0gMV1baiAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IE1hdGgubWluKG1hdHJpeFtpIC0gMV1baiAtIDFdICsgMSwgLy8gc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICBNYXRoLm1pbihtYXRyaXhbaV1baiAtIDFdICsgMSwgLy8gaW5zZXJ0aW9uXG4gICAgICAgICAgICAgIG1hdHJpeFtpIC0gMV1bal0gKyAxKSk7IC8vIGRlbGV0aW9uXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0cml4W2IubGVuZ3RoXVthLmxlbmd0aF07XG4gIH1cblxuO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFZhbGlkYXRvcjtcbmV4cG9ydCB7cHJpbnRTdHlsZX0iXX0=
},{"../util":46}],26:[function(require,module,exports){
'use strict';

var Emitter = require('emitter-component');
var Hammer = require('../module/hammer');
var hammerUtil = require('../hammerUtil');
var util = require('../util');
var DataSet = require('../DataSet');
var DataView = require('../DataView');
var Range = require('./Range');
var ItemSet = require('./component/ItemSet');
var TimeAxis = require('./component/TimeAxis');
var Activator = require('../shared/Activator');
var DateUtil = require('./DateUtil');
var CustomTime = require('./component/CustomTime');

/**
 * Create a timeline visualization
 * @constructor
 */
function Core() {}

// turn Core into an event emitter
Emitter(Core.prototype);

/**
 * Create the main DOM for the Core: a root panel containing left, right,
 * top, bottom, content, and background panel.
 * @param {Element} container  The container element where the Core will
 *                             be attached.
 * @protected
 */
Core.prototype._create = function (container) {
  this.dom = {};

  this.dom.container = container;

  this.dom.root = document.createElement('div');
  this.dom.background = document.createElement('div');
  this.dom.backgroundVertical = document.createElement('div');
  this.dom.backgroundHorizontal = document.createElement('div');
  this.dom.centerContainer = document.createElement('div');
  this.dom.leftContainer = document.createElement('div');
  this.dom.rightContainer = document.createElement('div');
  this.dom.center = document.createElement('div');
  this.dom.left = document.createElement('div');
  this.dom.right = document.createElement('div');
  this.dom.top = document.createElement('div');
  this.dom.bottom = document.createElement('div');
  this.dom.shadowTop = document.createElement('div');
  this.dom.shadowBottom = document.createElement('div');
  this.dom.shadowTopLeft = document.createElement('div');
  this.dom.shadowBottomLeft = document.createElement('div');
  this.dom.shadowTopRight = document.createElement('div');
  this.dom.shadowBottomRight = document.createElement('div');

  this.dom.root.className = 'vis-timeline';
  this.dom.background.className = 'vis-panel vis-background';
  this.dom.backgroundVertical.className = 'vis-panel vis-background vis-vertical';
  this.dom.backgroundHorizontal.className = 'vis-panel vis-background vis-horizontal';
  this.dom.centerContainer.className = 'vis-panel vis-center';
  this.dom.leftContainer.className = 'vis-panel vis-left';
  this.dom.rightContainer.className = 'vis-panel vis-right';
  this.dom.top.className = 'vis-panel vis-top';
  this.dom.bottom.className = 'vis-panel vis-bottom';
  this.dom.left.className = 'vis-content';
  this.dom.center.className = 'vis-content';
  this.dom.right.className = 'vis-content';
  this.dom.shadowTop.className = 'vis-shadow vis-top';
  this.dom.shadowBottom.className = 'vis-shadow vis-bottom';
  this.dom.shadowTopLeft.className = 'vis-shadow vis-top';
  this.dom.shadowBottomLeft.className = 'vis-shadow vis-bottom';
  this.dom.shadowTopRight.className = 'vis-shadow vis-top';
  this.dom.shadowBottomRight.className = 'vis-shadow vis-bottom';

  this.dom.root.appendChild(this.dom.background);
  this.dom.root.appendChild(this.dom.backgroundVertical);
  this.dom.root.appendChild(this.dom.backgroundHorizontal);
  this.dom.root.appendChild(this.dom.centerContainer);
  this.dom.root.appendChild(this.dom.leftContainer);
  this.dom.root.appendChild(this.dom.rightContainer);
  this.dom.root.appendChild(this.dom.top);
  this.dom.root.appendChild(this.dom.bottom);

  this.dom.centerContainer.appendChild(this.dom.center);
  this.dom.leftContainer.appendChild(this.dom.left);
  this.dom.rightContainer.appendChild(this.dom.right);

  this.dom.centerContainer.appendChild(this.dom.shadowTop);
  this.dom.centerContainer.appendChild(this.dom.shadowBottom);
  this.dom.leftContainer.appendChild(this.dom.shadowTopLeft);
  this.dom.leftContainer.appendChild(this.dom.shadowBottomLeft);
  this.dom.rightContainer.appendChild(this.dom.shadowTopRight);
  this.dom.rightContainer.appendChild(this.dom.shadowBottomRight);

  this.on('rangechange', (function () {
    this._redraw(); // this allows overriding the _redraw method
  }).bind(this));
  this.on('touch', this._onTouch.bind(this));
  this.on('pan', this._onDrag.bind(this));

  var me = this;
  this.on('change', function (properties) {
    if (properties && properties.queue == true) {
      // redraw once on next tick
      if (!me._redrawTimer) {
        me._redrawTimer = setTimeout(function () {
          me._redrawTimer = null;
          me._redraw();
        }, 0);
      }
    } else {
      // redraw immediately
      me._redraw();
    }
  });

  // create event listeners for all interesting events, these events will be
  // emitted via emitter
  this.hammer = new Hammer(this.dom.root);
  this.hammer.get('pinch').set({ enable: true });
  this.hammer.get('pan').set({ threshold: 5, direction: 30 }); // 30 is ALL_DIRECTIONS in hammer.
  this.listeners = {};

  var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend'
  // TODO: cleanup
  //'touch', 'pinch',
  //'tap', 'doubletap', 'hold',
  //'dragstart', 'drag', 'dragend',
  //'mousewheel', 'DOMMouseScroll' // DOMMouseScroll is needed for Firefox
  ];
  events.forEach(function (type) {
    var listener = function listener(event) {
      if (me.isActive()) {
        me.emit(type, event);
      }
    };
    me.hammer.on(type, listener);
    me.listeners[type] = listener;
  });

  // emulate a touch event (emitted before the start of a pan, pinch, tap, or press)
  hammerUtil.onTouch(this.hammer, (function (event) {
    me.emit('touch', event);
  }).bind(this));

  // emulate a release event (emitted after a pan, pinch, tap, or press)
  hammerUtil.onRelease(this.hammer, (function (event) {
    me.emit('release', event);
  }).bind(this));

  function onMouseWheel(event) {
    if (me.isActive()) {
      me.emit('mousewheel', event);
    }
  }
  this.dom.root.addEventListener('mousewheel', onMouseWheel);
  this.dom.root.addEventListener('DOMMouseScroll', onMouseWheel);

  // size properties of each of the panels
  this.props = {
    root: {},
    background: {},
    centerContainer: {},
    leftContainer: {},
    rightContainer: {},
    center: {},
    left: {},
    right: {},
    top: {},
    bottom: {},
    border: {},
    scrollTop: 0,
    scrollTopMin: 0
  };

  this.customTimes = [];

  // store state information needed for touch events
  this.touch = {};

  this.redrawCount = 0;

  // attach the root panel to the provided container
  if (!container) throw new Error('No container provided');
  container.appendChild(this.dom.root);
};

/**
 * Set options. Options will be passed to all components loaded in the Timeline.
 * @param {Object} [options]
 *                           {String} orientation
 *                              Vertical orientation for the Timeline,
 *                              can be 'bottom' (default) or 'top'.
 *                           {String | Number} width
 *                              Width for the timeline, a number in pixels or
 *                              a css string like '1000px' or '75%'. '100%' by default.
 *                           {String | Number} height
 *                              Fixed height for the Timeline, a number in pixels or
 *                              a css string like '400px' or '75%'. If undefined,
 *                              The Timeline will automatically size such that
 *                              its contents fit.
 *                           {String | Number} minHeight
 *                              Minimum height for the Timeline, a number in pixels or
 *                              a css string like '400px' or '75%'.
 *                           {String | Number} maxHeight
 *                              Maximum height for the Timeline, a number in pixels or
 *                              a css string like '400px' or '75%'.
 *                           {Number | Date | String} start
 *                              Start date for the visible window
 *                           {Number | Date | String} end
 *                              End date for the visible window
 */
Core.prototype.setOptions = function (options) {
  if (options) {
    // copy the known options
    var fields = ['width', 'height', 'minHeight', 'maxHeight', 'autoResize', 'start', 'end', 'clickToUse', 'dataAttributes', 'hiddenDates', 'locale', 'locales', 'moment', 'throttleRedraw'];
    util.selectiveExtend(fields, this.options, options);

    if ('orientation' in options) {
      if (typeof options.orientation === 'string') {
        this.options.orientation = {
          item: options.orientation,
          axis: options.orientation
        };
      } else if (typeof options.orientation === 'object') {
        if ('item' in options.orientation) {
          this.options.orientation.item = options.orientation.item;
        }
        if ('axis' in options.orientation) {
          this.options.orientation.axis = options.orientation.axis;
        }
      }
    }

    if (this.options.orientation.axis === 'both') {
      if (!this.timeAxis2) {
        var timeAxis2 = this.timeAxis2 = new TimeAxis(this.body);
        timeAxis2.setOptions = function (options) {
          var _options = options ? util.extend({}, options) : {};
          _options.orientation = 'top'; // override the orientation option, always top
          TimeAxis.prototype.setOptions.call(timeAxis2, _options);
        };
        this.components.push(timeAxis2);
      }
    } else {
      if (this.timeAxis2) {
        var index = this.components.indexOf(this.timeAxis2);
        if (index !== -1) {
          this.components.splice(index, 1);
        }
        this.timeAxis2.destroy();
        this.timeAxis2 = null;
      }
    }

    // if the graph2d's drawPoints is a function delegate the callback to the onRender property
    if (typeof options.drawPoints == 'function') {
      options.drawPoints = {
        onRender: options.drawPoints
      };
    }

    if ('hiddenDates' in this.options) {
      DateUtil.convertHiddenOptions(this.options.moment, this.body, this.options.hiddenDates);
    }

    if ('clickToUse' in options) {
      if (options.clickToUse) {
        if (!this.activator) {
          this.activator = new Activator(this.dom.root);
        }
      } else {
        if (this.activator) {
          this.activator.destroy();
          delete this.activator;
        }
      }
    }

    if ('showCustomTime' in options) {
      throw new Error('Option `showCustomTime` is deprecated. Create a custom time bar via timeline.addCustomTime(time [, id])');
    }

    // enable/disable autoResize
    this._initAutoResize();
  }

  // propagate options to all components
  this.components.forEach(function (component) {
    return component.setOptions(options);
  });

  // enable/disable configure
  if ('configure' in options) {
    if (!this.configurator) {
      this.configurator = this._createConfigurator();
    }

    this.configurator.setOptions(options.configure);

    // collect the settings of all components, and pass them to the configuration system
    var appliedOptions = util.deepExtend({}, this.options);
    this.components.forEach(function (component) {
      util.deepExtend(appliedOptions, component.options);
    });
    this.configurator.setModuleOptions({ global: appliedOptions });
  }

  // override redraw with a throttled version
  if (!this._origRedraw) {
    this._origRedraw = this._redraw.bind(this);
  }
  this._redraw = util.throttle(this._origRedraw, this.options.throttleRedraw);

  // redraw everything
  this._redraw();
};

/**
 * Returns true when the Timeline is active.
 * @returns {boolean}
 */
Core.prototype.isActive = function () {
  return !this.activator || this.activator.active;
};

/**
 * Destroy the Core, clean up all DOM elements and event listeners.
 */
Core.prototype.destroy = function () {
  // unbind datasets
  this.setItems(null);
  this.setGroups(null);

  // remove all event listeners
  this.off();

  // stop checking for changed size
  this._stopAutoResize();

  // remove from DOM
  if (this.dom.root.parentNode) {
    this.dom.root.parentNode.removeChild(this.dom.root);
  }
  this.dom = null;

  // remove Activator
  if (this.activator) {
    this.activator.destroy();
    delete this.activator;
  }

  // cleanup hammer touch events
  for (var event in this.listeners) {
    if (this.listeners.hasOwnProperty(event)) {
      delete this.listeners[event];
    }
  }
  this.listeners = null;
  this.hammer = null;

  // give all components the opportunity to cleanup
  this.components.forEach(function (component) {
    return component.destroy();
  });

  this.body = null;
};

/**
 * Set a custom time bar
 * @param {Date} time
 * @param {number} [id=undefined] Optional id of the custom time bar to be adjusted.
 */
Core.prototype.setCustomTime = function (time, id) {
  var customTimes = this.customTimes.filter(function (component) {
    return id === component.options.id;
  });

  if (customTimes.length === 0) {
    throw new Error('No custom time bar found with id ' + JSON.stringify(id));
  }

  if (customTimes.length > 0) {
    customTimes[0].setCustomTime(time);
  }
};

/**
 * Retrieve the current custom time.
 * @param {number} [id=undefined]    Id of the custom time bar.
 * @return {Date | undefined} customTime
 */
Core.prototype.getCustomTime = function (id) {
  var customTimes = this.customTimes.filter(function (component) {
    return component.options.id === id;
  });

  if (customTimes.length === 0) {
    throw new Error('No custom time bar found with id ' + JSON.stringify(id));
  }
  return customTimes[0].getCustomTime();
};

/**
 * Set a custom title for the custom time bar.
 * @param {String} [title] Custom title
 * @param {number} [id=undefined]    Id of the custom time bar.
 */
Core.prototype.setCustomTimeTitle = function (title, id) {
  var customTimes = this.customTimes.filter(function (component) {
    return component.options.id === id;
  });

  if (customTimes.length === 0) {
    throw new Error('No custom time bar found with id ' + JSON.stringify(id));
  }
  if (customTimes.length > 0) {
    return customTimes[0].setCustomTitle(title);
  }
};

/**
 * Retrieve meta information from an event.
 * Should be overridden by classes extending Core
 * @param {Event} event
 * @return {Object} An object with related information.
 */
Core.prototype.getEventProperties = function (event) {
  return { event: event };
};

/**
 * Add custom vertical bar
 * @param {Date | String | Number} [time]  A Date, unix timestamp, or
 *                                         ISO date string. Time point where
 *                                         the new bar should be placed.
 *                                         If not provided, `new Date()` will
 *                                         be used.
 * @param {Number | String} [id=undefined] Id of the new bar. Optional
 * @return {Number | String}               Returns the id of the new bar
 */
Core.prototype.addCustomTime = function (time, id) {
  var timestamp = time !== undefined ? util.convert(time, 'Date').valueOf() : new Date();

  var exists = this.customTimes.some(function (customTime) {
    return customTime.options.id === id;
  });
  if (exists) {
    throw new Error('A custom time with id ' + JSON.stringify(id) + ' already exists');
  }

  var customTime = new CustomTime(this.body, util.extend({}, this.options, {
    time: timestamp,
    id: id
  }));

  this.customTimes.push(customTime);
  this.components.push(customTime);
  this._redraw();

  return id;
};

/**
 * Remove previously added custom bar
 * @param {int} id ID of the custom bar to be removed
 * @return {boolean} True if the bar exists and is removed, false otherwise
 */
Core.prototype.removeCustomTime = function (id) {
  var customTimes = this.customTimes.filter(function (bar) {
    return bar.options.id === id;
  });

  if (customTimes.length === 0) {
    throw new Error('No custom time bar found with id ' + JSON.stringify(id));
  }

  customTimes.forEach((function (customTime) {
    this.customTimes.splice(this.customTimes.indexOf(customTime), 1);
    this.components.splice(this.components.indexOf(customTime), 1);
    customTime.destroy();
  }).bind(this));
};

/**
 * Get the id's of the currently visible items.
 * @returns {Array} The ids of the visible items
 */
Core.prototype.getVisibleItems = function () {
  return this.itemSet && this.itemSet.getVisibleItems() || [];
};

/**
 * Set Core window such that it fits all items
 * @param {Object} [options]  Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Core.prototype.fit = function (options) {
  var range = this.getDataRange();

  // skip range set if there is no min and max date
  if (range.min === null && range.max === null) {
    return;
  }

  // apply a margin of 1% left and right of the data
  var interval = range.max - range.min;
  var min = new Date(range.min.valueOf() - interval * 0.01);
  var max = new Date(range.max.valueOf() + interval * 0.01);

  var animation = options && options.animation !== undefined ? options.animation : true;
  this.range.setRange(min, max, animation);
};

/**
 * Calculate the data range of the items start and end dates
 * @returns {{min: Date | null, max: Date | null}}
 * @protected
 */
Core.prototype.getDataRange = function () {
  // must be implemented by Timeline and Graph2d
  throw new Error('Cannot invoke abstract method getDataRange');
};

/**
 * Set the visible window. Both parameters are optional, you can change only
 * start or only end. Syntax:
 *
 *     TimeLine.setWindow(start, end)
 *     TimeLine.setWindow(start, end, options)
 *     TimeLine.setWindow(range)
 *
 * Where start and end can be a Date, number, or string, and range is an
 * object with properties start and end.
 *
 * @param {Date | Number | String | Object} [start] Start date of visible window
 * @param {Date | Number | String} [end]            End date of visible window
 * @param {Object} [options]  Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Core.prototype.setWindow = function (start, end, options) {
  var animation;
  if (arguments.length == 1) {
    var range = arguments[0];
    animation = range.animation !== undefined ? range.animation : true;
    this.range.setRange(range.start, range.end, animation);
  } else {
    animation = options && options.animation !== undefined ? options.animation : true;
    this.range.setRange(start, end, animation);
  }
};

/**
 * Move the window such that given time is centered on screen.
 * @param {Date | Number | String} time
 * @param {Object} [options]  Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Core.prototype.moveTo = function (time, options) {
  var interval = this.range.end - this.range.start;
  var t = util.convert(time, 'Date').valueOf();

  var start = t - interval / 2;
  var end = t + interval / 2;
  var animation = options && options.animation !== undefined ? options.animation : true;

  this.range.setRange(start, end, animation);
};

/**
 * Get the visible window
 * @return {{start: Date, end: Date}}   Visible range
 */
Core.prototype.getWindow = function () {
  var range = this.range.getRange();
  return {
    start: new Date(range.start),
    end: new Date(range.end)
  };
};

/**
 * Force a redraw. Can be overridden by implementations of Core
 *
 * Note: this function will be overridden on construction with a trottled version
 */
Core.prototype.redraw = function () {
  this._redraw();
};

/**
 * Redraw for internal use. Redraws all components. See also the public
 * method redraw.
 * @protected
 */
Core.prototype._redraw = function () {
  var resized = false;
  var options = this.options;
  var props = this.props;
  var dom = this.dom;

  if (!dom) return; // when destroyed

  DateUtil.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);

  // update class names
  if (options.orientation == 'top') {
    util.addClassName(dom.root, 'vis-top');
    util.removeClassName(dom.root, 'vis-bottom');
  } else {
    util.removeClassName(dom.root, 'vis-top');
    util.addClassName(dom.root, 'vis-bottom');
  }

  // update root width and height options
  dom.root.style.maxHeight = util.option.asSize(options.maxHeight, '');
  dom.root.style.minHeight = util.option.asSize(options.minHeight, '');
  dom.root.style.width = util.option.asSize(options.width, '');

  // calculate border widths
  props.border.left = (dom.centerContainer.offsetWidth - dom.centerContainer.clientWidth) / 2;
  props.border.right = props.border.left;
  props.border.top = (dom.centerContainer.offsetHeight - dom.centerContainer.clientHeight) / 2;
  props.border.bottom = props.border.top;
  var borderRootHeight = dom.root.offsetHeight - dom.root.clientHeight;
  var borderRootWidth = dom.root.offsetWidth - dom.root.clientWidth;

  // workaround for a bug in IE: the clientWidth of an element with
  // a height:0px and overflow:hidden is not calculated and always has value 0
  if (dom.centerContainer.clientHeight === 0) {
    props.border.left = props.border.top;
    props.border.right = props.border.left;
  }
  if (dom.root.clientHeight === 0) {
    borderRootWidth = borderRootHeight;
  }

  // calculate the heights. If any of the side panels is empty, we set the height to
  // minus the border width, such that the border will be invisible
  props.center.height = dom.center.offsetHeight;
  props.left.height = dom.left.offsetHeight;
  props.right.height = dom.right.offsetHeight;
  props.top.height = dom.top.clientHeight || -props.border.top;
  props.bottom.height = dom.bottom.clientHeight || -props.border.bottom;

  // TODO: compensate borders when any of the panels is empty.

  // apply auto height
  // TODO: only calculate autoHeight when needed (else we cause an extra reflow/repaint of the DOM)
  var contentHeight = Math.max(props.left.height, props.center.height, props.right.height);
  var autoHeight = props.top.height + contentHeight + props.bottom.height + borderRootHeight + props.border.top + props.border.bottom;
  dom.root.style.height = util.option.asSize(options.height, autoHeight + 'px');

  // calculate heights of the content panels
  props.root.height = dom.root.offsetHeight;
  props.background.height = props.root.height - borderRootHeight;
  var containerHeight = props.root.height - props.top.height - props.bottom.height - borderRootHeight;
  props.centerContainer.height = containerHeight;
  props.leftContainer.height = containerHeight;
  props.rightContainer.height = props.leftContainer.height;

  // calculate the widths of the panels
  props.root.width = dom.root.offsetWidth;
  props.background.width = props.root.width - borderRootWidth;
  props.left.width = dom.leftContainer.clientWidth || -props.border.left;
  props.leftContainer.width = props.left.width;
  props.right.width = dom.rightContainer.clientWidth || -props.border.right;
  props.rightContainer.width = props.right.width;
  var centerWidth = props.root.width - props.left.width - props.right.width - borderRootWidth;
  props.center.width = centerWidth;
  props.centerContainer.width = centerWidth;
  props.top.width = centerWidth;
  props.bottom.width = centerWidth;

  // resize the panels
  dom.background.style.height = props.background.height + 'px';
  dom.backgroundVertical.style.height = props.background.height + 'px';
  dom.backgroundHorizontal.style.height = props.centerContainer.height + 'px';
  dom.centerContainer.style.height = props.centerContainer.height + 'px';
  dom.leftContainer.style.height = props.leftContainer.height + 'px';
  dom.rightContainer.style.height = props.rightContainer.height + 'px';

  dom.background.style.width = props.background.width + 'px';
  dom.backgroundVertical.style.width = props.centerContainer.width + 'px';
  dom.backgroundHorizontal.style.width = props.background.width + 'px';
  dom.centerContainer.style.width = props.center.width + 'px';
  dom.top.style.width = props.top.width + 'px';
  dom.bottom.style.width = props.bottom.width + 'px';

  // reposition the panels
  dom.background.style.left = '0';
  dom.background.style.top = '0';
  dom.backgroundVertical.style.left = props.left.width + props.border.left + 'px';
  dom.backgroundVertical.style.top = '0';
  dom.backgroundHorizontal.style.left = '0';
  dom.backgroundHorizontal.style.top = props.top.height + 'px';
  dom.centerContainer.style.left = props.left.width + 'px';
  dom.centerContainer.style.top = props.top.height + 'px';
  dom.leftContainer.style.left = '0';
  dom.leftContainer.style.top = props.top.height + 'px';
  dom.rightContainer.style.left = props.left.width + props.center.width + 'px';
  dom.rightContainer.style.top = props.top.height + 'px';
  dom.top.style.left = props.left.width + 'px';
  dom.top.style.top = '0';
  dom.bottom.style.left = props.left.width + 'px';
  dom.bottom.style.top = props.top.height + props.centerContainer.height + 'px';

  // update the scrollTop, feasible range for the offset can be changed
  // when the height of the Core or of the contents of the center changed
  this._updateScrollTop();

  // reposition the scrollable contents
  var offset = this.props.scrollTop;
  if (options.orientation.item != 'top') {
    offset += Math.max(this.props.centerContainer.height - this.props.center.height - this.props.border.top - this.props.border.bottom, 0);
  }
  dom.center.style.left = '0';
  dom.center.style.top = offset + 'px';
  dom.left.style.left = '0';
  dom.left.style.top = offset + 'px';
  dom.right.style.left = '0';
  dom.right.style.top = offset + 'px';

  // show shadows when vertical scrolling is available
  var visibilityTop = this.props.scrollTop == 0 ? 'hidden' : '';
  var visibilityBottom = this.props.scrollTop == this.props.scrollTopMin ? 'hidden' : '';
  dom.shadowTop.style.visibility = visibilityTop;
  dom.shadowBottom.style.visibility = visibilityBottom;
  dom.shadowTopLeft.style.visibility = visibilityTop;
  dom.shadowBottomLeft.style.visibility = visibilityBottom;
  dom.shadowTopRight.style.visibility = visibilityTop;
  dom.shadowBottomRight.style.visibility = visibilityBottom;

  // redraw all components
  this.components.forEach(function (component) {
    resized = component.redraw() || resized;
  });
  if (resized) {
    // keep repainting until all sizes are settled
    var MAX_REDRAWS = 3; // maximum number of consecutive redraws
    if (this.redrawCount < MAX_REDRAWS) {
      this.redrawCount++;
      this._redraw();
    } else {
      console.log('WARNING: infinite loop in redraw?');
    }
    this.redrawCount = 0;
  }
};

// TODO: deprecated since version 1.1.0, remove some day
Core.prototype.repaint = function () {
  throw new Error('Function repaint is deprecated. Use redraw instead.');
};

/**
 * Set a current time. This can be used for example to ensure that a client's
 * time is synchronized with a shared server time.
 * Only applicable when option `showCurrentTime` is true.
 * @param {Date | String | Number} time     A Date, unix timestamp, or
 *                                          ISO date string.
 */
Core.prototype.setCurrentTime = function (time) {
  if (!this.currentTime) {
    throw new Error('Option showCurrentTime must be true');
  }

  this.currentTime.setCurrentTime(time);
};

/**
 * Get the current time.
 * Only applicable when option `showCurrentTime` is true.
 * @return {Date} Returns the current time.
 */
Core.prototype.getCurrentTime = function () {
  if (!this.currentTime) {
    throw new Error('Option showCurrentTime must be true');
  }

  return this.currentTime.getCurrentTime();
};

/**
 * Convert a position on screen (pixels) to a datetime
 * @param {int}     x    Position on the screen in pixels
 * @return {Date}   time The datetime the corresponds with given position x
 * @protected
 */
// TODO: move this function to Range
Core.prototype._toTime = function (x) {
  return DateUtil.toTime(this, x, this.props.center.width);
};

/**
 * Convert a position on the global screen (pixels) to a datetime
 * @param {int}     x    Position on the screen in pixels
 * @return {Date}   time The datetime the corresponds with given position x
 * @protected
 */
// TODO: move this function to Range
Core.prototype._toGlobalTime = function (x) {
  return DateUtil.toTime(this, x, this.props.root.width);
  //var conversion = this.range.conversion(this.props.root.width);
  //return new Date(x / conversion.scale + conversion.offset);
};

/**
 * Convert a datetime (Date object) into a position on the screen
 * @param {Date}   time A date
 * @return {int}   x    The position on the screen in pixels which corresponds
 *                      with the given date.
 * @protected
 */
// TODO: move this function to Range
Core.prototype._toScreen = function (time) {
  return DateUtil.toScreen(this, time, this.props.center.width);
};

/**
 * Convert a datetime (Date object) into a position on the root
 * This is used to get the pixel density estimate for the screen, not the center panel
 * @param {Date}   time A date
 * @return {int}   x    The position on root in pixels which corresponds
 *                      with the given date.
 * @protected
 */
// TODO: move this function to Range
Core.prototype._toGlobalScreen = function (time) {
  return DateUtil.toScreen(this, time, this.props.root.width);
  //var conversion = this.range.conversion(this.props.root.width);
  //return (time.valueOf() - conversion.offset) * conversion.scale;
};

/**
 * Initialize watching when option autoResize is true
 * @private
 */
Core.prototype._initAutoResize = function () {
  if (this.options.autoResize == true) {
    this._startAutoResize();
  } else {
    this._stopAutoResize();
  }
};

/**
 * Watch for changes in the size of the container. On resize, the Panel will
 * automatically redraw itself.
 * @private
 */
Core.prototype._startAutoResize = function () {
  var me = this;

  this._stopAutoResize();

  this._onResize = function () {
    if (me.options.autoResize != true) {
      // stop watching when the option autoResize is changed to false
      me._stopAutoResize();
      return;
    }

    if (me.dom.root) {
      // check whether the frame is resized
      // Note: we compare offsetWidth here, not clientWidth. For some reason,
      // IE does not restore the clientWidth from 0 to the actual width after
      // changing the timeline's container display style from none to visible
      if (me.dom.root.offsetWidth != me.props.lastWidth || me.dom.root.offsetHeight != me.props.lastHeight) {
        me.props.lastWidth = me.dom.root.offsetWidth;
        me.props.lastHeight = me.dom.root.offsetHeight;

        me.emit('change');
      }
    }
  };

  // add event listener to window resize
  util.addEventListener(window, 'resize', this._onResize);

  this.watchTimer = setInterval(this._onResize, 1000);
};

/**
 * Stop watching for a resize of the frame.
 * @private
 */
Core.prototype._stopAutoResize = function () {
  if (this.watchTimer) {
    clearInterval(this.watchTimer);
    this.watchTimer = undefined;
  }

  // remove event listener on window.resize
  if (this._onResize) {
    util.removeEventListener(window, 'resize', this._onResize);
    this._onResize = null;
  }
};

/**
 * Start moving the timeline vertically
 * @param {Event} event
 * @private
 */
Core.prototype._onTouch = function (event) {
  this.touch.allowDragging = true;
  this.touch.initialScrollTop = this.props.scrollTop;
};

/**
 * Start moving the timeline vertically
 * @param {Event} event
 * @private
 */
Core.prototype._onPinch = function (event) {
  this.touch.allowDragging = false;
};

/**
 * Move the timeline vertically
 * @param {Event} event
 * @private
 */
Core.prototype._onDrag = function (event) {
  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.touch.allowDragging) return;

  var delta = event.deltaY;

  var oldScrollTop = this._getScrollTop();
  var newScrollTop = this._setScrollTop(this.touch.initialScrollTop + delta);

  if (newScrollTop != oldScrollTop) {
    this._redraw(); // TODO: this causes two redraws when dragging, the other is triggered by rangechange already
    this.emit("verticalDrag");
  }
};

/**
 * Apply a scrollTop
 * @param {Number} scrollTop
 * @returns {Number} scrollTop  Returns the applied scrollTop
 * @private
 */
Core.prototype._setScrollTop = function (scrollTop) {
  this.props.scrollTop = scrollTop;
  this._updateScrollTop();
  return this.props.scrollTop;
};

/**
 * Update the current scrollTop when the height of  the containers has been changed
 * @returns {Number} scrollTop  Returns the applied scrollTop
 * @private
 */
Core.prototype._updateScrollTop = function () {
  // recalculate the scrollTopMin
  var scrollTopMin = Math.min(this.props.centerContainer.height - this.props.center.height, 0); // is negative or zero
  if (scrollTopMin != this.props.scrollTopMin) {
    // in case of bottom orientation, change the scrollTop such that the contents
    // do not move relative to the time axis at the bottom
    if (this.options.orientation.item != 'top') {
      this.props.scrollTop += scrollTopMin - this.props.scrollTopMin;
    }
    this.props.scrollTopMin = scrollTopMin;
  }

  // limit the scrollTop to the feasible scroll range
  if (this.props.scrollTop > 0) this.props.scrollTop = 0;
  if (this.props.scrollTop < scrollTopMin) this.props.scrollTop = scrollTopMin;

  return this.props.scrollTop;
};

/**
 * Get the current scrollTop
 * @returns {number} scrollTop
 * @private
 */
Core.prototype._getScrollTop = function () {
  return this.props.scrollTop;
};

/**
 * Load a configurator
 * @return {Object}
 * @private
 */
Core.prototype._createConfigurator = function () {
  throw new Error('Cannot invoke abstract method _createConfigurator');
};

module.exports = Core;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvQ29yZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQzNDLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ3pDLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUMxQyxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDOUIsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3BDLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN0QyxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDL0IsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUM7QUFDN0MsSUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLHNCQUFzQixDQUFDLENBQUM7QUFDL0MsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUM7QUFDL0MsSUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3JDLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDOzs7Ozs7QUFNbkQsU0FBUyxJQUFJLEdBQUksRUFBRTs7O0FBR25CLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7Ozs7Ozs7OztBQVN4QixJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRyxVQUFVLFNBQVMsRUFBRTtBQUM1QyxNQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQzs7QUFFZCxNQUFJLENBQUMsR0FBRyxDQUFD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QUM7QUFDckUsUUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsR0FBRyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0dBQ3hELE1BQ0k7QUFDSCxhQUFTLEdBQUcsQUFBQyxPQUFPLElBQUksT0FBTyxDQUFDLFNBQVMsS0FBSyxTQUFTLEdBQUksT0FBTyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7QUFDcEYsUUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztHQUM1QztDQUNGLENBQUM7Ozs7Ozs7Ozs7Ozs7QUFhRixJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxVQUFTLElBQUksRUFBRSxPQUFPLEVBQUU7QUFDOUMsTUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUM7QUFDakQsTUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7O0FBRTdDLE1BQUksS0FBSyxHQUFHLENBQUMsR0FBRyxRQUFRLEdBQUcsQ0FBQyxDQUFDO0FBQzdCLE1BQUksR0FBRyxHQUFHLENBQUMsR0FBRyxRQUFRLEdBQUcsQ0FBQyxDQUFDO0FBQzNCLE1BQUksU0FBUyxHQUFHLEFBQUMsT0FBTyxJQUFJLE9BQU8sQ0FBQyxTQUFTLEtBQUssU0FBUyxHQUFJLE9BQU8sQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDOztBQUV4RixNQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0NBQzVDLENBQUM7Ozs7OztBQU1GLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFHLFlBQVc7QUFDcEMsTUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztB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SSxLQUFLLEVBQUU7QUFDMUMsVUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLElBQUssWUFBWSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxBQUFDLENBQUM7S0FDbEU7QUFDRCxRQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7R0FDeEM7OztBQUdELE1BQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztBQUN2RCxNQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLFlBQVksRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxZQUFZLENBQUM7O0FBRTdFLFNBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUM7Q0FDN0IsQ0FBQzs7Ozs7OztBQU9GLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFHLFlBQVk7QUFDekMsU0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQztDQUM3QixDQUFDOzs7Ozs7O0FBT0YsSUFBSSxDQUFDLFNBQVMsQ0FBQyxtQkFBbUIsR0FBRyxZQUFZO0FBQy9DLFFBQU0sSUFBSSxLQUFLLENBQUMsbURBQW1ELENBQUMsQ0FBQztDQUN0RSxDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvQ29yZS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBFbWl0dGVyID0gcmVxdWlyZSgnZW1pdHRlci1jb21wb25lbnQnKTtcbnZhciBIYW1tZXIgPSByZXF1aXJlKCcuLi9tb2R1bGUvaGFtbWVyJyk7XG52YXIgaGFtbWVyVXRpbCA9IHJlcXVpcmUoJy4uL2hhbW1lclV0aWwnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIERhdGFTZXQgPSByZXF1aXJlKCcuLi9EYXRhU2V0Jyk7XG52YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuLi9EYXRhVmlldycpO1xudmFyIFJhbmdlID0gcmVxdWlyZSgnLi9SYW5nZScpO1xudmFyIEl0ZW1TZXQgPSByZXF1aXJlKCcuL2NvbXBvbmVudC9JdGVtU2V0Jyk7XG52YXIgVGltZUF4aXMgPSByZXF1aXJlKCcuL2NvbXBvbmVudC9UaW1lQXhpcycpO1xudmFyIEFjdGl2YXRvciA9IHJlcXVpcmUoJy4uL3NoYXJlZC9BY3RpdmF0b3InKTtcbnZhciBEYXRlVXRpbCA9IHJlcXVpcmUoJy4vRGF0ZVV0aWwnKTtcbnZhciBDdXN0b21UaW1lID0gcmVxdWlyZSgnLi9jb21wb25lbnQvQ3VzdG9tVGltZScpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHRpbWVsaW5lIHZpc3VhbGl6YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb3JlICgpIHt9XG5cbi8vIHR1cm4gQ29yZSBpbnRvIGFuIGV2ZW50IGVtaXR0ZXJcbkVtaXR0ZXIoQ29yZS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgbWFpbiBET00gZm9yIHRoZSBDb3JlOiBhIHJvb3QgcGFuZWwgY29udGFpbmluZyBsZWZ0LCByaWdodCxcbiAqIHRvcCwgYm90dG9tLCBjb250ZW50LCBhbmQgYmFja2dyb3VuZCBwYW5lbC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyICBUaGUgY29udGFpbmVyIGVsZW1lbnQgd2hlcmUgdGhlIENvcmUgd2lsbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGF0dGFjaGVkLlxuICogQHByb3RlY3RlZFxuICovXG5Db3JlLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICB0aGlzLmRvbSA9IHt9O1xuXG4gIHRoaXMuZG9tLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICB0aGlzLmRvbS5yb290ICAgICAgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kVmVydGljYWwgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5sZWZ0Q29udGFpbmVyICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5yaWdodENvbnRhaW5lciAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5jZW50ZXIgICAgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5sZWZ0ICAgICAgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5yaWdodCAgICAgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS50b3AgICAgICAgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5ib3R0b20gICAgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5zaGFkb3dUb3AgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5zaGFkb3dCb3R0b20gICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5zaGFkb3dUb3BMZWZ0ICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5zaGFkb3dCb3R0b21MZWZ0ICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5zaGFkb3dUb3BSaWdodCAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5zaGFkb3dCb3R0b21SaWdodCAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIHRoaXMuZG9tLnJvb3QuY2xhc3NOYW1lICAgICAgICAgICAgICAgICA9ICd2aXMtdGltZWxpbmUnO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kLmNsYXNzTmFtZSAgICAgICAgICAgPSAndmlzLXBhbmVsIHZpcy1iYWNrZ3JvdW5kJztcbiAgdGhpcy5kb20uYmFja2dyb3VuZFZlcnRpY2FsLmNsYXNzTmFtZSAgID0gJ3Zpcy1wYW5lbCB2aXMtYmFja2dyb3VuZCB2aXMtdmVydGljYWwnO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbC5jbGFzc05hbWUgPSAndmlzLXBhbmVsIHZpcy1iYWNrZ3JvdW5kIHZpcy1ob3Jpem9udGFsJztcbiAgdGhpcy5kb20uY2VudGVyQ29udGFpbmVyLmNsYXNzTmFtZSAgICAgID0gJ3Zpcy1wYW5lbCB2aXMtY2VudGVyJztcbiAgdGhpcy5kb20ubGVmdENvbnRhaW5lci5jbGFzc05hbWUgICAgICAgID0gJ3Zpcy1wYW5lbCB2aXMtbGVmdCc7XG4gIHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyLmNsYXNzTmFtZSAgICAgICA9ICd2aXMtcGFuZWwgdmlzLXJpZ2h0JztcbiAgdGhpcy5kb20udG9wLmNsYXNzTmFtZSAgICAgICAgICAgICAgICAgID0gJ3Zpcy1wYW5lbCB2aXMtdG9wJztcbiAgdGhpcy5kb20uYm90dG9tLmNsYXNzTmFtZSAgICAgICAgICAgICAgID0gJ3Zpcy1wYW5lbCB2aXMtYm90dG9tJztcbiAgdGhpcy5kb20ubGVmdC5jbGFzc05hbWUgICAgICAgICAgICAgICAgID0gJ3Zpcy1jb250ZW50JztcbiAgdGhpcy5kb20uY2VudGVyLmNsYXNzTmFtZSAgICAgICAgICAgICAgID0gJ3Zpcy1jb250ZW50JztcbiAgdGhpcy5kb20ucmlnaHQuY2xhc3NOYW1lICAgICAgICAgICAgICAgID0gJ3Zpcy1jb250ZW50JztcbiAgdGhpcy5kb20uc2hhZG93VG9wLmNsYXNzTmFtZSAgICAgICAgICAgID0gJ3Zpcy1zaGFkb3cgdmlzLXRvcCc7XG4gIHRoaXMuZG9tLnNoYWRvd0JvdHRvbS5jbGFzc05hbWUgICAgICAgICA9ICd2aXMtc2hhZG93IHZpcy1ib3R0b20nO1xuICB0aGlzLmRvbS5zaGFkb3dUb3BMZWZ0LmNsYXNzTmFtZSAgICAgICAgPSAndmlzLXNoYWRvdyB2aXMtdG9wJztcbiAgdGhpcy5kb20uc2hhZG93Qm90dG9tTGVmdC5jbGFzc05hbWUgICAgID0gJ3Zpcy1zaGFkb3cgdmlzLWJvdHRvbSc7XG4gIHRoaXMuZG9tLnNoYWRvd1RvcFJpZ2h0LmNsYXNzTmFtZSAgICAgICA9ICd2aXMtc2hhZG93IHZpcy10b3AnO1xuICB0aGlzLmRvbS5zaGFkb3dCb3R0b21SaWdodC5jbGFzc05hbWUgICAgPSAndmlzLXNoYWRvdyB2aXMtYm90dG9tJztcblxuICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLmJhY2tncm91bmQpO1xuICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLmJhY2tncm91bmRWZXJ0aWNhbCk7XG4gIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20uYmFja2dyb3VuZEhvcml6b250YWwpO1xuICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lcik7XG4gIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20ubGVmdENvbnRhaW5lcik7XG4gIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20ucmlnaHRDb250YWluZXIpO1xuICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLnRvcCk7XG4gIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20uYm90dG9tKTtcblxuICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uY2VudGVyKTtcbiAgdGhpcy5kb20ubGVmdENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5sZWZ0KTtcbiAgdGhpcy5kb20ucmlnaHRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20ucmlnaHQpO1xuXG4gIHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5zaGFkb3dUb3ApO1xuICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93Qm90dG9tKTtcbiAgdGhpcy5kb20ubGVmdENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5zaGFkb3dUb3BMZWZ0KTtcbiAgdGhpcy5kb20ubGVmdENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5zaGFkb3dCb3R0b21MZWZ0KTtcbiAgdGhpcy5kb20ucmlnaHRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93VG9wUmlnaHQpO1xuICB0aGlzLmRvbS5yaWdodENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5zaGFkb3dCb3R0b21SaWdodCk7XG5cbiAgdGhpcy5vbigncmFuZ2VjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVkcmF3KCk7IC8vIHRoaXMgYWxsb3dzIG92ZXJyaWRpbmcgdGhlIF9yZWRyYXcgbWV0aG9kXG4gIH0uYmluZCh0aGlzKSk7XG4gIHRoaXMub24oJ3RvdWNoJywgICAgICAgdGhpcy5fb25Ub3VjaC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5vbigncGFuJywgICAgICAgICB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKSk7XG5cbiAgdmFyIG1lID0gdGhpcztcbiAgdGhpcy5vbignY2hhbmdlJywgZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICBpZiAocHJvcGVydGllcyAmJiBwcm9wZXJ0aWVzLnF1ZXVlID09IHRydWUpIHtcbiAgICAgIC8vIHJlZHJhdyBvbmNlIG9uIG5leHQgdGlja1xuICAgICAgaWYgKCFtZS5fcmVkcmF3VGltZXIpIHtcbiAgICAgICAgbWUuX3JlZHJhd1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWUuX3JlZHJhd1RpbWVyID0gbnVsbDtcbiAgICAgICAgICBtZS5fcmVkcmF3KCk7XG4gICAgICAgIH0sIDApXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gcmVkcmF3IGltbWVkaWF0ZWx5XG4gICAgICBtZS5fcmVkcmF3KCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBjcmVhdGUgZXZlbnQgbGlzdGVuZXJzIGZvciBhbGwgaW50ZXJlc3RpbmcgZXZlbnRzLCB0aGVzZSBldmVudHMgd2lsbCBiZVxuICAvLyBlbWl0dGVkIHZpYSBlbWl0dGVyXG4gIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLmRvbS5yb290KTtcbiAgdGhpcy5oYW1tZXIuZ2V0KCdwaW5jaCcpLnNldCh7ZW5hYmxlOiB0cnVlfSk7XG4gIHRoaXMuaGFtbWVyLmdldCgncGFuJykuc2V0KHt0aHJlc2hvbGQ6NSwgZGlyZWN0aW9uOjMwfSk7IC8vIDMwIGlzIEFMTF9ESVJFQ1RJT05TIGluIGhhbW1lci5cbiAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcblxuICB2YXIgZXZlbnRzID0gW1xuICAgICd0YXAnLCAnZG91YmxldGFwJywgJ3ByZXNzJyxcbiAgICAncGluY2gnLFxuICAgICdwYW4nLCAncGFuc3RhcnQnLCAncGFubW92ZScsICdwYW5lbmQnXG4gICAgICAvLyBUT0RPOiBjbGVhbnVwXG4gICAgLy8ndG91Y2gnLCAncGluY2gnLFxuICAgIC8vJ3RhcCcsICdkb3VibGV0YXAnLCAnaG9sZCcsXG4gICAgLy8nZHJhZ3N0YXJ0JywgJ2RyYWcnLCAnZHJhZ2VuZCcsXG4gICAgLy8nbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcgLy8gRE9NTW91c2VTY3JvbGwgaXMgbmVlZGVkIGZvciBGaXJlZm94XG4gIF07XG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAobWUuaXNBY3RpdmUoKSkge1xuICAgICAgICBtZS5lbWl0KHR5cGUsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1lLmhhbW1lci5vbih0eXBlLCBsaXN0ZW5lcik7XG4gICAgbWUubGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gIH0pO1xuXG4gIC8vIGVtdWxhdGUgYSB0b3VjaCBldmVudCAoZW1pdHRlZCBiZWZvcmUgdGhlIHN0YXJ0IG9mIGEgcGFuLCBwaW5jaCwgdGFwLCBvciBwcmVzcylcbiAgaGFtbWVyVXRpbC5vblRvdWNoKHRoaXMuaGFtbWVyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBtZS5lbWl0KCd0b3VjaCcsIGV2ZW50KTtcbiAgfS5iaW5kKHRoaXMpKTtcblxuICAvLyBlbXVsYXRlIGEgcmVsZWFzZSBldmVudCAoZW1pdHRlZCBhZnRlciBhIHBhbiwgcGluY2gsIHRhcCwgb3IgcHJlc3MpXG4gIGhhbW1lclV0aWwub25SZWxlYXNlKHRoaXMuaGFtbWVyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBtZS5lbWl0KCdyZWxlYXNlJywgZXZlbnQpO1xuICB9LmJpbmQodGhpcykpO1xuXG4gIGZ1bmN0aW9uIG9uTW91c2VXaGVlbChldmVudCkge1xuICAgIGlmIChtZS5pc0FjdGl2ZSgpKSB7XG4gICAgICBtZS5lbWl0KCdtb3VzZXdoZWVsJywgZXZlbnQpO1xuICAgIH1cbiAgfVxuICB0aGlzLmRvbS5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBvbk1vdXNlV2hlZWwpO1xuICB0aGlzLmRvbS5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgb25Nb3VzZVdoZWVsKTtcblxuICAvLyBzaXplIHByb3BlcnRpZXMgb2YgZWFjaCBvZiB0aGUgcGFuZWxzXG4gIHRoaXMucHJvcHMgPSB7XG4gICAgcm9vdDoge30sXG4gICAgYmFja2dyb3VuZDoge30sXG4gICAgY2VudGVyQ29udGFpbmVyOiB7fSxcbiAgICBsZWZ0Q29udGFpbmVyOiB7fSxcbiAgICByaWdodENvbnRhaW5lcjoge30sXG4gICAgY2VudGVyOiB7fSxcbiAgICBsZWZ0OiB7fSxcbiAgICByaWdodDoge30sXG4gICAgdG9wOiB7fSxcbiAgICBib3R0b206IHt9LFxuICAgIGJvcmRlcjoge30sXG4gICAgc2Nyb2xsVG9wOiAwLFxuICAgIHNjcm9sbFRvcE1pbjogMFxuICB9O1xuXG4gIHRoaXMuY3VzdG9tVGltZXMgPSBbXTtcblxuICAvLyBzdG9yZSBzdGF0ZSBpbmZvcm1hdGlvbiBuZWVkZWQgZm9yIHRvdWNoIGV2ZW50c1xuICB0aGlzLnRvdWNoID0ge307XG5cbiAgdGhpcy5yZWRyYXdDb3VudCA9IDA7XG5cbiAgLy8gYXR0YWNoIHRoZSByb290IHBhbmVsIHRvIHRoZSBwcm92aWRlZCBjb250YWluZXJcbiAgaWYgKCFjb250YWluZXIpIHRocm93IG5ldyBFcnJvcignTm8gY29udGFpbmVyIHByb3ZpZGVkJyk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5yb290KTtcbn07XG5cbi8qKlxuICogU2V0IG9wdGlvbnMuIE9wdGlvbnMgd2lsbCBiZSBwYXNzZWQgdG8gYWxsIGNvbXBvbmVudHMgbG9hZGVkIGluIHRoZSBUaW1lbGluZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gb3JpZW50YXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVydGljYWwgb3JpZW50YXRpb24gZm9yIHRoZSBUaW1lbGluZSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuIGJlICdib3R0b20nIChkZWZhdWx0KSBvciAndG9wJy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IE51bWJlcn0gd2lkdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2lkdGggZm9yIHRoZSB0aW1lbGluZSwgYSBudW1iZXIgaW4gcGl4ZWxzIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgY3NzIHN0cmluZyBsaWtlICcxMDAwcHgnIG9yICc3NSUnLiAnMTAwJScgYnkgZGVmYXVsdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IE51bWJlcn0gaGVpZ2h0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpeGVkIGhlaWdodCBmb3IgdGhlIFRpbWVsaW5lLCBhIG51bWJlciBpbiBwaXhlbHMgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBjc3Mgc3RyaW5nIGxpa2UgJzQwMHB4JyBvciAnNzUlJy4gSWYgdW5kZWZpbmVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgVGltZWxpbmUgd2lsbCBhdXRvbWF0aWNhbGx5IHNpemUgc3VjaCB0aGF0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0cyBjb250ZW50cyBmaXQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBOdW1iZXJ9IG1pbkhlaWdodFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNaW5pbXVtIGhlaWdodCBmb3IgdGhlIFRpbWVsaW5lLCBhIG51bWJlciBpbiBwaXhlbHMgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBjc3Mgc3RyaW5nIGxpa2UgJzQwMHB4JyBvciAnNzUlJy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IE51bWJlcn0gbWF4SGVpZ2h0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1heGltdW0gaGVpZ2h0IGZvciB0aGUgVGltZWxpbmUsIGEgbnVtYmVyIGluIHBpeGVscyBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGNzcyBzdHJpbmcgbGlrZSAnNDAwcHgnIG9yICc3NSUnLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyIHwgRGF0ZSB8IFN0cmluZ30gc3RhcnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RhcnQgZGF0ZSBmb3IgdGhlIHZpc2libGUgd2luZG93XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXIgfCBEYXRlIHwgU3RyaW5nfSBlbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kIGRhdGUgZm9yIHRoZSB2aXNpYmxlIHdpbmRvd1xuICovXG5Db3JlLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICAvLyBjb3B5IHRoZSBrbm93biBvcHRpb25zXG4gICAgdmFyIGZpZWxkcyA9IFtcbiAgICAgICd3aWR0aCcsICdoZWlnaHQnLCAnbWluSGVpZ2h0JywgJ21heEhlaWdodCcsICdhdXRvUmVzaXplJyxcbiAgICAgICdzdGFydCcsICdlbmQnLCAnY2xpY2tUb1VzZScsICdkYXRhQXR0cmlidXRlcycsICdoaWRkZW5EYXRlcycsXG4gICAgICAnbG9jYWxlJywgJ2xvY2FsZXMnLCAnbW9tZW50JyxcbiAgICAgICd0aHJvdHRsZVJlZHJhdydcbiAgICBdO1xuICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGlmICgnb3JpZW50YXRpb24nIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID0ge1xuICAgICAgICAgIGl0ZW06IG9wdGlvbnMub3JpZW50YXRpb24sXG4gICAgICAgICAgYXhpczogb3B0aW9ucy5vcmllbnRhdGlvblxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMub3JpZW50YXRpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICgnaXRlbScgaW4gb3B0aW9ucy5vcmllbnRhdGlvbikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtID0gb3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnYXhpcycgaW4gb3B0aW9ucy5vcmllbnRhdGlvbikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID0gb3B0aW9ucy5vcmllbnRhdGlvbi5heGlzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID09PSAnYm90aCcpIHtcbiAgICAgIGlmICghdGhpcy50aW1lQXhpczIpIHtcbiAgICAgICAgdmFyIHRpbWVBeGlzMiA9IHRoaXMudGltZUF4aXMyID0gbmV3IFRpbWVBeGlzKHRoaXMuYm9keSk7XG4gICAgICAgIHRpbWVBeGlzMi5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zID8gdXRpbC5leHRlbmQoe30sIG9wdGlvbnMpIDoge307XG4gICAgICAgICAgX29wdGlvbnMub3JpZW50YXRpb24gPSAndG9wJzsgLy8gb3ZlcnJpZGUgdGhlIG9yaWVudGF0aW9uIG9wdGlvbiwgYWx3YXlzIHRvcFxuICAgICAgICAgIFRpbWVBeGlzLnByb3RvdHlwZS5zZXRPcHRpb25zLmNhbGwodGltZUF4aXMyLCBfb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKHRpbWVBeGlzMik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHRoaXMudGltZUF4aXMyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuY29tcG9uZW50cy5pbmRleE9mKHRoaXMudGltZUF4aXMyKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZUF4aXMyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy50aW1lQXhpczIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBncmFwaDJkJ3MgZHJhd1BvaW50cyBpcyBhIGZ1bmN0aW9uIGRlbGVnYXRlIHRoZSBjYWxsYmFjayB0byB0aGUgb25SZW5kZXIgcHJvcGVydHlcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZHJhd1BvaW50cyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRpb25zLmRyYXdQb2ludHMgPSB7XG4gICAgICAgICAgb25SZW5kZXI6IG9wdGlvbnMuZHJhd1BvaW50c1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoJ2hpZGRlbkRhdGVzJyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgIERhdGVVdGlsLmNvbnZlcnRIaWRkZW5PcHRpb25zKHRoaXMub3B0aW9ucy5tb21lbnQsIHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLmhpZGRlbkRhdGVzKTtcbiAgICB9XG5cbiAgICBpZiAoJ2NsaWNrVG9Vc2UnIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLmNsaWNrVG9Vc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2YXRvcikge1xuICAgICAgICAgIHRoaXMuYWN0aXZhdG9yID0gbmV3IEFjdGl2YXRvcih0aGlzLmRvbS5yb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2YXRvcikge1xuICAgICAgICAgIHRoaXMuYWN0aXZhdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5hY3RpdmF0b3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJ3Nob3dDdXN0b21UaW1lJyBpbiBvcHRpb25zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBgc2hvd0N1c3RvbVRpbWVgIGlzIGRlcHJlY2F0ZWQuIENyZWF0ZSBhIGN1c3RvbSB0aW1lIGJhciB2aWEgdGltZWxpbmUuYWRkQ3VzdG9tVGltZSh0aW1lIFssIGlkXSknKTtcbiAgICB9XG5cbiAgICAvLyBlbmFibGUvZGlzYWJsZSBhdXRvUmVzaXplXG4gICAgdGhpcy5faW5pdEF1dG9SZXNpemUoKTtcbiAgfVxuXG4gIC8vIHByb3BhZ2F0ZSBvcHRpb25zIHRvIGFsbCBjb21wb25lbnRzXG4gIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGNvbXBvbmVudCA9PiBjb21wb25lbnQuc2V0T3B0aW9ucyhvcHRpb25zKSk7XG5cbiAgLy8gZW5hYmxlL2Rpc2FibGUgY29uZmlndXJlXG4gIGlmICgnY29uZmlndXJlJyBpbiBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZ3VyYXRvcikge1xuICAgICAgdGhpcy5jb25maWd1cmF0b3IgPSB0aGlzLl9jcmVhdGVDb25maWd1cmF0b3IoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZ3VyYXRvci5zZXRPcHRpb25zKG9wdGlvbnMuY29uZmlndXJlKTtcblxuICAgIC8vIGNvbGxlY3QgdGhlIHNldHRpbmdzIG9mIGFsbCBjb21wb25lbnRzLCBhbmQgcGFzcyB0aGVtIHRvIHRoZSBjb25maWd1cmF0aW9uIHN5c3RlbVxuICAgIHZhciBhcHBsaWVkT3B0aW9ucyA9IHV0aWwuZGVlcEV4dGVuZCh7fSwgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICB1dGlsLmRlZXBFeHRlbmQoYXBwbGllZE9wdGlvbnMsIGNvbXBvbmVudC5vcHRpb25zKTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbmZpZ3VyYXRvci5zZXRNb2R1bGVPcHRpb25zKHtnbG9iYWw6IGFwcGxpZWRPcHRpb25zfSk7XG4gIH1cblxuICAvLyBvdmVycmlkZSByZWRyYXcgd2l0aCBhIHRocm90dGxlZCB2ZXJzaW9uXG4gIGlmICghdGhpcy5fb3JpZ1JlZHJhdykge1xuICAgIHRoaXMuX29yaWdSZWRyYXcgPSB0aGlzLl9yZWRyYXcuYmluZCh0aGlzKTtcbiAgfVxuICB0aGlzLl9yZWRyYXcgPSB1dGlsLnRocm90dGxlKHRoaXMuX29yaWdSZWRyYXcsIHRoaXMub3B0aW9ucy50aHJvdHRsZVJlZHJhdyk7XG5cbiAgLy8gcmVkcmF3IGV2ZXJ5dGhpbmdcbiAgdGhpcy5fcmVkcmF3KCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBUaW1lbGluZSBpcyBhY3RpdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuQ29yZS5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5hY3RpdmF0b3IgfHwgdGhpcy5hY3RpdmF0b3IuYWN0aXZlO1xufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBDb3JlLCBjbGVhbiB1cCBhbGwgRE9NIGVsZW1lbnRzIGFuZCBldmVudCBsaXN0ZW5lcnMuXG4gKi9cbkNvcmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHVuYmluZCBkYXRhc2V0c1xuICB0aGlzLnNldEl0ZW1zKG51bGwpO1xuICB0aGlzLnNldEdyb3VwcyhudWxsKTtcblxuICAvLyByZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICB0aGlzLm9mZigpO1xuXG4gIC8vIHN0b3AgY2hlY2tpbmcgZm9yIGNoYW5nZWQgc2l6ZVxuICB0aGlzLl9zdG9wQXV0b1Jlc2l6ZSgpO1xuXG4gIC8vIHJlbW92ZSBmcm9tIERPTVxuICBpZiAodGhpcy5kb20ucm9vdC5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5kb20ucm9vdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLnJvb3QpO1xuICB9XG4gIHRoaXMuZG9tID0gbnVsbDtcblxuICAvLyByZW1vdmUgQWN0aXZhdG9yXG4gIGlmICh0aGlzLmFjdGl2YXRvcikge1xuICAgIHRoaXMuYWN0aXZhdG9yLmRlc3Ryb3koKTtcbiAgICBkZWxldGUgdGhpcy5hY3RpdmF0b3I7XG4gIH1cblxuICAvLyBjbGVhbnVwIGhhbW1lciB0b3VjaCBldmVudHNcbiAgZm9yICh2YXIgZXZlbnQgaW4gdGhpcy5saXN0ZW5lcnMpIHtcbiAgICBpZiAodGhpcy5saXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICBkZWxldGUgdGhpcy5saXN0ZW5lcnNbZXZlbnRdO1xuICAgIH1cbiAgfVxuICB0aGlzLmxpc3RlbmVycyA9IG51bGw7XG4gIHRoaXMuaGFtbWVyID0gbnVsbDtcblxuICAvLyBnaXZlIGFsbCBjb21wb25lbnRzIHRoZSBvcHBvcnR1bml0eSB0byBjbGVhbnVwXG4gIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGNvbXBvbmVudCA9PiBjb21wb25lbnQuZGVzdHJveSgpKTtcblxuICB0aGlzLmJvZHkgPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFNldCBhIGN1c3RvbSB0aW1lIGJhclxuICogQHBhcmFtIHtEYXRlfSB0aW1lXG4gKiBAcGFyYW0ge251bWJlcn0gW2lkPXVuZGVmaW5lZF0gT3B0aW9uYWwgaWQgb2YgdGhlIGN1c3RvbSB0aW1lIGJhciB0byBiZSBhZGp1c3RlZC5cbiAqL1xuQ29yZS5wcm90b3R5cGUuc2V0Q3VzdG9tVGltZSA9IGZ1bmN0aW9uICh0aW1lLCBpZCkge1xuICB2YXIgY3VzdG9tVGltZXMgPSB0aGlzLmN1c3RvbVRpbWVzLmZpbHRlcihmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGlkID09PSBjb21wb25lbnQub3B0aW9ucy5pZDtcbiAgfSk7XG5cbiAgaWYgKGN1c3RvbVRpbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gY3VzdG9tIHRpbWUgYmFyIGZvdW5kIHdpdGggaWQgJyArIEpTT04uc3RyaW5naWZ5KGlkKSlcbiAgfVxuXG4gIGlmIChjdXN0b21UaW1lcy5sZW5ndGggPiAwKSB7XG4gICAgY3VzdG9tVGltZXNbMF0uc2V0Q3VzdG9tVGltZSh0aW1lKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBjdXN0b20gdGltZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaWQ9dW5kZWZpbmVkXSAgICBJZCBvZiB0aGUgY3VzdG9tIHRpbWUgYmFyLlxuICogQHJldHVybiB7RGF0ZSB8IHVuZGVmaW5lZH0gY3VzdG9tVGltZVxuICovXG5Db3JlLnByb3RvdHlwZS5nZXRDdXN0b21UaW1lID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIGN1c3RvbVRpbWVzID0gdGhpcy5jdXN0b21UaW1lcy5maWx0ZXIoZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgIHJldHVybiBjb21wb25lbnQub3B0aW9ucy5pZCA9PT0gaWQ7XG4gIH0pO1xuXG4gIGlmIChjdXN0b21UaW1lcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGN1c3RvbSB0aW1lIGJhciBmb3VuZCB3aXRoIGlkICcgKyBKU09OLnN0cmluZ2lmeShpZCkpXG4gIH1cbiAgcmV0dXJuIGN1c3RvbVRpbWVzWzBdLmdldEN1c3RvbVRpbWUoKTtcbn07XG5cbi8qKlxuICogU2V0IGEgY3VzdG9tIHRpdGxlIGZvciB0aGUgY3VzdG9tIHRpbWUgYmFyLlxuICogQHBhcmFtIHtTdHJpbmd9IFt0aXRsZV0gQ3VzdG9tIHRpdGxlXG4gKiBAcGFyYW0ge251bWJlcn0gW2lkPXVuZGVmaW5lZF0gICAgSWQgb2YgdGhlIGN1c3RvbSB0aW1lIGJhci5cbiAqL1xuQ29yZS5wcm90b3R5cGUuc2V0Q3VzdG9tVGltZVRpdGxlID0gZnVuY3Rpb24odGl0bGUsIGlkKSB7XG4gIHZhciBjdXN0b21UaW1lcyA9IHRoaXMuY3VzdG9tVGltZXMuZmlsdGVyKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICByZXR1cm4gY29tcG9uZW50Lm9wdGlvbnMuaWQgPT09IGlkO1xuICB9KTtcblxuICBpZiAoY3VzdG9tVGltZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBjdXN0b20gdGltZSBiYXIgZm91bmQgd2l0aCBpZCAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKVxuICB9XG4gIGlmIChjdXN0b21UaW1lcy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGN1c3RvbVRpbWVzWzBdLnNldEN1c3RvbVRpdGxlKHRpdGxlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBtZXRhIGluZm9ybWF0aW9uIGZyb20gYW4gZXZlbnQuXG4gKiBTaG91bGQgYmUgb3ZlcnJpZGRlbiBieSBjbGFzc2VzIGV4dGVuZGluZyBDb3JlXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCByZWxhdGVkIGluZm9ybWF0aW9uLlxuICovXG5Db3JlLnByb3RvdHlwZS5nZXRFdmVudFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcmV0dXJuIHsgZXZlbnQ6IGV2ZW50IH07XG59O1xuXG4vKipcbiAqIEFkZCBjdXN0b20gdmVydGljYWwgYmFyXG4gKiBAcGFyYW0ge0RhdGUgfCBTdHJpbmcgfCBOdW1iZXJ9IFt0aW1lXSAgQSBEYXRlLCB1bml4IHRpbWVzdGFtcCwgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJU08gZGF0ZSBzdHJpbmcuIFRpbWUgcG9pbnQgd2hlcmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmV3IGJhciBzaG91bGQgYmUgcGxhY2VkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vdCBwcm92aWRlZCwgYG5ldyBEYXRlKClgIHdpbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSB1c2VkLlxuICogQHBhcmFtIHtOdW1iZXIgfCBTdHJpbmd9IFtpZD11bmRlZmluZWRdIElkIG9mIHRoZSBuZXcgYmFyLiBPcHRpb25hbFxuICogQHJldHVybiB7TnVtYmVyIHwgU3RyaW5nfSAgICAgICAgICAgICAgIFJldHVybnMgdGhlIGlkIG9mIHRoZSBuZXcgYmFyXG4gKi9cbkNvcmUucHJvdG90eXBlLmFkZEN1c3RvbVRpbWUgPSBmdW5jdGlvbiAodGltZSwgaWQpIHtcbiAgdmFyIHRpbWVzdGFtcCA9IHRpbWUgIT09IHVuZGVmaW5lZFxuICAgICAgPyB1dGlsLmNvbnZlcnQodGltZSwgJ0RhdGUnKS52YWx1ZU9mKClcbiAgICAgIDogbmV3IERhdGUoKTtcblxuICB2YXIgZXhpc3RzID0gdGhpcy5jdXN0b21UaW1lcy5zb21lKGZ1bmN0aW9uIChjdXN0b21UaW1lKSB7XG4gICAgcmV0dXJuIGN1c3RvbVRpbWUub3B0aW9ucy5pZCA9PT0gaWQ7XG4gIH0pO1xuICBpZiAoZXhpc3RzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIGN1c3RvbSB0aW1lIHdpdGggaWQgJyArIEpTT04uc3RyaW5naWZ5KGlkKSArICcgYWxyZWFkeSBleGlzdHMnKTtcbiAgfVxuXG4gIHZhciBjdXN0b21UaW1lID0gbmV3IEN1c3RvbVRpbWUodGhpcy5ib2R5LCB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCB7XG4gICAgdGltZSA6IHRpbWVzdGFtcCxcbiAgICBpZCA6IGlkXG4gIH0pKTtcblxuICB0aGlzLmN1c3RvbVRpbWVzLnB1c2goY3VzdG9tVGltZSk7XG4gIHRoaXMuY29tcG9uZW50cy5wdXNoKGN1c3RvbVRpbWUpO1xuICB0aGlzLl9yZWRyYXcoKTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBwcmV2aW91c2x5IGFkZGVkIGN1c3RvbSBiYXJcbiAqIEBwYXJhbSB7aW50fSBpZCBJRCBvZiB0aGUgY3VzdG9tIGJhciB0byBiZSByZW1vdmVkXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBiYXIgZXhpc3RzIGFuZCBpcyByZW1vdmVkLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuQ29yZS5wcm90b3R5cGUucmVtb3ZlQ3VzdG9tVGltZSA9IGZ1bmN0aW9uIChpZCkge1xuICB2YXIgY3VzdG9tVGltZXMgPSB0aGlzLmN1c3RvbVRpbWVzLmZpbHRlcihmdW5jdGlvbiAoYmFyKSB7XG4gICAgcmV0dXJuIChiYXIub3B0aW9ucy5pZCA9PT0gaWQpO1xuICB9KTtcblxuICBpZiAoY3VzdG9tVGltZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBjdXN0b20gdGltZSBiYXIgZm91bmQgd2l0aCBpZCAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKVxuICB9XG5cbiAgY3VzdG9tVGltZXMuZm9yRWFjaChmdW5jdGlvbiAoY3VzdG9tVGltZSkge1xuICAgIHRoaXMuY3VzdG9tVGltZXMuc3BsaWNlKHRoaXMuY3VzdG9tVGltZXMuaW5kZXhPZihjdXN0b21UaW1lKSwgMSk7XG4gICAgdGhpcy5jb21wb25lbnRzLnNwbGljZSh0aGlzLmNvbXBvbmVudHMuaW5kZXhPZihjdXN0b21UaW1lKSwgMSk7XG4gICAgY3VzdG9tVGltZS5kZXN0cm95KCk7XG4gIH0uYmluZCh0aGlzKSlcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGlkJ3Mgb2YgdGhlIGN1cnJlbnRseSB2aXNpYmxlIGl0ZW1zLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgaWRzIG9mIHRoZSB2aXNpYmxlIGl0ZW1zXG4gKi9cbkNvcmUucHJvdG90eXBlLmdldFZpc2libGVJdGVtcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pdGVtU2V0ICYmIHRoaXMuaXRlbVNldC5nZXRWaXNpYmxlSXRlbXMoKSB8fCBbXTtcbn07XG5cbi8qKlxuICogU2V0IENvcmUgd2luZG93IHN1Y2ggdGhhdCBpdCBmaXRzIGFsbCBpdGVtc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFuaW1hdGlvbjogYm9vbGVhbiB8IHtkdXJhdGlvbjogbnVtYmVyLCBlYXNpbmdGdW5jdGlvbjogc3RyaW5nfWBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZCB0byBzcGVjaWZ5IGR1cmF0aW9uIGFuZCBlYXNpbmcgZnVuY3Rpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICovXG5Db3JlLnByb3RvdHlwZS5maXQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciByYW5nZSA9IHRoaXMuZ2V0RGF0YVJhbmdlKCk7XG5cbiAgLy8gc2tpcCByYW5nZSBzZXQgaWYgdGhlcmUgaXMgbm8gbWluIGFuZCBtYXggZGF0ZVxuICBpZiAocmFuZ2UubWluID09PSBudWxsICYmIHJhbmdlLm1heCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGFwcGx5IGEgbWFyZ2luIG9mIDElIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBkYXRhXG4gIHZhciBpbnRlcnZhbCA9IHJhbmdlLm1heCAtIHJhbmdlLm1pbjtcbiAgdmFyIG1pbiA9IG5ldyBEYXRlKHJhbmdlLm1pbi52YWx1ZU9mKCkgLSBpbnRlcnZhbCAqIDAuMDEpO1xuICB2YXIgbWF4ID0gbmV3IERhdGUocmFuZ2UubWF4LnZhbHVlT2YoKSArIGludGVydmFsICogMC4wMSk7XG5cbiAgdmFyIGFuaW1hdGlvbiA9IChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5hbmltYXRpb24gOiB0cnVlO1xuICB0aGlzLnJhbmdlLnNldFJhbmdlKG1pbiwgbWF4LCBhbmltYXRpb24pO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGRhdGEgcmFuZ2Ugb2YgdGhlIGl0ZW1zIHN0YXJ0IGFuZCBlbmQgZGF0ZXNcbiAqIEByZXR1cm5zIHt7bWluOiBEYXRlIHwgbnVsbCwgbWF4OiBEYXRlIHwgbnVsbH19XG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvcmUucHJvdG90eXBlLmdldERhdGFSYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IFRpbWVsaW5lIGFuZCBHcmFwaDJkXG4gIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludm9rZSBhYnN0cmFjdCBtZXRob2QgZ2V0RGF0YVJhbmdlJyk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdmlzaWJsZSB3aW5kb3cuIEJvdGggcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwsIHlvdSBjYW4gY2hhbmdlIG9ubHlcbiAqIHN0YXJ0IG9yIG9ubHkgZW5kLiBTeW50YXg6XG4gKlxuICogICAgIFRpbWVMaW5lLnNldFdpbmRvdyhzdGFydCwgZW5kKVxuICogICAgIFRpbWVMaW5lLnNldFdpbmRvdyhzdGFydCwgZW5kLCBvcHRpb25zKVxuICogICAgIFRpbWVMaW5lLnNldFdpbmRvdyhyYW5nZSlcbiAqXG4gKiBXaGVyZSBzdGFydCBhbmQgZW5kIGNhbiBiZSBhIERhdGUsIG51bWJlciwgb3Igc3RyaW5nLCBhbmQgcmFuZ2UgaXMgYW5cbiAqIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgc3RhcnQgYW5kIGVuZC5cbiAqXG4gKiBAcGFyYW0ge0RhdGUgfCBOdW1iZXIgfCBTdHJpbmcgfCBPYmplY3R9IFtzdGFydF0gU3RhcnQgZGF0ZSBvZiB2aXNpYmxlIHdpbmRvd1xuICogQHBhcmFtIHtEYXRlIHwgTnVtYmVyIHwgU3RyaW5nfSBbZW5kXSAgICAgICAgICAgIEVuZCBkYXRlIG9mIHZpc2libGUgd2luZG93XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYW5pbWF0aW9uOiBib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9YFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHJhbmdlIGlzIGFuaW1hdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LiBBbiBvYmplY3QgY2FuIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBkdXJhdGlvbiBpcyA1MDAgbXMsIGFuZCBkZWZhdWx0IGVhc2luZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpcyAnZWFzZUluT3V0UXVhZCcuXG4gKi9cbkNvcmUucHJvdG90eXBlLnNldFdpbmRvdyA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIG9wdGlvbnMpIHtcbiAgdmFyIGFuaW1hdGlvbjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgIHZhciByYW5nZSA9IGFyZ3VtZW50c1swXTtcbiAgICBhbmltYXRpb24gPSAocmFuZ2UuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQpID8gcmFuZ2UuYW5pbWF0aW9uIDogdHJ1ZTtcbiAgICB0aGlzLnJhbmdlLnNldFJhbmdlKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGFuaW1hdGlvbik7XG4gIH1cbiAgZWxzZSB7XG4gICAgYW5pbWF0aW9uID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRpb24gIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmFuaW1hdGlvbiA6IHRydWU7XG4gICAgdGhpcy5yYW5nZS5zZXRSYW5nZShzdGFydCwgZW5kLCBhbmltYXRpb24pO1xuICB9XG59O1xuXG4vKipcbiAqIE1vdmUgdGhlIHdpbmRvdyBzdWNoIHRoYXQgZ2l2ZW4gdGltZSBpcyBjZW50ZXJlZCBvbiBzY3JlZW4uXG4gKiBAcGFyYW0ge0RhdGUgfCBOdW1iZXIgfCBTdHJpbmd9IHRpbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRpb246IGJvb2xlYW4gfCB7ZHVyYXRpb246IG51bWJlciwgZWFzaW5nRnVuY3Rpb246IHN0cmluZ31gXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21vb3RobHkgdG8gdGhlIG5ldyB3aW5kb3cuIEFuIG9iamVjdCBjYW4gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzICdlYXNlSW5PdXRRdWFkJy5cbiAqL1xuQ29yZS5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24odGltZSwgb3B0aW9ucykge1xuICB2YXIgaW50ZXJ2YWwgPSB0aGlzLnJhbmdlLmVuZCAtIHRoaXMucmFuZ2Uuc3RhcnQ7XG4gIHZhciB0ID0gdXRpbC5jb252ZXJ0KHRpbWUsICdEYXRlJykudmFsdWVPZigpO1xuXG4gIHZhciBzdGFydCA9IHQgLSBpbnRlcnZhbCAvIDI7XG4gIHZhciBlbmQgPSB0ICsgaW50ZXJ2YWwgLyAyO1xuICB2YXIgYW5pbWF0aW9uID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRpb24gIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmFuaW1hdGlvbiA6IHRydWU7XG5cbiAgdGhpcy5yYW5nZS5zZXRSYW5nZShzdGFydCwgZW5kLCBhbmltYXRpb24pO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHZpc2libGUgd2luZG93XG4gKiBAcmV0dXJuIHt7c3RhcnQ6IERhdGUsIGVuZDogRGF0ZX19ICAgVmlzaWJsZSByYW5nZVxuICovXG5Db3JlLnByb3RvdHlwZS5nZXRXaW5kb3cgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJhbmdlID0gdGhpcy5yYW5nZS5nZXRSYW5nZSgpO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBuZXcgRGF0ZShyYW5nZS5zdGFydCksXG4gICAgZW5kOiBuZXcgRGF0ZShyYW5nZS5lbmQpXG4gIH07XG59O1xuXG4vKipcbiAqIEZvcmNlIGEgcmVkcmF3LiBDYW4gYmUgb3ZlcnJpZGRlbiBieSBpbXBsZW1lbnRhdGlvbnMgb2YgQ29yZVxuICpcbiAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBvdmVycmlkZGVuIG9uIGNvbnN0cnVjdGlvbiB3aXRoIGEgdHJvdHRsZWQgdmVyc2lvblxuICovXG5Db3JlLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcmVkcmF3KCk7XG59O1xuXG4vKipcbiAqIFJlZHJhdyBmb3IgaW50ZXJuYWwgdXNlLiBSZWRyYXdzIGFsbCBjb21wb25lbnRzLiBTZWUgYWxzbyB0aGUgcHVibGljXG4gKiBtZXRob2QgcmVkcmF3LlxuICogQHByb3RlY3RlZFxuICovXG5Db3JlLnByb3RvdHlwZS5fcmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNpemVkID0gZmFsc2U7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICB2YXIgZG9tID0gdGhpcy5kb207XG5cbiAgaWYgKCFkb20pIHJldHVybjsgLy8gd2hlbiBkZXN0cm95ZWRcblxuICBEYXRlVXRpbC51cGRhdGVIaWRkZW5EYXRlcyh0aGlzLm9wdGlvbnMubW9tZW50LCB0aGlzLmJvZHksIHRoaXMub3B0aW9ucy5oaWRkZW5EYXRlcyk7XG5cbiAgLy8gdXBkYXRlIGNsYXNzIG5hbWVzXG4gIGlmIChvcHRpb25zLm9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgdXRpbC5hZGRDbGFzc05hbWUoZG9tLnJvb3QsICd2aXMtdG9wJyk7XG4gICAgdXRpbC5yZW1vdmVDbGFzc05hbWUoZG9tLnJvb3QsICd2aXMtYm90dG9tJyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdXRpbC5yZW1vdmVDbGFzc05hbWUoZG9tLnJvb3QsICd2aXMtdG9wJyk7XG4gICAgdXRpbC5hZGRDbGFzc05hbWUoZG9tLnJvb3QsICd2aXMtYm90dG9tJyk7XG4gIH1cblxuICAvLyB1cGRhdGUgcm9vdCB3aWR0aCBhbmQgaGVpZ2h0IG9wdGlvbnNcbiAgZG9tLnJvb3Quc3R5bGUubWF4SGVpZ2h0ID0gdXRpbC5vcHRpb24uYXNTaXplKG9wdGlvbnMubWF4SGVpZ2h0LCAnJyk7XG4gIGRvbS5yb290LnN0eWxlLm1pbkhlaWdodCA9IHV0aWwub3B0aW9uLmFzU2l6ZShvcHRpb25zLm1pbkhlaWdodCwgJycpO1xuICBkb20ucm9vdC5zdHlsZS53aWR0aCA9IHV0aWwub3B0aW9uLmFzU2l6ZShvcHRpb25zLndpZHRoLCAnJyk7XG5cbiAgLy8gY2FsY3VsYXRlIGJvcmRlciB3aWR0aHNcbiAgcHJvcHMuYm9yZGVyLmxlZnQgICA9IChkb20uY2VudGVyQ29udGFpbmVyLm9mZnNldFdpZHRoIC0gZG9tLmNlbnRlckNvbnRhaW5lci5jbGllbnRXaWR0aCkgLyAyO1xuICBwcm9wcy5ib3JkZXIucmlnaHQgID0gcHJvcHMuYm9yZGVyLmxlZnQ7XG4gIHByb3BzLmJvcmRlci50b3AgICAgPSAoZG9tLmNlbnRlckNvbnRhaW5lci5vZmZzZXRIZWlnaHQgLSBkb20uY2VudGVyQ29udGFpbmVyLmNsaWVudEhlaWdodCkgLyAyO1xuICBwcm9wcy5ib3JkZXIuYm90dG9tID0gcHJvcHMuYm9yZGVyLnRvcDtcbiAgdmFyIGJvcmRlclJvb3RIZWlnaHQ9IGRvbS5yb290Lm9mZnNldEhlaWdodCAtIGRvbS5yb290LmNsaWVudEhlaWdodDtcbiAgdmFyIGJvcmRlclJvb3RXaWR0aCA9IGRvbS5yb290Lm9mZnNldFdpZHRoIC0gZG9tLnJvb3QuY2xpZW50V2lkdGg7XG5cbiAgLy8gd29ya2Fyb3VuZCBmb3IgYSBidWcgaW4gSUU6IHRoZSBjbGllbnRXaWR0aCBvZiBhbiBlbGVtZW50IHdpdGhcbiAgLy8gYSBoZWlnaHQ6MHB4IGFuZCBvdmVyZmxvdzpoaWRkZW4gaXMgbm90IGNhbGN1bGF0ZWQgYW5kIGFsd2F5cyBoYXMgdmFsdWUgMFxuICBpZiAoZG9tLmNlbnRlckNvbnRhaW5lci5jbGllbnRIZWlnaHQgPT09IDApIHtcbiAgICBwcm9wcy5ib3JkZXIubGVmdCA9IHByb3BzLmJvcmRlci50b3A7XG4gICAgcHJvcHMuYm9yZGVyLnJpZ2h0ICA9IHByb3BzLmJvcmRlci5sZWZ0O1xuICB9XG4gIGlmIChkb20ucm9vdC5jbGllbnRIZWlnaHQgPT09IDApIHtcbiAgICBib3JkZXJSb290V2lkdGggPSBib3JkZXJSb290SGVpZ2h0O1xuICB9XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBoZWlnaHRzLiBJZiBhbnkgb2YgdGhlIHNpZGUgcGFuZWxzIGlzIGVtcHR5LCB3ZSBzZXQgdGhlIGhlaWdodCB0b1xuICAvLyBtaW51cyB0aGUgYm9yZGVyIHdpZHRoLCBzdWNoIHRoYXQgdGhlIGJvcmRlciB3aWxsIGJlIGludmlzaWJsZVxuICBwcm9wcy5jZW50ZXIuaGVpZ2h0ID0gZG9tLmNlbnRlci5vZmZzZXRIZWlnaHQ7XG4gIHByb3BzLmxlZnQuaGVpZ2h0ICAgPSBkb20ubGVmdC5vZmZzZXRIZWlnaHQ7XG4gIHByb3BzLnJpZ2h0LmhlaWdodCAgPSBkb20ucmlnaHQub2Zmc2V0SGVpZ2h0O1xuICBwcm9wcy50b3AuaGVpZ2h0ICAgID0gZG9tLnRvcC5jbGllbnRIZWlnaHQgICAgfHwgLXByb3BzLmJvcmRlci50b3A7XG4gIHByb3BzLmJvdHRvbS5oZWlnaHQgPSBkb20uYm90dG9tLmNsaWVudEhlaWdodCB8fCAtcHJvcHMuYm9yZGVyLmJvdHRvbTtcblxuICAvLyBUT0RPOiBjb21wZW5zYXRlIGJvcmRlcnMgd2hlbiBhbnkgb2YgdGhlIHBhbmVscyBpcyBlbXB0eS5cblxuICAvLyBhcHBseSBhdXRvIGhlaWdodFxuICAvLyBUT0RPOiBvbmx5IGNhbGN1bGF0ZSBhdXRvSGVpZ2h0IHdoZW4gbmVlZGVkIChlbHNlIHdlIGNhdXNlIGFuIGV4dHJhIHJlZmxvdy9yZXBhaW50IG9mIHRoZSBET00pXG4gIHZhciBjb250ZW50SGVpZ2h0ID0gTWF0aC5tYXgocHJvcHMubGVmdC5oZWlnaHQsIHByb3BzLmNlbnRlci5oZWlnaHQsIHByb3BzLnJpZ2h0LmhlaWdodCk7XG4gIHZhciBhdXRvSGVpZ2h0ID0gcHJvcHMudG9wLmhlaWdodCArIGNvbnRlbnRIZWlnaHQgKyBwcm9wcy5ib3R0b20uaGVpZ2h0ICtcbiAgICBib3JkZXJSb290SGVpZ2h0ICsgcHJvcHMuYm9yZGVyLnRvcCArIHByb3BzLmJvcmRlci5ib3R0b207XG4gIGRvbS5yb290LnN0eWxlLmhlaWdodCA9IHV0aWwub3B0aW9uLmFzU2l6ZShvcHRpb25zLmhlaWdodCwgYXV0b0hlaWdodCArICdweCcpO1xuXG4gIC8vIGNhbGN1bGF0ZSBoZWlnaHRzIG9mIHRoZSBjb250ZW50IHBhbmVsc1xuICBwcm9wcy5yb290LmhlaWdodCA9IGRvbS5yb290Lm9mZnNldEhlaWdodDtcbiAgcHJvcHMuYmFja2dyb3VuZC5oZWlnaHQgPSBwcm9wcy5yb290LmhlaWdodCAtIGJvcmRlclJvb3RIZWlnaHQ7XG4gIHZhciBjb250YWluZXJIZWlnaHQgPSBwcm9wcy5yb290LmhlaWdodCAtIHByb3BzLnRvcC5oZWlnaHQgLSBwcm9wcy5ib3R0b20uaGVpZ2h0IC1cbiAgICBib3JkZXJSb290SGVpZ2h0O1xuICBwcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0ICA9IGNvbnRhaW5lckhlaWdodDtcbiAgcHJvcHMubGVmdENvbnRhaW5lci5oZWlnaHQgICAgPSBjb250YWluZXJIZWlnaHQ7XG4gIHByb3BzLnJpZ2h0Q29udGFpbmVyLmhlaWdodCAgID0gcHJvcHMubGVmdENvbnRhaW5lci5oZWlnaHQ7XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSB3aWR0aHMgb2YgdGhlIHBhbmVsc1xuICBwcm9wcy5yb290LndpZHRoID0gZG9tLnJvb3Qub2Zmc2V0V2lkdGg7XG4gIHByb3BzLmJhY2tncm91bmQud2lkdGggPSBwcm9wcy5yb290LndpZHRoIC0gYm9yZGVyUm9vdFdpZHRoO1xuICBwcm9wcy5sZWZ0LndpZHRoID0gZG9tLmxlZnRDb250YWluZXIuY2xpZW50V2lkdGggICB8fCAtcHJvcHMuYm9yZGVyLmxlZnQ7XG4gIHByb3BzLmxlZnRDb250YWluZXIud2lkdGggPSBwcm9wcy5sZWZ0LndpZHRoO1xuICBwcm9wcy5yaWdodC53aWR0aCA9IGRvbS5yaWdodENvbnRhaW5lci5jbGllbnRXaWR0aCB8fCAtcHJvcHMuYm9yZGVyLnJpZ2h0O1xuICBwcm9wcy5yaWdodENvbnRhaW5lci53aWR0aCA9IHByb3BzLnJpZ2h0LndpZHRoO1xuICB2YXIgY2VudGVyV2lkdGggPSBwcm9wcy5yb290LndpZHRoIC0gcHJvcHMubGVmdC53aWR0aCAtIHByb3BzLnJpZ2h0LndpZHRoIC0gYm9yZGVyUm9vdFdpZHRoO1xuICBwcm9wcy5jZW50ZXIud2lkdGggICAgICAgICAgPSBjZW50ZXJXaWR0aDtcbiAgcHJvcHMuY2VudGVyQ29udGFpbmVyLndpZHRoID0gY2VudGVyV2lkdGg7XG4gIHByb3BzLnRvcC53aWR0aCAgICAgICAgICAgICA9IGNlbnRlcldpZHRoO1xuICBwcm9wcy5ib3R0b20ud2lkdGggICAgICAgICAgPSBjZW50ZXJXaWR0aDtcblxuICAvLyByZXNpemUgdGhlIHBhbmVsc1xuICBkb20uYmFja2dyb3VuZC5zdHlsZS5oZWlnaHQgICAgICAgICAgID0gcHJvcHMuYmFja2dyb3VuZC5oZWlnaHQgKyAncHgnO1xuICBkb20uYmFja2dyb3VuZFZlcnRpY2FsLnN0eWxlLmhlaWdodCAgID0gcHJvcHMuYmFja2dyb3VuZC5oZWlnaHQgKyAncHgnO1xuICBkb20uYmFja2dyb3VuZEhvcml6b250YWwuc3R5bGUuaGVpZ2h0ID0gcHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCArICdweCc7XG4gIGRvbS5jZW50ZXJDb250YWluZXIuc3R5bGUuaGVpZ2h0ICAgICAgPSBwcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0ICsgJ3B4JztcbiAgZG9tLmxlZnRDb250YWluZXIuc3R5bGUuaGVpZ2h0ICAgICAgICA9IHByb3BzLmxlZnRDb250YWluZXIuaGVpZ2h0ICsgJ3B4JztcbiAgZG9tLnJpZ2h0Q29udGFpbmVyLnN0eWxlLmhlaWdodCAgICAgICA9IHByb3BzLnJpZ2h0Q29udGFpbmVyLmhlaWdodCArICdweCc7XG5cbiAgZG9tLmJhY2tncm91bmQuc3R5bGUud2lkdGggICAgICAgICAgICA9IHByb3BzLmJhY2tncm91bmQud2lkdGggKyAncHgnO1xuICBkb20uYmFja2dyb3VuZFZlcnRpY2FsLnN0eWxlLndpZHRoICAgID0gcHJvcHMuY2VudGVyQ29udGFpbmVyLndpZHRoICsgJ3B4JztcbiAgZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLnN0eWxlLndpZHRoICA9IHByb3BzLmJhY2tncm91bmQud2lkdGggKyAncHgnO1xuICBkb20uY2VudGVyQ29udGFpbmVyLnN0eWxlLndpZHRoICAgICAgID0gcHJvcHMuY2VudGVyLndpZHRoICsgJ3B4JztcbiAgZG9tLnRvcC5zdHlsZS53aWR0aCAgICAgICAgICAgICAgICAgICA9IHByb3BzLnRvcC53aWR0aCArICdweCc7XG4gIGRvbS5ib3R0b20uc3R5bGUud2lkdGggICAgICAgICAgICAgICAgPSBwcm9wcy5ib3R0b20ud2lkdGggKyAncHgnO1xuXG4gIC8vIHJlcG9zaXRpb24gdGhlIHBhbmVsc1xuICBkb20uYmFja2dyb3VuZC5zdHlsZS5sZWZ0ICAgICAgICAgICA9ICcwJztcbiAgZG9tLmJhY2tncm91bmQuc3R5bGUudG9wICAgICAgICAgICAgPSAnMCc7XG4gIGRvbS5iYWNrZ3JvdW5kVmVydGljYWwuc3R5bGUubGVmdCAgID0gKHByb3BzLmxlZnQud2lkdGggKyBwcm9wcy5ib3JkZXIubGVmdCkgKyAncHgnO1xuICBkb20uYmFja2dyb3VuZFZlcnRpY2FsLnN0eWxlLnRvcCAgICA9ICcwJztcbiAgZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLnN0eWxlLmxlZnQgPSAnMCc7XG4gIGRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbC5zdHlsZS50b3AgID0gcHJvcHMudG9wLmhlaWdodCArICdweCc7XG4gIGRvbS5jZW50ZXJDb250YWluZXIuc3R5bGUubGVmdCAgICAgID0gcHJvcHMubGVmdC53aWR0aCArICdweCc7XG4gIGRvbS5jZW50ZXJDb250YWluZXIuc3R5bGUudG9wICAgICAgID0gcHJvcHMudG9wLmhlaWdodCArICdweCc7XG4gIGRvbS5sZWZ0Q29udGFpbmVyLnN0eWxlLmxlZnQgICAgICAgID0gJzAnO1xuICBkb20ubGVmdENvbnRhaW5lci5zdHlsZS50b3AgICAgICAgICA9IHByb3BzLnRvcC5oZWlnaHQgKyAncHgnO1xuICBkb20ucmlnaHRDb250YWluZXIuc3R5bGUubGVmdCAgICAgICA9IChwcm9wcy5sZWZ0LndpZHRoICsgcHJvcHMuY2VudGVyLndpZHRoKSArICdweCc7XG4gIGRvbS5yaWdodENvbnRhaW5lci5zdHlsZS50b3AgICAgICAgID0gcHJvcHMudG9wLmhlaWdodCArICdweCc7XG4gIGRvbS50b3Auc3R5bGUubGVmdCAgICAgICAgICAgICAgICAgID0gcHJvcHMubGVmdC53aWR0aCArICdweCc7XG4gIGRvbS50b3Auc3R5bGUudG9wICAgICAgICAgICAgICAgICAgID0gJzAnO1xuICBkb20uYm90dG9tLnN0eWxlLmxlZnQgICAgICAgICAgICAgICA9IHByb3BzLmxlZnQud2lkdGggKyAncHgnO1xuICBkb20uYm90dG9tLnN0eWxlLnRvcCAgICAgICAgICAgICAgICA9IChwcm9wcy50b3AuaGVpZ2h0ICsgcHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCkgKyAncHgnO1xuXG4gIC8vIHVwZGF0ZSB0aGUgc2Nyb2xsVG9wLCBmZWFzaWJsZSByYW5nZSBmb3IgdGhlIG9mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAvLyB3aGVuIHRoZSBoZWlnaHQgb2YgdGhlIENvcmUgb3Igb2YgdGhlIGNvbnRlbnRzIG9mIHRoZSBjZW50ZXIgY2hhbmdlZFxuICB0aGlzLl91cGRhdGVTY3JvbGxUb3AoKTtcblxuICAvLyByZXBvc2l0aW9uIHRoZSBzY3JvbGxhYmxlIGNvbnRlbnRzXG4gIHZhciBvZmZzZXQgPSB0aGlzLnByb3BzLnNjcm9sbFRvcDtcbiAgaWYgKG9wdGlvbnMub3JpZW50YXRpb24uaXRlbSAhPSAndG9wJykge1xuICAgIG9mZnNldCArPSBNYXRoLm1heCh0aGlzLnByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgLSB0aGlzLnByb3BzLmNlbnRlci5oZWlnaHQgLVxuICAgICAgdGhpcy5wcm9wcy5ib3JkZXIudG9wIC0gdGhpcy5wcm9wcy5ib3JkZXIuYm90dG9tLCAwKTtcbiAgfVxuICBkb20uY2VudGVyLnN0eWxlLmxlZnQgPSAnMCc7XG4gIGRvbS5jZW50ZXIuc3R5bGUudG9wICA9IG9mZnNldCArICdweCc7XG4gIGRvbS5sZWZ0LnN0eWxlLmxlZnQgICA9ICcwJztcbiAgZG9tLmxlZnQuc3R5bGUudG9wICAgID0gb2Zmc2V0ICsgJ3B4JztcbiAgZG9tLnJpZ2h0LnN0eWxlLmxlZnQgID0gJzAnO1xuICBkb20ucmlnaHQuc3R5bGUudG9wICAgPSBvZmZzZXQgKyAncHgnO1xuXG4gIC8vIHNob3cgc2hhZG93cyB3aGVuIHZlcnRpY2FsIHNjcm9sbGluZyBpcyBhdmFpbGFibGVcbiAgdmFyIHZpc2liaWxpdHlUb3AgPSB0aGlzLnByb3BzLnNjcm9sbFRvcCA9PSAwID8gJ2hpZGRlbicgOiAnJztcbiAgdmFyIHZpc2liaWxpdHlCb3R0b20gPSB0aGlzLnByb3BzLnNjcm9sbFRvcCA9PSB0aGlzLnByb3BzLnNjcm9sbFRvcE1pbiA/ICdoaWRkZW4nIDogJyc7XG4gIGRvbS5zaGFkb3dUb3Auc3R5bGUudmlzaWJpbGl0eSAgICAgICAgICA9IHZpc2liaWxpdHlUb3A7XG4gIGRvbS5zaGFkb3dCb3R0b20uc3R5bGUudmlzaWJpbGl0eSAgICAgICA9IHZpc2liaWxpdHlCb3R0b207XG4gIGRvbS5zaGFkb3dUb3BMZWZ0LnN0eWxlLnZpc2liaWxpdHkgICAgICA9IHZpc2liaWxpdHlUb3A7XG4gIGRvbS5zaGFkb3dCb3R0b21MZWZ0LnN0eWxlLnZpc2liaWxpdHkgICA9IHZpc2liaWxpdHlCb3R0b207XG4gIGRvbS5zaGFkb3dUb3BSaWdodC5zdHlsZS52aXNpYmlsaXR5ICAgICA9IHZpc2liaWxpdHlUb3A7XG4gIGRvbS5zaGFkb3dCb3R0b21SaWdodC5zdHlsZS52aXNpYmlsaXR5ICA9IHZpc2liaWxpdHlCb3R0b207XG5cbiAgLy8gcmVkcmF3IGFsbCBjb21wb25lbnRzXG4gIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICByZXNpemVkID0gY29tcG9uZW50LnJlZHJhdygpIHx8IHJlc2l6ZWQ7XG4gIH0pO1xuICBpZiAocmVzaXplZCkge1xuICAgIC8vIGtlZXAgcmVwYWludGluZyB1bnRpbCBhbGwgc2l6ZXMgYXJlIHNldHRsZWRcbiAgICB2YXIgTUFYX1JFRFJBV1MgPSAzOyAvLyBtYXhpbXVtIG51bWJlciBvZiBjb25zZWN1dGl2ZSByZWRyYXdzXG4gICAgaWYgKHRoaXMucmVkcmF3Q291bnQgPCBNQVhfUkVEUkFXUykge1xuICAgICAgdGhpcy5yZWRyYXdDb3VudCsrO1xuICAgICAgdGhpcy5fcmVkcmF3KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IGluZmluaXRlIGxvb3AgaW4gcmVkcmF3PycpO1xuICAgIH1cbiAgICB0aGlzLnJlZHJhd0NvdW50ID0gMDtcbiAgfVxufTtcblxuLy8gVE9ETzogZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMS4wLCByZW1vdmUgc29tZSBkYXlcbkNvcmUucHJvdG90eXBlLnJlcGFpbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gcmVwYWludCBpcyBkZXByZWNhdGVkLiBVc2UgcmVkcmF3IGluc3RlYWQuJyk7XG59O1xuXG4vKipcbiAqIFNldCBhIGN1cnJlbnQgdGltZS4gVGhpcyBjYW4gYmUgdXNlZCBmb3IgZXhhbXBsZSB0byBlbnN1cmUgdGhhdCBhIGNsaWVudCdzXG4gKiB0aW1lIGlzIHN5bmNocm9uaXplZCB3aXRoIGEgc2hhcmVkIHNlcnZlciB0aW1lLlxuICogT25seSBhcHBsaWNhYmxlIHdoZW4gb3B0aW9uIGBzaG93Q3VycmVudFRpbWVgIGlzIHRydWUuXG4gKiBAcGFyYW0ge0RhdGUgfCBTdHJpbmcgfCBOdW1iZXJ9IHRpbWUgICAgIEEgRGF0ZSwgdW5peCB0aW1lc3RhbXAsIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElTTyBkYXRlIHN0cmluZy5cbiAqL1xuQ29yZS5wcm90b3R5cGUuc2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbih0aW1lKSB7XG4gIGlmICghdGhpcy5jdXJyZW50VGltZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9uIHNob3dDdXJyZW50VGltZSBtdXN0IGJlIHRydWUnKTtcbiAgfVxuXG4gIHRoaXMuY3VycmVudFRpbWUuc2V0Q3VycmVudFRpbWUodGltZSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB0aW1lLlxuICogT25seSBhcHBsaWNhYmxlIHdoZW4gb3B0aW9uIGBzaG93Q3VycmVudFRpbWVgIGlzIHRydWUuXG4gKiBAcmV0dXJuIHtEYXRlfSBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUuXG4gKi9cbkNvcmUucHJvdG90eXBlLmdldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jdXJyZW50VGltZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9uIHNob3dDdXJyZW50VGltZSBtdXN0IGJlIHRydWUnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnJlbnRUaW1lLmdldEN1cnJlbnRUaW1lKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBwb3NpdGlvbiBvbiBzY3JlZW4gKHBpeGVscykgdG8gYSBkYXRldGltZVxuICogQHBhcmFtIHtpbnR9ICAgICB4ICAgIFBvc2l0aW9uIG9uIHRoZSBzY3JlZW4gaW4gcGl4ZWxzXG4gKiBAcmV0dXJuIHtEYXRlfSAgIHRpbWUgVGhlIGRhdGV0aW1lIHRoZSBjb3JyZXNwb25kcyB3aXRoIGdpdmVuIHBvc2l0aW9uIHhcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuLy8gVE9ETzogbW92ZSB0aGlzIGZ1bmN0aW9uIHRvIFJhbmdlXG5Db3JlLnByb3RvdHlwZS5fdG9UaW1lID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gRGF0ZVV0aWwudG9UaW1lKHRoaXMsIHgsIHRoaXMucHJvcHMuY2VudGVyLndpZHRoKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHBvc2l0aW9uIG9uIHRoZSBnbG9iYWwgc2NyZWVuIChwaXhlbHMpIHRvIGEgZGF0ZXRpbWVcbiAqIEBwYXJhbSB7aW50fSAgICAgeCAgICBQb3NpdGlvbiBvbiB0aGUgc2NyZWVuIGluIHBpeGVsc1xuICogQHJldHVybiB7RGF0ZX0gICB0aW1lIFRoZSBkYXRldGltZSB0aGUgY29ycmVzcG9uZHMgd2l0aCBnaXZlbiBwb3NpdGlvbiB4XG4gKiBAcHJvdGVjdGVkXG4gKi9cbi8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiB0byBSYW5nZVxuQ29yZS5wcm90b3R5cGUuX3RvR2xvYmFsVGltZSA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIERhdGVVdGlsLnRvVGltZSh0aGlzLCB4LCB0aGlzLnByb3BzLnJvb3Qud2lkdGgpO1xuICAvL3ZhciBjb252ZXJzaW9uID0gdGhpcy5yYW5nZS5jb252ZXJzaW9uKHRoaXMucHJvcHMucm9vdC53aWR0aCk7XG4gIC8vcmV0dXJuIG5ldyBEYXRlKHggLyBjb252ZXJzaW9uLnNjYWxlICsgY29udmVyc2lvbi5vZmZzZXQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgZGF0ZXRpbWUgKERhdGUgb2JqZWN0KSBpbnRvIGEgcG9zaXRpb24gb24gdGhlIHNjcmVlblxuICogQHBhcmFtIHtEYXRlfSAgIHRpbWUgQSBkYXRlXG4gKiBAcmV0dXJuIHtpbnR9ICAgeCAgICBUaGUgcG9zaXRpb24gb24gdGhlIHNjcmVlbiBpbiBwaXhlbHMgd2hpY2ggY29ycmVzcG9uZHNcbiAqICAgICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIGdpdmVuIGRhdGUuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbi8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiB0byBSYW5nZVxuQ29yZS5wcm90b3R5cGUuX3RvU2NyZWVuID0gZnVuY3Rpb24odGltZSkge1xuICByZXR1cm4gRGF0ZVV0aWwudG9TY3JlZW4odGhpcywgdGltZSwgdGhpcy5wcm9wcy5jZW50ZXIud2lkdGgpO1xufTtcblxuXG5cbi8qKlxuICogQ29udmVydCBhIGRhdGV0aW1lIChEYXRlIG9iamVjdCkgaW50byBhIHBvc2l0aW9uIG9uIHRoZSByb290XG4gKiBUaGlzIGlzIHVzZWQgdG8gZ2V0IHRoZSBwaXhlbCBkZW5zaXR5IGVzdGltYXRlIGZvciB0aGUgc2NyZWVuLCBub3QgdGhlIGNlbnRlciBwYW5lbFxuICogQHBhcmFtIHtEYXRlfSAgIHRpbWUgQSBkYXRlXG4gKiBAcmV0dXJuIHtpbnR9ICAgeCAgICBUaGUgcG9zaXRpb24gb24gcm9vdCBpbiBwaXhlbHMgd2hpY2ggY29ycmVzcG9uZHNcbiAqICAgICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIGdpdmVuIGRhdGUuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbi8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiB0byBSYW5nZVxuQ29yZS5wcm90b3R5cGUuX3RvR2xvYmFsU2NyZWVuID0gZnVuY3Rpb24odGltZSkge1xuICByZXR1cm4gRGF0ZVV0aWwudG9TY3JlZW4odGhpcywgdGltZSwgdGhpcy5wcm9wcy5yb290LndpZHRoKTtcbiAgLy92YXIgY29udmVyc2lvbiA9IHRoaXMucmFuZ2UuY29udmVyc2lvbih0aGlzLnByb3BzLnJvb3Qud2lkdGgpO1xuICAvL3JldHVybiAodGltZS52YWx1ZU9mKCkgLSBjb252ZXJzaW9uLm9mZnNldCkgKiBjb252ZXJzaW9uLnNjYWxlO1xufTtcblxuXG4vKipcbiAqIEluaXRpYWxpemUgd2F0Y2hpbmcgd2hlbiBvcHRpb24gYXV0b1Jlc2l6ZSBpcyB0cnVlXG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5faW5pdEF1dG9SZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuYXV0b1Jlc2l6ZSA9PSB0cnVlKSB7XG4gICAgdGhpcy5fc3RhcnRBdXRvUmVzaXplKCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5fc3RvcEF1dG9SZXNpemUoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYXRjaCBmb3IgY2hhbmdlcyBpbiB0aGUgc2l6ZSBvZiB0aGUgY29udGFpbmVyLiBPbiByZXNpemUsIHRoZSBQYW5lbCB3aWxsXG4gKiBhdXRvbWF0aWNhbGx5IHJlZHJhdyBpdHNlbGYuXG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fc3RhcnRBdXRvUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIHRoaXMuX3N0b3BBdXRvUmVzaXplKCk7XG5cbiAgdGhpcy5fb25SZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAobWUub3B0aW9ucy5hdXRvUmVzaXplICE9IHRydWUpIHtcbiAgICAgIC8vIHN0b3Agd2F0Y2hpbmcgd2hlbiB0aGUgb3B0aW9uIGF1dG9SZXNpemUgaXMgY2hhbmdlZCB0byBmYWxzZVxuICAgICAgbWUuX3N0b3BBdXRvUmVzaXplKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1lLmRvbS5yb290KSB7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBmcmFtZSBpcyByZXNpemVkXG4gICAgICAvLyBOb3RlOiB3ZSBjb21wYXJlIG9mZnNldFdpZHRoIGhlcmUsIG5vdCBjbGllbnRXaWR0aC4gRm9yIHNvbWUgcmVhc29uLFxuICAgICAgLy8gSUUgZG9lcyBub3QgcmVzdG9yZSB0aGUgY2xpZW50V2lkdGggZnJvbSAwIHRvIHRoZSBhY3R1YWwgd2lkdGggYWZ0ZXJcbiAgICAgIC8vIGNoYW5naW5nIHRoZSB0aW1lbGluZSdzIGNvbnRhaW5lciBkaXNwbGF5IHN0eWxlIGZyb20gbm9uZSB0byB2aXNpYmxlXG4gICAgICBpZiAoKG1lLmRvbS5yb290Lm9mZnNldFdpZHRoICE9IG1lLnByb3BzLmxhc3RXaWR0aCkgfHxcbiAgICAgICAgKG1lLmRvbS5yb290Lm9mZnNldEhlaWdodCAhPSBtZS5wcm9wcy5sYXN0SGVpZ2h0KSkge1xuICAgICAgICBtZS5wcm9wcy5sYXN0V2lkdGggPSBtZS5kb20ucm9vdC5vZmZzZXRXaWR0aDtcbiAgICAgICAgbWUucHJvcHMubGFzdEhlaWdodCA9IG1lLmRvbS5yb290Lm9mZnNldEhlaWdodDtcblxuICAgICAgICBtZS5lbWl0KCdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyIHRvIHdpbmRvdyByZXNpemVcbiAgdXRpbC5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplKTtcblxuICB0aGlzLndhdGNoVGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLl9vblJlc2l6ZSwgMTAwMCk7XG59O1xuXG4vKipcbiAqIFN0b3Agd2F0Y2hpbmcgZm9yIGEgcmVzaXplIG9mIHRoZSBmcmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbkNvcmUucHJvdG90eXBlLl9zdG9wQXV0b1Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMud2F0Y2hUaW1lcikge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy53YXRjaFRpbWVyKTtcbiAgICB0aGlzLndhdGNoVGltZXIgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93LnJlc2l6ZVxuICBpZiAodGhpcy5fb25SZXNpemUpIHtcbiAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUpO1xuICAgIHRoaXMuX29uUmVzaXplID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydCBtb3ZpbmcgdGhlIHRpbWVsaW5lIHZlcnRpY2FsbHlcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fb25Ub3VjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICB0aGlzLnRvdWNoLmFsbG93RHJhZ2dpbmcgPSB0cnVlO1xuICB0aGlzLnRvdWNoLmluaXRpYWxTY3JvbGxUb3AgPSB0aGlzLnByb3BzLnNjcm9sbFRvcDtcbn07XG5cbi8qKlxuICogU3RhcnQgbW92aW5nIHRoZSB0aW1lbGluZSB2ZXJ0aWNhbGx5XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX29uUGluY2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdGhpcy50b3VjaC5hbGxvd0RyYWdnaW5nID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIE1vdmUgdGhlIHRpbWVsaW5lIHZlcnRpY2FsbHlcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIHJlZnVzZSB0byBkcmFnIHdoZW4gd2Ugd2hlcmUgcGluY2hpbmcgdG8gcHJldmVudCB0aGUgdGltZWxpbmUgbWFrZSBhIGp1bXBcbiAgLy8gd2hlbiByZWxlYXNpbmcgdGhlIGZpbmdlcnMgaW4gb3Bwb3NpdGUgb3JkZXIgZnJvbSB0aGUgdG91Y2ggc2NyZWVuXG4gIGlmICghdGhpcy50b3VjaC5hbGxvd0RyYWdnaW5nKSByZXR1cm47XG5cbiAgdmFyIGRlbHRhID0gZXZlbnQuZGVsdGFZO1xuXG4gIHZhciBvbGRTY3JvbGxUb3AgPSB0aGlzLl9nZXRTY3JvbGxUb3AoKTtcbiAgdmFyIG5ld1Njcm9sbFRvcCA9IHRoaXMuX3NldFNjcm9sbFRvcCh0aGlzLnRvdWNoLmluaXRpYWxTY3JvbGxUb3AgKyBkZWx0YSk7XG5cblxuICBpZiAobmV3U2Nyb2xsVG9wICE9IG9sZFNjcm9sbFRvcCkge1xuICAgIHRoaXMuX3JlZHJhdygpOyAvLyBUT0RPOiB0aGlzIGNhdXNlcyB0d28gcmVkcmF3cyB3aGVuIGRyYWdnaW5nLCB0aGUgb3RoZXIgaXMgdHJpZ2dlcmVkIGJ5IHJhbmdlY2hhbmdlIGFscmVhZHlcbiAgICB0aGlzLmVtaXQoXCJ2ZXJ0aWNhbERyYWdcIik7XG4gIH1cbn07XG5cbi8qKlxuICogQXBwbHkgYSBzY3JvbGxUb3BcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGxUb3BcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNjcm9sbFRvcCAgUmV0dXJucyB0aGUgYXBwbGllZCBzY3JvbGxUb3BcbiAqIEBwcml2YXRlXG4gKi9cbkNvcmUucHJvdG90eXBlLl9zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoc2Nyb2xsVG9wKSB7XG4gIHRoaXMucHJvcHMuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICB0aGlzLl91cGRhdGVTY3JvbGxUb3AoKTtcbiAgcmV0dXJuIHRoaXMucHJvcHMuc2Nyb2xsVG9wO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGN1cnJlbnQgc2Nyb2xsVG9wIHdoZW4gdGhlIGhlaWdodCBvZiAgdGhlIGNvbnRhaW5lcnMgaGFzIGJlZW4gY2hhbmdlZFxuICogQHJldHVybnMge051bWJlcn0gc2Nyb2xsVG9wICBSZXR1cm5zIHRoZSBhcHBsaWVkIHNjcm9sbFRvcFxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX3VwZGF0ZVNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gcmVjYWxjdWxhdGUgdGhlIHNjcm9sbFRvcE1pblxuICB2YXIgc2Nyb2xsVG9wTWluID0gTWF0aC5taW4odGhpcy5wcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0IC0gdGhpcy5wcm9wcy5jZW50ZXIuaGVpZ2h0LCAwKTsgLy8gaXMgbmVnYXRpdmUgb3IgemVyb1xuICBpZiAoc2Nyb2xsVG9wTWluICE9IHRoaXMucHJvcHMuc2Nyb2xsVG9wTWluKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBib3R0b20gb3JpZW50YXRpb24sIGNoYW5nZSB0aGUgc2Nyb2xsVG9wIHN1Y2ggdGhhdCB0aGUgY29udGVudHNcbiAgICAvLyBkbyBub3QgbW92ZSByZWxhdGl2ZSB0byB0aGUgdGltZSBheGlzIGF0IHRoZSBib3R0b21cbiAgICBpZiAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gIT0gJ3RvcCcpIHtcbiAgICAgIHRoaXMucHJvcHMuc2Nyb2xsVG9wICs9IChzY3JvbGxUb3BNaW4gLSB0aGlzLnByb3BzLnNjcm9sbFRvcE1pbik7XG4gICAgfVxuICAgIHRoaXMucHJvcHMuc2Nyb2xsVG9wTWluID0gc2Nyb2xsVG9wTWluO1xuICB9XG5cbiAgLy8gbGltaXQgdGhlIHNjcm9sbFRvcCB0byB0aGUgZmVhc2libGUgc2Nyb2xsIHJhbmdlXG4gIGlmICh0aGlzLnByb3BzLnNjcm9sbFRvcCA+IDApIHRoaXMucHJvcHMuc2Nyb2xsVG9wID0gMDtcbiAgaWYgKHRoaXMucHJvcHMuc2Nyb2xsVG9wIDwgc2Nyb2xsVG9wTWluKSB0aGlzLnByb3BzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcE1pbjtcblxuICByZXR1cm4gdGhpcy5wcm9wcy5zY3JvbGxUb3A7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBzY3JvbGxUb3BcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNjcm9sbFRvcFxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX2dldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucHJvcHMuc2Nyb2xsVG9wO1xufTtcblxuLyoqXG4gKiBMb2FkIGEgY29uZmlndXJhdG9yXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fY3JlYXRlQ29uZmlndXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgYWJzdHJhY3QgbWV0aG9kIF9jcmVhdGVDb25maWd1cmF0b3InKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29yZTtcbiJdfQ==
},{"../DataSet":15,"../DataView":16,"../hammerUtil":18,"../module/hammer":19,"../shared/Activator":22,"../util":46,"./DateUtil":27,"./Range":28,"./component/CustomTime":35,"./component/ItemSet":37,"./component/TimeAxis":38,"emitter-component":10}],27:[function(require,module,exports){

/**
 * used in Core to convert the options into a volatile variable
 * 
 * @param {function} moment
 * @param {Object} body
 * @param {Array | Object} hiddenDates
 */
"use strict";

exports.convertHiddenOptions = function (moment, body, hiddenDates) {
  if (hiddenDates && !Array.isArray(hiddenDates)) {
    return exports.convertHiddenOptions(moment, body, [hiddenDates]);
  }

  body.hiddenDates = [];
  if (hiddenDates) {
    if (Array.isArray(hiddenDates) == true) {
      for (var i = 0; i < hiddenDates.length; i++) {
        if (hiddenDates[i].repeat === undefined) {
          var dateItem = {};
          dateItem.start = moment(hiddenDates[i].start).toDate().valueOf();
          dateItem.end = moment(hiddenDates[i].end).toDate().valueOf();
          body.hiddenDates.push(dateItem);
        }
      }
      body.hiddenDates.sort(function (a, b) {
        return a.start - b.start;
      }); // sort by start time
    }
  }
};

/**
 * create new entrees for the repeating hidden dates
 * @param {function} moment
 * @param {Object} body
 * @param {Array | Object} hiddenDates
 */
exports.updateHiddenDates = function (moment, body, hiddenDates) {
  if (hiddenDates && !Array.isArray(hiddenDates)) {
    return exports.updateHiddenDates(moment, body, [hiddenDates]);
  }

  if (hiddenDates && body.domProps.centerContainer.width !== undefined) {
    exports.convertHiddenOptions(moment, body, hiddenDates);

    var start = moment(body.range.start);
    var end = moment(body.range.end);

    var totalRange = body.range.end - body.range.start;
    var pixelTime = totalRange / body.domProps.centerContainer.width;

    for (var i = 0; i < hiddenDates.length; i++) {
      if (hiddenDates[i].repeat !== undefined) {
        var startDate = moment(hiddenDates[i].start);
        var endDate = moment(hiddenDates[i].end);

        if (startDate._d == "Invalid Date") {
          throw new Error("Supplied start date is not valid: " + hiddenDates[i].start);
        }
        if (endDate._d == "Invalid Date") {
          throw new Error("Supplied end date is not valid: " + hiddenDates[i].end);
        }

        var duration = endDate - startDate;
        if (duration >= 4 * pixelTime) {

          var offset = 0;
          var runUntil = end.clone();
          switch (hiddenDates[i].repeat) {
            case "daily":
              // case of time
              if (startDate.day() != endDate.day()) {
                offset = 1;
              }
              startDate.dayOfYear(start.dayOfYear());
              startDate.year(start.year());
              startDate.subtract(7, 'days');

              endDate.dayOfYear(start.dayOfYear());
              endDate.year(start.year());
              endDate.subtract(7 - offset, 'days');

              runUntil.add(1, 'weeks');
              break;
            case "weekly":
              var dayOffset = endDate.diff(startDate, 'days');
              var day = startDate.day();

              // set the start date to the range.start
              startDate.date(start.date());
              startDate.month(start.month());
              startDate.year(start.year());
              endDate = startDate.clone();

              // force
              startDate.day(day);
              endDate.day(day);
              endDate.add(dayOffset, 'days');

              startDate.subtract(1, 'weeks');
              endDate.subtract(1, 'weeks');

              runUntil.add(1, 'weeks');
              break;
            case "monthly":
              if (startDate.month() != endDate.month()) {
                offset = 1;
              }
              startDate.month(start.month());
              startDate.year(start.year());
              startDate.subtract(1, 'months');

              endDate.month(start.month());
              endDate.year(start.year());
              endDate.subtract(1, 'months');
              endDate.add(offset, 'months');

              runUntil.add(1, 'months');
              break;
            case "yearly":
              if (startDate.year() != endDate.year()) {
                offset = 1;
              }
              startDate.year(start.year());
              startDate.subtract(1, 'years');
              endDate.year(start.year());
              endDate.subtract(1, 'years');
              endDate.add(offset, 'years');

              runUntil.add(1, 'years');
              break;
            default:
              console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
              return;
          }
          while (startDate < runUntil) {
            body.hiddenDates.push({ start: startDate.valueOf(), end: endDate.valueOf() });
            switch (hiddenDates[i].repeat) {
              case "daily":
                startDate.add(1, 'days');
                endDate.add(1, 'days');
                break;
              case "weekly":
                startDate.add(1, 'weeks');
                endDate.add(1, 'weeks');
                break;
              case "monthly":
                startDate.add(1, 'months');
                endDate.add(1, 'months');
                break;
              case "yearly":
                startDate.add(1, 'y');
                endDate.add(1, 'y');
                break;
              default:
                console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
                return;
            }
          }
          body.hiddenDates.push({ start: startDate.valueOf(), end: endDate.valueOf() });
        }
      }
    }
    // remove duplicates, merge where possible
    exports.removeDuplicates(body);
    // ensure the new positions are not on hidden dates
    var startHidden = exports.isHidden(body.range.start, body.hiddenDates);
    var endHidden = exports.isHidden(body.range.end, body.hiddenDates);
    var rangeStart = body.range.start;
    var rangeEnd = body.range.end;
    if (startHidden.hidden == true) {
      rangeStart = body.range.startToFront == true ? startHidden.startDate - 1 : startHidden.endDate + 1;
    }
    if (endHidden.hidden == true) {
      rangeEnd = body.range.endToFront == true ? endHidden.startDate - 1 : endHidden.endDate + 1;
    }
    if (startHidden.hidden == true || endHidden.hidden == true) {
      body.range._applyRange(rangeStart, rangeEnd);
    }
  }
};

/**
 * remove duplicates from the hidden dates list. Duplicates are evil. They mess everything up.
 * Scales with N^2
 * @param body
 */
exports.removeDuplicates = function (body) {
  var hiddenDates = body.hiddenDates;
  var safeDates = [];
  for (var i = 0; i < hiddenDates.length; i++) {
    for (var j = 0; j < hiddenDates.length; j++) {
      if (i != j && hiddenDates[j].remove != true && hiddenDates[i].remove != true) {
        // j inside i
        if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
          hiddenDates[j].remove = true;
        }
        // j start inside i
        else if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].start <= hiddenDates[i].end) {
            hiddenDates[i].end = hiddenDates[j].end;
            hiddenDates[j].remove = true;
          }
          // j end inside i
          else if (hiddenDates[j].end >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
              hiddenDates[i].start = hiddenDates[j].start;
              hiddenDates[j].remove = true;
            }
      }
    }
  }

  for (var i = 0; i < hiddenDates.length; i++) {
    if (hiddenDates[i].remove !== true) {
      safeDates.push(hiddenDates[i]);
    }
  }

  body.hiddenDates = safeDates;
  body.hiddenDates.sort(function (a, b) {
    return a.start - b.start;
  }); // sort by start time
};

exports.printDates = function (dates) {
  for (var i = 0; i < dates.length; i++) {
    console.log(i, new Date(dates[i].start), new Date(dates[i].end), dates[i].start, dates[i].end, dates[i].remove);
  }
};

/**
 * Used in TimeStep to avoid the hidden times.
 * @param {function} moment
 * @param {TimeStep} timeStep
 * @param previousTime
 */
exports.stepOverHiddenDates = function (moment, timeStep, previousTime) {
  var stepInHidden = false;
  var currentValue = timeStep.current.valueOf();
  for (var i = 0; i < timeStep.hiddenDates.length; i++) {
    var startDate = timeStep.hiddenDates[i].start;
    var endDate = timeStep.hiddenDates[i].end;
    if (currentValue >= startDate && currentValue < endDate) {
      stepInHidden = true;
      break;
    }
  }

  if (stepInHidden == true && currentValue < timeStep._end.valueOf() && currentValue != previousTime) {
    var prevValue = moment(previousTime);
    var newValue = moment(endDate);
    //check if the next step should be major
    if (prevValue.year() != newValue.year()) {
      timeStep.switchedYear = true;
    } else if (prevValue.month() != newValue.month()) {
      timeStep.switchedMonth = true;
    } else if (prevValue.dayOfYear() != newValue.dayOfYear()) {
      timeStep.switchedDay = true;
    }

    timeStep.current = newValue;
  }
};

///**
// * Used in TimeStep to avoid the hidden times.
// * @param timeStep
// * @param previousTime
// */
//exports.checkFirstStep = function(timeStep) {
//  var stepInHidden = false;
//  var currentValue = timeStep.current.valueOf();
//  for (var i = 0; i < timeStep.hiddenDates.length; i++) {
//    var startDate = timeStep.hiddenDates[i].start;
//    var endDate = timeStep.hiddenDates[i].end;
//    if (currentValue >= startDate && currentValue < endDate) {
//      stepInHidden = true;
//      break;
//    }
//  }
//
//  if (stepInHidden == true && currentValue <= timeStep._end.valueOf()) {
//    var newValue = moment(endDate);
//    timeStep.current = newValue.toDate();
//  }
//};

/**
 * replaces the Core toScreen methods
 * @param Core
 * @param time
 * @param width
 * @returns {number}
 */
exports.toScreen = function (Core, time, width) {
  if (Core.body.hiddenDates.length == 0) {
    var conversion = Core.range.conversion(width);
    return (time.valueOf() - conversion.offset) * conversion.scale;
  } else {
    var hidden = exports.isHidden(time, Core.body.hiddenDates);
    if (hidden.hidden == true) {
      time = hidden.startDate;
    }

    var duration = exports.getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);
    time = exports.correctTimeForHidden(Core.options.moment, Core.body.hiddenDates, Core.range, time);

    var conversion = Core.range.conversion(width, duration);
    return (time.valueOf() - conversion.offset) * conversion.scale;
  }
};

/**
 * Replaces the core toTime methods
 * @param body
 * @param range
 * @param x
 * @param width
 * @returns {Date}
 */
exports.toTime = function (Core, x, width) {
  if (Core.body.hiddenDates.length == 0) {
    var conversion = Core.range.conversion(width);
    return new Date(x / conversion.scale + conversion.offset);
  } else {
    var hiddenDuration = exports.getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);
    var totalDuration = Core.range.end - Core.range.start - hiddenDuration;
    var partialDuration = totalDuration * x / width;
    var accumulatedHiddenDuration = exports.getAccumulatedHiddenDuration(Core.body.hiddenDates, Core.range, partialDuration);

    var newTime = new Date(accumulatedHiddenDuration + partialDuration + Core.range.start);
    return newTime;
  }
};

/**
 * Support function
 *
 * @param hiddenDates
 * @param range
 * @returns {number}
 */
exports.getHiddenDurationBetween = function (hiddenDates, start, end) {
  var duration = 0;
  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;
    // if time after the cutout, and the
    if (startDate >= start && endDate < end) {
      duration += endDate - startDate;
    }
  }
  return duration;
};

/**
 * Support function
 * @param moment
 * @param hiddenDates
 * @param range
 * @param time
 * @returns {{duration: number, time: *, offset: number}}
 */
exports.correctTimeForHidden = function (moment, hiddenDates, range, time) {
  time = moment(time).toDate().valueOf();
  time -= exports.getHiddenDurationBefore(moment, hiddenDates, range, time);
  return time;
};

exports.getHiddenDurationBefore = function (moment, hiddenDates, range, time) {
  var timeOffset = 0;
  time = moment(time).toDate().valueOf();

  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;
    // if time after the cutout, and the
    if (startDate >= range.start && endDate < range.end) {
      if (time >= endDate) {
        timeOffset += endDate - startDate;
      }
    }
  }
  return timeOffset;
};

/**
 * sum the duration from start to finish, including the hidden duration,
 * until the required amount has been reached, return the accumulated hidden duration
 * @param hiddenDates
 * @param range
 * @param time
 * @returns {{duration: number, time: *, offset: number}}
 */
exports.getAccumulatedHiddenDuration = function (hiddenDates, range, requiredDuration) {
  var hiddenDuration = 0;
  var duration = 0;
  var previousPoint = range.start;
  //exports.printDates(hiddenDates)
  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;
    // if time after the cutout, and the
    if (startDate >= range.start && endDate < range.end) {
      duration += startDate - previousPoint;
      previousPoint = endDate;
      if (duration >= requiredDuration) {
        break;
      } else {
        hiddenDuration += endDate - startDate;
      }
    }
  }

  return hiddenDuration;
};

/**
 * used to step over to either side of a hidden block. Correction is disabled on tablets, might be set to true
 * @param hiddenDates
 * @param time
 * @param direction
 * @param correctionEnabled
 * @returns {*}
 */
exports.snapAwayFromHidden = function (hiddenDates, time, direction, correctionEnabled) {
  var isHidden = exports.isHidden(time, hiddenDates);
  if (isHidden.hidden == true) {
    if (direction < 0) {
      if (correctionEnabled == true) {
        return isHidden.startDate - (isHidden.endDate - time) - 1;
      } else {
        return isHidden.startDate - 1;
      }
    } else {
      if (correctionEnabled == true) {
        return isHidden.endDate + (time - isHidden.startDate) + 1;
      } else {
        return isHidden.endDate + 1;
      }
    }
  } else {
    return time;
  }
};

/**
 * Check if a time is hidden
 *
 * @param time
 * @param hiddenDates
 * @returns {{hidden: boolean, startDate: Window.start, endDate: *}}
 */
exports.isHidden = function (time, hiddenDates) {
  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;

    if (time >= startDate && time < endDate) {
      // if the start is entering a hidden zone
      return { hidden: true, startDate: startDate, endDate: endDate };
      break;
    }
  }
  return { hidden: false, startDate: startDate, endDate: endDate };
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvRGF0ZVV0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQVFBLE9BQU8sQ0FBQyxvQkFBb0IsR0FBRyxVQUFTLE1BQU0sRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFO0FBQ2pFLE1BQUksV0FBVyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsRUFBRTtBQUM5QyxXQUFPLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQTtHQUNqRTs7QUFFRCxNQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQztBQUN0QixNQUFJLFdBQVcsRUFBRTtBQUNmLFFBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxJQUFJLEVBQUU7QUFDdEMsV0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDM0MsWUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFLLFNBQVMsRUFBRTtBQUN2QyxjQUFJLFFBQVEsR0FBRyxFQUFFLENBQUM7QUFDbEIsa0JBQVEsQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUNqRSxrQkFBUSxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQzdELGNBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FB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QUMzRCxNQUNJO0FBQ0gsZUFBTyxRQUFRLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztPQUMvQjtLQUNGLE1BQ0k7QUFDSCxVQUFJLGlCQUFpQixJQUFJLElBQUksRUFBRTtBQUM3QixlQUFPLFFBQVEsQ0FBQyxPQUFPLElBQUksSUFBSSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUEsQUFBQyxHQUFHLENBQUMsQ0FBQztPQUMzRCxNQUNJO0FBQ0gsZUFBTyxRQUFRLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQztPQUM3QjtLQUNGO0dBQ0YsTUFDSTtBQUNILFdBQU8sSUFBSSxDQUFDO0dBQ2I7Q0FFRixDQUFBOzs7Ozs7Ozs7QUFVRCxPQUFPLENBQUMsUUFBUSxHQUFHLFVBQVMsSUFBSSxFQUFFLFdBQVcsRUFBRTtBQUM3QyxPQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMzQyxRQUFJLFNBQVMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0FBQ3JDLFFBQUksT0FBTyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7O0FBRWpDLFFBQUksSUFBSSxJQUFJLFNBQVMsSUFBSSxJQUFJLEdBQUcsT0FBTyxFQUFFOztBQUN2QyxhQUFPLEVBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUMsQ0FBQztBQUM5RCxZQUFNO0tBQ1A7R0FDRjtBQUNELFNBQU8sRUFBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBQyxDQUFDO0NBQ2hFLENBQUEiLCJmaWxlIjoiL1VzZXJzL2RhcmluL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzLXZpZXdlci9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9EYXRlVXRpbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiB1c2VkIGluIENvcmUgdG8gY29udmVydCB0aGUgb3B0aW9ucyBpbnRvIGEgdm9sYXRpbGUgdmFyaWFibGVcbiAqIFxuICogQHBhcmFtIHtmdW5jdGlvbn0gbW9tZW50XG4gKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICogQHBhcmFtIHtBcnJheSB8IE9iamVjdH0gaGlkZGVuRGF0ZXNcbiAqL1xuZXhwb3J0cy5jb252ZXJ0SGlkZGVuT3B0aW9ucyA9IGZ1bmN0aW9uKG1vbWVudCwgYm9keSwgaGlkZGVuRGF0ZXMpIHtcbiAgaWYgKGhpZGRlbkRhdGVzICYmICFBcnJheS5pc0FycmF5KGhpZGRlbkRhdGVzKSkge1xuICAgIHJldHVybiBleHBvcnRzLmNvbnZlcnRIaWRkZW5PcHRpb25zKG1vbWVudCwgYm9keSwgW2hpZGRlbkRhdGVzXSlcbiAgfVxuXG4gIGJvZHkuaGlkZGVuRGF0ZXMgPSBbXTtcbiAgaWYgKGhpZGRlbkRhdGVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGlkZGVuRGF0ZXMpID09IHRydWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhpZGRlbkRhdGVzW2ldLnJlcGVhdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGRhdGVJdGVtID0ge307XG4gICAgICAgICAgZGF0ZUl0ZW0uc3RhcnQgPSBtb21lbnQoaGlkZGVuRGF0ZXNbaV0uc3RhcnQpLnRvRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgICBkYXRlSXRlbS5lbmQgPSBtb21lbnQoaGlkZGVuRGF0ZXNbaV0uZW5kKS50b0RhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgICAgYm9keS5oaWRkZW5EYXRlcy5wdXNoKGRhdGVJdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYm9keS5oaWRkZW5EYXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnN0YXJ0IC0gYi5zdGFydDtcbiAgICAgIH0pOyAvLyBzb3J0IGJ5IHN0YXJ0IHRpbWVcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBjcmVhdGUgbmV3IGVudHJlZXMgZm9yIHRoZSByZXBlYXRpbmcgaGlkZGVuIGRhdGVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb21lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gKiBAcGFyYW0ge0FycmF5IHwgT2JqZWN0fSBoaWRkZW5EYXRlc1xuICovXG5leHBvcnRzLnVwZGF0ZUhpZGRlbkRhdGVzID0gZnVuY3Rpb24gKG1vbWVudCwgYm9keSwgaGlkZGVuRGF0ZXMpIHtcbiAgaWYgKGhpZGRlbkRhdGVzICYmICFBcnJheS5pc0FycmF5KGhpZGRlbkRhdGVzKSkge1xuICAgIHJldHVybiBleHBvcnRzLnVwZGF0ZUhpZGRlbkRhdGVzKG1vbWVudCwgYm9keSwgW2hpZGRlbkRhdGVzXSlcbiAgfVxuXG4gIGlmIChoaWRkZW5EYXRlcyAmJiBib2R5LmRvbVByb3BzLmNlbnRlckNvbnRhaW5lci53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwb3J0cy5jb252ZXJ0SGlkZGVuT3B0aW9ucyhtb21lbnQsIGJvZHksIGhpZGRlbkRhdGVzKTtcblxuICAgIHZhciBzdGFydCA9IG1vbWVudChib2R5LnJhbmdlLnN0YXJ0KTtcbiAgICB2YXIgZW5kID0gbW9tZW50KGJvZHkucmFuZ2UuZW5kKTtcblxuICAgIHZhciB0b3RhbFJhbmdlID0gKGJvZHkucmFuZ2UuZW5kIC0gYm9keS5yYW5nZS5zdGFydCk7XG4gICAgdmFyIHBpeGVsVGltZSA9IHRvdGFsUmFuZ2UgLyBib2R5LmRvbVByb3BzLmNlbnRlckNvbnRhaW5lci53aWR0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChoaWRkZW5EYXRlc1tpXS5yZXBlYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgc3RhcnREYXRlID0gbW9tZW50KGhpZGRlbkRhdGVzW2ldLnN0YXJ0KTtcbiAgICAgICAgdmFyIGVuZERhdGUgPSBtb21lbnQoaGlkZGVuRGF0ZXNbaV0uZW5kKTtcblxuICAgICAgICBpZiAoc3RhcnREYXRlLl9kID09IFwiSW52YWxpZCBEYXRlXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXBwbGllZCBzdGFydCBkYXRlIGlzIG5vdCB2YWxpZDogXCIgKyBoaWRkZW5EYXRlc1tpXS5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZERhdGUuX2QgPT0gXCJJbnZhbGlkIERhdGVcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1cHBsaWVkIGVuZCBkYXRlIGlzIG5vdCB2YWxpZDogXCIgKyBoaWRkZW5EYXRlc1tpXS5lbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR1cmF0aW9uID0gZW5kRGF0ZSAtIHN0YXJ0RGF0ZTtcbiAgICAgICAgaWYgKGR1cmF0aW9uID49IDQgKiBwaXhlbFRpbWUpIHtcblxuICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgIHZhciBydW5VbnRpbCA9IGVuZC5jbG9uZSgpO1xuICAgICAgICAgIHN3aXRjaCAoaGlkZGVuRGF0ZXNbaV0ucmVwZWF0KSB7XG4gICAgICAgICAgICBjYXNlIFwiZGFpbHlcIjogLy8gY2FzZSBvZiB0aW1lXG4gICAgICAgICAgICAgIGlmIChzdGFydERhdGUuZGF5KCkgIT0gZW5kRGF0ZS5kYXkoKSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhcnREYXRlLmRheU9mWWVhcihzdGFydC5kYXlPZlllYXIoKSk7XG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZS55ZWFyKHN0YXJ0LnllYXIoKSk7XG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zdWJ0cmFjdCg3LCdkYXlzJyk7XG5cbiAgICAgICAgICAgICAgZW5kRGF0ZS5kYXlPZlllYXIoc3RhcnQuZGF5T2ZZZWFyKCkpO1xuICAgICAgICAgICAgICBlbmREYXRlLnllYXIoc3RhcnQueWVhcigpKTtcbiAgICAgICAgICAgICAgZW5kRGF0ZS5zdWJ0cmFjdCg3IC0gb2Zmc2V0LCdkYXlzJyk7XG5cbiAgICAgICAgICAgICAgcnVuVW50aWwuYWRkKDEsICd3ZWVrcycpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ3ZWVrbHlcIjpcbiAgICAgICAgICAgICAgdmFyIGRheU9mZnNldCA9IGVuZERhdGUuZGlmZihzdGFydERhdGUsJ2RheXMnKVxuICAgICAgICAgICAgICB2YXIgZGF5ID0gc3RhcnREYXRlLmRheSgpO1xuXG4gICAgICAgICAgICAgIC8vIHNldCB0aGUgc3RhcnQgZGF0ZSB0byB0aGUgcmFuZ2Uuc3RhcnRcbiAgICAgICAgICAgICAgc3RhcnREYXRlLmRhdGUoc3RhcnQuZGF0ZSgpKTtcbiAgICAgICAgICAgICAgc3RhcnREYXRlLm1vbnRoKHN0YXJ0Lm1vbnRoKCkpO1xuICAgICAgICAgICAgICBzdGFydERhdGUueWVhcihzdGFydC55ZWFyKCkpO1xuICAgICAgICAgICAgICBlbmREYXRlID0gc3RhcnREYXRlLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgLy8gZm9yY2VcbiAgICAgICAgICAgICAgc3RhcnREYXRlLmRheShkYXkpO1xuICAgICAgICAgICAgICBlbmREYXRlLmRheShkYXkpO1xuICAgICAgICAgICAgICBlbmREYXRlLmFkZChkYXlPZmZzZXQsJ2RheXMnKTtcblxuICAgICAgICAgICAgICBzdGFydERhdGUuc3VidHJhY3QoMSwnd2Vla3MnKTtcbiAgICAgICAgICAgICAgZW5kRGF0ZS5zdWJ0cmFjdCgxLCd3ZWVrcycpO1xuXG4gICAgICAgICAgICAgIHJ1blVudGlsLmFkZCgxLCAnd2Vla3MnKTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgXCJtb250aGx5XCI6XG4gICAgICAgICAgICAgIGlmIChzdGFydERhdGUubW9udGgoKSAhPSBlbmREYXRlLm1vbnRoKCkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZS5tb250aChzdGFydC5tb250aCgpKTtcbiAgICAgICAgICAgICAgc3RhcnREYXRlLnllYXIoc3RhcnQueWVhcigpKTtcbiAgICAgICAgICAgICAgc3RhcnREYXRlLnN1YnRyYWN0KDEsJ21vbnRocycpO1xuXG4gICAgICAgICAgICAgIGVuZERhdGUubW9udGgoc3RhcnQubW9udGgoKSk7XG4gICAgICAgICAgICAgIGVuZERhdGUueWVhcihzdGFydC55ZWFyKCkpO1xuICAgICAgICAgICAgICBlbmREYXRlLnN1YnRyYWN0KDEsJ21vbnRocycpO1xuICAgICAgICAgICAgICBlbmREYXRlLmFkZChvZmZzZXQsJ21vbnRocycpO1xuXG4gICAgICAgICAgICAgIHJ1blVudGlsLmFkZCgxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInllYXJseVwiOlxuICAgICAgICAgICAgICBpZiAoc3RhcnREYXRlLnllYXIoKSAhPSBlbmREYXRlLnllYXIoKSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhcnREYXRlLnllYXIoc3RhcnQueWVhcigpKTtcbiAgICAgICAgICAgICAgc3RhcnREYXRlLnN1YnRyYWN0KDEsJ3llYXJzJyk7XG4gICAgICAgICAgICAgIGVuZERhdGUueWVhcihzdGFydC55ZWFyKCkpO1xuICAgICAgICAgICAgICBlbmREYXRlLnN1YnRyYWN0KDEsJ3llYXJzJyk7XG4gICAgICAgICAgICAgIGVuZERhdGUuYWRkKG9mZnNldCwneWVhcnMnKTtcblxuICAgICAgICAgICAgICBydW5VbnRpbC5hZGQoMSwgJ3llYXJzJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXcm9uZyByZXBlYXQgZm9ybWF0LCBhbGxvd2VkIGFyZTogZGFpbHksIHdlZWtseSwgbW9udGhseSwgeWVhcmx5LiBHaXZlbjpcIiwgaGlkZGVuRGF0ZXNbaV0ucmVwZWF0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoc3RhcnREYXRlIDwgcnVuVW50aWwpIHtcbiAgICAgICAgICAgIGJvZHkuaGlkZGVuRGF0ZXMucHVzaCh7c3RhcnQ6IHN0YXJ0RGF0ZS52YWx1ZU9mKCksIGVuZDogZW5kRGF0ZS52YWx1ZU9mKCl9KTtcbiAgICAgICAgICAgIHN3aXRjaCAoaGlkZGVuRGF0ZXNbaV0ucmVwZWF0KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJkYWlseVwiOlxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5hZGQoMSwgJ2RheXMnKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLmFkZCgxLCAnZGF5cycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwid2Vla2x5XCI6XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLmFkZCgxLCAnd2Vla3MnKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLmFkZCgxLCAnd2Vla3MnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIm1vbnRobHlcIjpcbiAgICAgICAgICAgICAgICBzdGFydERhdGUuYWRkKDEsICdtb250aHMnKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLmFkZCgxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ5ZWFybHlcIjpcbiAgICAgICAgICAgICAgICBzdGFydERhdGUuYWRkKDEsICd5Jyk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZS5hZGQoMSwgJ3knKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldyb25nIHJlcGVhdCBmb3JtYXQsIGFsbG93ZWQgYXJlOiBkYWlseSwgd2Vla2x5LCBtb250aGx5LCB5ZWFybHkuIEdpdmVuOlwiLCBoaWRkZW5EYXRlc1tpXS5yZXBlYXQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYm9keS5oaWRkZW5EYXRlcy5wdXNoKHtzdGFydDogc3RhcnREYXRlLnZhbHVlT2YoKSwgZW5kOiBlbmREYXRlLnZhbHVlT2YoKX0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJlbW92ZSBkdXBsaWNhdGVzLCBtZXJnZSB3aGVyZSBwb3NzaWJsZVxuICAgIGV4cG9ydHMucmVtb3ZlRHVwbGljYXRlcyhib2R5KTtcbiAgICAvLyBlbnN1cmUgdGhlIG5ldyBwb3NpdGlvbnMgYXJlIG5vdCBvbiBoaWRkZW4gZGF0ZXNcbiAgICB2YXIgc3RhcnRIaWRkZW4gPSBleHBvcnRzLmlzSGlkZGVuKGJvZHkucmFuZ2Uuc3RhcnQsIGJvZHkuaGlkZGVuRGF0ZXMpO1xuICAgIHZhciBlbmRIaWRkZW4gPSBleHBvcnRzLmlzSGlkZGVuKGJvZHkucmFuZ2UuZW5kLGJvZHkuaGlkZGVuRGF0ZXMpO1xuICAgIHZhciByYW5nZVN0YXJ0ID0gYm9keS5yYW5nZS5zdGFydDtcbiAgICB2YXIgcmFuZ2VFbmQgPSBib2R5LnJhbmdlLmVuZDtcbiAgICBpZiAoc3RhcnRIaWRkZW4uaGlkZGVuID09IHRydWUpIHtyYW5nZVN0YXJ0ID0gYm9keS5yYW5nZS5zdGFydFRvRnJvbnQgPT0gdHJ1ZSA/IHN0YXJ0SGlkZGVuLnN0YXJ0RGF0ZSAtIDEgOiBzdGFydEhpZGRlbi5lbmREYXRlICsgMTt9XG4gICAgaWYgKGVuZEhpZGRlbi5oaWRkZW4gPT0gdHJ1ZSkgICB7cmFuZ2VFbmQgICA9IGJvZHkucmFuZ2UuZW5kVG9Gcm9udCA9PSB0cnVlID8gICBlbmRIaWRkZW4uc3RhcnREYXRlIC0gMSAgIDogZW5kSGlkZGVuLmVuZERhdGUgKyAxO31cbiAgICBpZiAoc3RhcnRIaWRkZW4uaGlkZGVuID09IHRydWUgfHwgZW5kSGlkZGVuLmhpZGRlbiA9PSB0cnVlKSB7XG4gICAgICBib2R5LnJhbmdlLl9hcHBseVJhbmdlKHJhbmdlU3RhcnQsIHJhbmdlRW5kKTtcbiAgICB9XG4gIH1cblxufVxuXG5cbi8qKlxuICogcmVtb3ZlIGR1cGxpY2F0ZXMgZnJvbSB0aGUgaGlkZGVuIGRhdGVzIGxpc3QuIER1cGxpY2F0ZXMgYXJlIGV2aWwuIFRoZXkgbWVzcyBldmVyeXRoaW5nIHVwLlxuICogU2NhbGVzIHdpdGggTl4yXG4gKiBAcGFyYW0gYm9keVxuICovXG5leHBvcnRzLnJlbW92ZUR1cGxpY2F0ZXMgPSBmdW5jdGlvbihib2R5KSB7XG4gIHZhciBoaWRkZW5EYXRlcyA9IGJvZHkuaGlkZGVuRGF0ZXM7XG4gIHZhciBzYWZlRGF0ZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChpICE9IGogJiYgaGlkZGVuRGF0ZXNbal0ucmVtb3ZlICE9IHRydWUgJiYgaGlkZGVuRGF0ZXNbaV0ucmVtb3ZlICE9IHRydWUpIHtcbiAgICAgICAgLy8gaiBpbnNpZGUgaVxuICAgICAgICBpZiAoaGlkZGVuRGF0ZXNbal0uc3RhcnQgPj0gaGlkZGVuRGF0ZXNbaV0uc3RhcnQgJiYgaGlkZGVuRGF0ZXNbal0uZW5kIDw9IGhpZGRlbkRhdGVzW2ldLmVuZCkge1xuICAgICAgICAgIGhpZGRlbkRhdGVzW2pdLnJlbW92ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaiBzdGFydCBpbnNpZGUgaVxuICAgICAgICBlbHNlIGlmIChoaWRkZW5EYXRlc1tqXS5zdGFydCA+PSBoaWRkZW5EYXRlc1tpXS5zdGFydCAmJiBoaWRkZW5EYXRlc1tqXS5zdGFydCA8PSBoaWRkZW5EYXRlc1tpXS5lbmQpIHtcbiAgICAgICAgICBoaWRkZW5EYXRlc1tpXS5lbmQgPSBoaWRkZW5EYXRlc1tqXS5lbmQ7XG4gICAgICAgICAgaGlkZGVuRGF0ZXNbal0ucmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBqIGVuZCBpbnNpZGUgaVxuICAgICAgICBlbHNlIGlmIChoaWRkZW5EYXRlc1tqXS5lbmQgPj0gaGlkZGVuRGF0ZXNbaV0uc3RhcnQgJiYgaGlkZGVuRGF0ZXNbal0uZW5kIDw9IGhpZGRlbkRhdGVzW2ldLmVuZCkge1xuICAgICAgICAgIGhpZGRlbkRhdGVzW2ldLnN0YXJ0ID0gaGlkZGVuRGF0ZXNbal0uc3RhcnQ7XG4gICAgICAgICAgaGlkZGVuRGF0ZXNbal0ucmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGlkZGVuRGF0ZXNbaV0ucmVtb3ZlICE9PSB0cnVlKSB7XG4gICAgICBzYWZlRGF0ZXMucHVzaChoaWRkZW5EYXRlc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgYm9keS5oaWRkZW5EYXRlcyA9IHNhZmVEYXRlcztcbiAgYm9keS5oaWRkZW5EYXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xuICB9KTsgLy8gc29ydCBieSBzdGFydCB0aW1lXG59O1xuXG5leHBvcnRzLnByaW50RGF0ZXMgPSBmdW5jdGlvbihkYXRlcykge1xuICBmb3IgKHZhciBpID0wOyBpIDwgZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zb2xlLmxvZyhpLCBuZXcgRGF0ZShkYXRlc1tpXS5zdGFydCksbmV3IERhdGUoZGF0ZXNbaV0uZW5kKSwgZGF0ZXNbaV0uc3RhcnQsIGRhdGVzW2ldLmVuZCwgZGF0ZXNbaV0ucmVtb3ZlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBVc2VkIGluIFRpbWVTdGVwIHRvIGF2b2lkIHRoZSBoaWRkZW4gdGltZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb21lbnRcbiAqIEBwYXJhbSB7VGltZVN0ZXB9IHRpbWVTdGVwXG4gKiBAcGFyYW0gcHJldmlvdXNUaW1lXG4gKi9cbmV4cG9ydHMuc3RlcE92ZXJIaWRkZW5EYXRlcyA9IGZ1bmN0aW9uKG1vbWVudCwgdGltZVN0ZXAsIHByZXZpb3VzVGltZSkge1xuICB2YXIgc3RlcEluSGlkZGVuID0gZmFsc2U7XG4gIHZhciBjdXJyZW50VmFsdWUgPSB0aW1lU3RlcC5jdXJyZW50LnZhbHVlT2YoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lU3RlcC5oaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGFydERhdGUgPSB0aW1lU3RlcC5oaWRkZW5EYXRlc1tpXS5zdGFydDtcbiAgICB2YXIgZW5kRGF0ZSA9IHRpbWVTdGVwLmhpZGRlbkRhdGVzW2ldLmVuZDtcbiAgICBpZiAoY3VycmVudFZhbHVlID49IHN0YXJ0RGF0ZSAmJiBjdXJyZW50VmFsdWUgPCBlbmREYXRlKSB7XG4gICAgICBzdGVwSW5IaWRkZW4gPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0ZXBJbkhpZGRlbiA9PSB0cnVlICYmIGN1cnJlbnRWYWx1ZSA8IHRpbWVTdGVwLl9lbmQudmFsdWVPZigpICYmIGN1cnJlbnRWYWx1ZSAhPSBwcmV2aW91c1RpbWUpIHtcbiAgICB2YXIgcHJldlZhbHVlID0gbW9tZW50KHByZXZpb3VzVGltZSk7XG4gICAgdmFyIG5ld1ZhbHVlID0gbW9tZW50KGVuZERhdGUpO1xuICAgIC8vY2hlY2sgaWYgdGhlIG5leHQgc3RlcCBzaG91bGQgYmUgbWFqb3JcbiAgICBpZiAocHJldlZhbHVlLnllYXIoKSAhPSBuZXdWYWx1ZS55ZWFyKCkpIHt0aW1lU3RlcC5zd2l0Y2hlZFllYXIgPSB0cnVlO31cbiAgICBlbHNlIGlmIChwcmV2VmFsdWUubW9udGgoKSAhPSBuZXdWYWx1ZS5tb250aCgpKSB7dGltZVN0ZXAuc3dpdGNoZWRNb250aCA9IHRydWU7fVxuICAgIGVsc2UgaWYgKHByZXZWYWx1ZS5kYXlPZlllYXIoKSAhPSBuZXdWYWx1ZS5kYXlPZlllYXIoKSkge3RpbWVTdGVwLnN3aXRjaGVkRGF5ID0gdHJ1ZTt9XG5cbiAgICB0aW1lU3RlcC5jdXJyZW50ID0gbmV3VmFsdWU7XG4gIH1cbn07XG5cblxuLy8vKipcbi8vICogVXNlZCBpbiBUaW1lU3RlcCB0byBhdm9pZCB0aGUgaGlkZGVuIHRpbWVzLlxuLy8gKiBAcGFyYW0gdGltZVN0ZXBcbi8vICogQHBhcmFtIHByZXZpb3VzVGltZVxuLy8gKi9cbi8vZXhwb3J0cy5jaGVja0ZpcnN0U3RlcCA9IGZ1bmN0aW9uKHRpbWVTdGVwKSB7XG4vLyAgdmFyIHN0ZXBJbkhpZGRlbiA9IGZhbHNlO1xuLy8gIHZhciBjdXJyZW50VmFsdWUgPSB0aW1lU3RlcC5jdXJyZW50LnZhbHVlT2YoKTtcbi8vICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVTdGVwLmhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4vLyAgICB2YXIgc3RhcnREYXRlID0gdGltZVN0ZXAuaGlkZGVuRGF0ZXNbaV0uc3RhcnQ7XG4vLyAgICB2YXIgZW5kRGF0ZSA9IHRpbWVTdGVwLmhpZGRlbkRhdGVzW2ldLmVuZDtcbi8vICAgIGlmIChjdXJyZW50VmFsdWUgPj0gc3RhcnREYXRlICYmIGN1cnJlbnRWYWx1ZSA8IGVuZERhdGUpIHtcbi8vICAgICAgc3RlcEluSGlkZGVuID0gdHJ1ZTtcbi8vICAgICAgYnJlYWs7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBpZiAoc3RlcEluSGlkZGVuID09IHRydWUgJiYgY3VycmVudFZhbHVlIDw9IHRpbWVTdGVwLl9lbmQudmFsdWVPZigpKSB7XG4vLyAgICB2YXIgbmV3VmFsdWUgPSBtb21lbnQoZW5kRGF0ZSk7XG4vLyAgICB0aW1lU3RlcC5jdXJyZW50ID0gbmV3VmFsdWUudG9EYXRlKCk7XG4vLyAgfVxuLy99O1xuXG4vKipcbiAqIHJlcGxhY2VzIHRoZSBDb3JlIHRvU2NyZWVuIG1ldGhvZHNcbiAqIEBwYXJhbSBDb3JlXG4gKiBAcGFyYW0gdGltZVxuICogQHBhcmFtIHdpZHRoXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLnRvU2NyZWVuID0gZnVuY3Rpb24oQ29yZSwgdGltZSwgd2lkdGgpIHtcbiAgaWYgKENvcmUuYm9keS5oaWRkZW5EYXRlcy5sZW5ndGggPT0gMCkge1xuICAgIHZhciBjb252ZXJzaW9uID0gQ29yZS5yYW5nZS5jb252ZXJzaW9uKHdpZHRoKTtcbiAgICByZXR1cm4gKHRpbWUudmFsdWVPZigpIC0gY29udmVyc2lvbi5vZmZzZXQpICogY29udmVyc2lvbi5zY2FsZTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgaGlkZGVuID0gZXhwb3J0cy5pc0hpZGRlbih0aW1lLCBDb3JlLmJvZHkuaGlkZGVuRGF0ZXMpO1xuICAgIGlmIChoaWRkZW4uaGlkZGVuID09IHRydWUpIHtcbiAgICAgIHRpbWUgPSBoaWRkZW4uc3RhcnREYXRlO1xuICAgIH1cblxuICAgIHZhciBkdXJhdGlvbiA9IGV4cG9ydHMuZ2V0SGlkZGVuRHVyYXRpb25CZXR3ZWVuKENvcmUuYm9keS5oaWRkZW5EYXRlcywgQ29yZS5yYW5nZS5zdGFydCwgQ29yZS5yYW5nZS5lbmQpO1xuICAgIHRpbWUgPSBleHBvcnRzLmNvcnJlY3RUaW1lRm9ySGlkZGVuKENvcmUub3B0aW9ucy5tb21lbnQsIENvcmUuYm9keS5oaWRkZW5EYXRlcywgQ29yZS5yYW5nZSwgdGltZSk7XG5cbiAgICB2YXIgY29udmVyc2lvbiA9IENvcmUucmFuZ2UuY29udmVyc2lvbih3aWR0aCwgZHVyYXRpb24pO1xuICAgIHJldHVybiAodGltZS52YWx1ZU9mKCkgLSBjb252ZXJzaW9uLm9mZnNldCkgKiBjb252ZXJzaW9uLnNjYWxlO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmVwbGFjZXMgdGhlIGNvcmUgdG9UaW1lIG1ldGhvZHNcbiAqIEBwYXJhbSBib2R5XG4gKiBAcGFyYW0gcmFuZ2VcbiAqIEBwYXJhbSB4XG4gKiBAcGFyYW0gd2lkdGhcbiAqIEByZXR1cm5zIHtEYXRlfVxuICovXG5leHBvcnRzLnRvVGltZSA9IGZ1bmN0aW9uKENvcmUsIHgsIHdpZHRoKSB7XG4gIGlmIChDb3JlLmJvZHkuaGlkZGVuRGF0ZXMubGVuZ3RoID09IDApIHtcbiAgICB2YXIgY29udmVyc2lvbiA9IENvcmUucmFuZ2UuY29udmVyc2lvbih3aWR0aCk7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHggLyBjb252ZXJzaW9uLnNjYWxlICsgY29udmVyc2lvbi5vZmZzZXQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBoaWRkZW5EdXJhdGlvbiA9IGV4cG9ydHMuZ2V0SGlkZGVuRHVyYXRpb25CZXR3ZWVuKENvcmUuYm9keS5oaWRkZW5EYXRlcywgQ29yZS5yYW5nZS5zdGFydCwgQ29yZS5yYW5nZS5lbmQpO1xuICAgIHZhciB0b3RhbER1cmF0aW9uID0gQ29yZS5yYW5nZS5lbmQgLSBDb3JlLnJhbmdlLnN0YXJ0IC0gaGlkZGVuRHVyYXRpb247XG4gICAgdmFyIHBhcnRpYWxEdXJhdGlvbiA9IHRvdGFsRHVyYXRpb24gKiB4IC8gd2lkdGg7XG4gICAgdmFyIGFjY3VtdWxhdGVkSGlkZGVuRHVyYXRpb24gPSBleHBvcnRzLmdldEFjY3VtdWxhdGVkSGlkZGVuRHVyYXRpb24oQ29yZS5ib2R5LmhpZGRlbkRhdGVzLCBDb3JlLnJhbmdlLCBwYXJ0aWFsRHVyYXRpb24pO1xuXG4gICAgdmFyIG5ld1RpbWUgPSBuZXcgRGF0ZShhY2N1bXVsYXRlZEhpZGRlbkR1cmF0aW9uICsgcGFydGlhbER1cmF0aW9uICsgQ29yZS5yYW5nZS5zdGFydCk7XG4gICAgcmV0dXJuIG5ld1RpbWU7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTdXBwb3J0IGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIGhpZGRlbkRhdGVzXG4gKiBAcGFyYW0gcmFuZ2VcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMuZ2V0SGlkZGVuRHVyYXRpb25CZXR3ZWVuID0gZnVuY3Rpb24oaGlkZGVuRGF0ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGR1cmF0aW9uID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGFydERhdGUgPSBoaWRkZW5EYXRlc1tpXS5zdGFydDtcbiAgICB2YXIgZW5kRGF0ZSA9IGhpZGRlbkRhdGVzW2ldLmVuZDtcbiAgICAvLyBpZiB0aW1lIGFmdGVyIHRoZSBjdXRvdXQsIGFuZCB0aGVcbiAgICBpZiAoc3RhcnREYXRlID49IHN0YXJ0ICYmIGVuZERhdGUgPCBlbmQpIHtcbiAgICAgIGR1cmF0aW9uICs9IGVuZERhdGUgLSBzdGFydERhdGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBkdXJhdGlvbjtcbn07XG5cblxuLyoqXG4gKiBTdXBwb3J0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gbW9tZW50XG4gKiBAcGFyYW0gaGlkZGVuRGF0ZXNcbiAqIEBwYXJhbSByYW5nZVxuICogQHBhcmFtIHRpbWVcbiAqIEByZXR1cm5zIHt7ZHVyYXRpb246IG51bWJlciwgdGltZTogKiwgb2Zmc2V0OiBudW1iZXJ9fVxuICovXG5leHBvcnRzLmNvcnJlY3RUaW1lRm9ySGlkZGVuID0gZnVuY3Rpb24obW9tZW50LCBoaWRkZW5EYXRlcywgcmFuZ2UsIHRpbWUpIHtcbiAgdGltZSA9IG1vbWVudCh0aW1lKS50b0RhdGUoKS52YWx1ZU9mKCk7XG4gIHRpbWUgLT0gZXhwb3J0cy5nZXRIaWRkZW5EdXJhdGlvbkJlZm9yZShtb21lbnQsIGhpZGRlbkRhdGVzLHJhbmdlLHRpbWUpO1xuICByZXR1cm4gdGltZTtcbn07XG5cbmV4cG9ydHMuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUgPSBmdW5jdGlvbihtb21lbnQsIGhpZGRlbkRhdGVzLCByYW5nZSwgdGltZSkge1xuICB2YXIgdGltZU9mZnNldCA9IDA7XG4gIHRpbWUgPSBtb21lbnQodGltZSkudG9EYXRlKCkudmFsdWVPZigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RhcnREYXRlID0gaGlkZGVuRGF0ZXNbaV0uc3RhcnQ7XG4gICAgdmFyIGVuZERhdGUgPSBoaWRkZW5EYXRlc1tpXS5lbmQ7XG4gICAgLy8gaWYgdGltZSBhZnRlciB0aGUgY3V0b3V0LCBhbmQgdGhlXG4gICAgaWYgKHN0YXJ0RGF0ZSA+PSByYW5nZS5zdGFydCAmJiBlbmREYXRlIDwgcmFuZ2UuZW5kKSB7XG4gICAgICBpZiAodGltZSA+PSBlbmREYXRlKSB7XG4gICAgICAgIHRpbWVPZmZzZXQgKz0gKGVuZERhdGUgLSBzdGFydERhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGltZU9mZnNldDtcbn1cblxuLyoqXG4gKiBzdW0gdGhlIGR1cmF0aW9uIGZyb20gc3RhcnQgdG8gZmluaXNoLCBpbmNsdWRpbmcgdGhlIGhpZGRlbiBkdXJhdGlvbixcbiAqIHVudGlsIHRoZSByZXF1aXJlZCBhbW91bnQgaGFzIGJlZW4gcmVhY2hlZCwgcmV0dXJuIHRoZSBhY2N1bXVsYXRlZCBoaWRkZW4gZHVyYXRpb25cbiAqIEBwYXJhbSBoaWRkZW5EYXRlc1xuICogQHBhcmFtIHJhbmdlXG4gKiBAcGFyYW0gdGltZVxuICogQHJldHVybnMge3tkdXJhdGlvbjogbnVtYmVyLCB0aW1lOiAqLCBvZmZzZXQ6IG51bWJlcn19XG4gKi9cbmV4cG9ydHMuZ2V0QWNjdW11bGF0ZWRIaWRkZW5EdXJhdGlvbiA9IGZ1bmN0aW9uKGhpZGRlbkRhdGVzLCByYW5nZSwgcmVxdWlyZWREdXJhdGlvbikge1xuICB2YXIgaGlkZGVuRHVyYXRpb24gPSAwO1xuICB2YXIgZHVyYXRpb24gPSAwO1xuICB2YXIgcHJldmlvdXNQb2ludCA9IHJhbmdlLnN0YXJ0O1xuICAvL2V4cG9ydHMucHJpbnREYXRlcyhoaWRkZW5EYXRlcylcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGFydERhdGUgPSBoaWRkZW5EYXRlc1tpXS5zdGFydDtcbiAgICB2YXIgZW5kRGF0ZSA9IGhpZGRlbkRhdGVzW2ldLmVuZDtcbiAgICAvLyBpZiB0aW1lIGFmdGVyIHRoZSBjdXRvdXQsIGFuZCB0aGVcbiAgICBpZiAoc3RhcnREYXRlID49IHJhbmdlLnN0YXJ0ICYmIGVuZERhdGUgPCByYW5nZS5lbmQpIHtcbiAgICAgIGR1cmF0aW9uICs9IHN0YXJ0RGF0ZSAtIHByZXZpb3VzUG9pbnQ7XG4gICAgICBwcmV2aW91c1BvaW50ID0gZW5kRGF0ZTtcbiAgICAgIGlmIChkdXJhdGlvbiA+PSByZXF1aXJlZER1cmF0aW9uKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGhpZGRlbkR1cmF0aW9uICs9IGVuZERhdGUgLSBzdGFydERhdGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhpZGRlbkR1cmF0aW9uO1xufTtcblxuXG5cbi8qKlxuICogdXNlZCB0byBzdGVwIG92ZXIgdG8gZWl0aGVyIHNpZGUgb2YgYSBoaWRkZW4gYmxvY2suIENvcnJlY3Rpb24gaXMgZGlzYWJsZWQgb24gdGFibGV0cywgbWlnaHQgYmUgc2V0IHRvIHRydWVcbiAqIEBwYXJhbSBoaWRkZW5EYXRlc1xuICogQHBhcmFtIHRpbWVcbiAqIEBwYXJhbSBkaXJlY3Rpb25cbiAqIEBwYXJhbSBjb3JyZWN0aW9uRW5hYmxlZFxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMuc25hcEF3YXlGcm9tSGlkZGVuID0gZnVuY3Rpb24oaGlkZGVuRGF0ZXMsIHRpbWUsIGRpcmVjdGlvbiwgY29ycmVjdGlvbkVuYWJsZWQpIHtcbiAgdmFyIGlzSGlkZGVuID0gZXhwb3J0cy5pc0hpZGRlbih0aW1lLCBoaWRkZW5EYXRlcyk7XG4gIGlmIChpc0hpZGRlbi5oaWRkZW4gPT0gdHJ1ZSkge1xuICAgIGlmIChkaXJlY3Rpb24gPCAwKSB7XG4gICAgICBpZiAoY29ycmVjdGlvbkVuYWJsZWQgPT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gaXNIaWRkZW4uc3RhcnREYXRlIC0gKGlzSGlkZGVuLmVuZERhdGUgLSB0aW1lKSAtIDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzSGlkZGVuLnN0YXJ0RGF0ZSAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGNvcnJlY3Rpb25FbmFibGVkID09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGlzSGlkZGVuLmVuZERhdGUgKyAodGltZSAtIGlzSGlkZGVuLnN0YXJ0RGF0ZSkgKyAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBpc0hpZGRlbi5lbmREYXRlICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cblxufVxuXG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0aW1lIGlzIGhpZGRlblxuICpcbiAqIEBwYXJhbSB0aW1lXG4gKiBAcGFyYW0gaGlkZGVuRGF0ZXNcbiAqIEByZXR1cm5zIHt7aGlkZGVuOiBib29sZWFuLCBzdGFydERhdGU6IFdpbmRvdy5zdGFydCwgZW5kRGF0ZTogKn19XG4gKi9cbmV4cG9ydHMuaXNIaWRkZW4gPSBmdW5jdGlvbih0aW1lLCBoaWRkZW5EYXRlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN0YXJ0RGF0ZSA9IGhpZGRlbkRhdGVzW2ldLnN0YXJ0O1xuICAgIHZhciBlbmREYXRlID0gaGlkZGVuRGF0ZXNbaV0uZW5kO1xuXG4gICAgaWYgKHRpbWUgPj0gc3RhcnREYXRlICYmIHRpbWUgPCBlbmREYXRlKSB7IC8vIGlmIHRoZSBzdGFydCBpcyBlbnRlcmluZyBhIGhpZGRlbiB6b25lXG4gICAgICByZXR1cm4ge2hpZGRlbjogdHJ1ZSwgc3RhcnREYXRlOiBzdGFydERhdGUsIGVuZERhdGU6IGVuZERhdGV9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7aGlkZGVuOiBmYWxzZSwgc3RhcnREYXRlOiBzdGFydERhdGUsIGVuZERhdGU6IGVuZERhdGV9O1xufSJdfQ==
},{}],28:[function(require,module,exports){
'use strict';

var util = require('../util');
var hammerUtil = require('../hammerUtil');
var moment = require('../module/moment');
var Component = require('./component/Component');
var DateUtil = require('./DateUtil');

/**
 * @constructor Range
 * A Range controls a numeric range with a start and end value.
 * The Range adjusts the range based on mouse events or programmatic changes,
 * and triggers events when the range is changing or has been changed.
 * @param {{dom: Object, domProps: Object, emitter: Emitter}} body
 * @param {Object} [options]    See description at Range.setOptions
 */
function Range(body, options) {
  var now = moment().hours(0).minutes(0).seconds(0).milliseconds(0);
  this.start = now.clone().add(-3, 'days').valueOf(); // Number
  this.end = now.clone().add(4, 'days').valueOf(); // Number

  this.body = body;
  this.deltaDifference = 0;
  this.scaleOffset = 0;
  this.startToFront = false;
  this.endToFront = true;

  // default options
  this.defaultOptions = {
    start: null,
    end: null,
    moment: moment,
    direction: 'horizontal', // 'horizontal' or 'vertical'
    moveable: true,
    zoomable: true,
    min: null,
    max: null,
    zoomMin: 10, // milliseconds
    zoomMax: 1000 * 60 * 60 * 24 * 365 * 10000 // milliseconds
  };
  this.options = util.extend({}, this.defaultOptions);

  this.props = {
    touch: {}
  };
  this.animationTimer = null;

  // drag listeners for dragging
  this.body.emitter.on('panstart', this._onDragStart.bind(this));
  this.body.emitter.on('panmove', this._onDrag.bind(this));
  this.body.emitter.on('panend', this._onDragEnd.bind(this));

  // mouse wheel for zooming
  this.body.emitter.on('mousewheel', this._onMouseWheel.bind(this));

  // pinch to zoom
  this.body.emitter.on('touch', this._onTouch.bind(this));
  this.body.emitter.on('pinch', this._onPinch.bind(this));

  this.setOptions(options);
}

Range.prototype = new Component();

/**
 * Set options for the range controller
 * @param {Object} options      Available options:
 *                              {Number | Date | String} start  Start date for the range
 *                              {Number | Date | String} end    End date for the range
 *                              {Number} min    Minimum value for start
 *                              {Number} max    Maximum value for end
 *                              {Number} zoomMin    Set a minimum value for
 *                                                  (end - start).
 *                              {Number} zoomMax    Set a maximum value for
 *                                                  (end - start).
 *                              {Boolean} moveable Enable moving of the range
 *                                                 by dragging. True by default
 *                              {Boolean} zoomable Enable zooming of the range
 *                                                 by pinching/scrolling. True by default
 */
Range.prototype.setOptions = function (options) {
  if (options) {
    // copy the options that we know
    var fields = ['direction', 'min', 'max', 'zoomMin', 'zoomMax', 'moveable', 'zoomable', 'moment', 'activate', 'hiddenDates', 'zoomKey'];
    util.selectiveExtend(fields, this.options, options);

    if ('start' in options || 'end' in options) {
      // apply a new range. both start and end are optional
      this.setRange(options.start, options.end);
    }
  }
};

/**
 * Test whether direction has a valid value
 * @param {String} direction    'horizontal' or 'vertical'
 */
function validateDirection(direction) {
  if (direction != 'horizontal' && direction != 'vertical') {
    throw new TypeError('Unknown direction "' + direction + '". ' + 'Choose "horizontal" or "vertical".');
  }
}

/**
 * Set a new start and end range
 * @param {Date | Number | String} [start]
 * @param {Date | Number | String} [end]
 * @param {boolean | {duration: number, easingFunction: string}} [animation=false]
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 * @param {Boolean} [byUser=false]
 *
 */
Range.prototype.setRange = function (start, end, animation, byUser) {
  if (byUser !== true) {
    byUser = false;
  }
  var finalStart = start != undefined ? util.convert(start, 'Date').valueOf() : null;
  var finalEnd = end != undefined ? util.convert(end, 'Date').valueOf() : null;
  this._cancelAnimation();

  if (animation) {
    // true or an Object
    var me = this;
    var initStart = this.start;
    var initEnd = this.end;
    var duration = typeof animation === 'object' && 'duration' in animation ? animation.duration : 500;
    var easingName = typeof animation === 'object' && 'easingFunction' in animation ? animation.easingFunction : 'easeInOutQuad';
    var easingFunction = util.easingFunctions[easingName];
    if (!easingFunction) {
      throw new Error('Unknown easing function ' + JSON.stringify(easingName) + '. ' + 'Choose from: ' + Object.keys(util.easingFunctions).join(', '));
    }

    var initTime = new Date().valueOf();
    var anyChanged = false;

    var next = function next() {
      if (!me.props.touch.dragging) {
        var now = new Date().valueOf();
        var time = now - initTime;
        var ease = easingFunction(time / duration);
        var done = time > duration;
        var s = done || finalStart === null ? finalStart : initStart + (finalStart - initStart) * ease;
        var e = done || finalEnd === null ? finalEnd : initEnd + (finalEnd - initEnd) * ease;

        changed = me._applyRange(s, e);
        DateUtil.updateHiddenDates(me.options.moment, me.body, me.options.hiddenDates);
        anyChanged = anyChanged || changed;
        if (changed) {
          me.body.emitter.emit('rangechange', { start: new Date(me.start), end: new Date(me.end), byUser: byUser });
        }

        if (done) {
          if (anyChanged) {
            me.body.emitter.emit('rangechanged', { start: new Date(me.start), end: new Date(me.end), byUser: byUser });
          }
        } else {
          // animate with as high as possible frame rate, leave 20 ms in between
          // each to prevent the browser from blocking
          me.animationTimer = setTimeout(next, 20);
        }
      }
    };

    return next();
  } else {
    var changed = this._applyRange(finalStart, finalEnd);
    DateUtil.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);
    if (changed) {
      var params = { start: new Date(this.start), end: new Date(this.end), byUser: byUser };
      this.body.emitter.emit('rangechange', params);
      this.body.emitter.emit('rangechanged', params);
    }
  }
};

/**
 * Stop an animation
 * @private
 */
Range.prototype._cancelAnimation = function () {
  if (this.animationTimer) {
    clearTimeout(this.animationTimer);
    this.animationTimer = null;
  }
};

/**
 * Set a new start and end range. This method is the same as setRange, but
 * does not trigger a range change and range changed event, and it returns
 * true when the range is changed
 * @param {Number} [start]
 * @param {Number} [end]
 * @return {Boolean} changed
 * @private
 */
Range.prototype._applyRange = function (start, end) {
  var newStart = start != null ? util.convert(start, 'Date').valueOf() : this.start,
      newEnd = end != null ? util.convert(end, 'Date').valueOf() : this.end,
      max = this.options.max != null ? util.convert(this.options.max, 'Date').valueOf() : null,
      min = this.options.min != null ? util.convert(this.options.min, 'Date').valueOf() : null,
      diff;

  // check for valid number
  if (isNaN(newStart) || newStart === null) {
    throw new Error('Invalid start "' + start + '"');
  }
  if (isNaN(newEnd) || newEnd === null) {
    throw new Error('Invalid end "' + end + '"');
  }

  // prevent start < end
  if (newEnd < newStart) {
    newEnd = newStart;
  }

  // prevent start < min
  if (min !== null) {
    if (newStart < min) {
      diff = min - newStart;
      newStart += diff;
      newEnd += diff;

      // prevent end > max
      if (max != null) {
        if (newEnd > max) {
          newEnd = max;
        }
      }
    }
  }

  // prevent end > max
  if (max !== null) {
    if (newEnd > max) {
      diff = newEnd - max;
      newStart -= diff;
      newEnd -= diff;

      // prevent start < min
      if (min != null) {
        if (newStart < min) {
          newStart = min;
        }
      }
    }
  }

  // prevent (end-start) < zoomMin
  if (this.options.zoomMin !== null) {
    var zoomMin = parseFloat(this.options.zoomMin);
    if (zoomMin < 0) {
      zoomMin = 0;
    }
    if (newEnd - newStart < zoomMin) {
      if (this.end - this.start === zoomMin && newStart > this.start && newEnd < this.end) {
        // ignore this action, we are already zoomed to the minimum
        newStart = this.start;
        newEnd = this.end;
      } else {
        // zoom to the minimum
        diff = zoomMin - (newEnd - newStart);
        newStart -= diff / 2;
        newEnd += diff / 2;
      }
    }
  }

  // prevent (end-start) > zoomMax
  if (this.options.zoomMax !== null) {
    var zoomMax = parseFloat(this.options.zoomMax);
    if (zoomMax < 0) {
      zoomMax = 0;
    }

    if (newEnd - newStart > zoomMax) {
      if (this.end - this.start === zoomMax && newStart < this.start && newEnd > this.end) {
        // ignore this action, we are already zoomed to the maximum
        newStart = this.start;
        newEnd = this.end;
      } else {
        // zoom to the maximum
        diff = newEnd - newStart - zoomMax;
        newStart += diff / 2;
        newEnd -= diff / 2;
      }
    }
  }

  var changed = this.start != newStart || this.end != newEnd;

  // if the new range does NOT overlap with the old range, emit checkRangedItems to avoid not showing ranged items (ranged meaning has end time, not necessarily of type Range)
  if (!(newStart >= this.start && newStart <= this.end || newEnd >= this.start && newEnd <= this.end) && !(this.start >= newStart && this.start <= newEnd || this.end >= newStart && this.end <= newEnd)) {
    this.body.emitter.emit('checkRangedItems');
  }

  this.start = newStart;
  this.end = newEnd;
  return changed;
};

/**
 * Retrieve the current range.
 * @return {Object} An object with start and end properties
 */
Range.prototype.getRange = function () {
  return {
    start: this.start,
    end: this.end
  };
};

/**
 * Calculate the conversion offset and scale for current range, based on
 * the provided width
 * @param {Number} width
 * @returns {{offset: number, scale: number}} conversion
 */
Range.prototype.conversion = function (width, totalHidden) {
  return Range.conversion(this.start, this.end, width, totalHidden);
};

/**
 * Static method to calculate the conversion offset and scale for a range,
 * based on the provided start, end, and width
 * @param {Number} start
 * @param {Number} end
 * @param {Number} width
 * @returns {{offset: number, scale: number}} conversion
 */
Range.conversion = function (start, end, width, totalHidden) {
  if (totalHidden === undefined) {
    totalHidden = 0;
  }
  if (width != 0 && end - start != 0) {
    return {
      offset: start,
      scale: width / (end - start - totalHidden)
    };
  } else {
    return {
      offset: 0,
      scale: 1
    };
  }
};

/**
 * Start dragging horizontally or vertically
 * @param {Event} event
 * @private
 */
Range.prototype._onDragStart = function (event) {
  this.deltaDifference = 0;
  this.previousDelta = 0;

  // only allow dragging when configured as movable
  if (!this.options.moveable) return;

  // only start dragging when the mouse is inside the current range
  if (!this._isInsideRange(event)) return;

  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.props.touch.allowDragging) return;

  this.props.touch.start = this.start;
  this.props.touch.end = this.end;
  this.props.touch.dragging = true;

  if (this.body.dom.root) {
    this.body.dom.root.style.cursor = 'move';
  }
};

/**
 * Perform dragging operation
 * @param {Event} event
 * @private
 */
Range.prototype._onDrag = function (event) {
  if (!this.props.touch.dragging) return;

  // only allow dragging when configured as movable
  if (!this.options.moveable) return;

  // TODO: this may be redundant in hammerjs2
  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.props.touch.allowDragging) return;

  var direction = this.options.direction;
  validateDirection(direction);
  var delta = direction == 'horizontal' ? event.deltaX : event.deltaY;
  delta -= this.deltaDifference;
  var interval = this.props.touch.end - this.props.touch.start;

  // normalize dragging speed if cutout is in between.
  var duration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
  interval -= duration;

  var width = direction == 'horizontal' ? this.body.domProps.center.width : this.body.domProps.center.height;
  var diffRange = -delta / width * interval;
  var newStart = this.props.touch.start + diffRange;
  var newEnd = this.props.touch.end + diffRange;

  // snapping times away from hidden zones
  var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, this.previousDelta - delta, true);
  var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, this.previousDelta - delta, true);
  if (safeStart != newStart || safeEnd != newEnd) {
    this.deltaDifference += delta;
    this.props.touch.start = safeStart;
    this.props.touch.end = safeEnd;
    this._onDrag(event);
    return;
  }

  this.previousDelta = delta;
  this._applyRange(newStart, newEnd);

  // fire a rangechange event
  this.body.emitter.emit('rangechange', {
    start: new Date(this.start),
    end: new Date(this.end),
    byUser: true
  });
};

/**
 * Stop dragging operation
 * @param {event} event
 * @private
 */
Range.prototype._onDragEnd = function (event) {
  if (!this.props.touch.dragging) return;

  // only allow dragging when configured as movable
  if (!this.options.moveable) return;

  // TODO: this may be redundant in hammerjs2
  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.props.touch.allowDragging) return;

  this.props.touch.dragging = false;
  if (this.body.dom.root) {
    this.body.dom.root.style.cursor = 'auto';
  }

  // fire a rangechanged event
  this.body.emitter.emit('rangechanged', {
    start: new Date(this.start),
    end: new Date(this.end),
    byUser: true
  });
};

/**
 * Event handler for mouse wheel event, used to zoom
 * Code from http://adomas.org/javascript-mouse-wheel/
 * @param {Event} event
 * @private
 */
Range.prototype._onMouseWheel = function (event) {
  // only allow zooming when configured as zoomable and moveable
  if (!(this.options.zoomable && this.options.moveable)) return;

  // only zoom when the mouse is inside the current range
  if (!this._isInsideRange(event)) return;

  // only zoom when the according key is pressed and the zoomKey option is set
  if (this.options.zoomKey && !event[this.options.zoomKey]) return;

  // retrieve delta
  var delta = 0;
  if (event.wheelDelta) {
    /* IE/Opera. */
    delta = event.wheelDelta / 120;
  } else if (event.detail) {
    /* Mozilla case. */
    // In Mozilla, sign of delta is different than in IE.
    // Also, delta is multiple of 3.
    delta = -event.detail / 3;
  }

  // If delta is nonzero, handle it.
  // Basically, delta is now positive if wheel was scrolled up,
  // and negative, if wheel was scrolled down.
  if (delta) {
    // perform the zoom action. Delta is normally 1 or -1

    // adjust a negative delta such that zooming in with delta 0.1
    // equals zooming out with a delta -0.1
    var scale;
    if (delta < 0) {
      scale = 1 - delta / 5;
    } else {
      scale = 1 / (1 + delta / 5);
    }

    // calculate center, the date to zoom around
    var pointer = getPointer({ x: event.clientX, y: event.clientY }, this.body.dom.center);
    var pointerDate = this._pointerToDate(pointer);

    this.zoom(scale, pointerDate, delta);
  }

  // Prevent default actions caused by mouse wheel
  // (else the page and timeline both zoom and scroll)
  event.preventDefault();
};

/**
 * Start of a touch gesture
 * @private
 */
Range.prototype._onTouch = function (event) {
  this.props.touch.start = this.start;
  this.props.touch.end = this.end;
  this.props.touch.allowDragging = true;
  this.props.touch.center = null;
  this.scaleOffset = 0;
  this.deltaDifference = 0;
};

/**
 * Handle pinch event
 * @param {Event} event
 * @private
 */
Range.prototype._onPinch = function (event) {
  // only allow zooming when configured as zoomable and moveable
  if (!(this.options.zoomable && this.options.moveable)) return;

  this.props.touch.allowDragging = false;

  if (!this.props.touch.center) {
    this.props.touch.center = getPointer(event.center, this.body.dom.center);
  }

  var scale = 1 / (event.scale + this.scaleOffset);
  var centerDate = this._pointerToDate(this.props.touch.center);

  var hiddenDuration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
  var hiddenDurationBefore = DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, centerDate);
  var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;

  // calculate new start and end
  var newStart = centerDate - hiddenDurationBefore + (this.props.touch.start - (centerDate - hiddenDurationBefore)) * scale;
  var newEnd = centerDate + hiddenDurationAfter + (this.props.touch.end - (centerDate + hiddenDurationAfter)) * scale;

  // snapping times away from hidden zones
  this.startToFront = 1 - scale <= 0; // used to do the right auto correction with periodic hidden times
  this.endToFront = scale - 1 <= 0; // used to do the right auto correction with periodic hidden times

  var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, 1 - scale, true);
  var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, scale - 1, true);
  if (safeStart != newStart || safeEnd != newEnd) {
    this.props.touch.start = safeStart;
    this.props.touch.end = safeEnd;
    this.scaleOffset = 1 - event.scale;
    newStart = safeStart;
    newEnd = safeEnd;
  }

  this.setRange(newStart, newEnd, false, true);

  this.startToFront = false; // revert to default
  this.endToFront = true; // revert to default
};

/**
 * Test whether the mouse from a mouse event is inside the visible window,
 * between the current start and end date
 * @param {Object} event
 * @return {boolean} Returns true when inside the visible window
 * @private
 */
Range.prototype._isInsideRange = function (event) {
  // calculate the time where the mouse is, check whether inside
  // and no scroll action should happen.
  var clientX = event.center ? event.center.x : event.clientX;
  var x = clientX - util.getAbsoluteLeft(this.body.dom.centerContainer);
  var time = this.body.util.toTime(x);

  return time >= this.start && time <= this.end;
};

/**
 * Helper function to calculate the center date for zooming
 * @param {{x: Number, y: Number}} pointer
 * @return {number} date
 * @private
 */
Range.prototype._pointerToDate = function (pointer) {
  var conversion;
  var direction = this.options.direction;

  validateDirection(direction);

  if (direction == 'horizontal') {
    return this.body.util.toTime(pointer.x).valueOf();
  } else {
    var height = this.body.domProps.center.height;
    conversion = this.conversion(height);
    return pointer.y / conversion.scale + conversion.offset;
  }
};

/**
 * Get the pointer location relative to the location of the dom element
 * @param {{x: Number, y: Number}} touch
 * @param {Element} element   HTML DOM element
 * @return {{x: Number, y: Number}} pointer
 * @private
 */
function getPointer(touch, element) {
  return {
    x: touch.x - util.getAbsoluteLeft(element),
    y: touch.y - util.getAbsoluteTop(element)
  };
}

/**
 * Zoom the range the given scale in or out. Start and end date will
 * be adjusted, and the timeline will be redrawn. You can optionally give a
 * date around which to zoom.
 * For example, try scale = 0.9 or 1.1
 * @param {Number} scale      Scaling factor. Values above 1 will zoom out,
 *                            values below 1 will zoom in.
 * @param {Number} [center]   Value representing a date around which will
 *                            be zoomed.
 */
Range.prototype.zoom = function (scale, center, delta) {
  // if centerDate is not provided, take it half between start Date and end Date
  if (center == null) {
    center = (this.start + this.end) / 2;
  }

  var hiddenDuration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
  var hiddenDurationBefore = DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, center);
  var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;

  // calculate new start and end
  var newStart = center - hiddenDurationBefore + (this.start - (center - hiddenDurationBefore)) * scale;
  var newEnd = center + hiddenDurationAfter + (this.end - (center + hiddenDurationAfter)) * scale;

  // snapping times away from hidden zones
  this.startToFront = delta > 0 ? false : true; // used to do the right autocorrection with periodic hidden times
  this.endToFront = -delta > 0 ? false : true; // used to do the right autocorrection with periodic hidden times
  var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, delta, true);
  var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, -delta, true);
  if (safeStart != newStart || safeEnd != newEnd) {
    newStart = safeStart;
    newEnd = safeEnd;
  }

  this.setRange(newStart, newEnd, false, true);

  this.startToFront = false; // revert to default
  this.endToFront = true; // revert to default
};

/**
 * Move the range with a given delta to the left or right. Start and end
 * value will be adjusted. For example, try delta = 0.1 or -0.1
 * @param {Number}  delta     Moving amount. Positive value will move right,
 *                            negative value will move left
 */
Range.prototype.move = function (delta) {
  // zoom start Date and end Date relative to the centerDate
  var diff = this.end - this.start;

  // apply new values
  var newStart = this.start + diff * delta;
  var newEnd = this.end + diff * delta;

  // TODO: reckon with min and max range

  this.start = newStart;
  this.end = newEnd;
};

/**
 * Move the range to a new center point
 * @param {Number} moveTo      New center point of the range
 */
Range.prototype.moveTo = function (moveTo) {
  var center = (this.start + this.end) / 2;

  var diff = center - moveTo;

  // calculate new start and end
  var newStart = this.start - diff;
  var newEnd = this.end - diff;

  this.setRange(newStart, newEnd);
};

module.exports = Range;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvUmFuZ2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDOUIsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQzFDLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ3pDLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBQ2pELElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQzs7Ozs7Ozs7OztBQVVyQyxTQUFTLEtBQUssQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFO0FBQzVCLE1BQUksR0FBRyxHQUFHLE1BQU0sRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsRSxNQUFJLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDbkQsTUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQzs7QUFFaEQsTUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7QUFDakIsTUFBSSxDQUFDLGVBQWUsR0FBRyxDQUFDLENBQUM7QUFDekIsTUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUM7QUFDckIsTUFBSSxDQUFDLFlBQVks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QUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQztBQUN0QixNQUFJLENBQUMsR0FBRyxHQUFHLE1BQU0sQ0FBQztDQUNuQixDQUFDOzs7Ozs7QUFNRixLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxVQUFTLE1BQU0sRUFBRTtBQUN4QyxNQUFJLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQSxHQUFJLENBQUMsQ0FBQzs7QUFFekMsTUFBSSxJQUFJLEdBQUcsTUFBTSxHQUFHLE1BQU0sQ0FBQzs7O0FBRzNCLE1BQUksUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0FBQ2pDLE1BQUksTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDOztBQUU3QixNQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztDQUNqQyxDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvUmFuZ2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBoYW1tZXJVdGlsID0gcmVxdWlyZSgnLi4vaGFtbWVyVXRpbCcpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJy4uL21vZHVsZS9tb21lbnQnKTtcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuL2NvbXBvbmVudC9Db21wb25lbnQnKTtcbnZhciBEYXRlVXRpbCA9IHJlcXVpcmUoJy4vRGF0ZVV0aWwnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgUmFuZ2VcbiAqIEEgUmFuZ2UgY29udHJvbHMgYSBudW1lcmljIHJhbmdlIHdpdGggYSBzdGFydCBhbmQgZW5kIHZhbHVlLlxuICogVGhlIFJhbmdlIGFkanVzdHMgdGhlIHJhbmdlIGJhc2VkIG9uIG1vdXNlIGV2ZW50cyBvciBwcm9ncmFtbWF0aWMgY2hhbmdlcyxcbiAqIGFuZCB0cmlnZ2VycyBldmVudHMgd2hlbiB0aGUgcmFuZ2UgaXMgY2hhbmdpbmcgb3IgaGFzIGJlZW4gY2hhbmdlZC5cbiAqIEBwYXJhbSB7e2RvbTogT2JqZWN0LCBkb21Qcm9wczogT2JqZWN0LCBlbWl0dGVyOiBFbWl0dGVyfX0gYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICBTZWUgZGVzY3JpcHRpb24gYXQgUmFuZ2Uuc2V0T3B0aW9uc1xuICovXG5mdW5jdGlvbiBSYW5nZShib2R5LCBvcHRpb25zKSB7XG4gIHZhciBub3cgPSBtb21lbnQoKS5ob3VycygwKS5taW51dGVzKDApLnNlY29uZHMoMCkubWlsbGlzZWNvbmRzKDApO1xuICB0aGlzLnN0YXJ0ID0gbm93LmNsb25lKCkuYWRkKC0zLCAnZGF5cycpLnZhbHVlT2YoKTsgLy8gTnVtYmVyXG4gIHRoaXMuZW5kID0gbm93LmNsb25lKCkuYWRkKDQsICdkYXlzJykudmFsdWVPZigpOyAgIC8vIE51bWJlclxuXG4gIHRoaXMuYm9keSA9IGJvZHk7XG4gIHRoaXMuZGVsdGFEaWZmZXJlbmNlID0gMDtcbiAgdGhpcy5zY2FsZU9mZnNldCA9IDA7XG4gIHRoaXMuc3RhcnRUb0Zyb250ID0gZmFsc2U7XG4gIHRoaXMuZW5kVG9Gcm9udCA9IHRydWU7XG5cbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgc3RhcnQ6IG51bGwsXG4gICAgZW5kOiBudWxsLFxuICAgIG1vbWVudDogbW9tZW50LFxuICAgIGRpcmVjdGlvbjogJ2hvcml6b250YWwnLCAvLyAnaG9yaXpvbnRhbCcgb3IgJ3ZlcnRpY2FsJ1xuICAgIG1vdmVhYmxlOiB0cnVlLFxuICAgIHpvb21hYmxlOiB0cnVlLFxuICAgIG1pbjogbnVsbCxcbiAgICBtYXg6IG51bGwsXG4gICAgem9vbU1pbjogMTAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtaWxsaXNlY29uZHNcbiAgICB6b29tTWF4OiAxMDAwICogNjAgKiA2MCAqIDI0ICogMzY1ICogMTAwMDAgIC8vIG1pbGxpc2Vjb25kc1xuICB9O1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgdGhpcy5wcm9wcyA9IHtcbiAgICB0b3VjaDoge31cbiAgfTtcbiAgdGhpcy5hbmltYXRpb25UaW1lciA9IG51bGw7XG5cbiAgLy8gZHJhZyBsaXN0ZW5lcnMgZm9yIGRyYWdnaW5nXG4gIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdwYW5zdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0LmJpbmQodGhpcykpO1xuICB0aGlzLmJvZHkuZW1pdHRlci5vbigncGFubW92ZScsICB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKSk7XG4gIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdwYW5lbmQnLCAgIHRoaXMuX29uRHJhZ0VuZC5iaW5kKHRoaXMpKTtcblxuICAvLyBtb3VzZSB3aGVlbCBmb3Igem9vbWluZ1xuICB0aGlzLmJvZHkuZW1pdHRlci5vbignbW91c2V3aGVlbCcsIHRoaXMuX29uTW91c2VXaGVlbC5iaW5kKHRoaXMpKTtcblxuICAvLyBwaW5jaCB0byB6b29tXG4gIHRoaXMuYm9keS5lbWl0dGVyLm9uKCd0b3VjaCcsIHRoaXMuX29uVG91Y2guYmluZCh0aGlzKSk7XG4gIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdwaW5jaCcsIHRoaXMuX29uUGluY2guYmluZCh0aGlzKSk7XG5cbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xufVxuXG5SYW5nZS5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbi8qKlxuICogU2V0IG9wdGlvbnMgZm9yIHRoZSByYW5nZSBjb250cm9sbGVyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyIHwgRGF0ZSB8IFN0cmluZ30gc3RhcnQgIFN0YXJ0IGRhdGUgZm9yIHRoZSByYW5nZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyIHwgRGF0ZSB8IFN0cmluZ30gZW5kICAgIEVuZCBkYXRlIGZvciB0aGUgcmFuZ2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWluICAgIE1pbmltdW0gdmFsdWUgZm9yIHN0YXJ0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IG1heCAgICBNYXhpbXVtIHZhbHVlIGZvciBlbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gem9vbU1pbiAgICBTZXQgYSBtaW5pbXVtIHZhbHVlIGZvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlbmQgLSBzdGFydCkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IHpvb21NYXggICAgU2V0IGEgbWF4aW11bSB2YWx1ZSBmb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZW5kIC0gc3RhcnQpLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gbW92ZWFibGUgRW5hYmxlIG1vdmluZyBvZiB0aGUgcmFuZ2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IGRyYWdnaW5nLiBUcnVlIGJ5IGRlZmF1bHRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IHpvb21hYmxlIEVuYWJsZSB6b29taW5nIG9mIHRoZSByYW5nZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgcGluY2hpbmcvc2Nyb2xsaW5nLiBUcnVlIGJ5IGRlZmF1bHRcbiAqL1xuUmFuZ2UucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucykge1xuICAgIC8vIGNvcHkgdGhlIG9wdGlvbnMgdGhhdCB3ZSBrbm93XG4gICAgdmFyIGZpZWxkcyA9IFtcbiAgICAgICdkaXJlY3Rpb24nLCAnbWluJywgJ21heCcsICd6b29tTWluJywgJ3pvb21NYXgnLCAnbW92ZWFibGUnLCAnem9vbWFibGUnLFxuICAgICAgJ21vbWVudCcsICdhY3RpdmF0ZScsICdoaWRkZW5EYXRlcycsICd6b29tS2V5J1xuICAgIF07XG4gICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCdzdGFydCcgaW4gb3B0aW9ucyB8fCAnZW5kJyBpbiBvcHRpb25zKSB7XG4gICAgICAvLyBhcHBseSBhIG5ldyByYW5nZS4gYm90aCBzdGFydCBhbmQgZW5kIGFyZSBvcHRpb25hbFxuICAgICAgdGhpcy5zZXRSYW5nZShvcHRpb25zLnN0YXJ0LCBvcHRpb25zLmVuZCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBkaXJlY3Rpb24gaGFzIGEgdmFsaWQgdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gICAgJ2hvcml6b250YWwnIG9yICd2ZXJ0aWNhbCdcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVEaXJlY3Rpb24gKGRpcmVjdGlvbikge1xuICBpZiAoZGlyZWN0aW9uICE9ICdob3Jpem9udGFsJyAmJiBkaXJlY3Rpb24gIT0gJ3ZlcnRpY2FsJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZGlyZWN0aW9uIFwiJyArIGRpcmVjdGlvbiArICdcIi4gJyArXG4gICAgICAgICdDaG9vc2UgXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiLicpO1xuICB9XG59XG5cbi8qKlxuICogU2V0IGEgbmV3IHN0YXJ0IGFuZCBlbmQgcmFuZ2VcbiAqIEBwYXJhbSB7RGF0ZSB8IE51bWJlciB8IFN0cmluZ30gW3N0YXJ0XVxuICogQHBhcmFtIHtEYXRlIHwgTnVtYmVyIHwgU3RyaW5nfSBbZW5kXVxuICogQHBhcmFtIHtib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9fSBbYW5pbWF0aW9uPWZhbHNlXVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHJhbmdlIGlzIGFuaW1hdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LiBBbiBvYmplY3QgY2FuIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBkdXJhdGlvbiBpcyA1MDAgbXMsIGFuZCBkZWZhdWx0IGVhc2luZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpcyAnZWFzZUluT3V0UXVhZCcuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtieVVzZXI9ZmFsc2VdXG4gKlxuICovXG5SYW5nZS5wcm90b3R5cGUuc2V0UmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBhbmltYXRpb24sIGJ5VXNlcikge1xuICBpZiAoYnlVc2VyICE9PSB0cnVlKSB7XG4gICAgYnlVc2VyID0gZmFsc2U7XG4gIH1cbiAgdmFyIGZpbmFsU3RhcnQgPSBzdGFydCAhPSB1bmRlZmluZWQgPyB1dGlsLmNvbnZlcnQoc3RhcnQsICdEYXRlJykudmFsdWVPZigpIDogbnVsbDtcbiAgdmFyIGZpbmFsRW5kICAgPSBlbmQgIT0gdW5kZWZpbmVkICAgPyB1dGlsLmNvbnZlcnQoZW5kLCAnRGF0ZScpLnZhbHVlT2YoKSAgIDogbnVsbDtcbiAgdGhpcy5fY2FuY2VsQW5pbWF0aW9uKCk7XG5cbiAgaWYgKGFuaW1hdGlvbikgeyAvLyB0cnVlIG9yIGFuIE9iamVjdFxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGluaXRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgdmFyIGluaXRFbmQgPSB0aGlzLmVuZDtcbiAgICB2YXIgZHVyYXRpb24gPSAodHlwZW9mIGFuaW1hdGlvbiA9PT0gJ29iamVjdCcgJiYgJ2R1cmF0aW9uJyBpbiBhbmltYXRpb24pID8gYW5pbWF0aW9uLmR1cmF0aW9uIDogNTAwO1xuICAgIHZhciBlYXNpbmdOYW1lID0gKHR5cGVvZiBhbmltYXRpb24gPT09ICdvYmplY3QnICYmICdlYXNpbmdGdW5jdGlvbicgaW4gYW5pbWF0aW9uKSA/IGFuaW1hdGlvbi5lYXNpbmdGdW5jdGlvbiA6ICdlYXNlSW5PdXRRdWFkJztcbiAgICB2YXIgZWFzaW5nRnVuY3Rpb24gPSB1dGlsLmVhc2luZ0Z1bmN0aW9uc1tlYXNpbmdOYW1lXTtcbiAgICBpZiAoIWVhc2luZ0Z1bmN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZWFzaW5nIGZ1bmN0aW9uICcgKyBKU09OLnN0cmluZ2lmeShlYXNpbmdOYW1lKSArICcuICcgK1xuICAgICAgICAgICdDaG9vc2UgZnJvbTogJyArIE9iamVjdC5rZXlzKHV0aWwuZWFzaW5nRnVuY3Rpb25zKS5qb2luKCcsICcpKTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdFRpbWUgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICB2YXIgYW55Q2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgdmFyIG5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIW1lLnByb3BzLnRvdWNoLmRyYWdnaW5nKSB7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgdmFyIHRpbWUgPSBub3cgLSBpbml0VGltZTtcbiAgICAgICAgdmFyIGVhc2UgPSBlYXNpbmdGdW5jdGlvbih0aW1lIC8gZHVyYXRpb24pO1xuICAgICAgICB2YXIgZG9uZSA9IHRpbWUgPiBkdXJhdGlvbjtcbiAgICAgICAgdmFyIHMgPSAoZG9uZSB8fCBmaW5hbFN0YXJ0ID09PSBudWxsKSA/IGZpbmFsU3RhcnQgOiBpbml0U3RhcnQgKyAoZmluYWxTdGFydCAtIGluaXRTdGFydCkgKiBlYXNlO1xuICAgICAgICB2YXIgZSA9IChkb25lIHx8IGZpbmFsRW5kICAgPT09IG51bGwpID8gZmluYWxFbmQgICA6IGluaXRFbmQgICArIChmaW5hbEVuZCAgIC0gaW5pdEVuZCkgICAqIGVhc2U7XG5cbiAgICAgICAgY2hhbmdlZCA9IG1lLl9hcHBseVJhbmdlKHMsIGUpO1xuICAgICAgICBEYXRlVXRpbC51cGRhdGVIaWRkZW5EYXRlcyhtZS5vcHRpb25zLm1vbWVudCwgbWUuYm9keSwgbWUub3B0aW9ucy5oaWRkZW5EYXRlcyk7XG4gICAgICAgIGFueUNoYW5nZWQgPSBhbnlDaGFuZ2VkIHx8IGNoYW5nZWQ7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgbWUuYm9keS5lbWl0dGVyLmVtaXQoJ3JhbmdlY2hhbmdlJywge3N0YXJ0OiBuZXcgRGF0ZShtZS5zdGFydCksIGVuZDogbmV3IERhdGUobWUuZW5kKSwgYnlVc2VyOmJ5VXNlcn0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBpZiAoYW55Q2hhbmdlZCkge1xuICAgICAgICAgICAgbWUuYm9keS5lbWl0dGVyLmVtaXQoJ3JhbmdlY2hhbmdlZCcsIHtzdGFydDogbmV3IERhdGUobWUuc3RhcnQpLCBlbmQ6IG5ldyBEYXRlKG1lLmVuZCksIGJ5VXNlcjpieVVzZXJ9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gYW5pbWF0ZSB3aXRoIGFzIGhpZ2ggYXMgcG9zc2libGUgZnJhbWUgcmF0ZSwgbGVhdmUgMjAgbXMgaW4gYmV0d2VlblxuICAgICAgICAgIC8vIGVhY2ggdG8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGJsb2NraW5nXG4gICAgICAgICAgbWUuYW5pbWF0aW9uVGltZXIgPSBzZXRUaW1lb3V0KG5leHQsIDIwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gbmV4dCgpO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBjaGFuZ2VkID0gdGhpcy5fYXBwbHlSYW5nZShmaW5hbFN0YXJ0LCBmaW5hbEVuZCk7XG4gICAgRGF0ZVV0aWwudXBkYXRlSGlkZGVuRGF0ZXModGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMuaGlkZGVuRGF0ZXMpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB2YXIgcGFyYW1zID0ge3N0YXJ0OiBuZXcgRGF0ZSh0aGlzLnN0YXJ0KSwgZW5kOiBuZXcgRGF0ZSh0aGlzLmVuZCksIGJ5VXNlcjpieVVzZXJ9O1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmFuZ2VjaGFuZ2UnLCBwYXJhbXMpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmFuZ2VjaGFuZ2VkJywgcGFyYW1zKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU3RvcCBhbiBhbmltYXRpb25cbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5fY2FuY2VsQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hbmltYXRpb25UaW1lcikge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmFuaW1hdGlvblRpbWVyKTtcbiAgICB0aGlzLmFuaW1hdGlvblRpbWVyID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgYSBuZXcgc3RhcnQgYW5kIGVuZCByYW5nZS4gVGhpcyBtZXRob2QgaXMgdGhlIHNhbWUgYXMgc2V0UmFuZ2UsIGJ1dFxuICogZG9lcyBub3QgdHJpZ2dlciBhIHJhbmdlIGNoYW5nZSBhbmQgcmFuZ2UgY2hhbmdlZCBldmVudCwgYW5kIGl0IHJldHVybnNcbiAqIHRydWUgd2hlbiB0aGUgcmFuZ2UgaXMgY2hhbmdlZFxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kXVxuICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICogQHByaXZhdGVcbiAqL1xuUmFuZ2UucHJvdG90eXBlLl9hcHBseVJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICB2YXIgbmV3U3RhcnQgPSAoc3RhcnQgIT0gbnVsbCkgPyB1dGlsLmNvbnZlcnQoc3RhcnQsICdEYXRlJykudmFsdWVPZigpIDogdGhpcy5zdGFydCxcbiAgICAgIG5ld0VuZCAgID0gKGVuZCAhPSBudWxsKSAgID8gdXRpbC5jb252ZXJ0KGVuZCwgJ0RhdGUnKS52YWx1ZU9mKCkgICA6IHRoaXMuZW5kLFxuICAgICAgbWF4ID0gKHRoaXMub3B0aW9ucy5tYXggIT0gbnVsbCkgPyB1dGlsLmNvbnZlcnQodGhpcy5vcHRpb25zLm1heCwgJ0RhdGUnKS52YWx1ZU9mKCkgOiBudWxsLFxuICAgICAgbWluID0gKHRoaXMub3B0aW9ucy5taW4gIT0gbnVsbCkgPyB1dGlsLmNvbnZlcnQodGhpcy5vcHRpb25zLm1pbiwgJ0RhdGUnKS52YWx1ZU9mKCkgOiBudWxsLFxuICAgICAgZGlmZjtcblxuICAvLyBjaGVjayBmb3IgdmFsaWQgbnVtYmVyXG4gIGlmIChpc05hTihuZXdTdGFydCkgfHwgbmV3U3RhcnQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhcnQgXCInICsgc3RhcnQgKyAnXCInKTtcbiAgfVxuICBpZiAoaXNOYU4obmV3RW5kKSB8fCBuZXdFbmQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5kIFwiJyArIGVuZCArICdcIicpO1xuICB9XG5cbiAgLy8gcHJldmVudCBzdGFydCA8IGVuZFxuICBpZiAobmV3RW5kIDwgbmV3U3RhcnQpIHtcbiAgICBuZXdFbmQgPSBuZXdTdGFydDtcbiAgfVxuXG4gIC8vIHByZXZlbnQgc3RhcnQgPCBtaW5cbiAgaWYgKG1pbiAhPT0gbnVsbCkge1xuICAgIGlmIChuZXdTdGFydCA8IG1pbikge1xuICAgICAgZGlmZiA9IChtaW4gLSBuZXdTdGFydCk7XG4gICAgICBuZXdTdGFydCArPSBkaWZmO1xuICAgICAgbmV3RW5kICs9IGRpZmY7XG5cbiAgICAgIC8vIHByZXZlbnQgZW5kID4gbWF4XG4gICAgICBpZiAobWF4ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG5ld0VuZCA+IG1heCkge1xuICAgICAgICAgIG5ld0VuZCA9IG1heDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHByZXZlbnQgZW5kID4gbWF4XG4gIGlmIChtYXggIT09IG51bGwpIHtcbiAgICBpZiAobmV3RW5kID4gbWF4KSB7XG4gICAgICBkaWZmID0gKG5ld0VuZCAtIG1heCk7XG4gICAgICBuZXdTdGFydCAtPSBkaWZmO1xuICAgICAgbmV3RW5kIC09IGRpZmY7XG5cbiAgICAgIC8vIHByZXZlbnQgc3RhcnQgPCBtaW5cbiAgICAgIGlmIChtaW4gIT0gbnVsbCkge1xuICAgICAgICBpZiAobmV3U3RhcnQgPCBtaW4pIHtcbiAgICAgICAgICBuZXdTdGFydCA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHByZXZlbnQgKGVuZC1zdGFydCkgPCB6b29tTWluXG4gIGlmICh0aGlzLm9wdGlvbnMuem9vbU1pbiAhPT0gbnVsbCkge1xuICAgIHZhciB6b29tTWluID0gcGFyc2VGbG9hdCh0aGlzLm9wdGlvbnMuem9vbU1pbik7XG4gICAgaWYgKHpvb21NaW4gPCAwKSB7XG4gICAgICB6b29tTWluID0gMDtcbiAgICB9XG4gICAgaWYgKChuZXdFbmQgLSBuZXdTdGFydCkgPCB6b29tTWluKSB7XG4gICAgICBpZiAoKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgPT09IHpvb21NaW4gJiYgbmV3U3RhcnQgPiB0aGlzLnN0YXJ0ICYmIG5ld0VuZCA8IHRoaXMuZW5kKSB7XG4gICAgICAgIC8vIGlnbm9yZSB0aGlzIGFjdGlvbiwgd2UgYXJlIGFscmVhZHkgem9vbWVkIHRvIHRoZSBtaW5pbXVtXG4gICAgICAgIG5ld1N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgbmV3RW5kID0gdGhpcy5lbmQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gem9vbSB0byB0aGUgbWluaW11bVxuICAgICAgICBkaWZmID0gKHpvb21NaW4gLSAobmV3RW5kIC0gbmV3U3RhcnQpKTtcbiAgICAgICAgbmV3U3RhcnQgLT0gZGlmZiAvIDI7XG4gICAgICAgIG5ld0VuZCArPSBkaWZmIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBwcmV2ZW50IChlbmQtc3RhcnQpID4gem9vbU1heFxuICBpZiAodGhpcy5vcHRpb25zLnpvb21NYXggIT09IG51bGwpIHtcbiAgICB2YXIgem9vbU1heCA9IHBhcnNlRmxvYXQodGhpcy5vcHRpb25zLnpvb21NYXgpO1xuICAgIGlmICh6b29tTWF4IDwgMCkge1xuICAgICAgem9vbU1heCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKChuZXdFbmQgLSBuZXdTdGFydCkgPiB6b29tTWF4KSB7XG4gICAgICBpZiAoKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgPT09IHpvb21NYXggJiYgbmV3U3RhcnQgPCB0aGlzLnN0YXJ0ICYmIG5ld0VuZCA+IHRoaXMuZW5kKSB7XG4gICAgICAgIC8vIGlnbm9yZSB0aGlzIGFjdGlvbiwgd2UgYXJlIGFscmVhZHkgem9vbWVkIHRvIHRoZSBtYXhpbXVtXG4gICAgICAgIG5ld1N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgbmV3RW5kID0gdGhpcy5lbmQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gem9vbSB0byB0aGUgbWF4aW11bVxuICAgICAgICBkaWZmID0gKChuZXdFbmQgLSBuZXdTdGFydCkgLSB6b29tTWF4KTtcbiAgICAgICAgbmV3U3RhcnQgKz0gZGlmZiAvIDI7XG4gICAgICAgIG5ld0VuZCAtPSBkaWZmIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgY2hhbmdlZCA9ICh0aGlzLnN0YXJ0ICE9IG5ld1N0YXJ0IHx8IHRoaXMuZW5kICE9IG5ld0VuZCk7XG5cbiAgLy8gaWYgdGhlIG5ldyByYW5nZSBkb2VzIE5PVCBvdmVybGFwIHdpdGggdGhlIG9sZCByYW5nZSwgZW1pdCBjaGVja1JhbmdlZEl0ZW1zIHRvIGF2b2lkIG5vdCBzaG93aW5nIHJhbmdlZCBpdGVtcyAocmFuZ2VkIG1lYW5pbmcgaGFzIGVuZCB0aW1lLCBub3QgbmVjZXNzYXJpbHkgb2YgdHlwZSBSYW5nZSlcbiAgaWYgKCEoKG5ld1N0YXJ0ID49IHRoaXMuc3RhcnQgJiYgbmV3U3RhcnQgICA8PSB0aGlzLmVuZCkgfHwgKG5ld0VuZCAgID49IHRoaXMuc3RhcnQgJiYgbmV3RW5kICAgPD0gdGhpcy5lbmQpKSAmJlxuICAgICAgISgodGhpcy5zdGFydCA+PSBuZXdTdGFydCAmJiB0aGlzLnN0YXJ0IDw9IG5ld0VuZCkgICB8fCAodGhpcy5lbmQgPj0gbmV3U3RhcnQgICAmJiB0aGlzLmVuZCA8PSBuZXdFbmQpICkpIHtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdjaGVja1JhbmdlZEl0ZW1zJyk7XG4gIH1cblxuICB0aGlzLnN0YXJ0ID0gbmV3U3RhcnQ7XG4gIHRoaXMuZW5kID0gbmV3RW5kO1xuICByZXR1cm4gY2hhbmdlZDtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGN1cnJlbnQgcmFuZ2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHN0YXJ0IGFuZCBlbmQgcHJvcGVydGllc1xuICovXG5SYW5nZS5wcm90b3R5cGUuZ2V0UmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogdGhpcy5zdGFydCxcbiAgICBlbmQ6IHRoaXMuZW5kXG4gIH07XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgY29udmVyc2lvbiBvZmZzZXQgYW5kIHNjYWxlIGZvciBjdXJyZW50IHJhbmdlLCBiYXNlZCBvblxuICogdGhlIHByb3ZpZGVkIHdpZHRoXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAqIEByZXR1cm5zIHt7b2Zmc2V0OiBudW1iZXIsIHNjYWxlOiBudW1iZXJ9fSBjb252ZXJzaW9uXG4gKi9cblJhbmdlLnByb3RvdHlwZS5jb252ZXJzaW9uID0gZnVuY3Rpb24gKHdpZHRoLCB0b3RhbEhpZGRlbikge1xuICByZXR1cm4gUmFuZ2UuY29udmVyc2lvbih0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgd2lkdGgsIHRvdGFsSGlkZGVuKTtcbn07XG5cbi8qKlxuICogU3RhdGljIG1ldGhvZCB0byBjYWxjdWxhdGUgdGhlIGNvbnZlcnNpb24gb2Zmc2V0IGFuZCBzY2FsZSBmb3IgYSByYW5nZSxcbiAqIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBzdGFydCwgZW5kLCBhbmQgd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFxuICogQHBhcmFtIHtOdW1iZXJ9IGVuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gKiBAcmV0dXJucyB7e29mZnNldDogbnVtYmVyLCBzY2FsZTogbnVtYmVyfX0gY29udmVyc2lvblxuICovXG5SYW5nZS5jb252ZXJzaW9uID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHdpZHRoLCB0b3RhbEhpZGRlbikge1xuICBpZiAodG90YWxIaWRkZW4gPT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsSGlkZGVuID0gMDtcbiAgfVxuICBpZiAod2lkdGggIT0gMCAmJiAoZW5kIC0gc3RhcnQgIT0gMCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0OiBzdGFydCxcbiAgICAgIHNjYWxlOiB3aWR0aCAvIChlbmQgLSBzdGFydCAtIHRvdGFsSGlkZGVuKVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0OiAwLFxuICAgICAgc2NhbGU6IDFcbiAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0IGRyYWdnaW5nIGhvcml6b250YWxseSBvciB2ZXJ0aWNhbGx5XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuUmFuZ2UucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHRoaXMuZGVsdGFEaWZmZXJlbmNlID0gMDtcbiAgdGhpcy5wcmV2aW91c0RlbHRhID0gMDtcblxuICAvLyBvbmx5IGFsbG93IGRyYWdnaW5nIHdoZW4gY29uZmlndXJlZCBhcyBtb3ZhYmxlXG4gIGlmICghdGhpcy5vcHRpb25zLm1vdmVhYmxlKSByZXR1cm47XG5cbiAgLy8gb25seSBzdGFydCBkcmFnZ2luZyB3aGVuIHRoZSBtb3VzZSBpcyBpbnNpZGUgdGhlIGN1cnJlbnQgcmFuZ2VcbiAgaWYgKCF0aGlzLl9pc0luc2lkZVJhbmdlKGV2ZW50KSkgcmV0dXJuO1xuXG4gIC8vIHJlZnVzZSB0byBkcmFnIHdoZW4gd2Ugd2hlcmUgcGluY2hpbmcgdG8gcHJldmVudCB0aGUgdGltZWxpbmUgbWFrZSBhIGp1bXBcbiAgLy8gd2hlbiByZWxlYXNpbmcgdGhlIGZpbmdlcnMgaW4gb3Bwb3NpdGUgb3JkZXIgZnJvbSB0aGUgdG91Y2ggc2NyZWVuXG4gIGlmICghdGhpcy5wcm9wcy50b3VjaC5hbGxvd0RyYWdnaW5nKSByZXR1cm47XG5cbiAgdGhpcy5wcm9wcy50b3VjaC5zdGFydCA9IHRoaXMuc3RhcnQ7XG4gIHRoaXMucHJvcHMudG91Y2guZW5kID0gdGhpcy5lbmQ7XG4gIHRoaXMucHJvcHMudG91Y2guZHJhZ2dpbmcgPSB0cnVlO1xuXG4gIGlmICh0aGlzLmJvZHkuZG9tLnJvb3QpIHtcbiAgICB0aGlzLmJvZHkuZG9tLnJvb3Quc3R5bGUuY3Vyc29yID0gJ21vdmUnO1xuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gZHJhZ2dpbmcgb3BlcmF0aW9uXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuUmFuZ2UucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKCF0aGlzLnByb3BzLnRvdWNoLmRyYWdnaW5nKSByZXR1cm47XG5cbiAgLy8gb25seSBhbGxvdyBkcmFnZ2luZyB3aGVuIGNvbmZpZ3VyZWQgYXMgbW92YWJsZVxuICBpZiAoIXRoaXMub3B0aW9ucy5tb3ZlYWJsZSkgcmV0dXJuO1xuXG4gIC8vIFRPRE86IHRoaXMgbWF5IGJlIHJlZHVuZGFudCBpbiBoYW1tZXJqczJcbiAgLy8gcmVmdXNlIHRvIGRyYWcgd2hlbiB3ZSB3aGVyZSBwaW5jaGluZyB0byBwcmV2ZW50IHRoZSB0aW1lbGluZSBtYWtlIGEganVtcFxuICAvLyB3aGVuIHJlbGVhc2luZyB0aGUgZmluZ2VycyBpbiBvcHBvc2l0ZSBvcmRlciBmcm9tIHRoZSB0b3VjaCBzY3JlZW5cbiAgaWYgKCF0aGlzLnByb3BzLnRvdWNoLmFsbG93RHJhZ2dpbmcpIHJldHVybjtcblxuICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgdmFsaWRhdGVEaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgdmFyIGRlbHRhID0gKGRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCcpID8gZXZlbnQuZGVsdGFYIDogZXZlbnQuZGVsdGFZO1xuICBkZWx0YSAtPSB0aGlzLmRlbHRhRGlmZmVyZW5jZTtcbiAgdmFyIGludGVydmFsID0gKHRoaXMucHJvcHMudG91Y2guZW5kIC0gdGhpcy5wcm9wcy50b3VjaC5zdGFydCk7XG5cbiAgLy8gbm9ybWFsaXplIGRyYWdnaW5nIHNwZWVkIGlmIGN1dG91dCBpcyBpbiBiZXR3ZWVuLlxuICB2YXIgZHVyYXRpb24gPSBEYXRlVXRpbC5nZXRIaWRkZW5EdXJhdGlvbkJldHdlZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gIGludGVydmFsIC09IGR1cmF0aW9uO1xuXG4gIHZhciB3aWR0aCA9IChkaXJlY3Rpb24gPT0gJ2hvcml6b250YWwnKSA/IHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXIud2lkdGggOiB0aGlzLmJvZHkuZG9tUHJvcHMuY2VudGVyLmhlaWdodDtcbiAgdmFyIGRpZmZSYW5nZSA9IC1kZWx0YSAvIHdpZHRoICogaW50ZXJ2YWw7XG4gIHZhciBuZXdTdGFydCA9IHRoaXMucHJvcHMudG91Y2guc3RhcnQgKyBkaWZmUmFuZ2U7XG4gIHZhciBuZXdFbmQgPSB0aGlzLnByb3BzLnRvdWNoLmVuZCArIGRpZmZSYW5nZTtcblxuICAvLyBzbmFwcGluZyB0aW1lcyBhd2F5IGZyb20gaGlkZGVuIHpvbmVzXG4gIHZhciBzYWZlU3RhcnQgPSBEYXRlVXRpbC5zbmFwQXdheUZyb21IaWRkZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCBuZXdTdGFydCwgdGhpcy5wcmV2aW91c0RlbHRhLWRlbHRhLCB0cnVlKTtcbiAgdmFyIHNhZmVFbmQgPSBEYXRlVXRpbC5zbmFwQXdheUZyb21IaWRkZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCBuZXdFbmQsIHRoaXMucHJldmlvdXNEZWx0YS1kZWx0YSwgdHJ1ZSk7XG4gIGlmIChzYWZlU3RhcnQgIT0gbmV3U3RhcnQgfHwgc2FmZUVuZCAhPSBuZXdFbmQpIHtcbiAgICB0aGlzLmRlbHRhRGlmZmVyZW5jZSArPSBkZWx0YTtcbiAgICB0aGlzLnByb3BzLnRvdWNoLnN0YXJ0ID0gc2FmZVN0YXJ0O1xuICAgIHRoaXMucHJvcHMudG91Y2guZW5kID0gc2FmZUVuZDtcbiAgICB0aGlzLl9vbkRyYWcoZXZlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMucHJldmlvdXNEZWx0YSA9IGRlbHRhO1xuICB0aGlzLl9hcHBseVJhbmdlKG5ld1N0YXJ0LCBuZXdFbmQpO1xuXG4gIC8vIGZpcmUgYSByYW5nZWNoYW5nZSBldmVudFxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZScsIHtcbiAgICBzdGFydDogbmV3IERhdGUodGhpcy5zdGFydCksXG4gICAgZW5kOiAgIG5ldyBEYXRlKHRoaXMuZW5kKSxcbiAgICBieVVzZXI6IHRydWVcbiAgfSk7XG59O1xuXG4vKipcbiAqIFN0b3AgZHJhZ2dpbmcgb3BlcmF0aW9uXG4gKiBAcGFyYW0ge2V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuUmFuZ2UucHJvdG90eXBlLl9vbkRyYWdFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKCF0aGlzLnByb3BzLnRvdWNoLmRyYWdnaW5nKSByZXR1cm47XG5cbiAgLy8gb25seSBhbGxvdyBkcmFnZ2luZyB3aGVuIGNvbmZpZ3VyZWQgYXMgbW92YWJsZVxuICBpZiAoIXRoaXMub3B0aW9ucy5tb3ZlYWJsZSkgcmV0dXJuO1xuXG4gIC8vIFRPRE86IHRoaXMgbWF5IGJlIHJlZHVuZGFudCBpbiBoYW1tZXJqczJcbiAgLy8gcmVmdXNlIHRvIGRyYWcgd2hlbiB3ZSB3aGVyZSBwaW5jaGluZyB0byBwcmV2ZW50IHRoZSB0aW1lbGluZSBtYWtlIGEganVtcFxuICAvLyB3aGVuIHJlbGVhc2luZyB0aGUgZmluZ2VycyBpbiBvcHBvc2l0ZSBvcmRlciBmcm9tIHRoZSB0b3VjaCBzY3JlZW5cbiAgaWYgKCF0aGlzLnByb3BzLnRvdWNoLmFsbG93RHJhZ2dpbmcpIHJldHVybjtcblxuICB0aGlzLnByb3BzLnRvdWNoLmRyYWdnaW5nID0gZmFsc2U7XG4gIGlmICh0aGlzLmJvZHkuZG9tLnJvb3QpIHtcbiAgICB0aGlzLmJvZHkuZG9tLnJvb3Quc3R5bGUuY3Vyc29yID0gJ2F1dG8nO1xuICB9XG5cbiAgLy8gZmlyZSBhIHJhbmdlY2hhbmdlZCBldmVudFxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZWQnLCB7XG4gICAgc3RhcnQ6IG5ldyBEYXRlKHRoaXMuc3RhcnQpLFxuICAgIGVuZDogICBuZXcgRGF0ZSh0aGlzLmVuZCksXG4gICAgYnlVc2VyOiB0cnVlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBFdmVudCBoYW5kbGVyIGZvciBtb3VzZSB3aGVlbCBldmVudCwgdXNlZCB0byB6b29tXG4gKiBDb2RlIGZyb20gaHR0cDovL2Fkb21hcy5vcmcvamF2YXNjcmlwdC1tb3VzZS13aGVlbC9cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX29uTW91c2VXaGVlbCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIC8vIG9ubHkgYWxsb3cgem9vbWluZyB3aGVuIGNvbmZpZ3VyZWQgYXMgem9vbWFibGUgYW5kIG1vdmVhYmxlXG4gIGlmICghKHRoaXMub3B0aW9ucy56b29tYWJsZSAmJiB0aGlzLm9wdGlvbnMubW92ZWFibGUpKSByZXR1cm47XG5cbiAgLy8gb25seSB6b29tIHdoZW4gdGhlIG1vdXNlIGlzIGluc2lkZSB0aGUgY3VycmVudCByYW5nZVxuICBpZiAoIXRoaXMuX2lzSW5zaWRlUmFuZ2UoZXZlbnQpKSByZXR1cm47XG4gIFxuICAvLyBvbmx5IHpvb20gd2hlbiB0aGUgYWNjb3JkaW5nIGtleSBpcyBwcmVzc2VkIGFuZCB0aGUgem9vbUtleSBvcHRpb24gaXMgc2V0XG4gIGlmICh0aGlzLm9wdGlvbnMuem9vbUtleSAmJiAhZXZlbnRbdGhpcy5vcHRpb25zLnpvb21LZXldKSByZXR1cm47XG5cbiAgLy8gcmV0cmlldmUgZGVsdGFcbiAgdmFyIGRlbHRhID0gMDtcbiAgaWYgKGV2ZW50LndoZWVsRGVsdGEpIHsgLyogSUUvT3BlcmEuICovXG4gICAgZGVsdGEgPSBldmVudC53aGVlbERlbHRhIC8gMTIwO1xuICB9IGVsc2UgaWYgKGV2ZW50LmRldGFpbCkgeyAvKiBNb3ppbGxhIGNhc2UuICovXG4gICAgLy8gSW4gTW96aWxsYSwgc2lnbiBvZiBkZWx0YSBpcyBkaWZmZXJlbnQgdGhhbiBpbiBJRS5cbiAgICAvLyBBbHNvLCBkZWx0YSBpcyBtdWx0aXBsZSBvZiAzLlxuICAgIGRlbHRhID0gLWV2ZW50LmRldGFpbCAvIDM7XG4gIH1cblxuICAvLyBJZiBkZWx0YSBpcyBub256ZXJvLCBoYW5kbGUgaXQuXG4gIC8vIEJhc2ljYWxseSwgZGVsdGEgaXMgbm93IHBvc2l0aXZlIGlmIHdoZWVsIHdhcyBzY3JvbGxlZCB1cCxcbiAgLy8gYW5kIG5lZ2F0aXZlLCBpZiB3aGVlbCB3YXMgc2Nyb2xsZWQgZG93bi5cbiAgaWYgKGRlbHRhKSB7XG4gICAgLy8gcGVyZm9ybSB0aGUgem9vbSBhY3Rpb24uIERlbHRhIGlzIG5vcm1hbGx5IDEgb3IgLTFcblxuICAgIC8vIGFkanVzdCBhIG5lZ2F0aXZlIGRlbHRhIHN1Y2ggdGhhdCB6b29taW5nIGluIHdpdGggZGVsdGEgMC4xXG4gICAgLy8gZXF1YWxzIHpvb21pbmcgb3V0IHdpdGggYSBkZWx0YSAtMC4xXG4gICAgdmFyIHNjYWxlO1xuICAgIGlmIChkZWx0YSA8IDApIHtcbiAgICAgIHNjYWxlID0gMSAtIChkZWx0YSAvIDUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHNjYWxlID0gMSAvICgxICsgKGRlbHRhIC8gNSkpIDtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgY2VudGVyLCB0aGUgZGF0ZSB0byB6b29tIGFyb3VuZFxuICAgIHZhciBwb2ludGVyID0gZ2V0UG9pbnRlcih7eDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WX0sIHRoaXMuYm9keS5kb20uY2VudGVyKTtcbiAgICB2YXIgcG9pbnRlckRhdGUgPSB0aGlzLl9wb2ludGVyVG9EYXRlKHBvaW50ZXIpO1xuXG4gICAgdGhpcy56b29tKHNjYWxlLCBwb2ludGVyRGF0ZSwgZGVsdGEpO1xuICB9XG5cbiAgLy8gUHJldmVudCBkZWZhdWx0IGFjdGlvbnMgY2F1c2VkIGJ5IG1vdXNlIHdoZWVsXG4gIC8vIChlbHNlIHRoZSBwYWdlIGFuZCB0aW1lbGluZSBib3RoIHpvb20gYW5kIHNjcm9sbClcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn07XG5cbi8qKlxuICogU3RhcnQgb2YgYSB0b3VjaCBnZXN0dXJlXG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX29uVG91Y2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdGhpcy5wcm9wcy50b3VjaC5zdGFydCA9IHRoaXMuc3RhcnQ7XG4gIHRoaXMucHJvcHMudG91Y2guZW5kID0gdGhpcy5lbmQ7XG4gIHRoaXMucHJvcHMudG91Y2guYWxsb3dEcmFnZ2luZyA9IHRydWU7XG4gIHRoaXMucHJvcHMudG91Y2guY2VudGVyID0gbnVsbDtcbiAgdGhpcy5zY2FsZU9mZnNldCA9IDA7XG4gIHRoaXMuZGVsdGFEaWZmZXJlbmNlID0gMDtcbn07XG5cbi8qKlxuICogSGFuZGxlIHBpbmNoIGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuUmFuZ2UucHJvdG90eXBlLl9vblBpbmNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIG9ubHkgYWxsb3cgem9vbWluZyB3aGVuIGNvbmZpZ3VyZWQgYXMgem9vbWFibGUgYW5kIG1vdmVhYmxlXG4gIGlmICghKHRoaXMub3B0aW9ucy56b29tYWJsZSAmJiB0aGlzLm9wdGlvbnMubW92ZWFibGUpKSByZXR1cm47XG5cbiAgdGhpcy5wcm9wcy50b3VjaC5hbGxvd0RyYWdnaW5nID0gZmFsc2U7XG5cbiAgaWYgKCF0aGlzLnByb3BzLnRvdWNoLmNlbnRlcikge1xuICAgIHRoaXMucHJvcHMudG91Y2guY2VudGVyID0gZ2V0UG9pbnRlcihldmVudC5jZW50ZXIsIHRoaXMuYm9keS5kb20uY2VudGVyKTtcbiAgfVxuXG4gIHZhciBzY2FsZSA9IDEgLyAoZXZlbnQuc2NhbGUgKyB0aGlzLnNjYWxlT2Zmc2V0KTtcbiAgdmFyIGNlbnRlckRhdGUgPSB0aGlzLl9wb2ludGVyVG9EYXRlKHRoaXMucHJvcHMudG91Y2guY2VudGVyKTtcblxuICB2YXIgaGlkZGVuRHVyYXRpb24gPSBEYXRlVXRpbC5nZXRIaWRkZW5EdXJhdGlvbkJldHdlZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gIHZhciBoaWRkZW5EdXJhdGlvbkJlZm9yZSA9IERhdGVVdGlsLmdldEhpZGRlbkR1cmF0aW9uQmVmb3JlKHRoaXMub3B0aW9ucy5tb21lbnQsIHRoaXMuYm9keS5oaWRkZW5EYXRlcywgdGhpcywgY2VudGVyRGF0ZSk7XG4gIHZhciBoaWRkZW5EdXJhdGlvbkFmdGVyID0gaGlkZGVuRHVyYXRpb24gLSBoaWRkZW5EdXJhdGlvbkJlZm9yZTtcblxuICAvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IGFuZCBlbmRcbiAgdmFyIG5ld1N0YXJ0ID0gKGNlbnRlckRhdGUgLSBoaWRkZW5EdXJhdGlvbkJlZm9yZSkgKyAodGhpcy5wcm9wcy50b3VjaC5zdGFydCAtIChjZW50ZXJEYXRlIC0gaGlkZGVuRHVyYXRpb25CZWZvcmUpKSAqIHNjYWxlO1xuICB2YXIgbmV3RW5kID0gKGNlbnRlckRhdGUgKyBoaWRkZW5EdXJhdGlvbkFmdGVyKSArICh0aGlzLnByb3BzLnRvdWNoLmVuZCAtIChjZW50ZXJEYXRlICsgaGlkZGVuRHVyYXRpb25BZnRlcikpICogc2NhbGU7XG5cbiAgLy8gc25hcHBpbmcgdGltZXMgYXdheSBmcm9tIGhpZGRlbiB6b25lc1xuICB0aGlzLnN0YXJ0VG9Gcm9udCA9IDEgLSBzY2FsZSA8PSAwOyAvLyB1c2VkIHRvIGRvIHRoZSByaWdodCBhdXRvIGNvcnJlY3Rpb24gd2l0aCBwZXJpb2RpYyBoaWRkZW4gdGltZXNcbiAgdGhpcy5lbmRUb0Zyb250ID0gc2NhbGUgLSAxIDw9IDA7ICAgLy8gdXNlZCB0byBkbyB0aGUgcmlnaHQgYXV0byBjb3JyZWN0aW9uIHdpdGggcGVyaW9kaWMgaGlkZGVuIHRpbWVzXG5cbiAgdmFyIHNhZmVTdGFydCA9IERhdGVVdGlsLnNuYXBBd2F5RnJvbUhpZGRlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIG5ld1N0YXJ0LCAxIC0gc2NhbGUsIHRydWUpO1xuICB2YXIgc2FmZUVuZCA9IERhdGVVdGlsLnNuYXBBd2F5RnJvbUhpZGRlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIG5ld0VuZCwgc2NhbGUgLSAxLCB0cnVlKTtcbiAgaWYgKHNhZmVTdGFydCAhPSBuZXdTdGFydCB8fCBzYWZlRW5kICE9IG5ld0VuZCkge1xuICAgIHRoaXMucHJvcHMudG91Y2guc3RhcnQgPSBzYWZlU3RhcnQ7XG4gICAgdGhpcy5wcm9wcy50b3VjaC5lbmQgPSBzYWZlRW5kO1xuICAgIHRoaXMuc2NhbGVPZmZzZXQgPSAxIC0gZXZlbnQuc2NhbGU7XG4gICAgbmV3U3RhcnQgPSBzYWZlU3RhcnQ7XG4gICAgbmV3RW5kID0gc2FmZUVuZDtcbiAgfVxuXG4gIHRoaXMuc2V0UmFuZ2UobmV3U3RhcnQsIG5ld0VuZCwgZmFsc2UsIHRydWUpO1xuXG4gIHRoaXMuc3RhcnRUb0Zyb250ID0gZmFsc2U7IC8vIHJldmVydCB0byBkZWZhdWx0XG4gIHRoaXMuZW5kVG9Gcm9udCA9IHRydWU7IC8vIHJldmVydCB0byBkZWZhdWx0XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciB0aGUgbW91c2UgZnJvbSBhIG1vdXNlIGV2ZW50IGlzIGluc2lkZSB0aGUgdmlzaWJsZSB3aW5kb3csXG4gKiBiZXR3ZWVuIHRoZSBjdXJyZW50IHN0YXJ0IGFuZCBlbmQgZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgd2hlbiBpbnNpZGUgdGhlIHZpc2libGUgd2luZG93XG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX2lzSW5zaWRlUmFuZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAvLyBjYWxjdWxhdGUgdGhlIHRpbWUgd2hlcmUgdGhlIG1vdXNlIGlzLCBjaGVjayB3aGV0aGVyIGluc2lkZVxuICAvLyBhbmQgbm8gc2Nyb2xsIGFjdGlvbiBzaG91bGQgaGFwcGVuLlxuICB2YXIgY2xpZW50WCA9IGV2ZW50LmNlbnRlciA/IGV2ZW50LmNlbnRlci54IDogZXZlbnQuY2xpZW50WDtcbiAgdmFyIHggPSBjbGllbnRYIC0gdXRpbC5nZXRBYnNvbHV0ZUxlZnQodGhpcy5ib2R5LmRvbS5jZW50ZXJDb250YWluZXIpO1xuICB2YXIgdGltZSA9IHRoaXMuYm9keS51dGlsLnRvVGltZSh4KTtcblxuICByZXR1cm4gdGltZSA+PSB0aGlzLnN0YXJ0ICYmIHRpbWUgPD0gdGhpcy5lbmQ7XG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdGhlIGNlbnRlciBkYXRlIGZvciB6b29taW5nXG4gKiBAcGFyYW0ge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19IHBvaW50ZXJcbiAqIEByZXR1cm4ge251bWJlcn0gZGF0ZVxuICogQHByaXZhdGVcbiAqL1xuUmFuZ2UucHJvdG90eXBlLl9wb2ludGVyVG9EYXRlID0gZnVuY3Rpb24gKHBvaW50ZXIpIHtcbiAgdmFyIGNvbnZlcnNpb247XG4gIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuXG4gIHZhbGlkYXRlRGlyZWN0aW9uKGRpcmVjdGlvbik7XG5cbiAgaWYgKGRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCcpIHtcbiAgICByZXR1cm4gdGhpcy5ib2R5LnV0aWwudG9UaW1lKHBvaW50ZXIueCkudmFsdWVPZigpO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmJvZHkuZG9tUHJvcHMuY2VudGVyLmhlaWdodDtcbiAgICBjb252ZXJzaW9uID0gdGhpcy5jb252ZXJzaW9uKGhlaWdodCk7XG4gICAgcmV0dXJuIHBvaW50ZXIueSAvIGNvbnZlcnNpb24uc2NhbGUgKyBjb252ZXJzaW9uLm9mZnNldDtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHBvaW50ZXIgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlIGxvY2F0aW9uIG9mIHRoZSBkb20gZWxlbWVudFxuICogQHBhcmFtIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSB0b3VjaFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50ICAgSFRNTCBET00gZWxlbWVudFxuICogQHJldHVybiB7e3g6IE51bWJlciwgeTogTnVtYmVyfX0gcG9pbnRlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRlciAodG91Y2gsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB0b3VjaC54IC0gdXRpbC5nZXRBYnNvbHV0ZUxlZnQoZWxlbWVudCksXG4gICAgeTogdG91Y2gueSAtIHV0aWwuZ2V0QWJzb2x1dGVUb3AoZWxlbWVudClcbiAgfTtcbn1cblxuLyoqXG4gKiBab29tIHRoZSByYW5nZSB0aGUgZ2l2ZW4gc2NhbGUgaW4gb3Igb3V0LiBTdGFydCBhbmQgZW5kIGRhdGUgd2lsbFxuICogYmUgYWRqdXN0ZWQsIGFuZCB0aGUgdGltZWxpbmUgd2lsbCBiZSByZWRyYXduLiBZb3UgY2FuIG9wdGlvbmFsbHkgZ2l2ZSBhXG4gKiBkYXRlIGFyb3VuZCB3aGljaCB0byB6b29tLlxuICogRm9yIGV4YW1wbGUsIHRyeSBzY2FsZSA9IDAuOSBvciAxLjFcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSAgICAgIFNjYWxpbmcgZmFjdG9yLiBWYWx1ZXMgYWJvdmUgMSB3aWxsIHpvb20gb3V0LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzIGJlbG93IDEgd2lsbCB6b29tIGluLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtjZW50ZXJdICAgVmFsdWUgcmVwcmVzZW50aW5nIGEgZGF0ZSBhcm91bmQgd2hpY2ggd2lsbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgem9vbWVkLlxuICovXG5SYW5nZS5wcm90b3R5cGUuem9vbSA9IGZ1bmN0aW9uKHNjYWxlLCBjZW50ZXIsIGRlbHRhKSB7XG4gIC8vIGlmIGNlbnRlckRhdGUgaXMgbm90IHByb3ZpZGVkLCB0YWtlIGl0IGhhbGYgYmV0d2VlbiBzdGFydCBEYXRlIGFuZCBlbmQgRGF0ZVxuICBpZiAoY2VudGVyID09IG51bGwpIHtcbiAgICBjZW50ZXIgPSAodGhpcy5zdGFydCArIHRoaXMuZW5kKSAvIDI7XG4gIH1cblxuICB2YXIgaGlkZGVuRHVyYXRpb24gPSBEYXRlVXRpbC5nZXRIaWRkZW5EdXJhdGlvbkJldHdlZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gIHZhciBoaWRkZW5EdXJhdGlvbkJlZm9yZSA9IERhdGVVdGlsLmdldEhpZGRlbkR1cmF0aW9uQmVmb3JlKHRoaXMub3B0aW9ucy5tb21lbnQsIHRoaXMuYm9keS5oaWRkZW5EYXRlcywgdGhpcywgY2VudGVyKTtcbiAgdmFyIGhpZGRlbkR1cmF0aW9uQWZ0ZXIgPSBoaWRkZW5EdXJhdGlvbiAtIGhpZGRlbkR1cmF0aW9uQmVmb3JlO1xuXG4gIC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgYW5kIGVuZFxuICB2YXIgbmV3U3RhcnQgPSAoY2VudGVyLWhpZGRlbkR1cmF0aW9uQmVmb3JlKSArICh0aGlzLnN0YXJ0IC0gKGNlbnRlci1oaWRkZW5EdXJhdGlvbkJlZm9yZSkpICogc2NhbGU7XG4gIHZhciBuZXdFbmQgICA9IChjZW50ZXIraGlkZGVuRHVyYXRpb25BZnRlcikgKyAodGhpcy5lbmQgLSAoY2VudGVyK2hpZGRlbkR1cmF0aW9uQWZ0ZXIpKSAqIHNjYWxlO1xuXG4gIC8vIHNuYXBwaW5nIHRpbWVzIGF3YXkgZnJvbSBoaWRkZW4gem9uZXNcbiAgdGhpcy5zdGFydFRvRnJvbnQgPSBkZWx0YSA+IDAgPyBmYWxzZSA6IHRydWU7IC8vIHVzZWQgdG8gZG8gdGhlIHJpZ2h0IGF1dG9jb3JyZWN0aW9uIHdpdGggcGVyaW9kaWMgaGlkZGVuIHRpbWVzXG4gIHRoaXMuZW5kVG9Gcm9udCA9IC1kZWx0YSAgPiAwID8gZmFsc2UgOiB0cnVlOyAvLyB1c2VkIHRvIGRvIHRoZSByaWdodCBhdXRvY29ycmVjdGlvbiB3aXRoIHBlcmlvZGljIGhpZGRlbiB0aW1lc1xuICB2YXIgc2FmZVN0YXJ0ID0gRGF0ZVV0aWwuc25hcEF3YXlGcm9tSGlkZGVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgbmV3U3RhcnQsIGRlbHRhLCB0cnVlKTtcbiAgdmFyIHNhZmVFbmQgPSBEYXRlVXRpbC5zbmFwQXdheUZyb21IaWRkZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCBuZXdFbmQsIC1kZWx0YSwgdHJ1ZSk7XG4gIGlmIChzYWZlU3RhcnQgIT0gbmV3U3RhcnQgfHwgc2FmZUVuZCAhPSBuZXdFbmQpIHtcbiAgICBuZXdTdGFydCA9IHNhZmVTdGFydDtcbiAgICBuZXdFbmQgPSBzYWZlRW5kO1xuICB9XG5cbiAgdGhpcy5zZXRSYW5nZShuZXdTdGFydCwgbmV3RW5kLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgdGhpcy5zdGFydFRvRnJvbnQgPSBmYWxzZTsgLy8gcmV2ZXJ0IHRvIGRlZmF1bHRcbiAgdGhpcy5lbmRUb0Zyb250ID0gdHJ1ZTsgLy8gcmV2ZXJ0IHRvIGRlZmF1bHRcbn07XG5cblxuXG4vKipcbiAqIE1vdmUgdGhlIHJhbmdlIHdpdGggYSBnaXZlbiBkZWx0YSB0byB0aGUgbGVmdCBvciByaWdodC4gU3RhcnQgYW5kIGVuZFxuICogdmFsdWUgd2lsbCBiZSBhZGp1c3RlZC4gRm9yIGV4YW1wbGUsIHRyeSBkZWx0YSA9IDAuMSBvciAtMC4xXG4gKiBAcGFyYW0ge051bWJlcn0gIGRlbHRhICAgICBNb3ZpbmcgYW1vdW50LiBQb3NpdGl2ZSB2YWx1ZSB3aWxsIG1vdmUgcmlnaHQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWdhdGl2ZSB2YWx1ZSB3aWxsIG1vdmUgbGVmdFxuICovXG5SYW5nZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKGRlbHRhKSB7XG4gIC8vIHpvb20gc3RhcnQgRGF0ZSBhbmQgZW5kIERhdGUgcmVsYXRpdmUgdG8gdGhlIGNlbnRlckRhdGVcbiAgdmFyIGRpZmYgPSAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KTtcblxuICAvLyBhcHBseSBuZXcgdmFsdWVzXG4gIHZhciBuZXdTdGFydCA9IHRoaXMuc3RhcnQgKyBkaWZmICogZGVsdGE7XG4gIHZhciBuZXdFbmQgPSB0aGlzLmVuZCArIGRpZmYgKiBkZWx0YTtcblxuICAvLyBUT0RPOiByZWNrb24gd2l0aCBtaW4gYW5kIG1heCByYW5nZVxuXG4gIHRoaXMuc3RhcnQgPSBuZXdTdGFydDtcbiAgdGhpcy5lbmQgPSBuZXdFbmQ7XG59O1xuXG4vKipcbiAqIE1vdmUgdGhlIHJhbmdlIHRvIGEgbmV3IGNlbnRlciBwb2ludFxuICogQHBhcmFtIHtOdW1iZXJ9IG1vdmVUbyAgICAgIE5ldyBjZW50ZXIgcG9pbnQgb2YgdGhlIHJhbmdlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbihtb3ZlVG8pIHtcbiAgdmFyIGNlbnRlciA9ICh0aGlzLnN0YXJ0ICsgdGhpcy5lbmQpIC8gMjtcblxuICB2YXIgZGlmZiA9IGNlbnRlciAtIG1vdmVUbztcblxuICAvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IGFuZCBlbmRcbiAgdmFyIG5ld1N0YXJ0ID0gdGhpcy5zdGFydCAtIGRpZmY7XG4gIHZhciBuZXdFbmQgPSB0aGlzLmVuZCAtIGRpZmY7XG5cbiAgdGhpcy5zZXRSYW5nZShuZXdTdGFydCwgbmV3RW5kKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZ2U7XG4iXX0=
},{"../hammerUtil":18,"../module/moment":20,"../util":46,"./DateUtil":27,"./component/Component":33}],29:[function(require,module,exports){
// Utility functions for ordering and stacking of items
'use strict';

var EPSILON = 0.001; // used when checking collisions, to prevent round-off errors

/**
 * Order items by their start data
 * @param {Item[]} items
 */
exports.orderByStart = function (items) {
  items.sort(function (a, b) {
    return a.data.start - b.data.start;
  });
};

/**
 * Order items by their end date. If they have no end date, their start date
 * is used.
 * @param {Item[]} items
 */
exports.orderByEnd = function (items) {
  items.sort(function (a, b) {
    var aTime = 'end' in a.data ? a.data.end : a.data.start,
        bTime = 'end' in b.data ? b.data.end : b.data.start;

    return aTime - bTime;
  });
};

/**
 * Adjust vertical positions of the items such that they don't overlap each
 * other.
 * @param {Item[]} items
 *            All visible items
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 *            Margins between items and between items and the axis.
 * @param {boolean} [force=false]
 *            If true, all items will be repositioned. If false (default), only
 *            items having a top===null will be re-stacked
 */
exports.stack = function (items, margin, force) {
  var i, iMax;

  if (force) {
    // reset top position of all items
    for (i = 0, iMax = items.length; i < iMax; i++) {
      items[i].top = null;
    }
  }

  // calculate new, non-overlapping positions
  for (i = 0, iMax = items.length; i < iMax; i++) {
    var item = items[i];
    if (item.stack && item.top === null) {
      // initialize top position
      item.top = margin.axis;

      do {
        // TODO: optimize checking for overlap. when there is a gap without items,
        //       you only need to check for items from the next item on, not from zero
        var collidingItem = null;
        for (var j = 0, jj = items.length; j < jj; j++) {
          var other = items[j];
          if (other.top !== null && other !== item && other.stack && exports.collision(item, other, margin.item)) {
            collidingItem = other;
            break;
          }
        }

        if (collidingItem != null) {
          // There is a collision. Reposition the items above the colliding element
          item.top = collidingItem.top + collidingItem.height + margin.item.vertical;
        }
      } while (collidingItem);
    }
  }
};

/**
 * Adjust vertical positions of the items without stacking them
 * @param {Item[]} items
 *            All visible items
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 *            Margins between items and between items and the axis.
 */
exports.nostack = function (items, margin, subgroups) {
  var i, iMax, newTop;

  // reset top position of all items
  for (i = 0, iMax = items.length; i < iMax; i++) {
    if (items[i].data.subgroup !== undefined) {
      newTop = margin.axis;
      for (var subgroup in subgroups) {
        if (subgroups.hasOwnProperty(subgroup)) {
          if (subgroups[subgroup].visible == true && subgroups[subgroup].index < subgroups[items[i].data.subgroup].index) {
            newTop += subgroups[subgroup].height + margin.item.vertical;
          }
        }
      }
      items[i].top = newTop;
    } else {
      items[i].top = margin.axis;
    }
  }
};

/**
 * Test if the two provided items collide
 * The items must have parameters left, width, top, and height.
 * @param {Item} a          The first item
 * @param {Item} b          The second item
 * @param {{horizontal: number, vertical: number}} margin
 *                          An object containing a horizontal and vertical
 *                          minimum required margin.
 * @return {boolean}        true if a and b collide, else false
 */
exports.collision = function (a, b, margin) {
  return a.left - margin.horizontal + EPSILON < b.left + b.width && a.left + a.width + margin.horizontal - EPSILON > b.left && a.top - margin.vertical + EPSILON < b.top + b.height && a.top + a.height + margin.vertical - EPSILON > b.top;
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvU3RhY2suanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDOzs7Ozs7QUFNcEIsT0FBTyxDQUFDLFlBQVksR0FBRyxVQUFTLEtBQUssRUFBRTtBQUNyQyxPQUFLLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUN6QixXQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO0dBQ3BDLENBQUMsQ0FBQztDQUNKLENBQUM7Ozs7Ozs7QUFPRixPQUFPLENBQUMsVUFBVSxHQUFHLFVBQVMsS0FBSyxFQUFFO0FBQ25DLE9BQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQ3pCLFFBQUksS0FBSyxHQUFHLEFBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxJQUFJLEdBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLO1FBQ3JELEtBQUssR0FBRyxBQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsSUFBSSxHQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDOztBQUUxRCxXQUFPLEtBQUssR0FBRyxLQUFLLENBQUM7R0FDdEIsQ0FBQyxDQUFDO0NBQ0osQ0FBQzs7Ozs7Ozs7Ozs7OztBQWFGLE9BQU8sQ0FBQyxLQUFLLEdBQUcsVUFBUyxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRTtBQUM3QyxNQUFJLENBQUMsRUFBRSxJQUFJLENBQUM7O0FBRVosTUFBSSxLQUFLLEVBQUU7O0FBRVQsU0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFF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QUU7QUFDekMsU0FBUSxBQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLFVBQVUsR0FBRyxPQUFPLEdBQVcsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsS0FBSyxBQUFDLElBQ3JFLEFBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxVQUFVLEdBQUcsT0FBTyxHQUFJLENBQUMsQ0FBQyxJQUFJLElBQ3pELEFBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUMsUUFBUSxHQUFHLE9BQU8sR0FBa0IsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsTUFBTSxBQUFDLElBQ3JFLEFBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxRQUFRLEdBQUcsT0FBTyxHQUFNLENBQUMsQ0FBQyxHQUFHLENBQUU7Q0FDL0QsQ0FBQyIsImZpbGUiOiIvVXNlcnMvZGFyaW4vRGV2ZWxvcG1lbnQvbWFwc3Rvcnkvc3RvcnktdG9vbHMtdmlld2VyL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL1N0YWNrLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIG9yZGVyaW5nIGFuZCBzdGFja2luZyBvZiBpdGVtc1xudmFyIEVQU0lMT04gPSAwLjAwMTsgLy8gdXNlZCB3aGVuIGNoZWNraW5nIGNvbGxpc2lvbnMsIHRvIHByZXZlbnQgcm91bmQtb2ZmIGVycm9yc1xuXG4vKipcbiAqIE9yZGVyIGl0ZW1zIGJ5IHRoZWlyIHN0YXJ0IGRhdGFcbiAqIEBwYXJhbSB7SXRlbVtdfSBpdGVtc1xuICovXG5leHBvcnRzLm9yZGVyQnlTdGFydCA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gIGl0ZW1zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5kYXRhLnN0YXJ0IC0gYi5kYXRhLnN0YXJ0O1xuICB9KTtcbn07XG5cbi8qKlxuICogT3JkZXIgaXRlbXMgYnkgdGhlaXIgZW5kIGRhdGUuIElmIHRoZXkgaGF2ZSBubyBlbmQgZGF0ZSwgdGhlaXIgc3RhcnQgZGF0ZVxuICogaXMgdXNlZC5cbiAqIEBwYXJhbSB7SXRlbVtdfSBpdGVtc1xuICovXG5leHBvcnRzLm9yZGVyQnlFbmQgPSBmdW5jdGlvbihpdGVtcykge1xuICBpdGVtcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGFUaW1lID0gKCdlbmQnIGluIGEuZGF0YSkgPyBhLmRhdGEuZW5kIDogYS5kYXRhLnN0YXJ0LFxuICAgICAgICBiVGltZSA9ICgnZW5kJyBpbiBiLmRhdGEpID8gYi5kYXRhLmVuZCA6IGIuZGF0YS5zdGFydDtcblxuICAgIHJldHVybiBhVGltZSAtIGJUaW1lO1xuICB9KTtcbn07XG5cbi8qKlxuICogQWRqdXN0IHZlcnRpY2FsIHBvc2l0aW9ucyBvZiB0aGUgaXRlbXMgc3VjaCB0aGF0IHRoZXkgZG9uJ3Qgb3ZlcmxhcCBlYWNoXG4gKiBvdGhlci5cbiAqIEBwYXJhbSB7SXRlbVtdfSBpdGVtc1xuICogICAgICAgICAgICBBbGwgdmlzaWJsZSBpdGVtc1xuICogQHBhcmFtIHt7aXRlbToge2hvcml6b250YWw6IG51bWJlciwgdmVydGljYWw6IG51bWJlcn0sIGF4aXM6IG51bWJlcn19IG1hcmdpblxuICogICAgICAgICAgICBNYXJnaW5zIGJldHdlZW4gaXRlbXMgYW5kIGJldHdlZW4gaXRlbXMgYW5kIHRoZSBheGlzLlxuICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdXG4gKiAgICAgICAgICAgIElmIHRydWUsIGFsbCBpdGVtcyB3aWxsIGJlIHJlcG9zaXRpb25lZC4gSWYgZmFsc2UgKGRlZmF1bHQpLCBvbmx5XG4gKiAgICAgICAgICAgIGl0ZW1zIGhhdmluZyBhIHRvcD09PW51bGwgd2lsbCBiZSByZS1zdGFja2VkXG4gKi9cbmV4cG9ydHMuc3RhY2sgPSBmdW5jdGlvbihpdGVtcywgbWFyZ2luLCBmb3JjZSkge1xuICB2YXIgaSwgaU1heDtcblxuICBpZiAoZm9yY2UpIHtcbiAgICAvLyByZXNldCB0b3AgcG9zaXRpb24gb2YgYWxsIGl0ZW1zXG4gICAgZm9yIChpID0gMCwgaU1heCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgaXRlbXNbaV0udG9wID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgbmV3LCBub24tb3ZlcmxhcHBpbmcgcG9zaXRpb25zXG4gIGZvciAoaSA9IDAsIGlNYXggPSBpdGVtcy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuICAgIGlmIChpdGVtLnN0YWNrICYmIGl0ZW0udG9wID09PSBudWxsKSB7XG4gICAgICAvLyBpbml0aWFsaXplIHRvcCBwb3NpdGlvblxuICAgICAgaXRlbS50b3AgPSBtYXJnaW4uYXhpcztcblxuICAgICAgZG8ge1xuICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSBjaGVja2luZyBmb3Igb3ZlcmxhcC4gd2hlbiB0aGVyZSBpcyBhIGdhcCB3aXRob3V0IGl0ZW1zLFxuICAgICAgICAvLyAgICAgICB5b3Ugb25seSBuZWVkIHRvIGNoZWNrIGZvciBpdGVtcyBmcm9tIHRoZSBuZXh0IGl0ZW0gb24sIG5vdCBmcm9tIHplcm9cbiAgICAgICAgdmFyIGNvbGxpZGluZ0l0ZW0gPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgamogPSBpdGVtcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgdmFyIG90aGVyID0gaXRlbXNbal07XG4gICAgICAgICAgaWYgKG90aGVyLnRvcCAhPT0gbnVsbCAmJiBvdGhlciAhPT0gaXRlbSAmJiBvdGhlci5zdGFjayAmJiBleHBvcnRzLmNvbGxpc2lvbihpdGVtLCBvdGhlciwgbWFyZ2luLml0ZW0pKSB7XG4gICAgICAgICAgICBjb2xsaWRpbmdJdGVtID0gb3RoZXI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sbGlkaW5nSXRlbSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgYSBjb2xsaXNpb24uIFJlcG9zaXRpb24gdGhlIGl0ZW1zIGFib3ZlIHRoZSBjb2xsaWRpbmcgZWxlbWVudFxuICAgICAgICAgIGl0ZW0udG9wID0gY29sbGlkaW5nSXRlbS50b3AgKyBjb2xsaWRpbmdJdGVtLmhlaWdodCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChjb2xsaWRpbmdJdGVtKTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBBZGp1c3QgdmVydGljYWwgcG9zaXRpb25zIG9mIHRoZSBpdGVtcyB3aXRob3V0IHN0YWNraW5nIHRoZW1cbiAqIEBwYXJhbSB7SXRlbVtdfSBpdGVtc1xuICogICAgICAgICAgICBBbGwgdmlzaWJsZSBpdGVtc1xuICogQHBhcmFtIHt7aXRlbToge2hvcml6b250YWw6IG51bWJlciwgdmVydGljYWw6IG51bWJlcn0sIGF4aXM6IG51bWJlcn19IG1hcmdpblxuICogICAgICAgICAgICBNYXJnaW5zIGJldHdlZW4gaXRlbXMgYW5kIGJldHdlZW4gaXRlbXMgYW5kIHRoZSBheGlzLlxuICovXG5leHBvcnRzLm5vc3RhY2sgPSBmdW5jdGlvbihpdGVtcywgbWFyZ2luLCBzdWJncm91cHMpIHtcbiAgdmFyIGksIGlNYXgsIG5ld1RvcDtcblxuICAvLyByZXNldCB0b3AgcG9zaXRpb24gb2YgYWxsIGl0ZW1zXG4gIGZvciAoaSA9IDAsIGlNYXggPSBpdGVtcy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICBpZiAoaXRlbXNbaV0uZGF0YS5zdWJncm91cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdUb3AgPSBtYXJnaW4uYXhpcztcbiAgICAgIGZvciAodmFyIHN1Ymdyb3VwIGluIHN1Ymdyb3Vwcykge1xuICAgICAgICBpZiAoc3ViZ3JvdXBzLmhhc093blByb3BlcnR5KHN1Ymdyb3VwKSkge1xuICAgICAgICAgIGlmIChzdWJncm91cHNbc3ViZ3JvdXBdLnZpc2libGUgPT0gdHJ1ZSAmJiBzdWJncm91cHNbc3ViZ3JvdXBdLmluZGV4IDwgc3ViZ3JvdXBzW2l0ZW1zW2ldLmRhdGEuc3ViZ3JvdXBdLmluZGV4KSB7XG4gICAgICAgICAgICBuZXdUb3AgKz0gc3ViZ3JvdXBzW3N1Ymdyb3VwXS5oZWlnaHQgKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGl0ZW1zW2ldLnRvcCA9IG5ld1RvcDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpdGVtc1tpXS50b3AgPSBtYXJnaW4uYXhpcztcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVGVzdCBpZiB0aGUgdHdvIHByb3ZpZGVkIGl0ZW1zIGNvbGxpZGVcbiAqIFRoZSBpdGVtcyBtdXN0IGhhdmUgcGFyYW1ldGVycyBsZWZ0LCB3aWR0aCwgdG9wLCBhbmQgaGVpZ2h0LlxuICogQHBhcmFtIHtJdGVtfSBhICAgICAgICAgIFRoZSBmaXJzdCBpdGVtXG4gKiBAcGFyYW0ge0l0ZW19IGIgICAgICAgICAgVGhlIHNlY29uZCBpdGVtXG4gKiBAcGFyYW0ge3tob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9fSBtYXJnaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBhIGhvcml6b250YWwgYW5kIHZlcnRpY2FsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bSByZXF1aXJlZCBtYXJnaW4uXG4gKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgdHJ1ZSBpZiBhIGFuZCBiIGNvbGxpZGUsIGVsc2UgZmFsc2VcbiAqL1xuZXhwb3J0cy5jb2xsaXNpb24gPSBmdW5jdGlvbihhLCBiLCBtYXJnaW4pIHtcbiAgcmV0dXJuICgoYS5sZWZ0IC0gbWFyZ2luLmhvcml6b250YWwgKyBFUFNJTE9OKSAgICAgICA8IChiLmxlZnQgKyBiLndpZHRoKSAmJlxuICAgICAgKGEubGVmdCArIGEud2lkdGggKyBtYXJnaW4uaG9yaXpvbnRhbCAtIEVQU0lMT04pID4gYi5sZWZ0ICYmXG4gICAgICAoYS50b3AgLSBtYXJnaW4udmVydGljYWwgKyBFUFNJTE9OKSAgICAgICAgICAgICAgPCAoYi50b3AgKyBiLmhlaWdodCkgJiZcbiAgICAgIChhLnRvcCArIGEuaGVpZ2h0ICsgbWFyZ2luLnZlcnRpY2FsIC0gRVBTSUxPTikgICA+IGIudG9wKTtcbn07XG4iXX0=
},{}],30:[function(require,module,exports){
'use strict';

var moment = require('../module/moment');
var DateUtil = require('./DateUtil');
var util = require('../util');

/**
 * @constructor  TimeStep
 * The class TimeStep is an iterator for dates. You provide a start date and an
 * end date. The class itself determines the best scale (step size) based on the
 * provided start Date, end Date, and minimumStep.
 *
 * If minimumStep is provided, the step size is chosen as close as possible
 * to the minimumStep but larger than minimumStep. If minimumStep is not
 * provided, the scale is set to 1 DAY.
 * The minimumStep should correspond with the onscreen size of about 6 characters
 *
 * Alternatively, you can set a scale by hand.
 * After creation, you can initialize the class by executing first(). Then you
 * can iterate from the start date to the end date via next(). You can check if
 * the end date is reached with the function hasNext(). After each step, you can
 * retrieve the current date via getCurrent().
 * The TimeStep has scales ranging from milliseconds, seconds, minutes, hours,
 * days, to years.
 *
 * Version: 1.2
 *
 * @param {Date} [start]         The start date, for example new Date(2010, 9, 21)
 *                               or new Date(2010, 9, 21, 23, 45, 00)
 * @param {Date} [end]           The end date
 * @param {Number} [minimumStep] Optional. Minimum step size in milliseconds
 */
function TimeStep(start, end, minimumStep, hiddenDates) {
  this.moment = moment;

  // variables
  this.current = this.moment();
  this._start = this.moment();
  this._end = this.moment();

  this.autoScale = true;
  this.scale = 'day';
  this.step = 1;

  // initialize the range
  this.setRange(start, end, minimumStep);

  // hidden Dates options
  this.switchedDay = false;
  this.switchedMonth = false;
  this.switchedYear = false;
  if (Array.isArray(hiddenDates)) {
    this.hiddenDates = hiddenDates;
  } else if (hiddenDates != undefined) {
    this.hiddenDates = [hiddenDates];
  } else {
    this.hiddenDates = [];
  }

  this.format = TimeStep.FORMAT; // default formatting
}

// Time formatting
TimeStep.FORMAT = {
  minorLabels: {
    millisecond: 'SSS',
    second: 's',
    minute: 'HH:mm',
    hour: 'HH:mm',
    weekday: 'ddd D',
    day: 'D',
    month: 'MMM',
    year: 'YYYY'
  },
  majorLabels: {
    millisecond: 'HH:mm:ss',
    second: 'D MMMM HH:mm',
    minute: 'ddd D MMMM',
    hour: 'ddd D MMMM',
    weekday: 'MMMM YYYY',
    day: 'MMMM YYYY',
    month: 'YYYY',
    year: ''
  }
};

/**
 * Set custom constructor function for moment. Can be used to set dates
 * to UTC or to set a utcOffset.
 * @param {function} moment
 */
TimeStep.prototype.setMoment = function (moment) {
  this.moment = moment;

  // update the date properties, can have a new utcOffset
  this.current = this.moment(this.current);
  this._start = this.moment(this._start);
  this._end = this.moment(this._end);
};

/**
 * Set custom formatting for the minor an major labels of the TimeStep.
 * Both `minorLabels` and `majorLabels` are an Object with properties:
 * 'millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'month', 'year'.
 * @param {{minorLabels: Object, majorLabels: Object}} format
 */
TimeStep.prototype.setFormat = function (format) {
  var defaultFormat = util.deepExtend({}, TimeStep.FORMAT);
  this.format = util.deepExtend(defaultFormat, format);
};

/**
 * Set a new range
 * If minimumStep is provided, the step size is chosen as close as possible
 * to the minimumStep but larger than minimumStep. If minimumStep is not
 * provided, the scale is set to 1 DAY.
 * The minimumStep should correspond with the onscreen size of about 6 characters
 * @param {Date} [start]      The start date and time.
 * @param {Date} [end]        The end date and time.
 * @param {int} [minimumStep] Optional. Minimum step size in milliseconds
 */
TimeStep.prototype.setRange = function (start, end, minimumStep) {
  if (!(start instanceof Date) || !(end instanceof Date)) {
    throw "No legal start or end date in method setRange";
  }

  this._start = start != undefined ? this.moment(start.valueOf()) : new Date();
  this._end = end != undefined ? this.moment(end.valueOf()) : new Date();

  if (this.autoScale) {
    this.setMinimumStep(minimumStep);
  }
};

/**
 * Set the range iterator to the start date.
 */
TimeStep.prototype.start = function () {
  this.current = this._start.clone();
  this.roundToMinor();
};

/**
 * Round the current date to the first minor date value
 * This must be executed once when the current date is set to start Date
 */
TimeStep.prototype.roundToMinor = function () {
  // round to floor
  // IMPORTANT: we have no breaks in this switch! (this is no bug)
  // noinspection FallThroughInSwitchStatementJS
  switch (this.scale) {
    case 'year':
      this.current.year(this.step * Math.floor(this.current.year() / this.step));
      this.current.month(0);
    case 'month':
      this.current.date(1);
    case 'day': // intentional fall through
    case 'weekday':
      this.current.hours(0);
    case 'hour':
      this.current.minutes(0);
    case 'minute':
      this.current.seconds(0);
    case 'second':
      this.current.milliseconds(0);
    //case 'millisecond': // nothing to do for milliseconds
  }

  if (this.step != 1) {
    // round down to the first minor value that is a multiple of the current step size
    switch (this.scale) {
      case 'millisecond':
        this.current.subtract(this.current.milliseconds() % this.step, 'milliseconds');break;
      case 'second':
        this.current.subtract(this.current.seconds() % this.step, 'seconds');break;
      case 'minute':
        this.current.subtract(this.current.minutes() % this.step, 'minutes');break;
      case 'hour':
        this.current.subtract(this.current.hours() % this.step, 'hours');break;
      case 'weekday': // intentional fall through
      case 'day':
        this.current.subtract((this.current.date() - 1) % this.step, 'day');break;
      case 'month':
        this.current.subtract(this.current.month() % this.step, 'month');break;
      case 'year':
        this.current.subtract(this.current.year() % this.step, 'year');break;
      default:
        break;
    }
  }
};

/**
 * Check if the there is a next step
 * @return {boolean}  true if the current date has not passed the end date
 */
TimeStep.prototype.hasNext = function () {
  return this.current.valueOf() <= this._end.valueOf();
};

/**
 * Do the next step
 */
TimeStep.prototype.next = function () {
  var prev = this.current.valueOf();

  // Two cases, needed to prevent issues with switching daylight savings
  // (end of March and end of October)
  if (this.current.month() < 6) {
    switch (this.scale) {
      case 'millisecond':
        this.current.add(this.step, 'millisecond');break;
      case 'second':
        this.current.add(this.step, 'second');break;
      case 'minute':
        this.current.add(this.step, 'minute');break;
      case 'hour':
        this.current.add(this.step, 'hour');
        // in case of skipping an hour for daylight savings, adjust the hour again (else you get: 0h 5h 9h ... instead of 0h 4h 8h ...)
        // TODO: is this still needed now we use the function of moment.js?
        this.current.subtract(this.current.hours() % this.step, 'hour');
        break;
      case 'weekday': // intentional fall through
      case 'day':
        this.current.add(this.step, 'day');break;
      case 'month':
        this.current.add(this.step, 'month');break;
      case 'year':
        this.current.add(this.step, 'year');break;
      default:
        break;
    }
  } else {
    switch (this.scale) {
      case 'millisecond':
        this.current.add(this.step, 'millisecond');break;
      case 'second':
        this.current.add(this.step, 'second');break;
      case 'minute':
        this.current.add(this.step, 'minute');break;
      case 'hour':
        this.current.add(this.step, 'hour');break;
      case 'weekday': // intentional fall through
      case 'day':
        this.current.add(this.step, 'day');break;
      case 'month':
        this.current.add(this.step, 'month');break;
      case 'year':
        this.current.add(this.step, 'year');break;
      default:
        break;
    }
  }

  if (this.step != 1) {
    // round down to the correct major value
    switch (this.scale) {
      case 'millisecond':
        if (this.current.milliseconds() < this.step) this.current.milliseconds(0);break;
      case 'second':
        if (this.current.seconds() < this.step) this.current.seconds(0);break;
      case 'minute':
        if (this.current.minutes() < this.step) this.current.minutes(0);break;
      case 'hour':
        if (this.current.hours() < this.step) this.current.hours(0);break;
      case 'weekday': // intentional fall through
      case 'day':
        if (this.current.date() < this.step + 1) this.current.date(1);break;
      case 'month':
        if (this.current.month() < this.step) this.current.month(0);break;
      case 'year':
        break; // nothing to do for year
      default:
        break;
    }
  }

  // safety mechanism: if current time is still unchanged, move to the end
  if (this.current.valueOf() == prev) {
    this.current = this._end.clone();
  }

  DateUtil.stepOverHiddenDates(this.moment, this, prev);
};

/**
 * Get the current datetime
 * @return {Moment}  current The current date
 */
TimeStep.prototype.getCurrent = function () {
  return this.current;
};

/**
 * Set a custom scale. Autoscaling will be disabled.
 * For example setScale('minute', 5) will result
 * in minor steps of 5 minutes, and major steps of an hour.
 *
 * @param {{scale: string, step: number}} params
 *                               An object containing two properties:
 *                               - A string 'scale'. Choose from 'millisecond', 'second',
 *                                 'minute', 'hour', 'weekday', 'day', 'month', 'year'.
 *                               - A number 'step'. A step size, by default 1.
 *                                 Choose for example 1, 2, 5, or 10.
 */
TimeStep.prototype.setScale = function (params) {
  if (params && typeof params.scale == 'string') {
    this.scale = params.scale;
    this.step = params.step > 0 ? params.step : 1;
    this.autoScale = false;
  }
};

/**
 * Enable or disable autoscaling
 * @param {boolean} enable  If true, autoascaling is set true
 */
TimeStep.prototype.setAutoScale = function (enable) {
  this.autoScale = enable;
};

/**
 * Automatically determine the scale that bests fits the provided minimum step
 * @param {Number} [minimumStep]  The minimum step size in milliseconds
 */
TimeStep.prototype.setMinimumStep = function (minimumStep) {
  if (minimumStep == undefined) {
    return;
  }

  //var b = asc + ds;

  var stepYear = 1000 * 60 * 60 * 24 * 30 * 12;
  var stepMonth = 1000 * 60 * 60 * 24 * 30;
  var stepDay = 1000 * 60 * 60 * 24;
  var stepHour = 1000 * 60 * 60;
  var stepMinute = 1000 * 60;
  var stepSecond = 1000;
  var stepMillisecond = 1;

  // find the smallest step that is larger than the provided minimumStep
  if (stepYear * 1000 > minimumStep) {
    this.scale = 'year';this.step = 1000;
  }
  if (stepYear * 500 > minimumStep) {
    this.scale = 'year';this.step = 500;
  }
  if (stepYear * 100 > minimumStep) {
    this.scale = 'year';this.step = 100;
  }
  if (stepYear * 50 > minimumStep) {
    this.scale = 'year';this.step = 50;
  }
  if (stepYear * 10 > minimumStep) {
    this.scale = 'year';this.step = 10;
  }
  if (stepYear * 5 > minimumStep) {
    this.scale = 'year';this.step = 5;
  }
  if (stepYear > minimumStep) {
    this.scale = 'year';this.step = 1;
  }
  if (stepMonth * 3 > minimumStep) {
    this.scale = 'month';this.step = 3;
  }
  if (stepMonth > minimumStep) {
    this.scale = 'month';this.step = 1;
  }
  if (stepDay * 5 > minimumStep) {
    this.scale = 'day';this.step = 5;
  }
  if (stepDay * 2 > minimumStep) {
    this.scale = 'day';this.step = 2;
  }
  if (stepDay > minimumStep) {
    this.scale = 'day';this.step = 1;
  }
  if (stepDay / 2 > minimumStep) {
    this.scale = 'weekday';this.step = 1;
  }
  if (stepHour * 4 > minimumStep) {
    this.scale = 'hour';this.step = 4;
  }
  if (stepHour > minimumStep) {
    this.scale = 'hour';this.step = 1;
  }
  if (stepMinute * 15 > minimumStep) {
    this.scale = 'minute';this.step = 15;
  }
  if (stepMinute * 10 > minimumStep) {
    this.scale = 'minute';this.step = 10;
  }
  if (stepMinute * 5 > minimumStep) {
    this.scale = 'minute';this.step = 5;
  }
  if (stepMinute > minimumStep) {
    this.scale = 'minute';this.step = 1;
  }
  if (stepSecond * 15 > minimumStep) {
    this.scale = 'second';this.step = 15;
  }
  if (stepSecond * 10 > minimumStep) {
    this.scale = 'second';this.step = 10;
  }
  if (stepSecond * 5 > minimumStep) {
    this.scale = 'second';this.step = 5;
  }
  if (stepSecond > minimumStep) {
    this.scale = 'second';this.step = 1;
  }
  if (stepMillisecond * 200 > minimumStep) {
    this.scale = 'millisecond';this.step = 200;
  }
  if (stepMillisecond * 100 > minimumStep) {
    this.scale = 'millisecond';this.step = 100;
  }
  if (stepMillisecond * 50 > minimumStep) {
    this.scale = 'millisecond';this.step = 50;
  }
  if (stepMillisecond * 10 > minimumStep) {
    this.scale = 'millisecond';this.step = 10;
  }
  if (stepMillisecond * 5 > minimumStep) {
    this.scale = 'millisecond';this.step = 5;
  }
  if (stepMillisecond > minimumStep) {
    this.scale = 'millisecond';this.step = 1;
  }
};

/**
 * Snap a date to a rounded value.
 * The snap intervals are dependent on the current scale and step.
 * Static function
 * @param {Date} date    the date to be snapped.
 * @param {string} scale Current scale, can be 'millisecond', 'second',
 *                       'minute', 'hour', 'weekday, 'day', 'month', 'year'.
 * @param {number} step  Current step (1, 2, 4, 5, ...
 * @return {Date} snappedDate
 */
TimeStep.snap = function (date, scale, step) {
  var clone = moment(date);

  if (scale == 'year') {
    var year = clone.year() + Math.round(clone.month() / 12);
    clone.year(Math.round(year / step) * step);
    clone.month(0);
    clone.date(0);
    clone.hours(0);
    clone.minutes(0);
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'month') {
    if (clone.date() > 15) {
      clone.date(1);
      clone.add(1, 'month');
      // important: first set Date to 1, after that change the month.
    } else {
        clone.date(1);
      }

    clone.hours(0);
    clone.minutes(0);
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'day') {
    //noinspection FallthroughInSwitchStatementJS
    switch (step) {
      case 5:
      case 2:
        clone.hours(Math.round(clone.hours() / 24) * 24);break;
      default:
        clone.hours(Math.round(clone.hours() / 12) * 12);break;
    }
    clone.minutes(0);
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'weekday') {
    //noinspection FallthroughInSwitchStatementJS
    switch (step) {
      case 5:
      case 2:
        clone.hours(Math.round(clone.hours() / 12) * 12);break;
      default:
        clone.hours(Math.round(clone.hours() / 6) * 6);break;
    }
    clone.minutes(0);
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'hour') {
    switch (step) {
      case 4:
        clone.minutes(Math.round(clone.minutes() / 60) * 60);break;
      default:
        clone.minutes(Math.round(clone.minutes() / 30) * 30);break;
    }
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'minute') {
    //noinspection FallthroughInSwitchStatementJS
    switch (step) {
      case 15:
      case 10:
        clone.minutes(Math.round(clone.minutes() / 5) * 5);
        clone.seconds(0);
        break;
      case 5:
        clone.seconds(Math.round(clone.seconds() / 60) * 60);break;
      default:
        clone.seconds(Math.round(clone.seconds() / 30) * 30);break;
    }
    clone.milliseconds(0);
  } else if (scale == 'second') {
    //noinspection FallthroughInSwitchStatementJS
    switch (step) {
      case 15:
      case 10:
        clone.seconds(Math.round(clone.seconds() / 5) * 5);
        clone.milliseconds(0);
        break;
      case 5:
        clone.milliseconds(Math.round(clone.milliseconds() / 1000) * 1000);break;
      default:
        clone.milliseconds(Math.round(clone.milliseconds() / 500) * 500);break;
    }
  } else if (scale == 'millisecond') {
    var _step = step > 5 ? step / 2 : 1;
    clone.milliseconds(Math.round(clone.milliseconds() / _step) * _step);
  }

  return clone;
};

/**
 * Check if the current value is a major value (for example when the step
 * is DAY, a major value is each first day of the MONTH)
 * @return {boolean} true if current date is major, else false.
 */
TimeStep.prototype.isMajor = function () {
  if (this.switchedYear == true) {
    this.switchedYear = false;
    switch (this.scale) {
      case 'year':
      case 'month':
      case 'weekday':
      case 'day':
      case 'hour':
      case 'minute':
      case 'second':
      case 'millisecond':
        return true;
      default:
        return false;
    }
  } else if (this.switchedMonth == true) {
    this.switchedMonth = false;
    switch (this.scale) {
      case 'weekday':
      case 'day':
      case 'hour':
      case 'minute':
      case 'second':
      case 'millisecond':
        return true;
      default:
        return false;
    }
  } else if (this.switchedDay == true) {
    this.switchedDay = false;
    switch (this.scale) {
      case 'millisecond':
      case 'second':
      case 'minute':
      case 'hour':
        return true;
      default:
        return false;
    }
  }

  var date = this.moment(this.current);
  switch (this.scale) {
    case 'millisecond':
      return date.milliseconds() == 0;
    case 'second':
      return date.seconds() == 0;
    case 'minute':
      return date.hours() == 0 && date.minutes() == 0;
    case 'hour':
      return date.hours() == 0;
    case 'weekday': // intentional fall through
    case 'day':
      return date.date() == 1;
    case 'month':
      return date.month() == 0;
    case 'year':
      return false;
    default:
      return false;
  }
};

/**
 * Returns formatted text for the minor axislabel, depending on the current
 * date and the scale. For example when scale is MINUTE, the current time is
 * formatted as "hh:mm".
 * @param {Date} [date] custom date. if not provided, current date is taken
 */
TimeStep.prototype.getLabelMinor = function (date) {
  if (date == undefined) {
    date = this.current;
  }

  var format = this.format.minorLabels[this.scale];
  return format && format.length > 0 ? this.moment(date).format(format) : '';
};

/**
 * Returns formatted text for the major axis label, depending on the current
 * date and the scale. For example when scale is MINUTE, the major scale is
 * hours, and the hour will be formatted as "hh".
 * @param {Date} [date] custom date. if not provided, current date is taken
 */
TimeStep.prototype.getLabelMajor = function (date) {
  if (date == undefined) {
    date = this.current;
  }

  var format = this.format.majorLabels[this.scale];
  return format && format.length > 0 ? this.moment(date).format(format) : '';
};

TimeStep.prototype.getClassName = function () {
  var _moment = this.moment;
  var m = this.moment(this.current);
  var current = m.locale ? m.locale('en') : m.lang('en'); // old versions of moment have .lang() function
  var step = this.step;

  function even(value) {
    return value / step % 2 == 0 ? ' vis-even' : ' vis-odd';
  }

  function today(date) {
    if (date.isSame(new Date(), 'day')) {
      return ' vis-today';
    }
    if (date.isSame(_moment().add(1, 'day'), 'day')) {
      return ' vis-tomorrow';
    }
    if (date.isSame(_moment().add(-1, 'day'), 'day')) {
      return ' vis-yesterday';
    }
    return '';
  }

  function currentWeek(date) {
    return date.isSame(new Date(), 'week') ? ' vis-current-week' : '';
  }

  function currentMonth(date) {
    return date.isSame(new Date(), 'month') ? ' vis-current-month' : '';
  }

  function currentYear(date) {
    return date.isSame(new Date(), 'year') ? ' vis-current-year' : '';
  }

  switch (this.scale) {
    case 'millisecond':
      return even(current.milliseconds()).trim();

    case 'second':
      return even(current.seconds()).trim();

    case 'minute':
      return even(current.minutes()).trim();

    case 'hour':
      var hours = current.hours();
      if (this.step == 4) {
        hours = hours + '-h' + (hours + 4);
      }
      return 'vis-h' + hours + today(current) + even(current.hours());

    case 'weekday':
      return 'vis-' + current.format('dddd').toLowerCase() + today(current) + currentWeek(current) + even(current.date());

    case 'day':
      var day = current.date();
      var month = current.format('MMMM').toLowerCase();
      return 'vis-day' + day + ' vis-' + month + currentMonth(current) + even(day - 1);

    case 'month':
      return 'vis-' + current.format('MMMM').toLowerCase() + currentMonth(current) + even(current.month());

    case 'year':
      var year = current.year();
      return 'vis-year' + year + currentYear(current) + even(year);

    default:
      return '';
  }
};

module.exports = TimeStep;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvVGltZVN0ZXAuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUN6QyxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDckMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEI5QixTQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUU7QUFDdEQsTUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7OztBQUdyQixNQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztBQUM3QixNQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztBQUM1QixNQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQzs7QUFFMUIsTUFBSSxDQUFDLFNBQVMsR0FBSSxJQUFJLENBQUM7QUFDdkIsTUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDbkIsTUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7OztBQUdkLE1BQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxXQUFXLENBQUMsQ0FBQzs7O0FBR3ZDLE1BQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO0FBQ3pCLE1BQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDO0FBQzNCLE1BQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO0FBQzFCLE1BQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsRUFBRTtBQUM5QixR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SUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7R0FBQztBQUN0RixNQUFJLFFBQVEsR0FBQyxFQUFFLEdBQUcsV0FBVyxFQUFXO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsQUFBUSxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztHQUFDO0FBQ3JGLE1BQUksUUFBUSxHQUFDLEVBQUUsR0FBRyxXQUFXLEVBQVc7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxBQUFRLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0dBQUM7QUFDckYsTUFBSSxRQUFRLEdBQUMsQ0FBQyxHQUFHLFdBQVcsRUFBWTtBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLEFBQVEsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLFFBQVEsR0FBRyxXQUFXLEVBQWM7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxBQUFRLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0dBQUM7QUFDcEYsTUFBSSxTQUFTLEdBQUMsQ0FBQyxHQUFHLFdBQVcsRUFBVztBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDLEFBQU8sSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLFNBQVMsR0FBRyxXQUFXLEVBQWE7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQyxBQUFPLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0dBQUM7QUFDcEYsTUFBSSxPQUFPLEdBQUMsQ0FBQyxHQUFHLFdBQVcsRUFBYTtBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEFBQVMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLE9BQU8sR0FBQyxDQUFDLEdBQUcsV0FBVyxFQUFhO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsQUFBUyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztHQUFDO0FBQ3BGLE1BQUksT0FBTyxHQUFHLFdBQVcsRUFBZTtBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEFBQVMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLE9BQU8sR0FBQyxDQUFDLEdBQUcsV0FBVyxFQUFhO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxTQUFTLENBQUMsQUFBSyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztHQUFDO0FBQ3BGLE1BQUksUUFBUSxHQUFDLENBQUMsR0FBRyxXQUFXLEVBQVk7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxBQUFRLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0dBQUM7QUFDcEYsTUFBSSxRQUFRLEdBQUcsV0FBVyxFQUFjO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsQUFBUSxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztHQUFDO0FBQ3BGLE1BQUksVUFBVSxHQUFDLEVBQUUsR0FBRyxXQUFXLEVBQVM7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxBQUFNLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0dBQUM7QUFDckYsTUFBSSxVQUFVLEdBQUMsRUFBRSxHQUFHLFdBQVcsRUFBUztBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEFBQU0sSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7R0FBQztBQUNyRixNQUFJLFVBQVUsR0FBQyxDQUFDLEdBQUcsV0FBVyxFQUFVO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsQUFBTSxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztHQUFDO0FBQ3BGLE1BQUksVUFBVSxHQUFHLFdBQVcsRUFBWTtBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEFBQU0sSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLFVBQVUsR0FBQyxFQUFFLEdBQUcsV0FBVyxFQUFTO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsQUFBTSxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztHQUFDO0FBQ3JGLE1BQUksVUFBVSxHQUFDLEVBQUUsR0FBRyxXQUFXLEVBQVM7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxBQUFNLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0dBQUM7QUFDckYsTUFBSSxVQUFVLEdBQUMsQ0FBQyxHQUFHLFdBQVcsRUFBVTtBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEFBQU0sSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLFVBQVUsR0FBRyxXQUFXLEVBQVk7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxBQUFNLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0dBQUM7QUFDcEYsTUFBSSxlQUFlLEdBQUMsR0FBRyxHQUFHLFdBQVcsRUFBRztBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsYUFBYSxDQUFDLEFBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7R0FBQztBQUN0RixNQUFJLGVBQWUsR0FBQyxHQUFHLEdBQUcsV0FBVyxFQUFHO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxhQUFhLENBQUMsQUFBQyxJQUFJLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQztHQUFDO0FBQ3RGLE1BQUksZUFBZSxHQUFDLEVBQUUsR0FBRyxXQUFXLEVBQUk7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLGFBQWEsQ0FBQyxBQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0dBQUM7QUFDckYsTUFBSSxlQUFlLEdBQUMsRUFBRSxHQUFHLFdBQVcsRUFBSTtBQUFDLFFBQUksQ0FBQyxL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TyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUNqRCxhQUFPLFNBQVMsR0FBRyxHQUFHLEdBQUcsT0FBTyxHQUFHLEtBQUssR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQzs7QUFBQSxBQUVuRixTQUFLLE9BQU87QUFDVixhQUFPLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFdBQVcsRUFBRSxHQUNoRCxZQUFZLENBQUMsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDOztBQUFBLEFBRXBELFNBQUssTUFBTTtBQUNULFVBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUMxQixhQUFPLFVBQVUsR0FBRyxJQUFJLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFBQSxBQUU5RDtBQUNFLGFBQU8sRUFBRSxDQUFDO0FBQUEsR0FDYjtDQUNGLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMiLCJmaWxlIjoiL1VzZXJzL2RhcmluL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzLXZpZXdlci9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9UaW1lU3RlcC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBtb21lbnQgPSByZXF1aXJlKCcuLi9tb2R1bGUvbW9tZW50Jyk7XG52YXIgRGF0ZVV0aWwgPSByZXF1aXJlKCcuL0RhdGVVdGlsJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgIFRpbWVTdGVwXG4gKiBUaGUgY2xhc3MgVGltZVN0ZXAgaXMgYW4gaXRlcmF0b3IgZm9yIGRhdGVzLiBZb3UgcHJvdmlkZSBhIHN0YXJ0IGRhdGUgYW5kIGFuXG4gKiBlbmQgZGF0ZS4gVGhlIGNsYXNzIGl0c2VsZiBkZXRlcm1pbmVzIHRoZSBiZXN0IHNjYWxlIChzdGVwIHNpemUpIGJhc2VkIG9uIHRoZVxuICogcHJvdmlkZWQgc3RhcnQgRGF0ZSwgZW5kIERhdGUsIGFuZCBtaW5pbXVtU3RlcC5cbiAqXG4gKiBJZiBtaW5pbXVtU3RlcCBpcyBwcm92aWRlZCwgdGhlIHN0ZXAgc2l6ZSBpcyBjaG9zZW4gYXMgY2xvc2UgYXMgcG9zc2libGVcbiAqIHRvIHRoZSBtaW5pbXVtU3RlcCBidXQgbGFyZ2VyIHRoYW4gbWluaW11bVN0ZXAuIElmIG1pbmltdW1TdGVwIGlzIG5vdFxuICogcHJvdmlkZWQsIHRoZSBzY2FsZSBpcyBzZXQgdG8gMSBEQVkuXG4gKiBUaGUgbWluaW11bVN0ZXAgc2hvdWxkIGNvcnJlc3BvbmQgd2l0aCB0aGUgb25zY3JlZW4gc2l6ZSBvZiBhYm91dCA2IGNoYXJhY3RlcnNcbiAqXG4gKiBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIHNldCBhIHNjYWxlIGJ5IGhhbmQuXG4gKiBBZnRlciBjcmVhdGlvbiwgeW91IGNhbiBpbml0aWFsaXplIHRoZSBjbGFzcyBieSBleGVjdXRpbmcgZmlyc3QoKS4gVGhlbiB5b3VcbiAqIGNhbiBpdGVyYXRlIGZyb20gdGhlIHN0YXJ0IGRhdGUgdG8gdGhlIGVuZCBkYXRlIHZpYSBuZXh0KCkuIFlvdSBjYW4gY2hlY2sgaWZcbiAqIHRoZSBlbmQgZGF0ZSBpcyByZWFjaGVkIHdpdGggdGhlIGZ1bmN0aW9uIGhhc05leHQoKS4gQWZ0ZXIgZWFjaCBzdGVwLCB5b3UgY2FuXG4gKiByZXRyaWV2ZSB0aGUgY3VycmVudCBkYXRlIHZpYSBnZXRDdXJyZW50KCkuXG4gKiBUaGUgVGltZVN0ZXAgaGFzIHNjYWxlcyByYW5naW5nIGZyb20gbWlsbGlzZWNvbmRzLCBzZWNvbmRzLCBtaW51dGVzLCBob3VycyxcbiAqIGRheXMsIHRvIHllYXJzLlxuICpcbiAqIFZlcnNpb246IDEuMlxuICpcbiAqIEBwYXJhbSB7RGF0ZX0gW3N0YXJ0XSAgICAgICAgIFRoZSBzdGFydCBkYXRlLCBmb3IgZXhhbXBsZSBuZXcgRGF0ZSgyMDEwLCA5LCAyMSlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIG5ldyBEYXRlKDIwMTAsIDksIDIxLCAyMywgNDUsIDAwKVxuICogQHBhcmFtIHtEYXRlfSBbZW5kXSAgICAgICAgICAgVGhlIGVuZCBkYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW21pbmltdW1TdGVwXSBPcHRpb25hbC4gTWluaW11bSBzdGVwIHNpemUgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmZ1bmN0aW9uIFRpbWVTdGVwKHN0YXJ0LCBlbmQsIG1pbmltdW1TdGVwLCBoaWRkZW5EYXRlcykge1xuICB0aGlzLm1vbWVudCA9IG1vbWVudDtcblxuICAvLyB2YXJpYWJsZXNcbiAgdGhpcy5jdXJyZW50ID0gdGhpcy5tb21lbnQoKTtcbiAgdGhpcy5fc3RhcnQgPSB0aGlzLm1vbWVudCgpO1xuICB0aGlzLl9lbmQgPSB0aGlzLm1vbWVudCgpO1xuXG4gIHRoaXMuYXV0b1NjYWxlICA9IHRydWU7XG4gIHRoaXMuc2NhbGUgPSAnZGF5JztcbiAgdGhpcy5zdGVwID0gMTtcblxuICAvLyBpbml0aWFsaXplIHRoZSByYW5nZVxuICB0aGlzLnNldFJhbmdlKHN0YXJ0LCBlbmQsIG1pbmltdW1TdGVwKTtcblxuICAvLyBoaWRkZW4gRGF0ZXMgb3B0aW9uc1xuICB0aGlzLnN3aXRjaGVkRGF5ID0gZmFsc2U7XG4gIHRoaXMuc3dpdGNoZWRNb250aCA9IGZhbHNlO1xuICB0aGlzLnN3aXRjaGVkWWVhciA9IGZhbHNlO1xuICBpZiAoQXJyYXkuaXNBcnJheShoaWRkZW5EYXRlcykpIHtcbiAgICB0aGlzLmhpZGRlbkRhdGVzID0gaGlkZGVuRGF0ZXM7XG4gIH1cbiAgZWxzZSBpZiAoaGlkZGVuRGF0ZXMgIT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5oaWRkZW5EYXRlcyA9IFtoaWRkZW5EYXRlc107XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5oaWRkZW5EYXRlcyA9IFtdO1xuICB9XG5cbiAgdGhpcy5mb3JtYXQgPSBUaW1lU3RlcC5GT1JNQVQ7IC8vIGRlZmF1bHQgZm9ybWF0dGluZ1xufVxuXG4vLyBUaW1lIGZvcm1hdHRpbmdcblRpbWVTdGVwLkZPUk1BVCA9IHtcbiAgbWlub3JMYWJlbHM6IHtcbiAgICBtaWxsaXNlY29uZDonU1NTJyxcbiAgICBzZWNvbmQ6ICAgICAncycsXG4gICAgbWludXRlOiAgICAgJ0hIOm1tJyxcbiAgICBob3VyOiAgICAgICAnSEg6bW0nLFxuICAgIHdlZWtkYXk6ICAgICdkZGQgRCcsXG4gICAgZGF5OiAgICAgICAgJ0QnLFxuICAgIG1vbnRoOiAgICAgICdNTU0nLFxuICAgIHllYXI6ICAgICAgICdZWVlZJ1xuICB9LFxuICBtYWpvckxhYmVsczoge1xuICAgIG1pbGxpc2Vjb25kOidISDptbTpzcycsXG4gICAgc2Vjb25kOiAgICAgJ0QgTU1NTSBISDptbScsXG4gICAgbWludXRlOiAgICAgJ2RkZCBEIE1NTU0nLFxuICAgIGhvdXI6ICAgICAgICdkZGQgRCBNTU1NJyxcbiAgICB3ZWVrZGF5OiAgICAnTU1NTSBZWVlZJyxcbiAgICBkYXk6ICAgICAgICAnTU1NTSBZWVlZJyxcbiAgICBtb250aDogICAgICAnWVlZWScsXG4gICAgeWVhcjogICAgICAgJydcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgY3VzdG9tIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBtb21lbnQuIENhbiBiZSB1c2VkIHRvIHNldCBkYXRlc1xuICogdG8gVVRDIG9yIHRvIHNldCBhIHV0Y09mZnNldC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1vbWVudFxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuc2V0TW9tZW50ID0gZnVuY3Rpb24gKG1vbWVudCkge1xuICB0aGlzLm1vbWVudCA9IG1vbWVudDtcblxuICAvLyB1cGRhdGUgdGhlIGRhdGUgcHJvcGVydGllcywgY2FuIGhhdmUgYSBuZXcgdXRjT2Zmc2V0XG4gIHRoaXMuY3VycmVudCA9IHRoaXMubW9tZW50KHRoaXMuY3VycmVudCk7XG4gIHRoaXMuX3N0YXJ0ID0gdGhpcy5tb21lbnQodGhpcy5fc3RhcnQpO1xuICB0aGlzLl9lbmQgPSB0aGlzLm1vbWVudCh0aGlzLl9lbmQpO1xufTtcblxuLyoqXG4gKiBTZXQgY3VzdG9tIGZvcm1hdHRpbmcgZm9yIHRoZSBtaW5vciBhbiBtYWpvciBsYWJlbHMgb2YgdGhlIFRpbWVTdGVwLlxuICogQm90aCBgbWlub3JMYWJlbHNgIGFuZCBgbWFqb3JMYWJlbHNgIGFyZSBhbiBPYmplY3Qgd2l0aCBwcm9wZXJ0aWVzOlxuICogJ21pbGxpc2Vjb25kJywgJ3NlY29uZCcsICdtaW51dGUnLCAnaG91cicsICd3ZWVrZGF5JywgJ2RheScsICdtb250aCcsICd5ZWFyJy5cbiAqIEBwYXJhbSB7e21pbm9yTGFiZWxzOiBPYmplY3QsIG1ham9yTGFiZWxzOiBPYmplY3R9fSBmb3JtYXRcbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLnNldEZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgdmFyIGRlZmF1bHRGb3JtYXQgPSB1dGlsLmRlZXBFeHRlbmQoe30sIFRpbWVTdGVwLkZPUk1BVCk7XG4gIHRoaXMuZm9ybWF0ID0gdXRpbC5kZWVwRXh0ZW5kKGRlZmF1bHRGb3JtYXQsIGZvcm1hdCk7XG59O1xuXG4vKipcbiAqIFNldCBhIG5ldyByYW5nZVxuICogSWYgbWluaW11bVN0ZXAgaXMgcHJvdmlkZWQsIHRoZSBzdGVwIHNpemUgaXMgY2hvc2VuIGFzIGNsb3NlIGFzIHBvc3NpYmxlXG4gKiB0byB0aGUgbWluaW11bVN0ZXAgYnV0IGxhcmdlciB0aGFuIG1pbmltdW1TdGVwLiBJZiBtaW5pbXVtU3RlcCBpcyBub3RcbiAqIHByb3ZpZGVkLCB0aGUgc2NhbGUgaXMgc2V0IHRvIDEgREFZLlxuICogVGhlIG1pbmltdW1TdGVwIHNob3VsZCBjb3JyZXNwb25kIHdpdGggdGhlIG9uc2NyZWVuIHNpemUgb2YgYWJvdXQgNiBjaGFyYWN0ZXJzXG4gKiBAcGFyYW0ge0RhdGV9IFtzdGFydF0gICAgICBUaGUgc3RhcnQgZGF0ZSBhbmQgdGltZS5cbiAqIEBwYXJhbSB7RGF0ZX0gW2VuZF0gICAgICAgIFRoZSBlbmQgZGF0ZSBhbmQgdGltZS5cbiAqIEBwYXJhbSB7aW50fSBbbWluaW11bVN0ZXBdIE9wdGlvbmFsLiBNaW5pbXVtIHN0ZXAgc2l6ZSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLnNldFJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgbWluaW11bVN0ZXApIHtcbiAgaWYgKCEoc3RhcnQgaW5zdGFuY2VvZiBEYXRlKSB8fCAhKGVuZCBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgdGhyb3cgIFwiTm8gbGVnYWwgc3RhcnQgb3IgZW5kIGRhdGUgaW4gbWV0aG9kIHNldFJhbmdlXCI7XG4gIH1cblxuICB0aGlzLl9zdGFydCA9IChzdGFydCAhPSB1bmRlZmluZWQpID8gdGhpcy5tb21lbnQoc3RhcnQudmFsdWVPZigpKSA6IG5ldyBEYXRlKCk7XG4gIHRoaXMuX2VuZCA9IChlbmQgIT0gdW5kZWZpbmVkKSA/IHRoaXMubW9tZW50KGVuZC52YWx1ZU9mKCkpIDogbmV3IERhdGUoKTtcblxuICBpZiAodGhpcy5hdXRvU2NhbGUpIHtcbiAgICB0aGlzLnNldE1pbmltdW1TdGVwKG1pbmltdW1TdGVwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgdGhlIHJhbmdlIGl0ZXJhdG9yIHRvIHRoZSBzdGFydCBkYXRlLlxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jdXJyZW50ID0gdGhpcy5fc3RhcnQuY2xvbmUoKTtcbiAgdGhpcy5yb3VuZFRvTWlub3IoKTtcbn07XG5cbi8qKlxuICogUm91bmQgdGhlIGN1cnJlbnQgZGF0ZSB0byB0aGUgZmlyc3QgbWlub3IgZGF0ZSB2YWx1ZVxuICogVGhpcyBtdXN0IGJlIGV4ZWN1dGVkIG9uY2Ugd2hlbiB0aGUgY3VycmVudCBkYXRlIGlzIHNldCB0byBzdGFydCBEYXRlXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5yb3VuZFRvTWlub3IgPSBmdW5jdGlvbigpIHtcbiAgLy8gcm91bmQgdG8gZmxvb3JcbiAgLy8gSU1QT1JUQU5UOiB3ZSBoYXZlIG5vIGJyZWFrcyBpbiB0aGlzIHN3aXRjaCEgKHRoaXMgaXMgbm8gYnVnKVxuICAvLyBub2luc3BlY3Rpb24gRmFsbFRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgIGNhc2UgJ3llYXInOlxuICAgICAgdGhpcy5jdXJyZW50LnllYXIodGhpcy5zdGVwICogTWF0aC5mbG9vcih0aGlzLmN1cnJlbnQueWVhcigpIC8gdGhpcy5zdGVwKSk7XG4gICAgICB0aGlzLmN1cnJlbnQubW9udGgoMCk7XG4gICAgY2FzZSAnbW9udGgnOiAgICAgICAgdGhpcy5jdXJyZW50LmRhdGUoMSk7XG4gICAgY2FzZSAnZGF5JzogICAgICAgICAgLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgY2FzZSAnd2Vla2RheSc6ICAgICAgdGhpcy5jdXJyZW50LmhvdXJzKDApO1xuICAgIGNhc2UgJ2hvdXInOiAgICAgICAgIHRoaXMuY3VycmVudC5taW51dGVzKDApO1xuICAgIGNhc2UgJ21pbnV0ZSc6ICAgICAgIHRoaXMuY3VycmVudC5zZWNvbmRzKDApO1xuICAgIGNhc2UgJ3NlY29uZCc6ICAgICAgIHRoaXMuY3VycmVudC5taWxsaXNlY29uZHMoMCk7XG4gICAgLy9jYXNlICdtaWxsaXNlY29uZCc6IC8vIG5vdGhpbmcgdG8gZG8gZm9yIG1pbGxpc2Vjb25kc1xuICB9XG5cbiAgaWYgKHRoaXMuc3RlcCAhPSAxKSB7XG4gICAgLy8gcm91bmQgZG93biB0byB0aGUgZmlyc3QgbWlub3IgdmFsdWUgdGhhdCBpcyBhIG11bHRpcGxlIG9mIHRoZSBjdXJyZW50IHN0ZXAgc2l6ZVxuICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiAgdGhpcy5jdXJyZW50LnN1YnRyYWN0KHRoaXMuY3VycmVudC5taWxsaXNlY29uZHMoKSAlIHRoaXMuc3RlcCwgJ21pbGxpc2Vjb25kcycpOyAgYnJlYWs7XG4gICAgICBjYXNlICdzZWNvbmQnOiAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50LnNlY29uZHMoKSAlIHRoaXMuc3RlcCwgJ3NlY29uZHMnKTsgYnJlYWs7XG4gICAgICBjYXNlICdtaW51dGUnOiAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50Lm1pbnV0ZXMoKSAlIHRoaXMuc3RlcCwgJ21pbnV0ZXMnKTsgYnJlYWs7XG4gICAgICBjYXNlICdob3VyJzogICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50LmhvdXJzKCkgJSB0aGlzLnN0ZXAsICdob3VycycpOyBicmVhaztcbiAgICAgIGNhc2UgJ3dlZWtkYXknOiAgICAgIC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuICAgICAgY2FzZSAnZGF5JzogICAgICAgICAgdGhpcy5jdXJyZW50LnN1YnRyYWN0KCh0aGlzLmN1cnJlbnQuZGF0ZSgpIC0gMSkgJSB0aGlzLnN0ZXAsICdkYXknKTsgYnJlYWs7XG4gICAgICBjYXNlICdtb250aCc6ICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50Lm1vbnRoKCkgJSB0aGlzLnN0ZXAsICdtb250aCcpOyAgYnJlYWs7XG4gICAgICBjYXNlICd5ZWFyJzogICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50LnllYXIoKSAlIHRoaXMuc3RlcCwgJ3llYXInKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHRoZXJlIGlzIGEgbmV4dCBzdGVwXG4gKiBAcmV0dXJuIHtib29sZWFufSAgdHJ1ZSBpZiB0aGUgY3VycmVudCBkYXRlIGhhcyBub3QgcGFzc2VkIHRoZSBlbmQgZGF0ZVxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLmN1cnJlbnQudmFsdWVPZigpIDw9IHRoaXMuX2VuZC52YWx1ZU9mKCkpO1xufTtcblxuLyoqXG4gKiBEbyB0aGUgbmV4dCBzdGVwXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwcmV2ID0gdGhpcy5jdXJyZW50LnZhbHVlT2YoKTtcblxuICAvLyBUd28gY2FzZXMsIG5lZWRlZCB0byBwcmV2ZW50IGlzc3VlcyB3aXRoIHN3aXRjaGluZyBkYXlsaWdodCBzYXZpbmdzXG4gIC8vIChlbmQgb2YgTWFyY2ggYW5kIGVuZCBvZiBPY3RvYmVyKVxuICBpZiAodGhpcy5jdXJyZW50Lm1vbnRoKCkgPCA2KSAgIHtcbiAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnbWlsbGlzZWNvbmQnKTsgYnJlYWs7XG4gICAgICBjYXNlICdzZWNvbmQnOiAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ3NlY29uZCcpOyBicmVhaztcbiAgICAgIGNhc2UgJ21pbnV0ZSc6ICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnbWludXRlJyk7IGJyZWFrO1xuICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnaG91cicpO1xuICAgICAgICAvLyBpbiBjYXNlIG9mIHNraXBwaW5nIGFuIGhvdXIgZm9yIGRheWxpZ2h0IHNhdmluZ3MsIGFkanVzdCB0aGUgaG91ciBhZ2FpbiAoZWxzZSB5b3UgZ2V0OiAwaCA1aCA5aCAuLi4gaW5zdGVhZCBvZiAwaCA0aCA4aCAuLi4pXG4gICAgICAgICAgLy8gVE9ETzogaXMgdGhpcyBzdGlsbCBuZWVkZWQgbm93IHdlIHVzZSB0aGUgZnVuY3Rpb24gb2YgbW9tZW50LmpzP1xuICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50LmhvdXJzKCkgJSB0aGlzLnN0ZXAsICdob3VyJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2Vla2RheSc6ICAgICAgLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgICBjYXNlICdkYXknOiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ2RheScpOyBicmVhaztcbiAgICAgIGNhc2UgJ21vbnRoJzogICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnbW9udGgnKTsgYnJlYWs7XG4gICAgICBjYXNlICd5ZWFyJzogICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ3llYXInKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBicmVhaztcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICBjYXNlICdtaWxsaXNlY29uZCc6ICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ21pbGxpc2Vjb25kJyk7IGJyZWFrO1xuICAgICAgY2FzZSAnc2Vjb25kJzogICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdzZWNvbmQnKTsgYnJlYWs7XG4gICAgICBjYXNlICdtaW51dGUnOiAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ21pbnV0ZScpOyBicmVhaztcbiAgICAgIGNhc2UgJ2hvdXInOiAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnaG91cicpOyBicmVhaztcbiAgICAgIGNhc2UgJ3dlZWtkYXknOiAgICAgIC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuICAgICAgY2FzZSAnZGF5JzogICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdkYXknKTsgYnJlYWs7XG4gICAgICBjYXNlICdtb250aCc6ICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ21vbnRoJyk7IGJyZWFrO1xuICAgICAgY2FzZSAneWVhcic6ICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICd5ZWFyJyk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuc3RlcCAhPSAxKSB7XG4gICAgLy8gcm91bmQgZG93biB0byB0aGUgY29ycmVjdCBtYWpvciB2YWx1ZVxuICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiAgaWYodGhpcy5jdXJyZW50Lm1pbGxpc2Vjb25kcygpIDwgdGhpcy5zdGVwKSB0aGlzLmN1cnJlbnQubWlsbGlzZWNvbmRzKDApOyAgYnJlYWs7XG4gICAgICBjYXNlICdzZWNvbmQnOiAgICAgICBpZih0aGlzLmN1cnJlbnQuc2Vjb25kcygpIDwgdGhpcy5zdGVwKSB0aGlzLmN1cnJlbnQuc2Vjb25kcygwKTsgIGJyZWFrO1xuICAgICAgY2FzZSAnbWludXRlJzogICAgICAgaWYodGhpcy5jdXJyZW50Lm1pbnV0ZXMoKSA8IHRoaXMuc3RlcCkgdGhpcy5jdXJyZW50Lm1pbnV0ZXMoMCk7ICBicmVhaztcbiAgICAgIGNhc2UgJ2hvdXInOiAgICAgICAgIGlmKHRoaXMuY3VycmVudC5ob3VycygpIDwgdGhpcy5zdGVwKSB0aGlzLmN1cnJlbnQuaG91cnMoMCk7ICBicmVhaztcbiAgICAgIGNhc2UgJ3dlZWtkYXknOiAgICAgIC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuICAgICAgY2FzZSAnZGF5JzogICAgICAgICAgaWYodGhpcy5jdXJyZW50LmRhdGUoKSA8IHRoaXMuc3RlcCsxKSB0aGlzLmN1cnJlbnQuZGF0ZSgxKTsgYnJlYWs7XG4gICAgICBjYXNlICdtb250aCc6ICAgICAgICBpZih0aGlzLmN1cnJlbnQubW9udGgoKSA8IHRoaXMuc3RlcCkgdGhpcy5jdXJyZW50Lm1vbnRoKDApOyAgYnJlYWs7XG4gICAgICBjYXNlICd5ZWFyJzogICAgICAgICBicmVhazsgLy8gbm90aGluZyB0byBkbyBmb3IgeWVhclxuICAgICAgZGVmYXVsdDogICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gc2FmZXR5IG1lY2hhbmlzbTogaWYgY3VycmVudCB0aW1lIGlzIHN0aWxsIHVuY2hhbmdlZCwgbW92ZSB0byB0aGUgZW5kXG4gIGlmICh0aGlzLmN1cnJlbnQudmFsdWVPZigpID09IHByZXYpIHtcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLl9lbmQuY2xvbmUoKTtcbiAgfVxuXG4gIERhdGVVdGlsLnN0ZXBPdmVySGlkZGVuRGF0ZXModGhpcy5tb21lbnQsIHRoaXMsIHByZXYpO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBkYXRldGltZVxuICogQHJldHVybiB7TW9tZW50fSAgY3VycmVudCBUaGUgY3VycmVudCBkYXRlXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5nZXRDdXJyZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmN1cnJlbnQ7XG59O1xuXG4vKipcbiAqIFNldCBhIGN1c3RvbSBzY2FsZS4gQXV0b3NjYWxpbmcgd2lsbCBiZSBkaXNhYmxlZC5cbiAqIEZvciBleGFtcGxlIHNldFNjYWxlKCdtaW51dGUnLCA1KSB3aWxsIHJlc3VsdFxuICogaW4gbWlub3Igc3RlcHMgb2YgNSBtaW51dGVzLCBhbmQgbWFqb3Igc3RlcHMgb2YgYW4gaG91ci5cbiAqXG4gKiBAcGFyYW0ge3tzY2FsZTogc3RyaW5nLCBzdGVwOiBudW1iZXJ9fSBwYXJhbXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHR3byBwcm9wZXJ0aWVzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBBIHN0cmluZyAnc2NhbGUnLiBDaG9vc2UgZnJvbSAnbWlsbGlzZWNvbmQnLCAnc2Vjb25kJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21pbnV0ZScsICdob3VyJywgJ3dlZWtkYXknLCAnZGF5JywgJ21vbnRoJywgJ3llYXInLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBBIG51bWJlciAnc3RlcCcuIEEgc3RlcCBzaXplLCBieSBkZWZhdWx0IDEuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENob29zZSBmb3IgZXhhbXBsZSAxLCAyLCA1LCBvciAxMC5cbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIGlmIChwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcy5zY2FsZSA9PSAnc3RyaW5nJykge1xuICAgIHRoaXMuc2NhbGUgPSBwYXJhbXMuc2NhbGU7XG4gICAgdGhpcy5zdGVwID0gcGFyYW1zLnN0ZXAgPiAwID8gcGFyYW1zLnN0ZXAgOiAxO1xuICAgIHRoaXMuYXV0b1NjYWxlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogRW5hYmxlIG9yIGRpc2FibGUgYXV0b3NjYWxpbmdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlICBJZiB0cnVlLCBhdXRvYXNjYWxpbmcgaXMgc2V0IHRydWVcbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLnNldEF1dG9TY2FsZSA9IGZ1bmN0aW9uIChlbmFibGUpIHtcbiAgdGhpcy5hdXRvU2NhbGUgPSBlbmFibGU7XG59O1xuXG5cbi8qKlxuICogQXV0b21hdGljYWxseSBkZXRlcm1pbmUgdGhlIHNjYWxlIHRoYXQgYmVzdHMgZml0cyB0aGUgcHJvdmlkZWQgbWluaW11bSBzdGVwXG4gKiBAcGFyYW0ge051bWJlcn0gW21pbmltdW1TdGVwXSAgVGhlIG1pbmltdW0gc3RlcCBzaXplIGluIG1pbGxpc2Vjb25kc1xuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuc2V0TWluaW11bVN0ZXAgPSBmdW5jdGlvbihtaW5pbXVtU3RlcCkge1xuICBpZiAobWluaW11bVN0ZXAgPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy92YXIgYiA9IGFzYyArIGRzO1xuXG4gIHZhciBzdGVwWWVhciAgICAgICA9ICgxMDAwICogNjAgKiA2MCAqIDI0ICogMzAgKiAxMik7XG4gIHZhciBzdGVwTW9udGggICAgICA9ICgxMDAwICogNjAgKiA2MCAqIDI0ICogMzApO1xuICB2YXIgc3RlcERheSAgICAgICAgPSAoMTAwMCAqIDYwICogNjAgKiAyNCk7XG4gIHZhciBzdGVwSG91ciAgICAgICA9ICgxMDAwICogNjAgKiA2MCk7XG4gIHZhciBzdGVwTWludXRlICAgICA9ICgxMDAwICogNjApO1xuICB2YXIgc3RlcFNlY29uZCAgICAgPSAoMTAwMCk7XG4gIHZhciBzdGVwTWlsbGlzZWNvbmQ9ICgxKTtcblxuICAvLyBmaW5kIHRoZSBzbWFsbGVzdCBzdGVwIHRoYXQgaXMgbGFyZ2VyIHRoYW4gdGhlIHByb3ZpZGVkIG1pbmltdW1TdGVwXG4gIGlmIChzdGVwWWVhcioxMDAwID4gbWluaW11bVN0ZXApICAgICAgICB7dGhpcy5zY2FsZSA9ICd5ZWFyJzsgICAgICAgIHRoaXMuc3RlcCA9IDEwMDA7fVxuICBpZiAoc3RlcFllYXIqNTAwID4gbWluaW11bVN0ZXApICAgICAgICAge3RoaXMuc2NhbGUgPSAneWVhcic7ICAgICAgICB0aGlzLnN0ZXAgPSA1MDA7fVxuICBpZiAoc3RlcFllYXIqMTAwID4gbWluaW11bVN0ZXApICAgICAgICAge3RoaXMuc2NhbGUgPSAneWVhcic7ICAgICAgICB0aGlzLnN0ZXAgPSAxMDA7fVxuICBpZiAoc3RlcFllYXIqNTAgPiBtaW5pbXVtU3RlcCkgICAgICAgICAge3RoaXMuc2NhbGUgPSAneWVhcic7ICAgICAgICB0aGlzLnN0ZXAgPSA1MDt9XG4gIGlmIChzdGVwWWVhcioxMCA+IG1pbmltdW1TdGVwKSAgICAgICAgICB7dGhpcy5zY2FsZSA9ICd5ZWFyJzsgICAgICAgIHRoaXMuc3RlcCA9IDEwO31cbiAgaWYgKHN0ZXBZZWFyKjUgPiBtaW5pbXVtU3RlcCkgICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ3llYXInOyAgICAgICAgdGhpcy5zdGVwID0gNTt9XG4gIGlmIChzdGVwWWVhciA+IG1pbmltdW1TdGVwKSAgICAgICAgICAgICB7dGhpcy5zY2FsZSA9ICd5ZWFyJzsgICAgICAgIHRoaXMuc3RlcCA9IDE7fVxuICBpZiAoc3RlcE1vbnRoKjMgPiBtaW5pbXVtU3RlcCkgICAgICAgICAge3RoaXMuc2NhbGUgPSAnbW9udGgnOyAgICAgICB0aGlzLnN0ZXAgPSAzO31cbiAgaWYgKHN0ZXBNb250aCA+IG1pbmltdW1TdGVwKSAgICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ21vbnRoJzsgICAgICAgdGhpcy5zdGVwID0gMTt9XG4gIGlmIChzdGVwRGF5KjUgPiBtaW5pbXVtU3RlcCkgICAgICAgICAgICB7dGhpcy5zY2FsZSA9ICdkYXknOyAgICAgICAgIHRoaXMuc3RlcCA9IDU7fVxuICBpZiAoc3RlcERheSoyID4gbWluaW11bVN0ZXApICAgICAgICAgICAge3RoaXMuc2NhbGUgPSAnZGF5JzsgICAgICAgICB0aGlzLnN0ZXAgPSAyO31cbiAgaWYgKHN0ZXBEYXkgPiBtaW5pbXVtU3RlcCkgICAgICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ2RheSc7ICAgICAgICAgdGhpcy5zdGVwID0gMTt9XG4gIGlmIChzdGVwRGF5LzIgPiBtaW5pbXVtU3RlcCkgICAgICAgICAgICB7dGhpcy5zY2FsZSA9ICd3ZWVrZGF5JzsgICAgIHRoaXMuc3RlcCA9IDE7fVxuICBpZiAoc3RlcEhvdXIqNCA+IG1pbmltdW1TdGVwKSAgICAgICAgICAge3RoaXMuc2NhbGUgPSAnaG91cic7ICAgICAgICB0aGlzLnN0ZXAgPSA0O31cbiAgaWYgKHN0ZXBIb3VyID4gbWluaW11bVN0ZXApICAgICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ2hvdXInOyAgICAgICAgdGhpcy5zdGVwID0gMTt9XG4gIGlmIChzdGVwTWludXRlKjE1ID4gbWluaW11bVN0ZXApICAgICAgICB7dGhpcy5zY2FsZSA9ICdtaW51dGUnOyAgICAgIHRoaXMuc3RlcCA9IDE1O31cbiAgaWYgKHN0ZXBNaW51dGUqMTAgPiBtaW5pbXVtU3RlcCkgICAgICAgIHt0aGlzLnNjYWxlID0gJ21pbnV0ZSc7ICAgICAgdGhpcy5zdGVwID0gMTA7fVxuICBpZiAoc3RlcE1pbnV0ZSo1ID4gbWluaW11bVN0ZXApICAgICAgICAge3RoaXMuc2NhbGUgPSAnbWludXRlJzsgICAgICB0aGlzLnN0ZXAgPSA1O31cbiAgaWYgKHN0ZXBNaW51dGUgPiBtaW5pbXVtU3RlcCkgICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ21pbnV0ZSc7ICAgICAgdGhpcy5zdGVwID0gMTt9XG4gIGlmIChzdGVwU2Vjb25kKjE1ID4gbWluaW11bVN0ZXApICAgICAgICB7dGhpcy5zY2FsZSA9ICdzZWNvbmQnOyAgICAgIHRoaXMuc3RlcCA9IDE1O31cbiAgaWYgKHN0ZXBTZWNvbmQqMTAgPiBtaW5pbXVtU3RlcCkgICAgICAgIHt0aGlzLnNjYWxlID0gJ3NlY29uZCc7ICAgICAgdGhpcy5zdGVwID0gMTA7fVxuICBpZiAoc3RlcFNlY29uZCo1ID4gbWluaW11bVN0ZXApICAgICAgICAge3RoaXMuc2NhbGUgPSAnc2Vjb25kJzsgICAgICB0aGlzLnN0ZXAgPSA1O31cbiAgaWYgKHN0ZXBTZWNvbmQgPiBtaW5pbXVtU3RlcCkgICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ3NlY29uZCc7ICAgICAgdGhpcy5zdGVwID0gMTt9XG4gIGlmIChzdGVwTWlsbGlzZWNvbmQqMjAwID4gbWluaW11bVN0ZXApICB7dGhpcy5zY2FsZSA9ICdtaWxsaXNlY29uZCc7IHRoaXMuc3RlcCA9IDIwMDt9XG4gIGlmIChzdGVwTWlsbGlzZWNvbmQqMTAwID4gbWluaW11bVN0ZXApICB7dGhpcy5zY2FsZSA9ICdtaWxsaXNlY29uZCc7IHRoaXMuc3RlcCA9IDEwMDt9XG4gIGlmIChzdGVwTWlsbGlzZWNvbmQqNTAgPiBtaW5pbXVtU3RlcCkgICB7dGhpcy5zY2FsZSA9ICdtaWxsaXNlY29uZCc7IHRoaXMuc3RlcCA9IDUwO31cbiAgaWYgKHN0ZXBNaWxsaXNlY29uZCoxMCA+IG1pbmltdW1TdGVwKSAgIHt0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzsgdGhpcy5zdGVwID0gMTA7fVxuICBpZiAoc3RlcE1pbGxpc2Vjb25kKjUgPiBtaW5pbXVtU3RlcCkgICAge3RoaXMuc2NhbGUgPSAnbWlsbGlzZWNvbmQnOyB0aGlzLnN0ZXAgPSA1O31cbiAgaWYgKHN0ZXBNaWxsaXNlY29uZCA+IG1pbmltdW1TdGVwKSAgICAgIHt0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzsgdGhpcy5zdGVwID0gMTt9XG59O1xuXG4vKipcbiAqIFNuYXAgYSBkYXRlIHRvIGEgcm91bmRlZCB2YWx1ZS5cbiAqIFRoZSBzbmFwIGludGVydmFscyBhcmUgZGVwZW5kZW50IG9uIHRoZSBjdXJyZW50IHNjYWxlIGFuZCBzdGVwLlxuICogU3RhdGljIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RhdGV9IGRhdGUgICAgdGhlIGRhdGUgdG8gYmUgc25hcHBlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzY2FsZSBDdXJyZW50IHNjYWxlLCBjYW4gYmUgJ21pbGxpc2Vjb25kJywgJ3NlY29uZCcsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgJ21pbnV0ZScsICdob3VyJywgJ3dlZWtkYXksICdkYXknLCAnbW9udGgnLCAneWVhcicuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RlcCAgQ3VycmVudCBzdGVwICgxLCAyLCA0LCA1LCAuLi5cbiAqIEByZXR1cm4ge0RhdGV9IHNuYXBwZWREYXRlXG4gKi9cblRpbWVTdGVwLnNuYXAgPSBmdW5jdGlvbihkYXRlLCBzY2FsZSwgc3RlcCkge1xuICB2YXIgY2xvbmUgPSBtb21lbnQoZGF0ZSk7XG5cbiAgaWYgKHNjYWxlID09ICd5ZWFyJykge1xuICAgIHZhciB5ZWFyID0gY2xvbmUueWVhcigpICsgTWF0aC5yb3VuZChjbG9uZS5tb250aCgpIC8gMTIpO1xuICAgIGNsb25lLnllYXIoTWF0aC5yb3VuZCh5ZWFyIC8gc3RlcCkgKiBzdGVwKTtcbiAgICBjbG9uZS5tb250aCgwKTtcbiAgICBjbG9uZS5kYXRlKDApO1xuICAgIGNsb25lLmhvdXJzKDApO1xuICAgIGNsb25lLm1pbnV0ZXMoMCk7XG4gICAgY2xvbmUuc2Vjb25kcygwKTtcbiAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gIH1cbiAgZWxzZSBpZiAoc2NhbGUgPT0gJ21vbnRoJykge1xuICAgIGlmIChjbG9uZS5kYXRlKCkgPiAxNSkge1xuICAgICAgY2xvbmUuZGF0ZSgxKTtcbiAgICAgIGNsb25lLmFkZCgxLCAnbW9udGgnKTtcbiAgICAgIC8vIGltcG9ydGFudDogZmlyc3Qgc2V0IERhdGUgdG8gMSwgYWZ0ZXIgdGhhdCBjaGFuZ2UgdGhlIG1vbnRoLlxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNsb25lLmRhdGUoMSk7XG4gICAgfVxuXG4gICAgY2xvbmUuaG91cnMoMCk7XG4gICAgY2xvbmUubWludXRlcygwKTtcbiAgICBjbG9uZS5zZWNvbmRzKDApO1xuICAgIGNsb25lLm1pbGxpc2Vjb25kcygwKTtcbiAgfVxuICBlbHNlIGlmIChzY2FsZSA9PSAnZGF5Jykge1xuICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgY2FzZSA1OlxuICAgICAgY2FzZSAyOlxuICAgICAgICBjbG9uZS5ob3VycyhNYXRoLnJvdW5kKGNsb25lLmhvdXJzKCkgLyAyNCkgKiAyNCk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2xvbmUuaG91cnMoTWF0aC5yb3VuZChjbG9uZS5ob3VycygpIC8gMTIpICogMTIpOyBicmVhaztcbiAgICB9XG4gICAgY2xvbmUubWludXRlcygwKTtcbiAgICBjbG9uZS5zZWNvbmRzKDApO1xuICAgIGNsb25lLm1pbGxpc2Vjb25kcygwKTtcbiAgfVxuICBlbHNlIGlmIChzY2FsZSA9PSAnd2Vla2RheScpIHtcbiAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgIGNhc2UgNTpcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgY2xvbmUuaG91cnMoTWF0aC5yb3VuZChjbG9uZS5ob3VycygpIC8gMTIpICogMTIpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNsb25lLmhvdXJzKE1hdGgucm91bmQoY2xvbmUuaG91cnMoKSAvIDYpICogNik7IGJyZWFrO1xuICAgIH1cbiAgICBjbG9uZS5taW51dGVzKDApO1xuICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgY2xvbmUubWlsbGlzZWNvbmRzKDApO1xuICB9XG4gIGVsc2UgaWYgKHNjYWxlID09ICdob3VyJykge1xuICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgY2FzZSA0OlxuICAgICAgICBjbG9uZS5taW51dGVzKE1hdGgucm91bmQoY2xvbmUubWludXRlcygpIC8gNjApICogNjApOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNsb25lLm1pbnV0ZXMoTWF0aC5yb3VuZChjbG9uZS5taW51dGVzKCkgLyAzMCkgKiAzMCk7IGJyZWFrO1xuICAgIH1cbiAgICBjbG9uZS5zZWNvbmRzKDApO1xuICAgIGNsb25lLm1pbGxpc2Vjb25kcygwKTtcbiAgfSBlbHNlIGlmIChzY2FsZSA9PSAnbWludXRlJykge1xuICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgY2FzZSAxNTpcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIGNsb25lLm1pbnV0ZXMoTWF0aC5yb3VuZChjbG9uZS5taW51dGVzKCkgLyA1KSAqIDUpO1xuICAgICAgICBjbG9uZS5zZWNvbmRzKDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgY2xvbmUuc2Vjb25kcyhNYXRoLnJvdW5kKGNsb25lLnNlY29uZHMoKSAvIDYwKSAqIDYwKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjbG9uZS5zZWNvbmRzKE1hdGgucm91bmQoY2xvbmUuc2Vjb25kcygpIC8gMzApICogMzApOyBicmVhaztcbiAgICB9XG4gICAgY2xvbmUubWlsbGlzZWNvbmRzKDApO1xuICB9XG4gIGVsc2UgaWYgKHNjYWxlID09ICdzZWNvbmQnKSB7XG4gICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgc3dpdGNoIChzdGVwKSB7XG4gICAgICBjYXNlIDE1OlxuICAgICAgY2FzZSAxMDpcbiAgICAgICAgY2xvbmUuc2Vjb25kcyhNYXRoLnJvdW5kKGNsb25lLnNlY29uZHMoKSAvIDUpICogNSk7XG4gICAgICAgIGNsb25lLm1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIGNsb25lLm1pbGxpc2Vjb25kcyhNYXRoLnJvdW5kKGNsb25lLm1pbGxpc2Vjb25kcygpIC8gMTAwMCkgKiAxMDAwKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjbG9uZS5taWxsaXNlY29uZHMoTWF0aC5yb3VuZChjbG9uZS5taWxsaXNlY29uZHMoKSAvIDUwMCkgKiA1MDApOyBicmVhaztcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoc2NhbGUgPT0gJ21pbGxpc2Vjb25kJykge1xuICAgIHZhciBfc3RlcCA9IHN0ZXAgPiA1ID8gc3RlcCAvIDIgOiAxO1xuICAgIGNsb25lLm1pbGxpc2Vjb25kcyhNYXRoLnJvdW5kKGNsb25lLm1pbGxpc2Vjb25kcygpIC8gX3N0ZXApICogX3N0ZXApO1xuICB9XG4gIFxuICByZXR1cm4gY2xvbmU7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBjdXJyZW50IHZhbHVlIGlzIGEgbWFqb3IgdmFsdWUgKGZvciBleGFtcGxlIHdoZW4gdGhlIHN0ZXBcbiAqIGlzIERBWSwgYSBtYWpvciB2YWx1ZSBpcyBlYWNoIGZpcnN0IGRheSBvZiB0aGUgTU9OVEgpXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGN1cnJlbnQgZGF0ZSBpcyBtYWpvciwgZWxzZSBmYWxzZS5cbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLmlzTWFqb3IgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc3dpdGNoZWRZZWFyID09IHRydWUpIHtcbiAgICB0aGlzLnN3aXRjaGVkWWVhciA9IGZhbHNlO1xuICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgY2FzZSAneWVhcic6XG4gICAgICBjYXNlICdtb250aCc6XG4gICAgICBjYXNlICd3ZWVrZGF5JzpcbiAgICAgIGNhc2UgJ2RheSc6XG4gICAgICBjYXNlICdob3VyJzpcbiAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAodGhpcy5zd2l0Y2hlZE1vbnRoID09IHRydWUpIHtcbiAgICB0aGlzLnN3aXRjaGVkTW9udGggPSBmYWxzZTtcbiAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgIGNhc2UgJ3dlZWtkYXknOlxuICAgICAgY2FzZSAnZGF5JzpcbiAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmICh0aGlzLnN3aXRjaGVkRGF5ID09IHRydWUpIHtcbiAgICB0aGlzLnN3aXRjaGVkRGF5ID0gZmFsc2U7XG4gICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGF0ZSA9IHRoaXMubW9tZW50KHRoaXMuY3VycmVudCk7XG4gIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgIHJldHVybiAoZGF0ZS5taWxsaXNlY29uZHMoKSA9PSAwKTtcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgcmV0dXJuIChkYXRlLnNlY29uZHMoKSA9PSAwKTtcbiAgICBjYXNlICdtaW51dGUnOlxuICAgICAgcmV0dXJuIChkYXRlLmhvdXJzKCkgPT0gMCkgJiYgKGRhdGUubWludXRlcygpID09IDApO1xuICAgIGNhc2UgJ2hvdXInOlxuICAgICAgcmV0dXJuIChkYXRlLmhvdXJzKCkgPT0gMCk7XG4gICAgY2FzZSAnd2Vla2RheSc6IC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuICAgIGNhc2UgJ2RheSc6XG4gICAgICByZXR1cm4gKGRhdGUuZGF0ZSgpID09IDEpO1xuICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIHJldHVybiAoZGF0ZS5tb250aCgpID09IDApO1xuICAgIGNhc2UgJ3llYXInOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGZvcm1hdHRlZCB0ZXh0IGZvciB0aGUgbWlub3IgYXhpc2xhYmVsLCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnRcbiAqIGRhdGUgYW5kIHRoZSBzY2FsZS4gRm9yIGV4YW1wbGUgd2hlbiBzY2FsZSBpcyBNSU5VVEUsIHRoZSBjdXJyZW50IHRpbWUgaXNcbiAqIGZvcm1hdHRlZCBhcyBcImhoOm1tXCIuXG4gKiBAcGFyYW0ge0RhdGV9IFtkYXRlXSBjdXN0b20gZGF0ZS4gaWYgbm90IHByb3ZpZGVkLCBjdXJyZW50IGRhdGUgaXMgdGFrZW5cbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLmdldExhYmVsTWlub3IgPSBmdW5jdGlvbihkYXRlKSB7XG4gIGlmIChkYXRlID09IHVuZGVmaW5lZCkge1xuICAgIGRhdGUgPSB0aGlzLmN1cnJlbnQ7XG4gIH1cblxuICB2YXIgZm9ybWF0ID0gdGhpcy5mb3JtYXQubWlub3JMYWJlbHNbdGhpcy5zY2FsZV07XG4gIHJldHVybiAoZm9ybWF0ICYmIGZvcm1hdC5sZW5ndGggPiAwKSA/IHRoaXMubW9tZW50KGRhdGUpLmZvcm1hdChmb3JtYXQpIDogJyc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZm9ybWF0dGVkIHRleHQgZm9yIHRoZSBtYWpvciBheGlzIGxhYmVsLCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnRcbiAqIGRhdGUgYW5kIHRoZSBzY2FsZS4gRm9yIGV4YW1wbGUgd2hlbiBzY2FsZSBpcyBNSU5VVEUsIHRoZSBtYWpvciBzY2FsZSBpc1xuICogaG91cnMsIGFuZCB0aGUgaG91ciB3aWxsIGJlIGZvcm1hdHRlZCBhcyBcImhoXCIuXG4gKiBAcGFyYW0ge0RhdGV9IFtkYXRlXSBjdXN0b20gZGF0ZS4gaWYgbm90IHByb3ZpZGVkLCBjdXJyZW50IGRhdGUgaXMgdGFrZW5cbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLmdldExhYmVsTWFqb3IgPSBmdW5jdGlvbihkYXRlKSB7XG4gIGlmIChkYXRlID09IHVuZGVmaW5lZCkge1xuICAgIGRhdGUgPSB0aGlzLmN1cnJlbnQ7XG4gIH1cblxuICB2YXIgZm9ybWF0ID0gdGhpcy5mb3JtYXQubWFqb3JMYWJlbHNbdGhpcy5zY2FsZV07XG4gIHJldHVybiAoZm9ybWF0ICYmIGZvcm1hdC5sZW5ndGggPiAwKSA/IHRoaXMubW9tZW50KGRhdGUpLmZvcm1hdChmb3JtYXQpIDogJyc7XG59O1xuXG5UaW1lU3RlcC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbW9tZW50ID0gdGhpcy5tb21lbnQ7XG4gIHZhciBtID0gdGhpcy5tb21lbnQodGhpcy5jdXJyZW50KTtcbiAgdmFyIGN1cnJlbnQgPSBtLmxvY2FsZSA/IG0ubG9jYWxlKCdlbicpIDogbS5sYW5nKCdlbicpOyAvLyBvbGQgdmVyc2lvbnMgb2YgbW9tZW50IGhhdmUgLmxhbmcoKSBmdW5jdGlvblxuICB2YXIgc3RlcCA9IHRoaXMuc3RlcDtcblxuICBmdW5jdGlvbiBldmVuKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAvIHN0ZXAgJSAyID09IDApID8gJyB2aXMtZXZlbicgOiAnIHZpcy1vZGQnO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9kYXkoZGF0ZSkge1xuICAgIGlmIChkYXRlLmlzU2FtZShuZXcgRGF0ZSgpLCAnZGF5JykpIHtcbiAgICAgIHJldHVybiAnIHZpcy10b2RheSc7XG4gICAgfVxuICAgIGlmIChkYXRlLmlzU2FtZShfbW9tZW50KCkuYWRkKDEsICdkYXknKSwgJ2RheScpKSB7XG4gICAgICByZXR1cm4gJyB2aXMtdG9tb3Jyb3cnO1xuICAgIH1cbiAgICBpZiAoZGF0ZS5pc1NhbWUoX21vbWVudCgpLmFkZCgtMSwgJ2RheScpLCAnZGF5JykpIHtcbiAgICAgIHJldHVybiAnIHZpcy15ZXN0ZXJkYXknO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBmdW5jdGlvbiBjdXJyZW50V2VlayhkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuaXNTYW1lKG5ldyBEYXRlKCksICd3ZWVrJykgPyAnIHZpcy1jdXJyZW50LXdlZWsnIDogJyc7XG4gIH1cblxuICBmdW5jdGlvbiBjdXJyZW50TW9udGgoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmlzU2FtZShuZXcgRGF0ZSgpLCAnbW9udGgnKSA/ICcgdmlzLWN1cnJlbnQtbW9udGgnIDogJyc7XG4gIH1cblxuICBmdW5jdGlvbiBjdXJyZW50WWVhcihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuaXNTYW1lKG5ldyBEYXRlKCksICd5ZWFyJykgPyAnIHZpcy1jdXJyZW50LXllYXInIDogJyc7XG4gIH1cblxuICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICByZXR1cm4gZXZlbihjdXJyZW50Lm1pbGxpc2Vjb25kcygpKS50cmltKCk7XG5cbiAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgcmV0dXJuIGV2ZW4oY3VycmVudC5zZWNvbmRzKCkpLnRyaW0oKTtcblxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICByZXR1cm4gZXZlbihjdXJyZW50Lm1pbnV0ZXMoKSkudHJpbSgpO1xuXG4gICAgY2FzZSAnaG91cic6XG4gICAgICB2YXIgaG91cnMgPSBjdXJyZW50LmhvdXJzKCk7XG4gICAgICBpZiAodGhpcy5zdGVwID09IDQpIHtcbiAgICAgICAgaG91cnMgPSBob3VycyArICctaCcgKyAoaG91cnMgKyA0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAndmlzLWgnICsgaG91cnMgKyB0b2RheShjdXJyZW50KSArIGV2ZW4oY3VycmVudC5ob3VycygpKTtcblxuICAgIGNhc2UgJ3dlZWtkYXknOlxuICAgICAgcmV0dXJuICd2aXMtJyArIGN1cnJlbnQuZm9ybWF0KCdkZGRkJykudG9Mb3dlckNhc2UoKSArXG4gICAgICAgICAgdG9kYXkoY3VycmVudCkgKyBjdXJyZW50V2VlayhjdXJyZW50KSArIGV2ZW4oY3VycmVudC5kYXRlKCkpO1xuXG4gICAgY2FzZSAnZGF5JzpcbiAgICAgIHZhciBkYXkgPSBjdXJyZW50LmRhdGUoKTtcbiAgICAgIHZhciBtb250aCA9IGN1cnJlbnQuZm9ybWF0KCdNTU1NJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiAndmlzLWRheScgKyBkYXkgKyAnIHZpcy0nICsgbW9udGggKyBjdXJyZW50TW9udGgoY3VycmVudCkgKyBldmVuKGRheSAtIDEpO1xuXG4gICAgY2FzZSAnbW9udGgnOlxuICAgICAgcmV0dXJuICd2aXMtJyArIGN1cnJlbnQuZm9ybWF0KCdNTU1NJykudG9Mb3dlckNhc2UoKSArXG4gICAgICAgICAgY3VycmVudE1vbnRoKGN1cnJlbnQpICsgZXZlbihjdXJyZW50Lm1vbnRoKCkpO1xuXG4gICAgY2FzZSAneWVhcic6XG4gICAgICB2YXIgeWVhciA9IGN1cnJlbnQueWVhcigpO1xuICAgICAgcmV0dXJuICd2aXMteWVhcicgKyB5ZWFyICsgY3VycmVudFllYXIoY3VycmVudCkrIGV2ZW4oeWVhcik7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVTdGVwO1xuIl19
},{"../module/moment":20,"../util":46,"./DateUtil":27}],31:[function(require,module,exports){
'use strict';

var Emitter = require('emitter-component');
var Hammer = require('../module/hammer');
var moment = require('../module/moment');
var util = require('../util');
var DataSet = require('../DataSet');
var DataView = require('../DataView');
var Range = require('./Range');
var Core = require('./Core');
var TimeAxis = require('./component/TimeAxis');
var CurrentTime = require('./component/CurrentTime');
var CustomTime = require('./component/CustomTime');
var ItemSet = require('./component/ItemSet');

var Configurator = require('../shared/Configurator');
var Validator = require('../shared/Validator')['default'];
var printStyle = require('../shared/Validator').printStyle;
var allOptions = require('./optionsTimeline').allOptions;
var configureOptions = require('./optionsTimeline').configureOptions;

/**
 * Create a timeline visualization
 * @param {HTMLElement} container
 * @param {vis.DataSet | vis.DataView | Array} [items]
 * @param {vis.DataSet | vis.DataView | Array} [groups]
 * @param {Object} [options]  See Timeline.setOptions for the available options.
 * @constructor
 * @extends Core
 */
function Timeline(container, items, groups, options) {
  if (!(this instanceof Timeline)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // if the third element is options, the forth is groups (optionally);
  if (!(Array.isArray(groups) || groups instanceof DataSet || groups instanceof DataView) && groups instanceof Object) {
    var forthArgument = options;
    options = groups;
    groups = forthArgument;
  }

  var me = this;
  this.defaultOptions = {
    start: null,
    end: null,

    autoResize: true,
    throttleRedraw: 0, // ms

    orientation: {
      axis: 'bottom', // axis orientation: 'bottom', 'top', or 'both'
      item: 'bottom' // not relevant
    },

    moment: moment,

    width: null,
    height: null,
    maxHeight: null,
    minHeight: null
  };
  this.options = util.deepExtend({}, this.defaultOptions);

  // Create the DOM, props, and emitter
  this._create(container);

  // all components listed here will be repainted automatically
  this.components = [];

  this.body = {
    dom: this.dom,
    domProps: this.props,
    emitter: {
      on: this.on.bind(this),
      off: this.off.bind(this),
      emit: this.emit.bind(this)
    },
    hiddenDates: [],
    util: {
      getScale: function getScale() {
        return me.timeAxis.step.scale;
      },
      getStep: function getStep() {
        return me.timeAxis.step.step;
      },

      toScreen: me._toScreen.bind(me),
      toGlobalScreen: me._toGlobalScreen.bind(me), // this refers to the root.width
      toTime: me._toTime.bind(me),
      toGlobalTime: me._toGlobalTime.bind(me)
    }
  };

  // range
  this.range = new Range(this.body);
  this.components.push(this.range);
  this.body.range = this.range;

  // time axis
  this.timeAxis = new TimeAxis(this.body);
  this.timeAxis2 = null; // used in case of orientation option 'both'
  this.components.push(this.timeAxis);

  // current time bar
  this.currentTime = new CurrentTime(this.body);
  this.components.push(this.currentTime);

  // item set
  this.itemSet = new ItemSet(this.body);
  this.components.push(this.itemSet);

  this.itemsData = null; // DataSet
  this.groupsData = null; // DataSet

  this.on('tap', function (event) {
    me.emit('click', me.getEventProperties(event));
  });
  this.on('doubletap', function (event) {
    me.emit('doubleClick', me.getEventProperties(event));
  });
  this.dom.root.oncontextmenu = function (event) {
    me.emit('contextmenu', me.getEventProperties(event));
  };

  // apply options
  if (options) {
    this.setOptions(options);
  }

  // IMPORTANT: THIS HAPPENS BEFORE SET ITEMS!
  if (groups) {
    this.setGroups(groups);
  }

  // create itemset
  if (items) {
    this.setItems(items);
  } else {
    this._redraw();
  }
}

// Extend the functionality from Core
Timeline.prototype = new Core();

/**
 * Load a configurator
 * @return {Object}
 * @private
 */
Timeline.prototype._createConfigurator = function () {
  return new Configurator(this, this.dom.container, configureOptions);
};

/**
 * Force a redraw. The size of all items will be recalculated.
 * Can be useful to manually redraw when option autoResize=false and the window
 * has been resized, or when the items CSS has been changed.
 *
 * Note: this function will be overridden on construction with a trottled version
 */
Timeline.prototype.redraw = function () {
  this.itemSet && this.itemSet.markDirty({ refreshItems: true });
  this._redraw();
};

Timeline.prototype.setOptions = function (options) {
  // validate options
  var errorFound = Validator.validate(options, allOptions);
  if (errorFound === true) {
    console.log('%cErrors have been found in the supplied options object.', printStyle);
  }

  Core.prototype.setOptions.call(this, options);

  if ('type' in options) {
    if (options.type !== this.options.type) {
      this.options.type = options.type;

      // force recreation of all items
      var itemsData = this.itemsData;
      if (itemsData) {
        var selection = this.getSelection();
        this.setItems(null); // remove all
        this.setItems(itemsData); // add all
        this.setSelection(selection); // restore selection
      }
    }
  }
};

/**
 * Set items
 * @param {vis.DataSet | Array | null} items
 */
Timeline.prototype.setItems = function (items) {
  var initialLoad = this.itemsData == null;

  // convert to type DataSet when needed
  var newDataSet;
  if (!items) {
    newDataSet = null;
  } else if (items instanceof DataSet || items instanceof DataView) {
    newDataSet = items;
  } else {
    // turn an array into a dataset
    newDataSet = new DataSet(items, {
      type: {
        start: 'Date',
        end: 'Date'
      }
    });
  }

  // set items
  this.itemsData = newDataSet;
  this.itemSet && this.itemSet.setItems(newDataSet);

  if (initialLoad) {
    if (this.options.start != undefined || this.options.end != undefined) {
      if (this.options.start == undefined || this.options.end == undefined) {
        var range = this.getItemRange();
      }

      var start = this.options.start != undefined ? this.options.start : range.min;
      var end = this.options.end != undefined ? this.options.end : range.max;

      this.setWindow(start, end, { animation: false });
    } else {
      this.fit({ animation: false });
    }
  }
};

/**
 * Set groups
 * @param {vis.DataSet | Array} groups
 */
Timeline.prototype.setGroups = function (groups) {
  // convert to type DataSet when needed
  var newDataSet;
  if (!groups) {
    newDataSet = null;
  } else if (groups instanceof DataSet || groups instanceof DataView) {
    newDataSet = groups;
  } else {
    // turn an array into a dataset
    newDataSet = new DataSet(groups);
  }

  this.groupsData = newDataSet;
  this.itemSet.setGroups(newDataSet);
};

/**
 * Set both items and groups in one go
 * @param {{items: Array | vis.DataSet, groups: Array | vis.DataSet}} data
 */
Timeline.prototype.setData = function (data) {
  if (data && data.groups) {
    this.setGroups(data.groups);
  }

  if (data && data.items) {
    this.setItems(data.items);
  }
};

/**
 * Set selected items by their id. Replaces the current selection
 * Unknown id's are silently ignored.
 * @param {string[] | string} [ids]  An array with zero or more id's of the items to be
 *                                selected. If ids is an empty array, all items will be
 *                                unselected.
 * @param {Object} [options]      Available options:
 *                                `focus: boolean`
 *                                    If true, focus will be set to the selected item(s)
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 *                                    Only applicable when option focus is true.
 */
Timeline.prototype.setSelection = function (ids, options) {
  this.itemSet && this.itemSet.setSelection(ids);

  if (options && options.focus) {
    this.focus(ids, options);
  }
};

/**
 * Get the selected items by their id
 * @return {Array} ids  The ids of the selected items
 */
Timeline.prototype.getSelection = function () {
  return this.itemSet && this.itemSet.getSelection() || [];
};

/**
 * Adjust the visible window such that the selected item (or multiple items)
 * are centered on screen.
 * @param {String | String[]} id     An item id or array with item ids
 * @param {Object} [options]      Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Timeline.prototype.focus = function (id, options) {
  if (!this.itemsData || id == undefined) return;

  var ids = Array.isArray(id) ? id : [id];

  // get the specified item(s)
  var itemsData = this.itemsData.getDataSet().get(ids, {
    type: {
      start: 'Date',
      end: 'Date'
    }
  });

  // calculate minimum start and maximum end of specified items
  var start = null;
  var end = null;
  itemsData.forEach(function (itemData) {
    var s = itemData.start.valueOf();
    var e = 'end' in itemData ? itemData.end.valueOf() : itemData.start.valueOf();

    if (start === null || s < start) {
      start = s;
    }

    if (end === null || e > end) {
      end = e;
    }
  });

  if (start !== null && end !== null) {
    // calculate the new middle and interval for the window
    var middle = (start + end) / 2;
    var interval = Math.max(this.range.end - this.range.start, (end - start) * 1.1);

    var animation = options && options.animation !== undefined ? options.animation : true;
    this.range.setRange(middle - interval / 2, middle + interval / 2, animation);
  }
};

/**
 * Set Timeline window such that it fits all items
 * @param {Object} [options]  Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Timeline.prototype.fit = function (options) {
  var animation = options && options.animation !== undefined ? options.animation : true;
  var range = this.getItemRange();
  this.range.setRange(range.min, range.max, animation);
};

/**
 * Determine the range of the items, taking into account their actual width
 * and a margin of 10 pixels on both sides.
 * @return {{min: Date | null, max: Date | null}}
 */
Timeline.prototype.getItemRange = function () {
  var _this = this;

  // get a rough approximation for the range based on the items start and end dates
  var range = this.getDataRange();
  var min = range.min;
  var max = range.max;
  var minItem = null;
  var maxItem = null;

  if (min != null && max != null) {
    var interval;
    var factor;
    var lhs;
    var rhs;
    var delta;

    (function () {
      var getStart = function getStart(item) {
        return util.convert(item.data.start, 'Date').valueOf();
      };

      var getEnd = function getEnd(item) {
        var end = item.data.end != undefined ? item.data.end : item.data.start;
        return util.convert(end, 'Date').valueOf();
      }

      // calculate the date of the left side and right side of the items given
      ;

      interval = max - min;
      // ms
      if (interval <= 0) {
        interval = 10;
      }
      factor = interval / _this.props.center.width;
      util.forEach(_this.itemSet.items, (function (item) {
        item.show();

        var start = getStart(item);
        var end = getEnd(item);

        var left = new Date(start - (item.getWidthLeft() + 10) * factor);
        var right = new Date(end + (item.getWidthRight() + 10) * factor);

        if (left < min) {
          min = left;
          minItem = item;
        }
        if (right > max) {
          max = right;
          maxItem = item;
        }
      }).bind(_this));

      if (minItem && maxItem) {
        lhs = minItem.getWidthLeft() + 10;
        rhs = maxItem.getWidthRight() + 10;
        delta = _this.props.center.width - lhs - rhs;
        // px

        if (delta > 0) {
          min = getStart(minItem) - lhs * interval / delta; // ms
          max = getEnd(maxItem) + rhs * interval / delta; // ms
        }
      }
    })();
  }

  return {
    min: min != null ? new Date(min) : null,
    max: max != null ? new Date(max) : null
  };
};

/**
 * Calculate the data range of the items start and end dates
 * @returns {{min: Date | null, max: Date | null}}
 */
Timeline.prototype.getDataRange = function () {
  var min = null;
  var max = null;

  var dataset = this.itemsData && this.itemsData.getDataSet();
  if (dataset) {
    dataset.forEach(function (item) {
      var start = util.convert(item.start, 'Date').valueOf();
      var end = util.convert(item.end != undefined ? item.end : item.start, 'Date').valueOf();
      if (min === null || start < min) {
        min = start;
      }
      if (max === null || end > max) {
        max = start;
      }
    });
  }

  return {
    min: min != null ? new Date(min) : null,
    max: max != null ? new Date(max) : null
  };
};

/**
 * Generate Timeline related information from an event
 * @param {Event} event
 * @return {Object} An object with related information, like on which area
 *                  The event happened, whether clicked on an item, etc.
 */
Timeline.prototype.getEventProperties = function (event) {
  var clientX = event.center ? event.center.x : event.clientX;
  var clientY = event.center ? event.center.y : event.clientY;
  var x = clientX - util.getAbsoluteLeft(this.dom.centerContainer);
  var y = clientY - util.getAbsoluteTop(this.dom.centerContainer);

  var item = this.itemSet.itemFromTarget(event);
  var group = this.itemSet.groupFromTarget(event);
  var customTime = CustomTime.customTimeFromTarget(event);

  var snap = this.itemSet.options.snap || null;
  var scale = this.body.util.getScale();
  var step = this.body.util.getStep();
  var time = this._toTime(x);
  var snappedTime = snap ? snap(time, scale, step) : time;

  var element = util.getTarget(event);
  var what = null;
  if (item != null) {
    what = 'item';
  } else if (customTime != null) {
    what = 'custom-time';
  } else if (util.hasParent(element, this.timeAxis.dom.foreground)) {
    what = 'axis';
  } else if (this.timeAxis2 && util.hasParent(element, this.timeAxis2.dom.foreground)) {
    what = 'axis';
  } else if (util.hasParent(element, this.itemSet.dom.labelSet)) {
    what = 'group-label';
  } else if (util.hasParent(element, this.currentTime.bar)) {
    what = 'current-time';
  } else if (util.hasParent(element, this.dom.center)) {
    what = 'background';
  }

  return {
    event: event,
    item: item ? item.id : null,
    group: group ? group.groupId : null,
    what: what,
    pageX: event.srcEvent ? event.srcEvent.pageX : event.pageX,
    pageY: event.srcEvent ? event.srcEvent.pageY : event.pageY,
    x: x,
    y: y,
    time: time,
    snappedTime: snappedTime
  };
};

module.exports = Timeline;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvVGltZWxpbmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsbUJBQW1CLENBQUMsQ0FBQztBQUMzQyxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUN6QyxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUN6QyxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDOUIsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3BDLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN0QyxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDL0IsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzdCLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0FBQy9DLElBQUksV0FBVyxHQUFHLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0FBQ3JELElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0FBQ25ELElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDOztBQUU3QyxJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsd0JBQXdCLENBQUMsQ0FBQztBQUNyRCxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMscUJBQXFCLENBQUMsV0FBUSxDQUFDO0FBQ3ZELElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLFVBQVUsQ0FBQztBQUMzRCxJQUFJLFVBQVUsR0FBRyxPQUFPLENB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SyxHQUFHLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSTtBQUNuQyxRQUFJLEVBQUUsSUFBSTtBQUNWLFNBQUssRUFBRSxLQUFLLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLO0FBQzFELFNBQUssRUFBRSxLQUFLLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLO0FBQzFELEtBQUMsRUFBRSxDQUFDO0FBQ0osS0FBQyxFQUFFLENBQUM7QUFDSixRQUFJLEVBQUUsSUFBSTtBQUNWLGVBQVcsRUFBRSxXQUFXO0dBQ3pCLENBQUE7Q0FDRixDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsUUFBUSxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvVGltZWxpbmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2VtaXR0ZXItY29tcG9uZW50Jyk7XG52YXIgSGFtbWVyID0gcmVxdWlyZSgnLi4vbW9kdWxlL2hhbW1lcicpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJy4uL21vZHVsZS9tb21lbnQnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIERhdGFTZXQgPSByZXF1aXJlKCcuLi9EYXRhU2V0Jyk7XG52YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuLi9EYXRhVmlldycpO1xudmFyIFJhbmdlID0gcmVxdWlyZSgnLi9SYW5nZScpO1xudmFyIENvcmUgPSByZXF1aXJlKCcuL0NvcmUnKTtcbnZhciBUaW1lQXhpcyA9IHJlcXVpcmUoJy4vY29tcG9uZW50L1RpbWVBeGlzJyk7XG52YXIgQ3VycmVudFRpbWUgPSByZXF1aXJlKCcuL2NvbXBvbmVudC9DdXJyZW50VGltZScpO1xudmFyIEN1c3RvbVRpbWUgPSByZXF1aXJlKCcuL2NvbXBvbmVudC9DdXN0b21UaW1lJyk7XG52YXIgSXRlbVNldCA9IHJlcXVpcmUoJy4vY29tcG9uZW50L0l0ZW1TZXQnKTtcblxudmFyIENvbmZpZ3VyYXRvciA9IHJlcXVpcmUoJy4uL3NoYXJlZC9Db25maWd1cmF0b3InKTtcbnZhciBWYWxpZGF0b3IgPSByZXF1aXJlKCcuLi9zaGFyZWQvVmFsaWRhdG9yJykuZGVmYXVsdDtcbnZhciBwcmludFN0eWxlID0gcmVxdWlyZSgnLi4vc2hhcmVkL1ZhbGlkYXRvcicpLnByaW50U3R5bGU7XG52YXIgYWxsT3B0aW9ucyA9IHJlcXVpcmUoJy4vb3B0aW9uc1RpbWVsaW5lJykuYWxsT3B0aW9ucztcbnZhciBjb25maWd1cmVPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zVGltZWxpbmUnKS5jb25maWd1cmVPcHRpb25zO1xuXG4vKipcbiAqIENyZWF0ZSBhIHRpbWVsaW5lIHZpc3VhbGl6YXRpb25cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IHZpcy5EYXRhVmlldyB8IEFycmF5fSBbaXRlbXNdXG4gKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgdmlzLkRhdGFWaWV3IHwgQXJyYXl9IFtncm91cHNdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBTZWUgVGltZWxpbmUuc2V0T3B0aW9ucyBmb3IgdGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDb3JlXG4gKi9cbmZ1bmN0aW9uIFRpbWVsaW5lIChjb250YWluZXIsIGl0ZW1zLCBncm91cHMsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRpbWVsaW5lKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gIH1cblxuICAvLyBpZiB0aGUgdGhpcmQgZWxlbWVudCBpcyBvcHRpb25zLCB0aGUgZm9ydGggaXMgZ3JvdXBzIChvcHRpb25hbGx5KTtcbiAgaWYgKCEoQXJyYXkuaXNBcnJheShncm91cHMpIHx8IGdyb3VwcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVZpZXcpICYmIGdyb3VwcyBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIHZhciBmb3J0aEFyZ3VtZW50ID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gZ3JvdXBzO1xuICAgIGdyb3VwcyA9IGZvcnRoQXJndW1lbnQ7XG4gIH1cblxuICB2YXIgbWUgPSB0aGlzO1xuICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIHN0YXJ0OiBudWxsLFxuICAgIGVuZDogICBudWxsLFxuXG4gICAgYXV0b1Jlc2l6ZTogdHJ1ZSxcbiAgICB0aHJvdHRsZVJlZHJhdzogMCwgLy8gbXNcblxuICAgIG9yaWVudGF0aW9uOiB7XG4gICAgICBheGlzOiAnYm90dG9tJywgICAvLyBheGlzIG9yaWVudGF0aW9uOiAnYm90dG9tJywgJ3RvcCcsIG9yICdib3RoJ1xuICAgICAgaXRlbTogJ2JvdHRvbScgICAgLy8gbm90IHJlbGV2YW50XG4gICAgfSxcblxuICAgIG1vbWVudDogbW9tZW50LFxuXG4gICAgd2lkdGg6IG51bGwsXG4gICAgaGVpZ2h0OiBudWxsLFxuICAgIG1heEhlaWdodDogbnVsbCxcbiAgICBtaW5IZWlnaHQ6IG51bGxcbiAgfTtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5kZWVwRXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAvLyBDcmVhdGUgdGhlIERPTSwgcHJvcHMsIGFuZCBlbWl0dGVyXG4gIHRoaXMuX2NyZWF0ZShjb250YWluZXIpO1xuXG4gIC8vIGFsbCBjb21wb25lbnRzIGxpc3RlZCBoZXJlIHdpbGwgYmUgcmVwYWludGVkIGF1dG9tYXRpY2FsbHlcbiAgdGhpcy5jb21wb25lbnRzID0gW107XG5cbiAgdGhpcy5ib2R5ID0ge1xuICAgIGRvbTogdGhpcy5kb20sXG4gICAgZG9tUHJvcHM6IHRoaXMucHJvcHMsXG4gICAgZW1pdHRlcjoge1xuICAgICAgb246IHRoaXMub24uYmluZCh0aGlzKSxcbiAgICAgIG9mZjogdGhpcy5vZmYuYmluZCh0aGlzKSxcbiAgICAgIGVtaXQ6IHRoaXMuZW1pdC5iaW5kKHRoaXMpXG4gICAgfSxcbiAgICBoaWRkZW5EYXRlczogW10sXG4gICAgdXRpbDoge1xuICAgICAgZ2V0U2NhbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1lLnRpbWVBeGlzLnN0ZXAuc2NhbGU7XG4gICAgICB9LFxuICAgICAgZ2V0U3RlcDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbWUudGltZUF4aXMuc3RlcC5zdGVwO1xuICAgICAgfSxcblxuICAgICAgdG9TY3JlZW46IG1lLl90b1NjcmVlbi5iaW5kKG1lKSxcbiAgICAgIHRvR2xvYmFsU2NyZWVuOiBtZS5fdG9HbG9iYWxTY3JlZW4uYmluZChtZSksIC8vIHRoaXMgcmVmZXJzIHRvIHRoZSByb290LndpZHRoXG4gICAgICB0b1RpbWU6IG1lLl90b1RpbWUuYmluZChtZSksXG4gICAgICB0b0dsb2JhbFRpbWUgOiBtZS5fdG9HbG9iYWxUaW1lLmJpbmQobWUpXG4gICAgfVxuICB9O1xuXG4gIC8vIHJhbmdlXG4gIHRoaXMucmFuZ2UgPSBuZXcgUmFuZ2UodGhpcy5ib2R5KTtcbiAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy5yYW5nZSk7XG4gIHRoaXMuYm9keS5yYW5nZSA9IHRoaXMucmFuZ2U7XG5cbiAgLy8gdGltZSBheGlzXG4gIHRoaXMudGltZUF4aXMgPSBuZXcgVGltZUF4aXModGhpcy5ib2R5KTtcbiAgdGhpcy50aW1lQXhpczIgPSBudWxsOyAvLyB1c2VkIGluIGNhc2Ugb2Ygb3JpZW50YXRpb24gb3B0aW9uICdib3RoJ1xuICB0aGlzLmNvbXBvbmVudHMucHVzaCh0aGlzLnRpbWVBeGlzKTtcblxuICAvLyBjdXJyZW50IHRpbWUgYmFyXG4gIHRoaXMuY3VycmVudFRpbWUgPSBuZXcgQ3VycmVudFRpbWUodGhpcy5ib2R5KTtcbiAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy5jdXJyZW50VGltZSk7XG5cbiAgLy8gaXRlbSBzZXRcbiAgdGhpcy5pdGVtU2V0ID0gbmV3IEl0ZW1TZXQodGhpcy5ib2R5KTtcbiAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy5pdGVtU2V0KTtcblxuICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7ICAgICAgLy8gRGF0YVNldFxuICB0aGlzLmdyb3Vwc0RhdGEgPSBudWxsOyAgICAgLy8gRGF0YVNldFxuXG4gIHRoaXMub24oJ3RhcCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIG1lLmVtaXQoJ2NsaWNrJywgbWUuZ2V0RXZlbnRQcm9wZXJ0aWVzKGV2ZW50KSlcbiAgfSk7XG4gIHRoaXMub24oJ2RvdWJsZXRhcCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIG1lLmVtaXQoJ2RvdWJsZUNsaWNrJywgbWUuZ2V0RXZlbnRQcm9wZXJ0aWVzKGV2ZW50KSlcbiAgfSk7XG4gIHRoaXMuZG9tLnJvb3Qub25jb250ZXh0bWVudSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIG1lLmVtaXQoJ2NvbnRleHRtZW51JywgbWUuZ2V0RXZlbnRQcm9wZXJ0aWVzKGV2ZW50KSlcbiAgfTtcblxuICAvLyBhcHBseSBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gSU1QT1JUQU5UOiBUSElTIEhBUFBFTlMgQkVGT1JFIFNFVCBJVEVNUyFcbiAgaWYgKGdyb3Vwcykge1xuICAgIHRoaXMuc2V0R3JvdXBzKGdyb3Vwcyk7XG4gIH1cblxuICAvLyBjcmVhdGUgaXRlbXNldFxuICBpZiAoaXRlbXMpIHtcbiAgICB0aGlzLnNldEl0ZW1zKGl0ZW1zKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLl9yZWRyYXcoKTtcbiAgfVxufVxuXG4vLyBFeHRlbmQgdGhlIGZ1bmN0aW9uYWxpdHkgZnJvbSBDb3JlXG5UaW1lbGluZS5wcm90b3R5cGUgPSBuZXcgQ29yZSgpO1xuXG4vKipcbiAqIExvYWQgYSBjb25maWd1cmF0b3JcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblRpbWVsaW5lLnByb3RvdHlwZS5fY3JlYXRlQ29uZmlndXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IENvbmZpZ3VyYXRvcih0aGlzLCB0aGlzLmRvbS5jb250YWluZXIsIGNvbmZpZ3VyZU9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBGb3JjZSBhIHJlZHJhdy4gVGhlIHNpemUgb2YgYWxsIGl0ZW1zIHdpbGwgYmUgcmVjYWxjdWxhdGVkLlxuICogQ2FuIGJlIHVzZWZ1bCB0byBtYW51YWxseSByZWRyYXcgd2hlbiBvcHRpb24gYXV0b1Jlc2l6ZT1mYWxzZSBhbmQgdGhlIHdpbmRvd1xuICogaGFzIGJlZW4gcmVzaXplZCwgb3Igd2hlbiB0aGUgaXRlbXMgQ1NTIGhhcyBiZWVuIGNoYW5nZWQuXG4gKlxuICogTm90ZTogdGhpcyBmdW5jdGlvbiB3aWxsIGJlIG92ZXJyaWRkZW4gb24gY29uc3RydWN0aW9uIHdpdGggYSB0cm90dGxlZCB2ZXJzaW9uXG4gKi9cblRpbWVsaW5lLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pdGVtU2V0ICYmIHRoaXMuaXRlbVNldC5tYXJrRGlydHkoe3JlZnJlc2hJdGVtczogdHJ1ZX0pO1xuICB0aGlzLl9yZWRyYXcoKTtcbn07XG5cblRpbWVsaW5lLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgLy8gdmFsaWRhdGUgb3B0aW9uc1xuICBsZXQgZXJyb3JGb3VuZCA9IFZhbGlkYXRvci52YWxpZGF0ZShvcHRpb25zLCBhbGxPcHRpb25zKTtcbiAgaWYgKGVycm9yRm91bmQgPT09IHRydWUpIHtcbiAgICBjb25zb2xlLmxvZygnJWNFcnJvcnMgaGF2ZSBiZWVuIGZvdW5kIGluIHRoZSBzdXBwbGllZCBvcHRpb25zIG9iamVjdC4nLCBwcmludFN0eWxlKTtcbiAgfVxuXG4gIENvcmUucHJvdG90eXBlLnNldE9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAoJ3R5cGUnIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy50eXBlICE9PSB0aGlzLm9wdGlvbnMudHlwZSkge1xuICAgICAgdGhpcy5vcHRpb25zLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cbiAgICAgIC8vIGZvcmNlIHJlY3JlYXRpb24gb2YgYWxsIGl0ZW1zXG4gICAgICB2YXIgaXRlbXNEYXRhID0gdGhpcy5pdGVtc0RhdGE7XG4gICAgICBpZiAoaXRlbXNEYXRhKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnNldEl0ZW1zKG51bGwpOyAgICAgICAgICAvLyByZW1vdmUgYWxsXG4gICAgICAgIHRoaXMuc2V0SXRlbXMoaXRlbXNEYXRhKTsgICAgIC8vIGFkZCBhbGxcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTsgLy8gcmVzdG9yZSBzZWxlY3Rpb25cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGl0ZW1zXG4gKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgQXJyYXkgfCBudWxsfSBpdGVtc1xuICovXG5UaW1lbGluZS5wcm90b3R5cGUuc2V0SXRlbXMgPSBmdW5jdGlvbihpdGVtcykge1xuICB2YXIgaW5pdGlhbExvYWQgPSAodGhpcy5pdGVtc0RhdGEgPT0gbnVsbCk7XG5cbiAgLy8gY29udmVydCB0byB0eXBlIERhdGFTZXQgd2hlbiBuZWVkZWRcbiAgdmFyIG5ld0RhdGFTZXQ7XG4gIGlmICghaXRlbXMpIHtcbiAgICBuZXdEYXRhU2V0ID0gbnVsbDtcbiAgfVxuICBlbHNlIGlmIChpdGVtcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgaXRlbXMgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIG5ld0RhdGFTZXQgPSBpdGVtcztcbiAgfVxuICBlbHNlIHtcbiAgICAvLyB0dXJuIGFuIGFycmF5IGludG8gYSBkYXRhc2V0XG4gICAgbmV3RGF0YVNldCA9IG5ldyBEYXRhU2V0KGl0ZW1zLCB7XG4gICAgICB0eXBlOiB7XG4gICAgICAgIHN0YXJ0OiAnRGF0ZScsXG4gICAgICAgIGVuZDogJ0RhdGUnXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBzZXQgaXRlbXNcbiAgdGhpcy5pdGVtc0RhdGEgPSBuZXdEYXRhU2V0O1xuICB0aGlzLml0ZW1TZXQgJiYgdGhpcy5pdGVtU2V0LnNldEl0ZW1zKG5ld0RhdGFTZXQpO1xuXG4gIGlmIChpbml0aWFsTG9hZCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhcnQgIT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5lbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0YXJ0ID09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMuZW5kID09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldEl0ZW1SYW5nZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLm9wdGlvbnMuc3RhcnQgIT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnN0YXJ0IDogcmFuZ2UubWluO1xuICAgICAgdmFyIGVuZCAgID0gdGhpcy5vcHRpb25zLmVuZCAhPSB1bmRlZmluZWQgICA/IHRoaXMub3B0aW9ucy5lbmQgICA6IHJhbmdlLm1heDtcblxuICAgICAgdGhpcy5zZXRXaW5kb3coc3RhcnQsIGVuZCwge2FuaW1hdGlvbjogZmFsc2V9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmZpdCh7YW5pbWF0aW9uOiBmYWxzZX0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgZ3JvdXBzXG4gKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgQXJyYXl9IGdyb3Vwc1xuICovXG5UaW1lbGluZS5wcm90b3R5cGUuc2V0R3JvdXBzID0gZnVuY3Rpb24oZ3JvdXBzKSB7XG4gIC8vIGNvbnZlcnQgdG8gdHlwZSBEYXRhU2V0IHdoZW4gbmVlZGVkXG4gIHZhciBuZXdEYXRhU2V0O1xuICBpZiAoIWdyb3Vwcykge1xuICAgIG5ld0RhdGFTZXQgPSBudWxsO1xuICB9XG4gIGVsc2UgaWYgKGdyb3VwcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICBuZXdEYXRhU2V0ID0gZ3JvdXBzO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIHR1cm4gYW4gYXJyYXkgaW50byBhIGRhdGFzZXRcbiAgICBuZXdEYXRhU2V0ID0gbmV3IERhdGFTZXQoZ3JvdXBzKTtcbiAgfVxuXG4gIHRoaXMuZ3JvdXBzRGF0YSA9IG5ld0RhdGFTZXQ7XG4gIHRoaXMuaXRlbVNldC5zZXRHcm91cHMobmV3RGF0YVNldCk7XG59O1xuXG4vKipcbiAqIFNldCBib3RoIGl0ZW1zIGFuZCBncm91cHMgaW4gb25lIGdvXG4gKiBAcGFyYW0ge3tpdGVtczogQXJyYXkgfCB2aXMuRGF0YVNldCwgZ3JvdXBzOiBBcnJheSB8IHZpcy5EYXRhU2V0fX0gZGF0YVxuICovXG5UaW1lbGluZS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIGlmIChkYXRhICYmIGRhdGEuZ3JvdXBzKSB7XG4gICAgdGhpcy5zZXRHcm91cHMoZGF0YS5ncm91cHMpO1xuICB9XG5cbiAgaWYgKGRhdGEgJiYgZGF0YS5pdGVtcykge1xuICAgIHRoaXMuc2V0SXRlbXMoZGF0YS5pdGVtcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IHNlbGVjdGVkIGl0ZW1zIGJ5IHRoZWlyIGlkLiBSZXBsYWNlcyB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAqIFVua25vd24gaWQncyBhcmUgc2lsZW50bHkgaWdub3JlZC5cbiAqIEBwYXJhbSB7c3RyaW5nW10gfCBzdHJpbmd9IFtpZHNdICBBbiBhcnJheSB3aXRoIHplcm8gb3IgbW9yZSBpZCdzIG9mIHRoZSBpdGVtcyB0byBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLiBJZiBpZHMgaXMgYW4gZW1wdHkgYXJyYXksIGFsbCBpdGVtcyB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5zZWxlY3RlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgZm9jdXM6IGJvb2xlYW5gXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUsIGZvY3VzIHdpbGwgYmUgc2V0IHRvIHRoZSBzZWxlY3RlZCBpdGVtKHMpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFuaW1hdGlvbjogYm9vbGVhbiB8IHtkdXJhdGlvbjogbnVtYmVyLCBlYXNpbmdGdW5jdGlvbjogc3RyaW5nfWBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZCB0byBzcGVjaWZ5IGR1cmF0aW9uIGFuZCBlYXNpbmcgZnVuY3Rpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IGFwcGxpY2FibGUgd2hlbiBvcHRpb24gZm9jdXMgaXMgdHJ1ZS5cbiAqL1xuVGltZWxpbmUucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKGlkcywgb3B0aW9ucykge1xuICB0aGlzLml0ZW1TZXQgJiYgdGhpcy5pdGVtU2V0LnNldFNlbGVjdGlvbihpZHMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZm9jdXMpIHtcbiAgICB0aGlzLmZvY3VzKGlkcywgb3B0aW9ucyk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBzZWxlY3RlZCBpdGVtcyBieSB0aGVpciBpZFxuICogQHJldHVybiB7QXJyYXl9IGlkcyAgVGhlIGlkcyBvZiB0aGUgc2VsZWN0ZWQgaXRlbXNcbiAqL1xuVGltZWxpbmUucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pdGVtU2V0ICYmIHRoaXMuaXRlbVNldC5nZXRTZWxlY3Rpb24oKSB8fCBbXTtcbn07XG5cbi8qKlxuICogQWRqdXN0IHRoZSB2aXNpYmxlIHdpbmRvdyBzdWNoIHRoYXQgdGhlIHNlbGVjdGVkIGl0ZW0gKG9yIG11bHRpcGxlIGl0ZW1zKVxuICogYXJlIGNlbnRlcmVkIG9uIHNjcmVlbi5cbiAqIEBwYXJhbSB7U3RyaW5nIHwgU3RyaW5nW119IGlkICAgICBBbiBpdGVtIGlkIG9yIGFycmF5IHdpdGggaXRlbSBpZHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYW5pbWF0aW9uOiBib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9YFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHJhbmdlIGlzIGFuaW1hdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LiBBbiBvYmplY3QgY2FuIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBkdXJhdGlvbiBpcyA1MDAgbXMsIGFuZCBkZWZhdWx0IGVhc2luZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpcyAnZWFzZUluT3V0UXVhZCcuXG4gKi9cblRpbWVsaW5lLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKGlkLCBvcHRpb25zKSB7XG4gIGlmICghdGhpcy5pdGVtc0RhdGEgfHwgaWQgPT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgdmFyIGlkcyA9IEFycmF5LmlzQXJyYXkoaWQpID8gaWQgOiBbaWRdO1xuXG4gIC8vIGdldCB0aGUgc3BlY2lmaWVkIGl0ZW0ocylcbiAgdmFyIGl0ZW1zRGF0YSA9IHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKS5nZXQoaWRzLCB7XG4gICAgdHlwZToge1xuICAgICAgc3RhcnQ6ICdEYXRlJyxcbiAgICAgIGVuZDogJ0RhdGUnXG4gICAgfVxuICB9KTtcblxuICAvLyBjYWxjdWxhdGUgbWluaW11bSBzdGFydCBhbmQgbWF4aW11bSBlbmQgb2Ygc3BlY2lmaWVkIGl0ZW1zXG4gIHZhciBzdGFydCA9IG51bGw7XG4gIHZhciBlbmQgPSBudWxsO1xuICBpdGVtc0RhdGEuZm9yRWFjaChmdW5jdGlvbiAoaXRlbURhdGEpIHtcbiAgICB2YXIgcyA9IGl0ZW1EYXRhLnN0YXJ0LnZhbHVlT2YoKTtcbiAgICB2YXIgZSA9ICdlbmQnIGluIGl0ZW1EYXRhID8gaXRlbURhdGEuZW5kLnZhbHVlT2YoKSA6IGl0ZW1EYXRhLnN0YXJ0LnZhbHVlT2YoKTtcblxuICAgIGlmIChzdGFydCA9PT0gbnVsbCB8fCBzIDwgc3RhcnQpIHtcbiAgICAgIHN0YXJ0ID0gcztcbiAgICB9XG5cbiAgICBpZiAoZW5kID09PSBudWxsIHx8IGUgPiBlbmQpIHtcbiAgICAgIGVuZCA9IGU7XG4gICAgfVxuICB9KTtcblxuICBpZiAoc3RhcnQgIT09IG51bGwgJiYgZW5kICE9PSBudWxsKSB7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBuZXcgbWlkZGxlIGFuZCBpbnRlcnZhbCBmb3IgdGhlIHdpbmRvd1xuICAgIHZhciBtaWRkbGUgPSAoc3RhcnQgKyBlbmQpIC8gMjtcbiAgICB2YXIgaW50ZXJ2YWwgPSBNYXRoLm1heCgodGhpcy5yYW5nZS5lbmQgLSB0aGlzLnJhbmdlLnN0YXJ0KSwgKGVuZCAtIHN0YXJ0KSAqIDEuMSk7XG5cbiAgICB2YXIgYW5pbWF0aW9uID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRpb24gIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmFuaW1hdGlvbiA6IHRydWU7XG4gICAgdGhpcy5yYW5nZS5zZXRSYW5nZShtaWRkbGUgLSBpbnRlcnZhbCAvIDIsIG1pZGRsZSArIGludGVydmFsIC8gMiwgYW5pbWF0aW9uKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgVGltZWxpbmUgd2luZG93IHN1Y2ggdGhhdCBpdCBmaXRzIGFsbCBpdGVtc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFuaW1hdGlvbjogYm9vbGVhbiB8IHtkdXJhdGlvbjogbnVtYmVyLCBlYXNpbmdGdW5jdGlvbjogc3RyaW5nfWBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZCB0byBzcGVjaWZ5IGR1cmF0aW9uIGFuZCBlYXNpbmcgZnVuY3Rpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICovXG5UaW1lbGluZS5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIGFuaW1hdGlvbiA9IChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5hbmltYXRpb24gOiB0cnVlO1xuICB2YXIgcmFuZ2UgPSB0aGlzLmdldEl0ZW1SYW5nZSgpO1xuICB0aGlzLnJhbmdlLnNldFJhbmdlKHJhbmdlLm1pbiwgcmFuZ2UubWF4LCBhbmltYXRpb24pO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIHJhbmdlIG9mIHRoZSBpdGVtcywgdGFraW5nIGludG8gYWNjb3VudCB0aGVpciBhY3R1YWwgd2lkdGhcbiAqIGFuZCBhIG1hcmdpbiBvZiAxMCBwaXhlbHMgb24gYm90aCBzaWRlcy5cbiAqIEByZXR1cm4ge3ttaW46IERhdGUgfCBudWxsLCBtYXg6IERhdGUgfCBudWxsfX1cbiAqL1xuVGltZWxpbmUucHJvdG90eXBlLmdldEl0ZW1SYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gZ2V0IGEgcm91Z2ggYXBwcm94aW1hdGlvbiBmb3IgdGhlIHJhbmdlIGJhc2VkIG9uIHRoZSBpdGVtcyBzdGFydCBhbmQgZW5kIGRhdGVzXG4gIHZhciByYW5nZSA9IHRoaXMuZ2V0RGF0YVJhbmdlKCk7XG4gIHZhciBtaW4gPSByYW5nZS5taW47XG4gIHZhciBtYXggPSByYW5nZS5tYXg7XG4gIHZhciBtaW5JdGVtID0gbnVsbDtcbiAgdmFyIG1heEl0ZW0gPSBudWxsO1xuXG4gIGlmIChtaW4gIT0gbnVsbCAmJiBtYXggIT0gbnVsbCkge1xuICAgIHZhciBpbnRlcnZhbCA9IChtYXggLSBtaW4pOyAvLyBtc1xuICAgIGlmIChpbnRlcnZhbCA8PSAwKSB7XG4gICAgICBpbnRlcnZhbCA9IDEwO1xuICAgIH1cbiAgICB2YXIgZmFjdG9yID0gaW50ZXJ2YWwgLyB0aGlzLnByb3BzLmNlbnRlci53aWR0aDtcblxuICAgIGZ1bmN0aW9uIGdldFN0YXJ0KGl0ZW0pIHtcbiAgICAgIHJldHVybiB1dGlsLmNvbnZlcnQoaXRlbS5kYXRhLnN0YXJ0LCAnRGF0ZScpLnZhbHVlT2YoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVuZChpdGVtKSB7XG4gICAgICB2YXIgZW5kID0gaXRlbS5kYXRhLmVuZCAhPSB1bmRlZmluZWQgPyBpdGVtLmRhdGEuZW5kIDogaXRlbS5kYXRhLnN0YXJ0O1xuICAgICAgcmV0dXJuIHV0aWwuY29udmVydChlbmQsICdEYXRlJykudmFsdWVPZigpO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGF0ZSBvZiB0aGUgbGVmdCBzaWRlIGFuZCByaWdodCBzaWRlIG9mIHRoZSBpdGVtcyBnaXZlblxuICAgIHV0aWwuZm9yRWFjaCh0aGlzLml0ZW1TZXQuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpdGVtLnNob3coKTtcblxuICAgICAgdmFyIHN0YXJ0ID0gZ2V0U3RhcnQoaXRlbSk7XG4gICAgICB2YXIgZW5kID0gZ2V0RW5kKGl0ZW0pO1xuXG4gICAgICB2YXIgbGVmdCAgPSBuZXcgRGF0ZShzdGFydCAtIChpdGVtLmdldFdpZHRoTGVmdCgpICsgMTApICogZmFjdG9yKTtcbiAgICAgIHZhciByaWdodCA9IG5ldyBEYXRlKGVuZCAgICsgKGl0ZW0uZ2V0V2lkdGhSaWdodCgpICsgMTApICogZmFjdG9yKTtcblxuICAgICAgaWYgKGxlZnQgPCBtaW4pIHtcbiAgICAgICAgbWluID0gbGVmdDtcbiAgICAgICAgbWluSXRlbSA9IGl0ZW07XG4gICAgICB9XG4gICAgICBpZiAocmlnaHQgPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gcmlnaHQ7XG4gICAgICAgIG1heEl0ZW0gPSBpdGVtO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICBpZiAobWluSXRlbSAmJiBtYXhJdGVtKSB7XG4gICAgICB2YXIgbGhzID0gbWluSXRlbS5nZXRXaWR0aExlZnQoKSArIDEwO1xuICAgICAgdmFyIHJocyA9IG1heEl0ZW0uZ2V0V2lkdGhSaWdodCgpICsgMTA7XG4gICAgICB2YXIgZGVsdGEgPSB0aGlzLnByb3BzLmNlbnRlci53aWR0aCAtIGxocyAtIHJoczsgIC8vIHB4XG5cbiAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgbWluID0gZ2V0U3RhcnQobWluSXRlbSkgLSBsaHMgKiBpbnRlcnZhbCAvIGRlbHRhOyAvLyBtc1xuICAgICAgICBtYXggPSBnZXRFbmQobWF4SXRlbSkgICArIHJocyAqIGludGVydmFsIC8gZGVsdGE7IC8vIG1zXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGwsXG4gICAgbWF4OiBtYXggIT0gbnVsbCA/IG5ldyBEYXRlKG1heCkgOiBudWxsXG4gIH1cbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBkYXRhIHJhbmdlIG9mIHRoZSBpdGVtcyBzdGFydCBhbmQgZW5kIGRhdGVzXG4gKiBAcmV0dXJucyB7e21pbjogRGF0ZSB8IG51bGwsIG1heDogRGF0ZSB8IG51bGx9fVxuICovXG5UaW1lbGluZS5wcm90b3R5cGUuZ2V0RGF0YVJhbmdlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtaW4gPSBudWxsO1xuICB2YXIgbWF4ID0gbnVsbDtcblxuICB2YXIgZGF0YXNldCA9IHRoaXMuaXRlbXNEYXRhICYmIHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKTtcbiAgaWYgKGRhdGFzZXQpIHtcbiAgICBkYXRhc2V0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBzdGFydCA9IHV0aWwuY29udmVydChpdGVtLnN0YXJ0LCAnRGF0ZScpLnZhbHVlT2YoKTtcbiAgICAgIHZhciBlbmQgICA9IHV0aWwuY29udmVydChpdGVtLmVuZCAhPSB1bmRlZmluZWQgPyBpdGVtLmVuZCA6IGl0ZW0uc3RhcnQsICdEYXRlJykudmFsdWVPZigpO1xuICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBzdGFydCA8IG1pbikge1xuICAgICAgICBtaW4gPSBzdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChtYXggPT09IG51bGwgfHwgZW5kID4gbWF4KSB7XG4gICAgICAgIG1heCA9IHN0YXJ0O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGwsXG4gICAgbWF4OiBtYXggIT0gbnVsbCA/IG5ldyBEYXRlKG1heCkgOiBudWxsXG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGUgVGltZWxpbmUgcmVsYXRlZCBpbmZvcm1hdGlvbiBmcm9tIGFuIGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCByZWxhdGVkIGluZm9ybWF0aW9uLCBsaWtlIG9uIHdoaWNoIGFyZWFcbiAqICAgICAgICAgICAgICAgICAgVGhlIGV2ZW50IGhhcHBlbmVkLCB3aGV0aGVyIGNsaWNrZWQgb24gYW4gaXRlbSwgZXRjLlxuICovXG5UaW1lbGluZS5wcm90b3R5cGUuZ2V0RXZlbnRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBjbGllbnRYID0gZXZlbnQuY2VudGVyID8gZXZlbnQuY2VudGVyLnggOiBldmVudC5jbGllbnRYO1xuICB2YXIgY2xpZW50WSA9IGV2ZW50LmNlbnRlciA/IGV2ZW50LmNlbnRlci55IDogZXZlbnQuY2xpZW50WTtcbiAgdmFyIHggPSBjbGllbnRYIC0gdXRpbC5nZXRBYnNvbHV0ZUxlZnQodGhpcy5kb20uY2VudGVyQ29udGFpbmVyKTtcbiAgdmFyIHkgPSBjbGllbnRZIC0gdXRpbC5nZXRBYnNvbHV0ZVRvcCh0aGlzLmRvbS5jZW50ZXJDb250YWluZXIpO1xuXG4gIHZhciBpdGVtICA9IHRoaXMuaXRlbVNldC5pdGVtRnJvbVRhcmdldChldmVudCk7XG4gIHZhciBncm91cCA9IHRoaXMuaXRlbVNldC5ncm91cEZyb21UYXJnZXQoZXZlbnQpO1xuICB2YXIgY3VzdG9tVGltZSA9IEN1c3RvbVRpbWUuY3VzdG9tVGltZUZyb21UYXJnZXQoZXZlbnQpO1xuXG4gIHZhciBzbmFwID0gdGhpcy5pdGVtU2V0Lm9wdGlvbnMuc25hcCB8fCBudWxsO1xuICB2YXIgc2NhbGUgPSB0aGlzLmJvZHkudXRpbC5nZXRTY2FsZSgpO1xuICB2YXIgc3RlcCA9IHRoaXMuYm9keS51dGlsLmdldFN0ZXAoKTtcbiAgdmFyIHRpbWUgPSB0aGlzLl90b1RpbWUoeCk7XG4gIHZhciBzbmFwcGVkVGltZSA9IHNuYXAgPyBzbmFwKHRpbWUsIHNjYWxlLCBzdGVwKSA6IHRpbWU7XG5cbiAgdmFyIGVsZW1lbnQgPSB1dGlsLmdldFRhcmdldChldmVudCk7XG4gIHZhciB3aGF0ID0gbnVsbDtcbiAgaWYgKGl0ZW0gIT0gbnVsbCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3doYXQgPSAnaXRlbSc7fVxuICBlbHNlIGlmIChjdXN0b21UaW1lICE9IG51bGwpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7d2hhdCA9ICdjdXN0b20tdGltZSc7fVxuICBlbHNlIGlmICh1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLnRpbWVBeGlzLmRvbS5mb3JlZ3JvdW5kKSkgICAgICB7d2hhdCA9ICdheGlzJzt9XG4gIGVsc2UgaWYgKHRoaXMudGltZUF4aXMyICYmIHV0aWwuaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMudGltZUF4aXMyLmRvbS5mb3JlZ3JvdW5kKSkge3doYXQgPSAnYXhpcyc7fVxuICBlbHNlIGlmICh1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLml0ZW1TZXQuZG9tLmxhYmVsU2V0KSkgICAgICAgICB7d2hhdCA9ICdncm91cC1sYWJlbCc7fVxuICBlbHNlIGlmICh1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLmN1cnJlbnRUaW1lLmJhcikpICAgICAgICAgICAgICB7d2hhdCA9ICdjdXJyZW50LXRpbWUnO31cbiAgZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy5kb20uY2VudGVyKSkgICAgICAgICAgICAgICAgICAge3doYXQgPSAnYmFja2dyb3VuZCc7fVxuXG4gIHJldHVybiB7XG4gICAgZXZlbnQ6IGV2ZW50LFxuICAgIGl0ZW06IGl0ZW0gPyBpdGVtLmlkIDogbnVsbCxcbiAgICBncm91cDogZ3JvdXAgPyBncm91cC5ncm91cElkIDogbnVsbCxcbiAgICB3aGF0OiB3aGF0LFxuICAgIHBhZ2VYOiBldmVudC5zcmNFdmVudCA/IGV2ZW50LnNyY0V2ZW50LnBhZ2VYIDogZXZlbnQucGFnZVgsXG4gICAgcGFnZVk6IGV2ZW50LnNyY0V2ZW50ID8gZXZlbnQuc3JjRXZlbnQucGFnZVkgOiBldmVudC5wYWdlWSxcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgdGltZTogdGltZSxcbiAgICBzbmFwcGVkVGltZTogc25hcHBlZFRpbWVcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lbGluZTtcbiJdfQ==
},{"../DataSet":15,"../DataView":16,"../module/hammer":19,"../module/moment":20,"../shared/Configurator":24,"../shared/Validator":25,"../util":46,"./Core":26,"./Range":28,"./component/CurrentTime":34,"./component/CustomTime":35,"./component/ItemSet":37,"./component/TimeAxis":38,"./optionsTimeline":45,"emitter-component":10}],32:[function(require,module,exports){
'use strict';

var util = require('../../util');
var Group = require('./Group');

/**
 * @constructor BackgroundGroup
 * @param {Number | String} groupId
 * @param {Object} data
 * @param {ItemSet} itemSet
 */
function BackgroundGroup(groupId, data, itemSet) {
  Group.call(this, groupId, data, itemSet);

  this.width = 0;
  this.height = 0;
  this.top = 0;
  this.left = 0;
}

BackgroundGroup.prototype = Object.create(Group.prototype);

/**
 * Repaint this group
 * @param {{start: number, end: number}} range
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 * @param {boolean} [restack=false]  Force restacking of all items
 * @return {boolean} Returns true if the group is resized
 */
BackgroundGroup.prototype.redraw = function (range, margin, restack) {
  var resized = false;

  this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);

  // calculate actual size
  this.width = this.dom.background.offsetWidth;

  // apply new height (just always zero for BackgroundGroup
  this.dom.background.style.height = '0';

  // update vertical position of items after they are re-stacked and the height of the group is calculated
  for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
    var item = this.visibleItems[i];
    item.repositionY(margin);
  }

  return resized;
};

/**
 * Show this group: attach to the DOM
 */
BackgroundGroup.prototype.show = function () {
  if (!this.dom.background.parentNode) {
    this.itemSet.dom.background.appendChild(this.dom.background);
  }
};

module.exports = BackgroundGroup;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L0JhY2tncm91bmRHcm91cC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNqQyxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7Ozs7Ozs7O0FBUS9CLFNBQVMsZUFBZSxDQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFO0FBQ2hELE9BQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7O0FBRXpDLE1BQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0FBQ2YsTUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDaEIsTUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7QUFDYixNQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztDQUNmOztBQUVELGVBQWUsQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7Ozs7Ozs7OztBQVMzRCxlQUFlLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxVQUFTLEtBQUssRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFO0FBQ2xFLE1BQUksT0FBTyxHQUFHLEtBQUssQ0FBQzs7QUFFcEIsTUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsWUFBWSxFQUFFLEtBQUssQ0FBQyxDQUFDOzs7QUFHMUYsTUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUM7OztBQUc3QyxNQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFJLEdBQUcsQ0FBQzs7O0FBR3hDLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzFELFFBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDaEMsUUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztHQUMxQjs7QUFFRCxTQUFPLE9BQU8sQ0FBQztDQUNoQixDQUFDOzs7OztBQUtGLGVBQWUsQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHLFlBQVc7QUFDMUMsTUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFVBQVUsRUFBRTtBQUNuQyxRQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7R0FDOUQ7Q0FDRixDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsZUFBZSxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L0JhY2tncm91bmRHcm91cC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIEdyb3VwID0gcmVxdWlyZSgnLi9Hcm91cCcpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBCYWNrZ3JvdW5kR3JvdXBcbiAqIEBwYXJhbSB7TnVtYmVyIHwgU3RyaW5nfSBncm91cElkXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtJdGVtU2V0fSBpdGVtU2V0XG4gKi9cbmZ1bmN0aW9uIEJhY2tncm91bmRHcm91cCAoZ3JvdXBJZCwgZGF0YSwgaXRlbVNldCkge1xuICBHcm91cC5jYWxsKHRoaXMsIGdyb3VwSWQsIGRhdGEsIGl0ZW1TZXQpO1xuXG4gIHRoaXMud2lkdGggPSAwO1xuICB0aGlzLmhlaWdodCA9IDA7XG4gIHRoaXMudG9wID0gMDtcbiAgdGhpcy5sZWZ0ID0gMDtcbn1cblxuQmFja2dyb3VuZEdyb3VwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3JvdXAucHJvdG90eXBlKTtcblxuLyoqXG4gKiBSZXBhaW50IHRoaXMgZ3JvdXBcbiAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2VcbiAqIEBwYXJhbSB7e2l0ZW06IHtob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9LCBheGlzOiBudW1iZXJ9fSBtYXJnaW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3RhY2s9ZmFsc2VdICBGb3JjZSByZXN0YWNraW5nIG9mIGFsbCBpdGVtc1xuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBncm91cCBpcyByZXNpemVkXG4gKi9cbkJhY2tncm91bmRHcm91cC5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24ocmFuZ2UsIG1hcmdpbiwgcmVzdGFjaykge1xuICB2YXIgcmVzaXplZCA9IGZhbHNlO1xuXG4gIHRoaXMudmlzaWJsZUl0ZW1zID0gdGhpcy5fdXBkYXRlVmlzaWJsZUl0ZW1zKHRoaXMub3JkZXJlZEl0ZW1zLCB0aGlzLnZpc2libGVJdGVtcywgcmFuZ2UpO1xuXG4gIC8vIGNhbGN1bGF0ZSBhY3R1YWwgc2l6ZVxuICB0aGlzLndpZHRoID0gdGhpcy5kb20uYmFja2dyb3VuZC5vZmZzZXRXaWR0aDtcblxuICAvLyBhcHBseSBuZXcgaGVpZ2h0IChqdXN0IGFsd2F5cyB6ZXJvIGZvciBCYWNrZ3JvdW5kR3JvdXBcbiAgdGhpcy5kb20uYmFja2dyb3VuZC5zdHlsZS5oZWlnaHQgID0gJzAnO1xuXG4gIC8vIHVwZGF0ZSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiBpdGVtcyBhZnRlciB0aGV5IGFyZSByZS1zdGFja2VkIGFuZCB0aGUgaGVpZ2h0IG9mIHRoZSBncm91cCBpcyBjYWxjdWxhdGVkXG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMudmlzaWJsZUl0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHRoaXMudmlzaWJsZUl0ZW1zW2ldO1xuICAgIGl0ZW0ucmVwb3NpdGlvblkobWFyZ2luKTtcbiAgfVxuXG4gIHJldHVybiByZXNpemVkO1xufTtcblxuLyoqXG4gKiBTaG93IHRoaXMgZ3JvdXA6IGF0dGFjaCB0byB0aGUgRE9NXG4gKi9cbkJhY2tncm91bmRHcm91cC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZG9tLmJhY2tncm91bmQucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuaXRlbVNldC5kb20uYmFja2dyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5iYWNrZ3JvdW5kKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrZ3JvdW5kR3JvdXA7XG4iXX0=
},{"../../util":46,"./Group":36}],33:[function(require,module,exports){
/**
 * Prototype for visual components
 * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} [body]
 * @param {Object} [options]
 */
"use strict";

function Component(body, options) {
  this.options = null;
  this.props = null;
}

/**
 * Set options for the component. The new options will be merged into the
 * current options.
 * @param {Object} options
 */
Component.prototype.setOptions = function (options) {
  if (options) {
    util.extend(this.options, options);
  }
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
Component.prototype.redraw = function () {
  // should be implemented by the component
  return false;
};

/**
 * Destroy the component. Cleanup DOM and event listeners
 */
Component.prototype.destroy = function () {
  // should be implemented by the component
};

/**
 * Test whether the component is resized since the last time _isResized() was
 * called.
 * @return {Boolean} Returns true if the component is resized
 * @protected
 */
Component.prototype._isResized = function () {
  var resized = this.props._previousWidth !== this.props.width || this.props._previousHeight !== this.props.height;

  this.props._previousWidth = this.props.width;
  this.props._previousHeight = this.props.height;

  return resized;
};

module.exports = Component;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L0NvbXBvbmVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBS0EsU0FBUyxTQUFTLENBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRTtBQUNqQyxNQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztBQUNwQixNQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztDQUNuQjs7Ozs7OztBQU9ELFNBQVMsQ0FBQyxTQUFTLENBQUMsVUFBVSxHQUFHLFVBQVMsT0FBTyxFQUFFO0FBQ2pELE1BQUksT0FBTyxFQUFFO0FBQ1gsUUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0dBQ3BDO0NBQ0YsQ0FBQzs7Ozs7O0FBTUYsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsWUFBVzs7QUFFdEMsU0FBTyxLQUFLLENBQUM7Q0FDZCxDQUFDOzs7OztBQUtGLFNBQVMsQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUFHLFlBQVc7O0NBRXhDLENBQUM7Ozs7Ozs7O0FBUUYsU0FBUyxDQUFDLFNBQVMsQ0FBQyxVQUFVLEdBQUcsWUFBVztBQUMxQyxNQUFJLE9BQU8sR0FBSSxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssSUFDekQsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLEtBQUssSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEFBQUMsQ0FBQzs7QUFFdEQsTUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUM7QUFDN0MsTUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7O0FBRS9DLFNBQU8sT0FBTyxDQUFDO0NBQ2hCLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUMiLCJmaWxlIjoiL1VzZXJzL2RhcmluL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzLXZpZXdlci9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvQ29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcm90b3R5cGUgZm9yIHZpc3VhbCBjb21wb25lbnRzXG4gKiBAcGFyYW0ge3tkb206IE9iamVjdCwgZG9tUHJvcHM6IE9iamVjdCwgZW1pdHRlcjogRW1pdHRlciwgcmFuZ2U6IFJhbmdlfX0gW2JvZHldXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKi9cbmZ1bmN0aW9uIENvbXBvbmVudCAoYm9keSwgb3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBudWxsO1xuICB0aGlzLnByb3BzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTZXQgb3B0aW9ucyBmb3IgdGhlIGNvbXBvbmVudC4gVGhlIG5ldyBvcHRpb25zIHdpbGwgYmUgbWVyZ2VkIGludG8gdGhlXG4gKiBjdXJyZW50IG9wdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXBhaW50IHRoZSBjb21wb25lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgLy8gc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBjb21wb25lbnRcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBjb21wb25lbnQuIENsZWFudXAgRE9NIGFuZCBldmVudCBsaXN0ZW5lcnNcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIC8vIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgY29tcG9uZW50XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWQgc2luY2UgdGhlIGxhc3QgdGltZSBfaXNSZXNpemVkKCkgd2FzXG4gKiBjYWxsZWQuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuX2lzUmVzaXplZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzaXplZCA9ICh0aGlzLnByb3BzLl9wcmV2aW91c1dpZHRoICE9PSB0aGlzLnByb3BzLndpZHRoIHx8XG4gICAgICB0aGlzLnByb3BzLl9wcmV2aW91c0hlaWdodCAhPT0gdGhpcy5wcm9wcy5oZWlnaHQpO1xuXG4gIHRoaXMucHJvcHMuX3ByZXZpb3VzV2lkdGggPSB0aGlzLnByb3BzLndpZHRoO1xuICB0aGlzLnByb3BzLl9wcmV2aW91c0hlaWdodCA9IHRoaXMucHJvcHMuaGVpZ2h0O1xuXG4gIHJldHVybiByZXNpemVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQ7XG4iXX0=
},{}],34:[function(require,module,exports){
'use strict';

var util = require('../../util');
var Component = require('./Component');
var moment = require('../../module/moment');
var locales = require('../locales');

/**
 * A current time bar
 * @param {{range: Range, dom: Object, domProps: Object}} body
 * @param {Object} [options]        Available parameters:
 *                                  {Boolean} [showCurrentTime]
 * @constructor CurrentTime
 * @extends Component
 */
function CurrentTime(body, options) {
  this.body = body;

  // default options
  this.defaultOptions = {
    showCurrentTime: true,

    moment: moment,
    locales: locales,
    locale: 'en'
  };
  this.options = util.extend({}, this.defaultOptions);
  this.offset = 0;

  this._create();

  this.setOptions(options);
}

CurrentTime.prototype = new Component();

/**
 * Create the HTML DOM for the current time bar
 * @private
 */
CurrentTime.prototype._create = function () {
  var bar = document.createElement('div');
  bar.className = 'vis-current-time';
  bar.style.position = 'absolute';
  bar.style.top = '0px';
  bar.style.height = '100%';

  this.bar = bar;
};

/**
 * Destroy the CurrentTime bar
 */
CurrentTime.prototype.destroy = function () {
  this.options.showCurrentTime = false;
  this.redraw(); // will remove the bar from the DOM and stop refreshing

  this.body = null;
};

/**
 * Set options for the component. Options will be merged in current options.
 * @param {Object} options  Available parameters:
 *                          {boolean} [showCurrentTime]
 */
CurrentTime.prototype.setOptions = function (options) {
  if (options) {
    // copy all options that we know
    util.selectiveExtend(['showCurrentTime', 'moment', 'locale', 'locales'], this.options, options);
  }
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
CurrentTime.prototype.redraw = function () {
  if (this.options.showCurrentTime) {
    var parent = this.body.dom.backgroundVertical;
    if (this.bar.parentNode != parent) {
      // attach to the dom
      if (this.bar.parentNode) {
        this.bar.parentNode.removeChild(this.bar);
      }
      parent.appendChild(this.bar);

      this.start();
    }

    var now = this.options.moment(new Date().valueOf() + this.offset);
    var x = this.body.util.toScreen(now);

    var locale = this.options.locales[this.options.locale];
    if (!locale) {
      if (!this.warned) {
        console.log('WARNING: options.locales[\'' + this.options.locale + '\'] not found. See http://visjs.org/docs/timeline.html#Localization');
        this.warned = true;
      }
      locale = this.options.locales['en']; // fall back on english when not available
    }
    var title = locale.current + ' ' + locale.time + ': ' + now.format('dddd, MMMM Do YYYY, H:mm:ss');
    title = title.charAt(0).toUpperCase() + title.substring(1);

    this.bar.style.left = x + 'px';
    this.bar.title = title;
  } else {
    // remove the line from the DOM
    if (this.bar.parentNode) {
      this.bar.parentNode.removeChild(this.bar);
    }
    this.stop();
  }

  return false;
};

/**
 * Start auto refreshing the current time bar
 */
CurrentTime.prototype.start = function () {
  var me = this;

  function update() {
    me.stop();

    // determine interval to refresh
    var scale = me.body.range.conversion(me.body.domProps.center.width).scale;
    var interval = 1 / scale / 10;
    if (interval < 30) interval = 30;
    if (interval > 1000) interval = 1000;

    me.redraw();

    // start a renderTimer to adjust for the new time
    me.currentTimeTimer = setTimeout(update, interval);
  }

  update();
};

/**
 * Stop auto refreshing the current time bar
 */
CurrentTime.prototype.stop = function () {
  if (this.currentTimeTimer !== undefined) {
    clearTimeout(this.currentTimeTimer);
    delete this.currentTimeTimer;
  }
};

/**
 * Set a current time. This can be used for example to ensure that a client's
 * time is synchronized with a shared server time.
 * @param {Date | String | Number} time     A Date, unix timestamp, or
 *                                          ISO date string.
 */
CurrentTime.prototype.setCurrentTime = function (time) {
  var t = util.convert(time, 'Date').valueOf();
  var now = new Date().valueOf();
  this.offset = t - now;
  this.redraw();
};

/**
 * Get the current time.
 * @return {Date} Returns the current time.
 */
CurrentTime.prototype.getCurrentTime = function () {
  return new Date(new Date().valueOf() + this.offset);
};

module.exports = CurrentTime;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L0N1cnJlbnRUaW1lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ2pDLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN2QyxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQztBQUM1QyxJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7Ozs7Ozs7Ozs7QUFVcEMsU0FBUyxXQUFXLENBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRTtBQUNuQyxNQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQzs7O0FBR2pCLE1BQUksQ0FBQyxjQUFjLEdBQUc7QUFDcEIsbUJBQWUsRUFBRSxJQUFJOztBQUVyQixVQUFNLEVBQUUsTUFBTTtBQUNkLFdBQU8sRUFBRSxPQUFPO0FBQ2hCLFVBQU0sRUFBRSxJQUFJO0dBQ2IsQ0FBQztBQUNGLE1BQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQ3BELE1BQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDOztBQUVoQixNQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7O0FBRWYsTUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztDQUMxQjs7QUFFRCxXQUFXLENBQUMsU0FBUyxHQUFHLElBQUksU0FBUyxFQUFFLENBQUM7Ozs7OztBQU14QyxXQUFXLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRyxZQUFXO0FBQ3pDLE1BQUksR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFD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QUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUNwQyxXQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztHQUM5QjtDQUNGLENBQUM7Ozs7Ozs7O0FBUUYsV0FBVyxDQUFDLFNBQVMsQ0FBQyxjQUFjLEdBQUcsVUFBUyxJQUFJLEVBQUU7QUFDcEQsTUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDN0MsTUFBSSxHQUFHLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUMvQixNQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDdEIsTUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0NBQ2YsQ0FBQzs7Ozs7O0FBTUYsV0FBVyxDQUFDLFNBQVMsQ0FBQyxjQUFjLEdBQUcsWUFBVztBQUNoRCxTQUFPLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0NBQ3JELENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxXQUFXLENBQUMiLCJmaWxlIjoiL1VzZXJzL2RhcmluL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzLXZpZXdlci9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvQ3VycmVudFRpbWUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuL0NvbXBvbmVudCcpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZS9tb21lbnQnKTtcbnZhciBsb2NhbGVzID0gcmVxdWlyZSgnLi4vbG9jYWxlcycpO1xuXG4vKipcbiAqIEEgY3VycmVudCB0aW1lIGJhclxuICogQHBhcmFtIHt7cmFuZ2U6IFJhbmdlLCBkb206IE9iamVjdCwgZG9tUHJvcHM6IE9iamVjdH19IGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIEF2YWlsYWJsZSBwYXJhbWV0ZXJzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IFtzaG93Q3VycmVudFRpbWVdXG4gKiBAY29uc3RydWN0b3IgQ3VycmVudFRpbWVcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5mdW5jdGlvbiBDdXJyZW50VGltZSAoYm9keSwgb3B0aW9ucykge1xuICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIHNob3dDdXJyZW50VGltZTogdHJ1ZSxcblxuICAgIG1vbWVudDogbW9tZW50LFxuICAgIGxvY2FsZXM6IGxvY2FsZXMsXG4gICAgbG9jYWxlOiAnZW4nXG4gIH07XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgdGhpcy5vZmZzZXQgPSAwO1xuXG4gIHRoaXMuX2NyZWF0ZSgpO1xuXG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbn1cblxuQ3VycmVudFRpbWUucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgSFRNTCBET00gZm9yIHRoZSBjdXJyZW50IHRpbWUgYmFyXG4gKiBAcHJpdmF0ZVxuICovXG5DdXJyZW50VGltZS5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGJhci5jbGFzc05hbWUgPSAndmlzLWN1cnJlbnQtdGltZSc7XG4gIGJhci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGJhci5zdHlsZS50b3AgPSAnMHB4JztcbiAgYmFyLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcblxuICB0aGlzLmJhciA9IGJhcjtcbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGUgQ3VycmVudFRpbWUgYmFyXG4gKi9cbkN1cnJlbnRUaW1lLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm9wdGlvbnMuc2hvd0N1cnJlbnRUaW1lID0gZmFsc2U7XG4gIHRoaXMucmVkcmF3KCk7IC8vIHdpbGwgcmVtb3ZlIHRoZSBiYXIgZnJvbSB0aGUgRE9NIGFuZCBzdG9wIHJlZnJlc2hpbmdcblxuICB0aGlzLmJvZHkgPSBudWxsO1xufTtcblxuLyoqXG4gKiBTZXQgb3B0aW9ucyBmb3IgdGhlIGNvbXBvbmVudC4gT3B0aW9ucyB3aWxsIGJlIG1lcmdlZCBpbiBjdXJyZW50IG9wdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgQXZhaWxhYmxlIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAge2Jvb2xlYW59IFtzaG93Q3VycmVudFRpbWVdXG4gKi9cbkN1cnJlbnRUaW1lLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucykge1xuICAgIC8vIGNvcHkgYWxsIG9wdGlvbnMgdGhhdCB3ZSBrbm93XG4gICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoWydzaG93Q3VycmVudFRpbWUnLCAnbW9tZW50JywgJ2xvY2FsZScsICdsb2NhbGVzJ10sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwYWludCB0aGUgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gKi9cbkN1cnJlbnRUaW1lLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5zaG93Q3VycmVudFRpbWUpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5ib2R5LmRvbS5iYWNrZ3JvdW5kVmVydGljYWw7XG4gICAgaWYgKHRoaXMuYmFyLnBhcmVudE5vZGUgIT0gcGFyZW50KSB7XG4gICAgICAvLyBhdHRhY2ggdG8gdGhlIGRvbVxuICAgICAgaWYgKHRoaXMuYmFyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5iYXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmJhcik7XG4gICAgICB9XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5iYXIpO1xuXG4gICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IHRoaXMub3B0aW9ucy5tb21lbnQobmV3IERhdGUoKS52YWx1ZU9mKCkgKyB0aGlzLm9mZnNldCk7XG4gICAgdmFyIHggPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbihub3cpO1xuXG4gICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgIGlmICghbG9jYWxlKSB7XG4gICAgICBpZiAoIXRoaXMud2FybmVkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBvcHRpb25zLmxvY2FsZXNbXFwnJyArIHRoaXMub3B0aW9ucy5sb2NhbGUgKyAnXFwnXSBub3QgZm91bmQuIFNlZSBodHRwOi8vdmlzanMub3JnL2RvY3MvdGltZWxpbmUuaHRtbCNMb2NhbGl6YXRpb24nKTtcbiAgICAgICAgdGhpcy53YXJuZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ107IC8vIGZhbGwgYmFjayBvbiBlbmdsaXNoIHdoZW4gbm90IGF2YWlsYWJsZVxuICAgIH1cbiAgICB2YXIgdGl0bGUgPSBsb2NhbGUuY3VycmVudCArICcgJyArIGxvY2FsZS50aW1lICsgJzogJyArIG5vdy5mb3JtYXQoJ2RkZGQsIE1NTU0gRG8gWVlZWSwgSDptbTpzcycpO1xuICAgIHRpdGxlID0gdGl0bGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0aXRsZS5zdWJzdHJpbmcoMSk7XG5cbiAgICB0aGlzLmJhci5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgdGhpcy5iYXIudGl0bGUgPSB0aXRsZTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyByZW1vdmUgdGhlIGxpbmUgZnJvbSB0aGUgRE9NXG4gICAgaWYgKHRoaXMuYmFyLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuYmFyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5iYXIpO1xuICAgIH1cbiAgICB0aGlzLnN0b3AoKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogU3RhcnQgYXV0byByZWZyZXNoaW5nIHRoZSBjdXJyZW50IHRpbWUgYmFyXG4gKi9cbkN1cnJlbnRUaW1lLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgbWUuc3RvcCgpO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGludGVydmFsIHRvIHJlZnJlc2hcbiAgICB2YXIgc2NhbGUgPSBtZS5ib2R5LnJhbmdlLmNvbnZlcnNpb24obWUuYm9keS5kb21Qcm9wcy5jZW50ZXIud2lkdGgpLnNjYWxlO1xuICAgIHZhciBpbnRlcnZhbCA9IDEgLyBzY2FsZSAvIDEwO1xuICAgIGlmIChpbnRlcnZhbCA8IDMwKSAgIGludGVydmFsID0gMzA7XG4gICAgaWYgKGludGVydmFsID4gMTAwMCkgaW50ZXJ2YWwgPSAxMDAwO1xuXG4gICAgbWUucmVkcmF3KCk7XG5cbiAgICAvLyBzdGFydCBhIHJlbmRlclRpbWVyIHRvIGFkanVzdCBmb3IgdGhlIG5ldyB0aW1lXG4gICAgbWUuY3VycmVudFRpbWVUaW1lciA9IHNldFRpbWVvdXQodXBkYXRlLCBpbnRlcnZhbCk7XG4gIH1cblxuICB1cGRhdGUoKTtcbn07XG5cbi8qKlxuICogU3RvcCBhdXRvIHJlZnJlc2hpbmcgdGhlIGN1cnJlbnQgdGltZSBiYXJcbiAqL1xuQ3VycmVudFRpbWUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY3VycmVudFRpbWVUaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuY3VycmVudFRpbWVUaW1lcik7XG4gICAgZGVsZXRlIHRoaXMuY3VycmVudFRpbWVUaW1lcjtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgYSBjdXJyZW50IHRpbWUuIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGV4YW1wbGUgdG8gZW5zdXJlIHRoYXQgYSBjbGllbnQnc1xuICogdGltZSBpcyBzeW5jaHJvbml6ZWQgd2l0aCBhIHNoYXJlZCBzZXJ2ZXIgdGltZS5cbiAqIEBwYXJhbSB7RGF0ZSB8IFN0cmluZyB8IE51bWJlcn0gdGltZSAgICAgQSBEYXRlLCB1bml4IHRpbWVzdGFtcCwgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSVNPIGRhdGUgc3RyaW5nLlxuICovXG5DdXJyZW50VGltZS5wcm90b3R5cGUuc2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbih0aW1lKSB7XG4gIHZhciB0ID0gdXRpbC5jb252ZXJ0KHRpbWUsICdEYXRlJykudmFsdWVPZigpO1xuICB2YXIgbm93ID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gIHRoaXMub2Zmc2V0ID0gdCAtIG5vdztcbiAgdGhpcy5yZWRyYXcoKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHRpbWUuXG4gKiBAcmV0dXJuIHtEYXRlfSBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUuXG4gKi9cbkN1cnJlbnRUaW1lLnByb3RvdHlwZS5nZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IERhdGUobmV3IERhdGUoKS52YWx1ZU9mKCkgKyB0aGlzLm9mZnNldCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEN1cnJlbnRUaW1lO1xuIl19
},{"../../module/moment":20,"../../util":46,"../locales":44,"./Component":33}],35:[function(require,module,exports){
'use strict';

var Hammer = require('../../module/hammer');
var util = require('../../util');
var Component = require('./Component');
var moment = require('../../module/moment');
var locales = require('../locales');

/**
 * A custom time bar
 * @param {{range: Range, dom: Object}} body
 * @param {Object} [options]        Available parameters:
 *                                  {number | string} id
 *                                  {string} locales
 *                                  {string} locale
 * @constructor CustomTime
 * @extends Component
 */

function CustomTime(body, options) {
  this.body = body;

  // default options
  this.defaultOptions = {
    moment: moment,
    locales: locales,
    locale: 'en',
    id: undefined,
    title: undefined
  };
  this.options = util.extend({}, this.defaultOptions);

  if (options && options.time) {
    this.customTime = options.time;
  } else {
    this.customTime = new Date();
  }

  this.eventParams = {}; // stores state parameters while dragging the bar

  this.setOptions(options);

  // create the DOM
  this._create();
}

CustomTime.prototype = new Component();

/**
 * Set options for the component. Options will be merged in current options.
 * @param {Object} options  Available parameters:
 *                                  {number | string} id
 *                                  {string} locales
 *                                  {string} locale
 */
CustomTime.prototype.setOptions = function (options) {
  if (options) {
    // copy all options that we know
    util.selectiveExtend(['moment', 'locale', 'locales', 'id'], this.options, options);
  }
};

/**
 * Create the DOM for the custom time
 * @private
 */
CustomTime.prototype._create = function () {
  var bar = document.createElement('div');
  bar['custom-time'] = this;
  bar.className = 'vis-custom-time ' + (this.options.id || '');
  bar.style.position = 'absolute';
  bar.style.top = '0px';
  bar.style.height = '100%';
  this.bar = bar;

  var drag = document.createElement('div');
  drag.style.position = 'relative';
  drag.style.top = '0px';
  drag.style.left = '-10px';
  drag.style.height = '100%';
  drag.style.width = '20px';
  bar.appendChild(drag);

  // attach event listeners
  this.hammer = new Hammer(drag);
  this.hammer.on('panstart', this._onDragStart.bind(this));
  this.hammer.on('panmove', this._onDrag.bind(this));
  this.hammer.on('panend', this._onDragEnd.bind(this));
  this.hammer.get('pan').set({ threshold: 5, direction: 30 }); // 30 is ALL_DIRECTIONS in hammer.
};

/**
 * Destroy the CustomTime bar
 */
CustomTime.prototype.destroy = function () {
  this.hide();

  this.hammer.destroy();
  this.hammer = null;

  this.body = null;
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
CustomTime.prototype.redraw = function () {
  var parent = this.body.dom.backgroundVertical;
  if (this.bar.parentNode != parent) {
    // attach to the dom
    if (this.bar.parentNode) {
      this.bar.parentNode.removeChild(this.bar);
    }
    parent.appendChild(this.bar);
  }

  var x = this.body.util.toScreen(this.customTime);

  var locale = this.options.locales[this.options.locale];
  if (!locale) {
    if (!this.warned) {
      console.log('WARNING: options.locales[\'' + this.options.locale + '\'] not found. See http://visjs.org/docs/timeline.html#Localization');
      this.warned = true;
    }
    locale = this.options.locales['en']; // fall back on english when not available
  }

  var title = this.options.title;
  // To hide the title completely use empty string ''.
  if (title === undefined) {
    title = locale.time + ': ' + this.options.moment(this.customTime).format('dddd, MMMM Do YYYY, H:mm:ss');
    title = title.charAt(0).toUpperCase() + title.substring(1);
  }

  this.bar.style.left = x + 'px';
  this.bar.title = title;

  return false;
};

/**
 * Remove the CustomTime from the DOM
 */
CustomTime.prototype.hide = function () {
  // remove the line from the DOM
  if (this.bar.parentNode) {
    this.bar.parentNode.removeChild(this.bar);
  }
};

/**
 * Set custom time.
 * @param {Date | number | string} time
 */
CustomTime.prototype.setCustomTime = function (time) {
  this.customTime = util.convert(time, 'Date');
  this.redraw();
};

/**
 * Retrieve the current custom time.
 * @return {Date} customTime
 */
CustomTime.prototype.getCustomTime = function () {
  return new Date(this.customTime.valueOf());
};

/**
  * Set custom title.
  * @param {Date | number | string} title
  */
CustomTime.prototype.setCustomTitle = function (title) {
  this.options.title = title;
};

/**
 * Start moving horizontally
 * @param {Event} event
 * @private
 */
CustomTime.prototype._onDragStart = function (event) {
  this.eventParams.dragging = true;
  this.eventParams.customTime = this.customTime;

  event.stopPropagation();
};

/**
 * Perform moving operating.
 * @param {Event} event
 * @private
 */
CustomTime.prototype._onDrag = function (event) {
  if (!this.eventParams.dragging) return;

  var x = this.body.util.toScreen(this.eventParams.customTime) + event.deltaX;
  var time = this.body.util.toTime(x);

  this.setCustomTime(time);

  // fire a timechange event
  this.body.emitter.emit('timechange', {
    id: this.options.id,
    time: new Date(this.customTime.valueOf())
  });

  event.stopPropagation();
};

/**
 * Stop moving operating.
 * @param {Event} event
 * @private
 */
CustomTime.prototype._onDragEnd = function (event) {
  if (!this.eventParams.dragging) return;

  // fire a timechanged event
  this.body.emitter.emit('timechanged', {
    id: this.options.id,
    time: new Date(this.customTime.valueOf())
  });

  event.stopPropagation();
};

/**
 * Find a custom time from an event target:
 * searches for the attribute 'custom-time' in the event target's element tree
 * @param {Event} event
 * @return {CustomTime | null} customTime
 */
CustomTime.customTimeFromTarget = function (event) {
  var target = event.target;
  while (target) {
    if (target.hasOwnProperty('custom-time')) {
      return target['custom-time'];
    }
    target = target.parentNode;
  }

  return null;
};

module.exports = CustomTime;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L0N1c3RvbVRpbWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQztBQUM1QyxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDakMsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3ZDLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0FBQzVDLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7OztBQWFwQyxTQUFTLFVBQVUsQ0FBRSxJQUFJLEVBQUUsT0FBTyxFQUFFO0FBQ2xDLE1BQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDOzs7QUFHakIsTUFBSSxDQUFDLGNBQWMsR0FBRztBQUNwQixVQUFNLEVBQUUsTUFBTTtBQUNkLFdBQU8sRUFBRSxPQUFPO0FBQ2hCLFVBQU0sRUFBRSxJQUFJO0FBQ1osTUFBRSxFQUFFLFNBQVM7QUFDYixTQUFLLEVBQUUsU0FBUztHQUNqQixDQUFDO0FBQ0YsTUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7O0FBRXBELE1BQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxJQUFJLEVBQUU7QUFDM0IsUUFBSSxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDO0dBQ2hDLE1BQU07QUFDTCxRQUFJLENBQUMsVUFBVSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7R0FDOUI7O0FBRUQsTUFBSSxDQUFDLFdBQVcsR0FBRyxFQUFFLENBQUM7O0FBRXRCLE1BQUks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LFFBQUksRUFBRSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxDQUFDO0dBQzFDLENBQUMsQ0FBQzs7QUFFSCxPQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7Q0FDekIsQ0FBQzs7Ozs7Ozs7QUFRRixVQUFVLENBQUMsb0JBQW9CLEdBQUcsVUFBUyxLQUFLLEVBQUU7QUFDaEQsTUFBSSxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztBQUMxQixTQUFPLE1BQU0sRUFBRTtBQUNiLFFBQUksTUFBTSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsRUFBRTtBQUN4QyxhQUFPLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQztLQUM5QjtBQUNELFVBQU0sR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDO0dBQzVCOztBQUVELFNBQU8sSUFBSSxDQUFDO0NBQ2IsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLFVBQVUsQ0FBQyIsImZpbGUiOiIvVXNlcnMvZGFyaW4vRGV2ZWxvcG1lbnQvbWFwc3Rvcnkvc3RvcnktdG9vbHMtdmlld2VyL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9DdXN0b21UaW1lLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEhhbW1lciA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZS9oYW1tZXInKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50Jyk7XG52YXIgbW9tZW50ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlL21vbWVudCcpO1xudmFyIGxvY2FsZXMgPSByZXF1aXJlKCcuLi9sb2NhbGVzJyk7XG5cbi8qKlxuICogQSBjdXN0b20gdGltZSBiYXJcbiAqIEBwYXJhbSB7e3JhbmdlOiBSYW5nZSwgZG9tOiBPYmplY3R9fSBib2R5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBBdmFpbGFibGUgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtudW1iZXIgfCBzdHJpbmd9IGlkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBsb2NhbGVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBsb2NhbGVcbiAqIEBjb25zdHJ1Y3RvciBDdXN0b21UaW1lXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG5mdW5jdGlvbiBDdXN0b21UaW1lIChib2R5LCBvcHRpb25zKSB7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbW9tZW50OiBtb21lbnQsXG4gICAgbG9jYWxlczogbG9jYWxlcyxcbiAgICBsb2NhbGU6ICdlbicsXG4gICAgaWQ6IHVuZGVmaW5lZCxcbiAgICB0aXRsZTogdW5kZWZpbmVkXG4gIH07XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnRpbWUpIHtcbiAgICB0aGlzLmN1c3RvbVRpbWUgPSBvcHRpb25zLnRpbWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5jdXN0b21UaW1lID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gIHRoaXMuZXZlbnRQYXJhbXMgPSB7fTsgLy8gc3RvcmVzIHN0YXRlIHBhcmFtZXRlcnMgd2hpbGUgZHJhZ2dpbmcgdGhlIGJhclxuXG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAvLyBjcmVhdGUgdGhlIERPTVxuICB0aGlzLl9jcmVhdGUoKTtcbn1cblxuQ3VzdG9tVGltZS5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbi8qKlxuICogU2V0IG9wdGlvbnMgZm9yIHRoZSBjb21wb25lbnQuIE9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgaW4gY3VycmVudCBvcHRpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgIEF2YWlsYWJsZSBwYXJhbWV0ZXJzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlciB8IHN0cmluZ30gaWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGxvY2FsZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGxvY2FsZVxuICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucykge1xuICAgIC8vIGNvcHkgYWxsIG9wdGlvbnMgdGhhdCB3ZSBrbm93XG4gICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoWydtb21lbnQnLCAnbG9jYWxlJywgJ2xvY2FsZXMnLCAnaWQnXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIERPTSBmb3IgdGhlIGN1c3RvbSB0aW1lXG4gKiBAcHJpdmF0ZVxuICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgYmFyWydjdXN0b20tdGltZSddID0gdGhpcztcbiAgYmFyLmNsYXNzTmFtZSA9ICd2aXMtY3VzdG9tLXRpbWUgJyArICh0aGlzLm9wdGlvbnMuaWQgfHwgJycpO1xuICBiYXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBiYXIuc3R5bGUudG9wID0gJzBweCc7XG4gIGJhci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gIHRoaXMuYmFyID0gYmFyO1xuXG4gIHZhciBkcmFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRyYWcuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICBkcmFnLnN0eWxlLnRvcCA9ICcwcHgnO1xuICBkcmFnLnN0eWxlLmxlZnQgPSAnLTEwcHgnO1xuICBkcmFnLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgZHJhZy5zdHlsZS53aWR0aCA9ICcyMHB4JztcbiAgYmFyLmFwcGVuZENoaWxkKGRyYWcpO1xuXG4gIC8vIGF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbiAgdGhpcy5oYW1tZXIgPSBuZXcgSGFtbWVyKGRyYWcpO1xuICB0aGlzLmhhbW1lci5vbigncGFuc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5oYW1tZXIub24oJ3Bhbm1vdmUnLCAgdGhpcy5fb25EcmFnLmJpbmQodGhpcykpO1xuICB0aGlzLmhhbW1lci5vbigncGFuZW5kJywgICB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKSk7XG4gIHRoaXMuaGFtbWVyLmdldCgncGFuJykuc2V0KHt0aHJlc2hvbGQ6NSwgZGlyZWN0aW9uOjMwfSk7IC8vIDMwIGlzIEFMTF9ESVJFQ1RJT05TIGluIGhhbW1lci5cbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGUgQ3VzdG9tVGltZSBiYXJcbiAqL1xuQ3VzdG9tVGltZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oaWRlKCk7XG5cbiAgdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICB0aGlzLmhhbW1lciA9IG51bGw7XG5cbiAgdGhpcy5ib2R5ID0gbnVsbDtcbn07XG5cbi8qKlxuICogUmVwYWludCB0aGUgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMuYm9keS5kb20uYmFja2dyb3VuZFZlcnRpY2FsO1xuICBpZiAodGhpcy5iYXIucGFyZW50Tm9kZSAhPSBwYXJlbnQpIHtcbiAgICAvLyBhdHRhY2ggdG8gdGhlIGRvbVxuICAgIGlmICh0aGlzLmJhci5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmJhci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYmFyKTtcbiAgICB9XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuYmFyKTtcbiAgfVxuXG4gIHZhciB4ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4odGhpcy5jdXN0b21UaW1lKTtcblxuICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gIGlmICghbG9jYWxlKSB7XG4gICAgaWYgKCF0aGlzLndhcm5lZCkge1xuICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IG9wdGlvbnMubG9jYWxlc1tcXCcnICsgdGhpcy5vcHRpb25zLmxvY2FsZSArICdcXCddIG5vdCBmb3VuZC4gU2VlIGh0dHA6Ly92aXNqcy5vcmcvZG9jcy90aW1lbGluZS5odG1sI0xvY2FsaXphdGlvbicpO1xuICAgICAgdGhpcy53YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXTsgLy8gZmFsbCBiYWNrIG9uIGVuZ2xpc2ggd2hlbiBub3QgYXZhaWxhYmxlXG4gIH1cblxuICB2YXIgdGl0bGUgPSB0aGlzLm9wdGlvbnMudGl0bGU7XG4gIC8vIFRvIGhpZGUgdGhlIHRpdGxlIGNvbXBsZXRlbHkgdXNlIGVtcHR5IHN0cmluZyAnJy5cbiAgaWYgKHRpdGxlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aXRsZSA9IGxvY2FsZS50aW1lICsgJzogJyArIHRoaXMub3B0aW9ucy5tb21lbnQodGhpcy5jdXN0b21UaW1lKS5mb3JtYXQoJ2RkZGQsIE1NTU0gRG8gWVlZWSwgSDptbTpzcycpO1xuICAgIHRpdGxlID0gdGl0bGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0aXRsZS5zdWJzdHJpbmcoMSk7XG4gIH1cblxuICB0aGlzLmJhci5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gIHRoaXMuYmFyLnRpdGxlID0gdGl0bGU7XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIEN1c3RvbVRpbWUgZnJvbSB0aGUgRE9NXG4gKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHJlbW92ZSB0aGUgbGluZSBmcm9tIHRoZSBET01cbiAgaWYgKHRoaXMuYmFyLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLmJhci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYmFyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgY3VzdG9tIHRpbWUuXG4gKiBAcGFyYW0ge0RhdGUgfCBudW1iZXIgfCBzdHJpbmd9IHRpbWVcbiAqL1xuQ3VzdG9tVGltZS5wcm90b3R5cGUuc2V0Q3VzdG9tVGltZSA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgdGhpcy5jdXN0b21UaW1lID0gdXRpbC5jb252ZXJ0KHRpbWUsICdEYXRlJyk7XG4gIHRoaXMucmVkcmF3KCk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGN1c3RvbSB0aW1lLlxuICogQHJldHVybiB7RGF0ZX0gY3VzdG9tVGltZVxuICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5nZXRDdXN0b21UaW1lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgRGF0ZSh0aGlzLmN1c3RvbVRpbWUudmFsdWVPZigpKTtcbn07XG5cbi8qKlxuICAqIFNldCBjdXN0b20gdGl0bGUuXG4gICogQHBhcmFtIHtEYXRlIHwgbnVtYmVyIHwgc3RyaW5nfSB0aXRsZVxuICAqL1xuQ3VzdG9tVGltZS5wcm90b3R5cGUuc2V0Q3VzdG9tVGl0bGUgPSBmdW5jdGlvbih0aXRsZSkge1xuICB0aGlzLm9wdGlvbnMudGl0bGUgPSB0aXRsZTtcbn07XG5cbi8qKlxuICogU3RhcnQgbW92aW5nIGhvcml6b250YWxseVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHRoaXMuZXZlbnRQYXJhbXMuZHJhZ2dpbmcgPSB0cnVlO1xuICB0aGlzLmV2ZW50UGFyYW1zLmN1c3RvbVRpbWUgPSB0aGlzLmN1c3RvbVRpbWU7XG5cbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gbW92aW5nIG9wZXJhdGluZy5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICghdGhpcy5ldmVudFBhcmFtcy5kcmFnZ2luZykgcmV0dXJuO1xuXG4gIHZhciB4ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4odGhpcy5ldmVudFBhcmFtcy5jdXN0b21UaW1lKSArIGV2ZW50LmRlbHRhWDtcbiAgdmFyIHRpbWUgPSB0aGlzLmJvZHkudXRpbC50b1RpbWUoeCk7XG5cbiAgdGhpcy5zZXRDdXN0b21UaW1lKHRpbWUpO1xuXG4gIC8vIGZpcmUgYSB0aW1lY2hhbmdlIGV2ZW50XG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3RpbWVjaGFuZ2UnLCB7XG4gICAgaWQ6IHRoaXMub3B0aW9ucy5pZCxcbiAgICB0aW1lOiBuZXcgRGF0ZSh0aGlzLmN1c3RvbVRpbWUudmFsdWVPZigpKVxuICB9KTtcblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn07XG5cbi8qKlxuICogU3RvcCBtb3Zpbmcgb3BlcmF0aW5nLlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLl9vbkRyYWdFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKCF0aGlzLmV2ZW50UGFyYW1zLmRyYWdnaW5nKSByZXR1cm47XG5cbiAgLy8gZmlyZSBhIHRpbWVjaGFuZ2VkIGV2ZW50XG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3RpbWVjaGFuZ2VkJywge1xuICAgIGlkOiB0aGlzLm9wdGlvbnMuaWQsXG4gICAgdGltZTogbmV3IERhdGUodGhpcy5jdXN0b21UaW1lLnZhbHVlT2YoKSlcbiAgfSk7XG5cbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59O1xuXG4vKipcbiAqIEZpbmQgYSBjdXN0b20gdGltZSBmcm9tIGFuIGV2ZW50IHRhcmdldDpcbiAqIHNlYXJjaGVzIGZvciB0aGUgYXR0cmlidXRlICdjdXN0b20tdGltZScgaW4gdGhlIGV2ZW50IHRhcmdldCdzIGVsZW1lbnQgdHJlZVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge0N1c3RvbVRpbWUgfCBudWxsfSBjdXN0b21UaW1lXG4gKi9cbkN1c3RvbVRpbWUuY3VzdG9tVGltZUZyb21UYXJnZXQgPSBmdW5jdGlvbihldmVudCkge1xuICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICB3aGlsZSAodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eSgnY3VzdG9tLXRpbWUnKSkge1xuICAgICAgcmV0dXJuIHRhcmdldFsnY3VzdG9tLXRpbWUnXTtcbiAgICB9XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3VzdG9tVGltZTtcbiJdfQ==
},{"../../module/hammer":19,"../../module/moment":20,"../../util":46,"../locales":44,"./Component":33}],36:[function(require,module,exports){
'use strict';

var util = require('../../util');
var stack = require('../Stack');
var RangeItem = require('./item/RangeItem');

/**
 * @constructor Group
 * @param {Number | String} groupId
 * @param {Object} data
 * @param {ItemSet} itemSet
 */
function Group(groupId, data, itemSet) {
  this.groupId = groupId;
  this.subgroups = {};
  this.subgroupIndex = 0;
  this.subgroupOrderer = data && data.subgroupOrder;
  this.itemSet = itemSet;

  this.dom = {};
  this.props = {
    label: {
      width: 0,
      height: 0
    }
  };
  this.className = null;

  this.items = {}; // items filtered by groupId of this group
  this.visibleItems = []; // items currently visible in window
  this.orderedItems = {
    byStart: [],
    byEnd: []
  };
  this.checkRangedItems = false; // needed to refresh the ranged items if the window is programatically changed with NO overlap.
  var me = this;
  this.itemSet.body.emitter.on("checkRangedItems", function () {
    me.checkRangedItems = true;
  });

  this._create();

  this.setData(data);
}

/**
 * Create DOM elements for the group
 * @private
 */
Group.prototype._create = function () {
  var label = document.createElement('div');
  if (this.itemSet.options.groupEditable.order) {
    label.className = 'vis-label draggable';
  } else {
    label.className = 'vis-label';
  }
  this.dom.label = label;

  var inner = document.createElement('div');
  inner.className = 'vis-inner';
  label.appendChild(inner);
  this.dom.inner = inner;

  var foreground = document.createElement('div');
  foreground.className = 'vis-group';
  foreground['timeline-group'] = this;
  this.dom.foreground = foreground;

  this.dom.background = document.createElement('div');
  this.dom.background.className = 'vis-group';

  this.dom.axis = document.createElement('div');
  this.dom.axis.className = 'vis-group';

  // create a hidden marker to detect when the Timelines container is attached
  // to the DOM, or the style of a parent of the Timeline is changed from
  // display:none is changed to visible.
  this.dom.marker = document.createElement('div');
  this.dom.marker.style.visibility = 'hidden';
  this.dom.marker.innerHTML = '?';
  this.dom.background.appendChild(this.dom.marker);
};

/**
 * Set the group data for this group
 * @param {Object} data   Group data, can contain properties content and className
 */
Group.prototype.setData = function (data) {
  // update contents
  var content;
  if (this.itemSet.options && this.itemSet.options.groupTemplate) {
    content = this.itemSet.options.groupTemplate(data);
  } else {
    content = data && data.content;
  }

  if (content instanceof Element) {
    this.dom.inner.appendChild(content);
    while (this.dom.inner.firstChild) {
      this.dom.inner.removeChild(this.dom.inner.firstChild);
    }
    this.dom.inner.appendChild(content);
  } else if (content !== undefined && content !== null) {
    this.dom.inner.innerHTML = content;
  } else {
    this.dom.inner.innerHTML = this.groupId || ''; // groupId can be null
  }

  // update title
  this.dom.label.title = data && data.title || '';

  if (!this.dom.inner.firstChild) {
    util.addClassName(this.dom.inner, 'vis-hidden');
  } else {
    util.removeClassName(this.dom.inner, 'vis-hidden');
  }

  // update className
  var className = data && data.className || null;
  if (className != this.className) {
    if (this.className) {
      util.removeClassName(this.dom.label, this.className);
      util.removeClassName(this.dom.foreground, this.className);
      util.removeClassName(this.dom.background, this.className);
      util.removeClassName(this.dom.axis, this.className);
    }
    util.addClassName(this.dom.label, className);
    util.addClassName(this.dom.foreground, className);
    util.addClassName(this.dom.background, className);
    util.addClassName(this.dom.axis, className);
    this.className = className;
  }

  // update style
  if (this.style) {
    util.removeCssText(this.dom.label, this.style);
    this.style = null;
  }
  if (data && data.style) {
    util.addCssText(this.dom.label, data.style);
    this.style = data.style;
  }
};

/**
 * Get the width of the group label
 * @return {number} width
 */
Group.prototype.getLabelWidth = function () {
  return this.props.label.width;
};

/**
 * Repaint this group
 * @param {{start: number, end: number}} range
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 * @param {boolean} [restack=false]  Force restacking of all items
 * @return {boolean} Returns true if the group is resized
 */
Group.prototype.redraw = function (range, margin, restack) {
  var resized = false;

  // force recalculation of the height of the items when the marker height changed
  // (due to the Timeline being attached to the DOM or changed from display:none to visible)
  var markerHeight = this.dom.marker.clientHeight;
  if (markerHeight != this.lastMarkerHeight) {
    this.lastMarkerHeight = markerHeight;

    util.forEach(this.items, function (item) {
      item.dirty = true;
      if (item.displayed) item.redraw();
    });

    restack = true;
  }

  // reposition visible items vertically
  if (typeof this.itemSet.options.order === 'function') {
    // a custom order function

    if (restack) {
      // brute force restack of all items

      // show all items
      var me = this;
      var limitSize = false;
      util.forEach(this.items, function (item) {
        if (!item.displayed) {
          item.redraw();
          me.visibleItems.push(item);
        }
        item.repositionX(limitSize);
      });

      // order all items and force a restacking
      var customOrderedItems = this.orderedItems.byStart.slice().sort(function (a, b) {
        return me.itemSet.options.order(a.data, b.data);
      });
      stack.stack(customOrderedItems, margin, true /* restack=true */);
    }

    this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);
  } else {
    // no custom order function, lazy stacking
    this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);

    if (this.itemSet.options.stack) {
      // TODO: ugly way to access options...
      stack.stack(this.visibleItems, margin, restack);
    } else {
      // no stacking
      stack.nostack(this.visibleItems, margin, this.subgroups);
    }
  }

  // recalculate the height of the group
  var height = this._calculateHeight(margin);

  // calculate actual size and position
  var foreground = this.dom.foreground;
  this.top = foreground.offsetTop;
  this.left = foreground.offsetLeft;
  this.width = foreground.offsetWidth;
  resized = util.updateProperty(this, 'height', height) || resized;

  // recalculate size of label
  resized = util.updateProperty(this.props.label, 'width', this.dom.inner.clientWidth) || resized;
  resized = util.updateProperty(this.props.label, 'height', this.dom.inner.clientHeight) || resized;

  // apply new height
  this.dom.background.style.height = height + 'px';
  this.dom.foreground.style.height = height + 'px';
  this.dom.label.style.height = height + 'px';

  // update vertical position of items after they are re-stacked and the height of the group is calculated
  for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
    var item = this.visibleItems[i];
    item.repositionY(margin);
  }

  return resized;
};

/**
 * recalculate the height of the group
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 * @returns {number} Returns the height
 * @private
 */
Group.prototype._calculateHeight = function (margin) {
  // recalculate the height of the group
  var height;
  var visibleItems = this.visibleItems;
  //var visibleSubgroups = [];
  //this.visibleSubgroups = 0;
  this.resetSubgroups();
  var me = this;
  if (visibleItems.length > 0) {
    var min = visibleItems[0].top;
    var max = visibleItems[0].top + visibleItems[0].height;
    util.forEach(visibleItems, function (item) {
      min = Math.min(min, item.top);
      max = Math.max(max, item.top + item.height);
      if (item.data.subgroup !== undefined) {
        me.subgroups[item.data.subgroup].height = Math.max(me.subgroups[item.data.subgroup].height, item.height);
        me.subgroups[item.data.subgroup].visible = true;
      }
    });
    if (min > margin.axis) {
      // there is an empty gap between the lowest item and the axis
      var offset = min - margin.axis;
      max -= offset;
      util.forEach(visibleItems, function (item) {
        item.top -= offset;
      });
    }
    height = max + margin.item.vertical / 2;
  } else {
    height = 0;
  }
  height = Math.max(height, this.props.label.height);

  return height;
};

/**
 * Show this group: attach to the DOM
 */
Group.prototype.show = function () {
  if (!this.dom.label.parentNode) {
    this.itemSet.dom.labelSet.appendChild(this.dom.label);
  }

  if (!this.dom.foreground.parentNode) {
    this.itemSet.dom.foreground.appendChild(this.dom.foreground);
  }

  if (!this.dom.background.parentNode) {
    this.itemSet.dom.background.appendChild(this.dom.background);
  }

  if (!this.dom.axis.parentNode) {
    this.itemSet.dom.axis.appendChild(this.dom.axis);
  }
};

/**
 * Hide this group: remove from the DOM
 */
Group.prototype.hide = function () {
  var label = this.dom.label;
  if (label.parentNode) {
    label.parentNode.removeChild(label);
  }

  var foreground = this.dom.foreground;
  if (foreground.parentNode) {
    foreground.parentNode.removeChild(foreground);
  }

  var background = this.dom.background;
  if (background.parentNode) {
    background.parentNode.removeChild(background);
  }

  var axis = this.dom.axis;
  if (axis.parentNode) {
    axis.parentNode.removeChild(axis);
  }
};

/**
 * Add an item to the group
 * @param {Item} item
 */
Group.prototype.add = function (item) {
  this.items[item.id] = item;
  item.setParent(this);

  // add to
  if (item.data.subgroup !== undefined) {
    if (this.subgroups[item.data.subgroup] === undefined) {
      this.subgroups[item.data.subgroup] = { height: 0, visible: false, index: this.subgroupIndex, items: [] };
      this.subgroupIndex++;
    }
    this.subgroups[item.data.subgroup].items.push(item);
  }
  this.orderSubgroups();

  if (this.visibleItems.indexOf(item) == -1) {
    var range = this.itemSet.body.range; // TODO: not nice accessing the range like this
    this._checkIfVisible(item, this.visibleItems, range);
  }
};

Group.prototype.orderSubgroups = function () {
  if (this.subgroupOrderer !== undefined) {
    var sortArray = [];
    if (typeof this.subgroupOrderer == 'string') {
      for (var subgroup in this.subgroups) {
        sortArray.push({ subgroup: subgroup, sortField: this.subgroups[subgroup].items[0].data[this.subgroupOrderer] });
      }
      sortArray.sort(function (a, b) {
        return a.sortField - b.sortField;
      });
    } else if (typeof this.subgroupOrderer == 'function') {
      for (var subgroup in this.subgroups) {
        sortArray.push(this.subgroups[subgroup].items[0].data);
      }
      sortArray.sort(this.subgroupOrderer);
    }

    if (sortArray.length > 0) {
      for (var i = 0; i < sortArray.length; i++) {
        this.subgroups[sortArray[i].subgroup].index = i;
      }
    }
  }
};

Group.prototype.resetSubgroups = function () {
  for (var subgroup in this.subgroups) {
    if (this.subgroups.hasOwnProperty(subgroup)) {
      this.subgroups[subgroup].visible = false;
    }
  }
};

/**
 * Remove an item from the group
 * @param {Item} item
 */
Group.prototype.remove = function (item) {
  delete this.items[item.id];
  item.setParent(null);

  // remove from visible items
  var index = this.visibleItems.indexOf(item);
  if (index != -1) this.visibleItems.splice(index, 1);

  if (item.data.subgroup !== undefined) {
    var subgroup = this.subgroups[item.data.subgroup];
    if (subgroup) {
      var itemIndex = subgroup.items.indexOf(item);
      subgroup.items.splice(itemIndex, 1);
      if (!subgroup.items.length) {
        delete this.subgroups[item.data.subgroup];
        this.subgroupIndex--;
      }
      this.orderSubgroups();
    }
  }
};

/**
 * Remove an item from the corresponding DataSet
 * @param {Item} item
 */
Group.prototype.removeFromDataSet = function (item) {
  this.itemSet.removeItem(item.id);
};

/**
 * Reorder the items
 */
Group.prototype.order = function () {
  var array = util.toArray(this.items);
  var startArray = [];
  var endArray = [];

  for (var i = 0; i < array.length; i++) {
    if (array[i].data.end !== undefined) {
      endArray.push(array[i]);
    }
    startArray.push(array[i]);
  }
  this.orderedItems = {
    byStart: startArray,
    byEnd: endArray
  };

  stack.orderByStart(this.orderedItems.byStart);
  stack.orderByEnd(this.orderedItems.byEnd);
};

/**
 * Update the visible items
 * @param {{byStart: Item[], byEnd: Item[]}} orderedItems   All items ordered by start date and by end date
 * @param {Item[]} visibleItems                             The previously visible items.
 * @param {{start: number, end: number}} range              Visible range
 * @return {Item[]} visibleItems                            The new visible items.
 * @private
 */
Group.prototype._updateVisibleItems = function (orderedItems, oldVisibleItems, range) {
  var visibleItems = [];
  var visibleItemsLookup = {}; // we keep this to quickly look up if an item already exists in the list without using indexOf on visibleItems
  var interval = (range.end - range.start) / 4;
  var lowerBound = range.start - interval;
  var upperBound = range.end + interval;
  var item, i;

  // this function is used to do the binary search.
  var searchFunction = function searchFunction(value) {
    if (value < lowerBound) {
      return -1;
    } else if (value <= upperBound) {
      return 0;
    } else {
      return 1;
    }
  };

  // first check if the items that were in view previously are still in view.
  // IMPORTANT: this handles the case for the items with startdate before the window and enddate after the window!
  // also cleans up invisible items.
  if (oldVisibleItems.length > 0) {
    for (i = 0; i < oldVisibleItems.length; i++) {
      this._checkIfVisibleWithReference(oldVisibleItems[i], visibleItems, visibleItemsLookup, range);
    }
  }

  // we do a binary search for the items that have only start values.
  var initialPosByStart = util.binarySearchCustom(orderedItems.byStart, searchFunction, 'data', 'start');

  // trace the visible items from the inital start pos both ways until an invisible item is found, we only look at the start values.
  this._traceVisible(initialPosByStart, orderedItems.byStart, visibleItems, visibleItemsLookup, function (item) {
    return item.data.start < lowerBound || item.data.start > upperBound;
  });

  // if the window has changed programmatically without overlapping the old window, the ranged items with start < lowerBound and end > upperbound are not shown.
  // We therefore have to brute force check all items in the byEnd list
  if (this.checkRangedItems == true) {
    this.checkRangedItems = false;
    for (i = 0; i < orderedItems.byEnd.length; i++) {
      this._checkIfVisibleWithReference(orderedItems.byEnd[i], visibleItems, visibleItemsLookup, range);
    }
  } else {
    // we do a binary search for the items that have defined end times.
    var initialPosByEnd = util.binarySearchCustom(orderedItems.byEnd, searchFunction, 'data', 'end');

    // trace the visible items from the inital start pos both ways until an invisible item is found, we only look at the end values.
    this._traceVisible(initialPosByEnd, orderedItems.byEnd, visibleItems, visibleItemsLookup, function (item) {
      return item.data.end < lowerBound || item.data.end > upperBound;
    });
  }

  // finally, we reposition all the visible items.
  for (i = 0; i < visibleItems.length; i++) {
    item = visibleItems[i];
    if (!item.displayed) item.show();
    // reposition item horizontally
    item.repositionX();
  }

  // debug
  //console.log("new line")
  //if (this.groupId == null) {
  //  for (i = 0; i < orderedItems.byStart.length; i++) {
  //    item = orderedItems.byStart[i].data;
  //    console.log('start',i,initialPosByStart, item.start.valueOf(), item.content, item.start >= lowerBound && item.start <= upperBound,i == initialPosByStart ? "<------------------- HEREEEE" : "")
  //  }
  //  for (i = 0; i < orderedItems.byEnd.length; i++) {
  //    item = orderedItems.byEnd[i].data;
  //    console.log('rangeEnd',i,initialPosByEnd, item.end.valueOf(), item.content, item.end >= range.start && item.end <= range.end,i == initialPosByEnd ? "<------------------- HEREEEE" : "")
  //  }
  //}

  return visibleItems;
};

Group.prototype._traceVisible = function (initialPos, items, visibleItems, visibleItemsLookup, breakCondition) {
  var item;
  var i;

  if (initialPos != -1) {
    for (i = initialPos; i >= 0; i--) {
      item = items[i];
      if (breakCondition(item)) {
        break;
      } else {
        if (visibleItemsLookup[item.id] === undefined) {
          visibleItemsLookup[item.id] = true;
          visibleItems.push(item);
        }
      }
    }

    for (i = initialPos + 1; i < items.length; i++) {
      item = items[i];
      if (breakCondition(item)) {
        break;
      } else {
        if (visibleItemsLookup[item.id] === undefined) {
          visibleItemsLookup[item.id] = true;
          visibleItems.push(item);
        }
      }
    }
  }
};

/**
 * this function is very similar to the _checkIfInvisible() but it does not
 * return booleans, hides the item if it should not be seen and always adds to
 * the visibleItems.
 * this one is for brute forcing and hiding.
 *
 * @param {Item} item
 * @param {Array} visibleItems
 * @param {{start:number, end:number}} range
 * @private
 */
Group.prototype._checkIfVisible = function (item, visibleItems, range) {
  if (item.isVisible(range)) {
    if (!item.displayed) item.show();
    // reposition item horizontally
    item.repositionX();
    visibleItems.push(item);
  } else {
    if (item.displayed) item.hide();
  }
};

/**
 * this function is very similar to the _checkIfInvisible() but it does not
 * return booleans, hides the item if it should not be seen and always adds to
 * the visibleItems.
 * this one is for brute forcing and hiding.
 *
 * @param {Item} item
 * @param {Array} visibleItems
 * @param {{start:number, end:number}} range
 * @private
 */
Group.prototype._checkIfVisibleWithReference = function (item, visibleItems, visibleItemsLookup, range) {
  if (item.isVisible(range)) {
    if (visibleItemsLookup[item.id] === undefined) {
      visibleItemsLookup[item.id] = true;
      visibleItems.push(item);
    }
  } else {
    if (item.displayed) item.hide();
  }
};

module.exports = Group;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L0dyb3VwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ2pDLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNoQyxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQzs7Ozs7Ozs7QUFRNUMsU0FBUyxLQUFLLENBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUU7QUFDdEMsTUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7QUFDdkIsTUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7QUFDcEIsTUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUM7QUFDdkIsTUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQztBQUNsRCxNQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQzs7QUFFdkIsTUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFDZCxNQUFJLENBQUMsS0FBSyxHQUFHO0FBQ1gsU0FBSyxFQUFFO0FBQ0wsV0FBSyxFQUFFLENBQUM7QUFDUixZQUFNLEVBQUUsQ0FBQztLQUNWO0dBQ0YsQ0FBQztBQUNGLE1BQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDOztBQUV0QixNQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNoQixNQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQztBQUN2QixNQUFJLENBQUMsWUFBWSxHQUFHO0FBQ2xCLFdBQU8sRUFBRSxFQUFFO0FBQ1gsU0FBSyxFQUFFLEVBQUU7R0FDVixDQUFDO0FBQ0YsTUFBSSxDQUFDLGdCQUFnQixHQUFHLEtBQUss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SUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ3JELFVBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzFELFVBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzFELFVBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQ3JEO0FBQ0QsUUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQztBQUM3QyxRQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ2xELFFBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDbEQsUUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztBQUM1QyxRQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztHQUM1Qjs7O0FBR0QsTUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO0FBQ2QsUUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDL0MsUUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7R0FDbkI7QUFDRCxNQUFJLElBQUksSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO0FBQ3RCLFFBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxD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QUFJLEVBQUUsQ0FBQztHQUNqQztDQUNGLENBQUM7O0FBSUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMiLCJmaWxlIjoiL1VzZXJzL2RhcmluL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzLXZpZXdlci9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvR3JvdXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbnZhciBzdGFjayA9IHJlcXVpcmUoJy4uL1N0YWNrJyk7XG52YXIgUmFuZ2VJdGVtID0gcmVxdWlyZSgnLi9pdGVtL1JhbmdlSXRlbScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBHcm91cFxuICogQHBhcmFtIHtOdW1iZXIgfCBTdHJpbmd9IGdyb3VwSWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0l0ZW1TZXR9IGl0ZW1TZXRcbiAqL1xuZnVuY3Rpb24gR3JvdXAgKGdyb3VwSWQsIGRhdGEsIGl0ZW1TZXQpIHtcbiAgdGhpcy5ncm91cElkID0gZ3JvdXBJZDtcbiAgdGhpcy5zdWJncm91cHMgPSB7fTtcbiAgdGhpcy5zdWJncm91cEluZGV4ID0gMDtcbiAgdGhpcy5zdWJncm91cE9yZGVyZXIgPSBkYXRhICYmIGRhdGEuc3ViZ3JvdXBPcmRlcjtcbiAgdGhpcy5pdGVtU2V0ID0gaXRlbVNldDtcblxuICB0aGlzLmRvbSA9IHt9O1xuICB0aGlzLnByb3BzID0ge1xuICAgIGxhYmVsOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH1cbiAgfTtcbiAgdGhpcy5jbGFzc05hbWUgPSBudWxsO1xuXG4gIHRoaXMuaXRlbXMgPSB7fTsgICAgICAgIC8vIGl0ZW1zIGZpbHRlcmVkIGJ5IGdyb3VwSWQgb2YgdGhpcyBncm91cFxuICB0aGlzLnZpc2libGVJdGVtcyA9IFtdOyAvLyBpdGVtcyBjdXJyZW50bHkgdmlzaWJsZSBpbiB3aW5kb3dcbiAgdGhpcy5vcmRlcmVkSXRlbXMgPSB7XG4gICAgYnlTdGFydDogW10sXG4gICAgYnlFbmQ6IFtdXG4gIH07XG4gIHRoaXMuY2hlY2tSYW5nZWRJdGVtcyA9IGZhbHNlOyAvLyBuZWVkZWQgdG8gcmVmcmVzaCB0aGUgcmFuZ2VkIGl0ZW1zIGlmIHRoZSB3aW5kb3cgaXMgcHJvZ3JhbWF0aWNhbGx5IGNoYW5nZWQgd2l0aCBOTyBvdmVybGFwLlxuICB2YXIgbWUgPSB0aGlzO1xuICB0aGlzLml0ZW1TZXQuYm9keS5lbWl0dGVyLm9uKFwiY2hlY2tSYW5nZWRJdGVtc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgbWUuY2hlY2tSYW5nZWRJdGVtcyA9IHRydWU7XG4gIH0pXG5cbiAgdGhpcy5fY3JlYXRlKCk7XG5cbiAgdGhpcy5zZXREYXRhKGRhdGEpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBET00gZWxlbWVudHMgZm9yIHRoZSBncm91cFxuICogQHByaXZhdGVcbiAqL1xuR3JvdXAucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGlmICh0aGlzLml0ZW1TZXQub3B0aW9ucy5ncm91cEVkaXRhYmxlLm9yZGVyKSB7XG5cdCAgbGFiZWwuY2xhc3NOYW1lID0gJ3Zpcy1sYWJlbCBkcmFnZ2FibGUnO1xuICB9IGVsc2Uge1xuXHQgIGxhYmVsLmNsYXNzTmFtZSA9ICd2aXMtbGFiZWwnO1xuICB9XG4gIHRoaXMuZG9tLmxhYmVsID0gbGFiZWw7XG5cbiAgdmFyIGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGlubmVyLmNsYXNzTmFtZSA9ICd2aXMtaW5uZXInO1xuICBsYWJlbC5hcHBlbmRDaGlsZChpbm5lcik7XG4gIHRoaXMuZG9tLmlubmVyID0gaW5uZXI7XG5cbiAgdmFyIGZvcmVncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZm9yZWdyb3VuZC5jbGFzc05hbWUgPSAndmlzLWdyb3VwJztcbiAgZm9yZWdyb3VuZFsndGltZWxpbmUtZ3JvdXAnXSA9IHRoaXM7XG4gIHRoaXMuZG9tLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kO1xuXG4gIHRoaXMuZG9tLmJhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20uYmFja2dyb3VuZC5jbGFzc05hbWUgPSAndmlzLWdyb3VwJztcblxuICB0aGlzLmRvbS5heGlzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmF4aXMuY2xhc3NOYW1lID0gJ3Zpcy1ncm91cCc7XG5cbiAgLy8gY3JlYXRlIGEgaGlkZGVuIG1hcmtlciB0byBkZXRlY3Qgd2hlbiB0aGUgVGltZWxpbmVzIGNvbnRhaW5lciBpcyBhdHRhY2hlZFxuICAvLyB0byB0aGUgRE9NLCBvciB0aGUgc3R5bGUgb2YgYSBwYXJlbnQgb2YgdGhlIFRpbWVsaW5lIGlzIGNoYW5nZWQgZnJvbVxuICAvLyBkaXNwbGF5Om5vbmUgaXMgY2hhbmdlZCB0byB2aXNpYmxlLlxuICB0aGlzLmRvbS5tYXJrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20ubWFya2VyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgdGhpcy5kb20ubWFya2VyLmlubmVySFRNTCA9ICc/JztcbiAgdGhpcy5kb20uYmFja2dyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5tYXJrZXIpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGdyb3VwIGRhdGEgZm9yIHRoaXMgZ3JvdXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgR3JvdXAgZGF0YSwgY2FuIGNvbnRhaW4gcHJvcGVydGllcyBjb250ZW50IGFuZCBjbGFzc05hbWVcbiAqL1xuR3JvdXAucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gIC8vIHVwZGF0ZSBjb250ZW50c1xuICB2YXIgY29udGVudDtcbiAgaWYgKHRoaXMuaXRlbVNldC5vcHRpb25zICYmIHRoaXMuaXRlbVNldC5vcHRpb25zLmdyb3VwVGVtcGxhdGUpIHtcbiAgICBjb250ZW50ID0gdGhpcy5pdGVtU2V0Lm9wdGlvbnMuZ3JvdXBUZW1wbGF0ZShkYXRhKTtcbiAgfVxuICBlbHNlIHtcbiAgICBjb250ZW50ID0gZGF0YSAmJiBkYXRhLmNvbnRlbnQ7XG4gIH1cblxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICB0aGlzLmRvbS5pbm5lci5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICB3aGlsZSAodGhpcy5kb20uaW5uZXIuZmlyc3RDaGlsZCkge1xuICAgICAgdGhpcy5kb20uaW5uZXIucmVtb3ZlQ2hpbGQodGhpcy5kb20uaW5uZXIuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHRoaXMuZG9tLmlubmVyLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICB9XG4gIGVsc2UgaWYgKGNvbnRlbnQgIT09IHVuZGVmaW5lZCAmJiBjb250ZW50ICE9PSBudWxsKSB7XG4gICAgdGhpcy5kb20uaW5uZXIuaW5uZXJIVE1MID0gY29udGVudDtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmRvbS5pbm5lci5pbm5lckhUTUwgPSB0aGlzLmdyb3VwSWQgfHwgJyc7IC8vIGdyb3VwSWQgY2FuIGJlIG51bGxcbiAgfVxuXG4gIC8vIHVwZGF0ZSB0aXRsZVxuICB0aGlzLmRvbS5sYWJlbC50aXRsZSA9IGRhdGEgJiYgZGF0YS50aXRsZSB8fCAnJztcblxuICBpZiAoIXRoaXMuZG9tLmlubmVyLmZpcnN0Q2hpbGQpIHtcbiAgICB1dGlsLmFkZENsYXNzTmFtZSh0aGlzLmRvbS5pbm5lciwgJ3Zpcy1oaWRkZW4nKTtcbiAgfVxuICBlbHNlIHtcbiAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5pbm5lciwgJ3Zpcy1oaWRkZW4nKTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBjbGFzc05hbWVcbiAgdmFyIGNsYXNzTmFtZSA9IGRhdGEgJiYgZGF0YS5jbGFzc05hbWUgfHwgbnVsbDtcbiAgaWYgKGNsYXNzTmFtZSAhPSB0aGlzLmNsYXNzTmFtZSkge1xuICAgIGlmICh0aGlzLmNsYXNzTmFtZSkge1xuICAgICAgdXRpbC5yZW1vdmVDbGFzc05hbWUodGhpcy5kb20ubGFiZWwsIHRoaXMuY2xhc3NOYW1lKTtcbiAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKHRoaXMuZG9tLmZvcmVncm91bmQsIHRoaXMuY2xhc3NOYW1lKTtcbiAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKHRoaXMuZG9tLmJhY2tncm91bmQsIHRoaXMuY2xhc3NOYW1lKTtcbiAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKHRoaXMuZG9tLmF4aXMsIHRoaXMuY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgdXRpbC5hZGRDbGFzc05hbWUodGhpcy5kb20ubGFiZWwsIGNsYXNzTmFtZSk7XG4gICAgdXRpbC5hZGRDbGFzc05hbWUodGhpcy5kb20uZm9yZWdyb3VuZCwgY2xhc3NOYW1lKTtcbiAgICB1dGlsLmFkZENsYXNzTmFtZSh0aGlzLmRvbS5iYWNrZ3JvdW5kLCBjbGFzc05hbWUpO1xuICAgIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmF4aXMsIGNsYXNzTmFtZSk7XG4gICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gIH1cblxuICAvLyB1cGRhdGUgc3R5bGVcbiAgaWYgKHRoaXMuc3R5bGUpIHtcbiAgICB1dGlsLnJlbW92ZUNzc1RleHQodGhpcy5kb20ubGFiZWwsIHRoaXMuc3R5bGUpO1xuICAgIHRoaXMuc3R5bGUgPSBudWxsO1xuICB9XG4gIGlmIChkYXRhICYmIGRhdGEuc3R5bGUpIHtcbiAgICB1dGlsLmFkZENzc1RleHQodGhpcy5kb20ubGFiZWwsIGRhdGEuc3R5bGUpO1xuICAgIHRoaXMuc3R5bGUgPSBkYXRhLnN0eWxlO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgd2lkdGggb2YgdGhlIGdyb3VwIGxhYmVsXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHdpZHRoXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5nZXRMYWJlbFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnByb3BzLmxhYmVsLndpZHRoO1xufTtcblxuXG4vKipcbiAqIFJlcGFpbnQgdGhpcyBncm91cFxuICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZVxuICogQHBhcmFtIHt7aXRlbToge2hvcml6b250YWw6IG51bWJlciwgdmVydGljYWw6IG51bWJlcn0sIGF4aXM6IG51bWJlcn19IG1hcmdpblxuICogQHBhcmFtIHtib29sZWFufSBbcmVzdGFjaz1mYWxzZV0gIEZvcmNlIHJlc3RhY2tpbmcgb2YgYWxsIGl0ZW1zXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGdyb3VwIGlzIHJlc2l6ZWRcbiAqL1xuR3JvdXAucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKHJhbmdlLCBtYXJnaW4sIHJlc3RhY2spIHtcbiAgdmFyIHJlc2l6ZWQgPSBmYWxzZTtcblxuICAvLyBmb3JjZSByZWNhbGN1bGF0aW9uIG9mIHRoZSBoZWlnaHQgb2YgdGhlIGl0ZW1zIHdoZW4gdGhlIG1hcmtlciBoZWlnaHQgY2hhbmdlZFxuICAvLyAoZHVlIHRvIHRoZSBUaW1lbGluZSBiZWluZyBhdHRhY2hlZCB0byB0aGUgRE9NIG9yIGNoYW5nZWQgZnJvbSBkaXNwbGF5Om5vbmUgdG8gdmlzaWJsZSlcbiAgdmFyIG1hcmtlckhlaWdodCA9IHRoaXMuZG9tLm1hcmtlci5jbGllbnRIZWlnaHQ7XG4gIGlmIChtYXJrZXJIZWlnaHQgIT0gdGhpcy5sYXN0TWFya2VySGVpZ2h0KSB7XG4gICAgdGhpcy5sYXN0TWFya2VySGVpZ2h0ID0gbWFya2VySGVpZ2h0O1xuXG4gICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpdGVtLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIGlmIChpdGVtLmRpc3BsYXllZCkgaXRlbS5yZWRyYXcoKTtcbiAgICB9KTtcblxuICAgIHJlc3RhY2sgPSB0cnVlO1xuICB9XG5cbiAgLy8gcmVwb3NpdGlvbiB2aXNpYmxlIGl0ZW1zIHZlcnRpY2FsbHlcbiAgaWYgKHR5cGVvZiB0aGlzLml0ZW1TZXQub3B0aW9ucy5vcmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGEgY3VzdG9tIG9yZGVyIGZ1bmN0aW9uXG5cbiAgICBpZiAocmVzdGFjaykge1xuICAgICAgLy8gYnJ1dGUgZm9yY2UgcmVzdGFjayBvZiBhbGwgaXRlbXNcblxuICAgICAgLy8gc2hvdyBhbGwgaXRlbXNcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgbGltaXRTaXplID0gZmFsc2U7XG4gICAgICB1dGlsLmZvckVhY2godGhpcy5pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFpdGVtLmRpc3BsYXllZCkge1xuICAgICAgICAgIGl0ZW0ucmVkcmF3KCk7XG4gICAgICAgICAgbWUudmlzaWJsZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS5yZXBvc2l0aW9uWChsaW1pdFNpemUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIG9yZGVyIGFsbCBpdGVtcyBhbmQgZm9yY2UgYSByZXN0YWNraW5nXG4gICAgICB2YXIgY3VzdG9tT3JkZXJlZEl0ZW1zID0gdGhpcy5vcmRlcmVkSXRlbXMuYnlTdGFydC5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG1lLml0ZW1TZXQub3B0aW9ucy5vcmRlcihhLmRhdGEsIGIuZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIHN0YWNrLnN0YWNrKGN1c3RvbU9yZGVyZWRJdGVtcywgbWFyZ2luLCB0cnVlIC8qIHJlc3RhY2s9dHJ1ZSAqLyk7XG4gICAgfVxuXG4gICAgdGhpcy52aXNpYmxlSXRlbXMgPSB0aGlzLl91cGRhdGVWaXNpYmxlSXRlbXModGhpcy5vcmRlcmVkSXRlbXMsIHRoaXMudmlzaWJsZUl0ZW1zLCByYW5nZSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gbm8gY3VzdG9tIG9yZGVyIGZ1bmN0aW9uLCBsYXp5IHN0YWNraW5nXG4gICAgdGhpcy52aXNpYmxlSXRlbXMgPSB0aGlzLl91cGRhdGVWaXNpYmxlSXRlbXModGhpcy5vcmRlcmVkSXRlbXMsIHRoaXMudmlzaWJsZUl0ZW1zLCByYW5nZSk7XG5cbiAgICBpZiAodGhpcy5pdGVtU2V0Lm9wdGlvbnMuc3RhY2spIHsgLy8gVE9ETzogdWdseSB3YXkgdG8gYWNjZXNzIG9wdGlvbnMuLi5cbiAgICAgIHN0YWNrLnN0YWNrKHRoaXMudmlzaWJsZUl0ZW1zLCBtYXJnaW4sIHJlc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gbm8gc3RhY2tpbmdcbiAgICAgIHN0YWNrLm5vc3RhY2sodGhpcy52aXNpYmxlSXRlbXMsIG1hcmdpbiwgdGhpcy5zdWJncm91cHMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlY2FsY3VsYXRlIHRoZSBoZWlnaHQgb2YgdGhlIGdyb3VwXG4gIHZhciBoZWlnaHQgPSB0aGlzLl9jYWxjdWxhdGVIZWlnaHQobWFyZ2luKTtcblxuICAvLyBjYWxjdWxhdGUgYWN0dWFsIHNpemUgYW5kIHBvc2l0aW9uXG4gIHZhciBmb3JlZ3JvdW5kID0gdGhpcy5kb20uZm9yZWdyb3VuZDtcbiAgdGhpcy50b3AgPSBmb3JlZ3JvdW5kLm9mZnNldFRvcDtcbiAgdGhpcy5sZWZ0ID0gZm9yZWdyb3VuZC5vZmZzZXRMZWZ0O1xuICB0aGlzLndpZHRoID0gZm9yZWdyb3VuZC5vZmZzZXRXaWR0aDtcbiAgcmVzaXplZCA9IHV0aWwudXBkYXRlUHJvcGVydHkodGhpcywgJ2hlaWdodCcsIGhlaWdodCkgfHwgcmVzaXplZDtcblxuICAvLyByZWNhbGN1bGF0ZSBzaXplIG9mIGxhYmVsXG4gIHJlc2l6ZWQgPSB1dGlsLnVwZGF0ZVByb3BlcnR5KHRoaXMucHJvcHMubGFiZWwsICd3aWR0aCcsIHRoaXMuZG9tLmlubmVyLmNsaWVudFdpZHRoKSB8fCByZXNpemVkO1xuICByZXNpemVkID0gdXRpbC51cGRhdGVQcm9wZXJ0eSh0aGlzLnByb3BzLmxhYmVsLCAnaGVpZ2h0JywgdGhpcy5kb20uaW5uZXIuY2xpZW50SGVpZ2h0KSB8fCByZXNpemVkO1xuXG4gIC8vIGFwcGx5IG5ldyBoZWlnaHRcbiAgdGhpcy5kb20uYmFja2dyb3VuZC5zdHlsZS5oZWlnaHQgID0gaGVpZ2h0ICsgJ3B4JztcbiAgdGhpcy5kb20uZm9yZWdyb3VuZC5zdHlsZS5oZWlnaHQgID0gaGVpZ2h0ICsgJ3B4JztcbiAgdGhpcy5kb20ubGFiZWwuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAvLyB1cGRhdGUgdmVydGljYWwgcG9zaXRpb24gb2YgaXRlbXMgYWZ0ZXIgdGhleSBhcmUgcmUtc3RhY2tlZCBhbmQgdGhlIGhlaWdodCBvZiB0aGUgZ3JvdXAgaXMgY2FsY3VsYXRlZFxuICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLnZpc2libGVJdGVtcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLnZpc2libGVJdGVtc1tpXTtcbiAgICBpdGVtLnJlcG9zaXRpb25ZKG1hcmdpbik7XG4gIH1cblxuICByZXR1cm4gcmVzaXplZDtcbn07XG5cbi8qKlxuICogcmVjYWxjdWxhdGUgdGhlIGhlaWdodCBvZiB0aGUgZ3JvdXBcbiAqIEBwYXJhbSB7e2l0ZW06IHtob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9LCBheGlzOiBudW1iZXJ9fSBtYXJnaW5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGhlaWdodFxuICogQHByaXZhdGVcbiAqL1xuR3JvdXAucHJvdG90eXBlLl9jYWxjdWxhdGVIZWlnaHQgPSBmdW5jdGlvbiAobWFyZ2luKSB7XG4gIC8vIHJlY2FsY3VsYXRlIHRoZSBoZWlnaHQgb2YgdGhlIGdyb3VwXG4gIHZhciBoZWlnaHQ7XG4gIHZhciB2aXNpYmxlSXRlbXMgPSB0aGlzLnZpc2libGVJdGVtcztcbiAgLy92YXIgdmlzaWJsZVN1Ymdyb3VwcyA9IFtdO1xuICAvL3RoaXMudmlzaWJsZVN1Ymdyb3VwcyA9IDA7XG4gIHRoaXMucmVzZXRTdWJncm91cHMoKTtcbiAgdmFyIG1lID0gdGhpcztcbiAgaWYgKHZpc2libGVJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIG1pbiA9IHZpc2libGVJdGVtc1swXS50b3A7XG4gICAgdmFyIG1heCA9IHZpc2libGVJdGVtc1swXS50b3AgKyB2aXNpYmxlSXRlbXNbMF0uaGVpZ2h0O1xuICAgIHV0aWwuZm9yRWFjaCh2aXNpYmxlSXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGl0ZW0udG9wKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgKGl0ZW0udG9wICsgaXRlbS5oZWlnaHQpKTtcbiAgICAgIGlmIChpdGVtLmRhdGEuc3ViZ3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtZS5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXS5oZWlnaHQgPSBNYXRoLm1heChtZS5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXS5oZWlnaHQsaXRlbS5oZWlnaHQpO1xuICAgICAgICBtZS5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobWluID4gbWFyZ2luLmF4aXMpIHtcbiAgICAgIC8vIHRoZXJlIGlzIGFuIGVtcHR5IGdhcCBiZXR3ZWVuIHRoZSBsb3dlc3QgaXRlbSBhbmQgdGhlIGF4aXNcbiAgICAgIHZhciBvZmZzZXQgPSBtaW4gLSBtYXJnaW4uYXhpcztcbiAgICAgIG1heCAtPSBvZmZzZXQ7XG4gICAgICB1dGlsLmZvckVhY2godmlzaWJsZUl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpdGVtLnRvcCAtPSBvZmZzZXQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaGVpZ2h0ID0gbWF4ICsgbWFyZ2luLml0ZW0udmVydGljYWwgLyAyO1xuICB9XG4gIGVsc2Uge1xuICAgIGhlaWdodCA9IDA7XG4gIH1cbiAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCB0aGlzLnByb3BzLmxhYmVsLmhlaWdodCk7XG5cbiAgcmV0dXJuIGhlaWdodDtcbn07XG5cbi8qKlxuICogU2hvdyB0aGlzIGdyb3VwOiBhdHRhY2ggdG8gdGhlIERPTVxuICovXG5Hcm91cC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZG9tLmxhYmVsLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLml0ZW1TZXQuZG9tLmxhYmVsU2V0LmFwcGVuZENoaWxkKHRoaXMuZG9tLmxhYmVsKTtcbiAgfVxuXG4gIGlmICghdGhpcy5kb20uZm9yZWdyb3VuZC5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5pdGVtU2V0LmRvbS5mb3JlZ3JvdW5kLmFwcGVuZENoaWxkKHRoaXMuZG9tLmZvcmVncm91bmQpO1xuICB9XG5cbiAgaWYgKCF0aGlzLmRvbS5iYWNrZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLml0ZW1TZXQuZG9tLmJhY2tncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5kb20uYmFja2dyb3VuZCk7XG4gIH1cblxuICBpZiAoIXRoaXMuZG9tLmF4aXMucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuaXRlbVNldC5kb20uYXhpcy5hcHBlbmRDaGlsZCh0aGlzLmRvbS5heGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBIaWRlIHRoaXMgZ3JvdXA6IHJlbW92ZSBmcm9tIHRoZSBET01cbiAqL1xuR3JvdXAucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxhYmVsID0gdGhpcy5kb20ubGFiZWw7XG4gIGlmIChsYWJlbC5wYXJlbnROb2RlKSB7XG4gICAgbGFiZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsYWJlbCk7XG4gIH1cblxuICB2YXIgZm9yZWdyb3VuZCA9IHRoaXMuZG9tLmZvcmVncm91bmQ7XG4gIGlmIChmb3JlZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICBmb3JlZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZm9yZWdyb3VuZCk7XG4gIH1cblxuICB2YXIgYmFja2dyb3VuZCA9IHRoaXMuZG9tLmJhY2tncm91bmQ7XG4gIGlmIChiYWNrZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICBiYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYmFja2dyb3VuZCk7XG4gIH1cblxuICB2YXIgYXhpcyA9IHRoaXMuZG9tLmF4aXM7XG4gIGlmIChheGlzLnBhcmVudE5vZGUpIHtcbiAgICBheGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYXhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGFuIGl0ZW0gdG8gdGhlIGdyb3VwXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqL1xuR3JvdXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgdGhpcy5pdGVtc1tpdGVtLmlkXSA9IGl0ZW07XG4gIGl0ZW0uc2V0UGFyZW50KHRoaXMpO1xuXG4gIC8vIGFkZCB0b1xuICBpZiAoaXRlbS5kYXRhLnN1Ymdyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpcy5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnN1Ymdyb3Vwc1tpdGVtLmRhdGEuc3ViZ3JvdXBdID0ge2hlaWdodDowLCB2aXNpYmxlOiBmYWxzZSwgaW5kZXg6dGhpcy5zdWJncm91cEluZGV4LCBpdGVtczogW119O1xuICAgICAgdGhpcy5zdWJncm91cEluZGV4Kys7XG4gICAgfVxuICAgIHRoaXMuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0uaXRlbXMucHVzaChpdGVtKTtcbiAgfVxuICB0aGlzLm9yZGVyU3ViZ3JvdXBzKCk7XG5cbiAgaWYgKHRoaXMudmlzaWJsZUl0ZW1zLmluZGV4T2YoaXRlbSkgPT0gLTEpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLml0ZW1TZXQuYm9keS5yYW5nZTsgLy8gVE9ETzogbm90IG5pY2UgYWNjZXNzaW5nIHRoZSByYW5nZSBsaWtlIHRoaXNcbiAgICB0aGlzLl9jaGVja0lmVmlzaWJsZShpdGVtLCB0aGlzLnZpc2libGVJdGVtcywgcmFuZ2UpO1xuICB9XG59O1xuXG5Hcm91cC5wcm90b3R5cGUub3JkZXJTdWJncm91cHMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc3ViZ3JvdXBPcmRlcmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc29ydEFycmF5ID0gW107XG4gICAgaWYgKHR5cGVvZiB0aGlzLnN1Ymdyb3VwT3JkZXJlciA9PSAnc3RyaW5nJykge1xuICAgICAgZm9yICh2YXIgc3ViZ3JvdXAgaW4gdGhpcy5zdWJncm91cHMpIHtcbiAgICAgICAgc29ydEFycmF5LnB1c2goe3N1Ymdyb3VwOiBzdWJncm91cCwgc29ydEZpZWxkOiB0aGlzLnN1Ymdyb3Vwc1tzdWJncm91cF0uaXRlbXNbMF0uZGF0YVt0aGlzLnN1Ymdyb3VwT3JkZXJlcl19KVxuICAgICAgfVxuICAgICAgc29ydEFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuc29ydEZpZWxkIC0gYi5zb3J0RmllbGQ7XG4gICAgICB9KVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5zdWJncm91cE9yZGVyZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm9yICh2YXIgc3ViZ3JvdXAgaW4gdGhpcy5zdWJncm91cHMpIHtcbiAgICAgICAgc29ydEFycmF5LnB1c2godGhpcy5zdWJncm91cHNbc3ViZ3JvdXBdLml0ZW1zWzBdLmRhdGEpO1xuICAgICAgfVxuICAgICAgc29ydEFycmF5LnNvcnQodGhpcy5zdWJncm91cE9yZGVyZXIpO1xuICAgIH1cblxuICAgIGlmIChzb3J0QXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5zdWJncm91cHNbc29ydEFycmF5W2ldLnN1Ymdyb3VwXS5pbmRleCA9IGk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5Hcm91cC5wcm90b3R5cGUucmVzZXRTdWJncm91cHMgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgc3ViZ3JvdXAgaW4gdGhpcy5zdWJncm91cHMpIHtcbiAgICBpZiAodGhpcy5zdWJncm91cHMuaGFzT3duUHJvcGVydHkoc3ViZ3JvdXApKSB7XG4gICAgICB0aGlzLnN1Ymdyb3Vwc1tzdWJncm91cF0udmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIHRoZSBncm91cFxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGRlbGV0ZSB0aGlzLml0ZW1zW2l0ZW0uaWRdO1xuICBpdGVtLnNldFBhcmVudChudWxsKTtcblxuICAvLyByZW1vdmUgZnJvbSB2aXNpYmxlIGl0ZW1zXG4gIHZhciBpbmRleCA9IHRoaXMudmlzaWJsZUl0ZW1zLmluZGV4T2YoaXRlbSk7XG4gIGlmIChpbmRleCAhPSAtMSkgdGhpcy52aXNpYmxlSXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICBpZihpdGVtLmRhdGEuc3ViZ3JvdXAgIT09IHVuZGVmaW5lZCl7XG4gICAgdmFyIHN1Ymdyb3VwID0gdGhpcy5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXTtcbiAgICBpZiAoc3ViZ3JvdXApe1xuICAgICAgdmFyIGl0ZW1JbmRleCA9IHN1Ymdyb3VwLml0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICBzdWJncm91cC5pdGVtcy5zcGxpY2UoaXRlbUluZGV4LDEpO1xuICAgICAgaWYgKCFzdWJncm91cC5pdGVtcy5sZW5ndGgpe1xuICAgICAgICBkZWxldGUgdGhpcy5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXTtcbiAgICAgICAgdGhpcy5zdWJncm91cEluZGV4LS07XG4gICAgICB9XG4gICAgICB0aGlzLm9yZGVyU3ViZ3JvdXBzKCk7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgY29ycmVzcG9uZGluZyBEYXRhU2V0XG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqL1xuR3JvdXAucHJvdG90eXBlLnJlbW92ZUZyb21EYXRhU2V0ID0gZnVuY3Rpb24oaXRlbSkge1xuICB0aGlzLml0ZW1TZXQucmVtb3ZlSXRlbShpdGVtLmlkKTtcbn07XG5cblxuLyoqXG4gKiBSZW9yZGVyIHRoZSBpdGVtc1xuICovXG5Hcm91cC5wcm90b3R5cGUub3JkZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGFycmF5ID0gdXRpbC50b0FycmF5KHRoaXMuaXRlbXMpO1xuICB2YXIgc3RhcnRBcnJheSA9IFtdO1xuICB2YXIgZW5kQXJyYXkgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycmF5W2ldLmRhdGEuZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZEFycmF5LnB1c2goYXJyYXlbaV0pO1xuICAgIH1cbiAgICBzdGFydEFycmF5LnB1c2goYXJyYXlbaV0pO1xuICB9XG4gIHRoaXMub3JkZXJlZEl0ZW1zID0ge1xuICAgIGJ5U3RhcnQ6IHN0YXJ0QXJyYXksXG4gICAgYnlFbmQ6IGVuZEFycmF5XG4gIH07XG5cbiAgc3RhY2sub3JkZXJCeVN0YXJ0KHRoaXMub3JkZXJlZEl0ZW1zLmJ5U3RhcnQpO1xuICBzdGFjay5vcmRlckJ5RW5kKHRoaXMub3JkZXJlZEl0ZW1zLmJ5RW5kKTtcbn07XG5cblxuLyoqXG4gKiBVcGRhdGUgdGhlIHZpc2libGUgaXRlbXNcbiAqIEBwYXJhbSB7e2J5U3RhcnQ6IEl0ZW1bXSwgYnlFbmQ6IEl0ZW1bXX19IG9yZGVyZWRJdGVtcyAgIEFsbCBpdGVtcyBvcmRlcmVkIGJ5IHN0YXJ0IGRhdGUgYW5kIGJ5IGVuZCBkYXRlXG4gKiBAcGFyYW0ge0l0ZW1bXX0gdmlzaWJsZUl0ZW1zICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgcHJldmlvdXNseSB2aXNpYmxlIGl0ZW1zLlxuICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZSAgICAgICAgICAgICAgVmlzaWJsZSByYW5nZVxuICogQHJldHVybiB7SXRlbVtdfSB2aXNpYmxlSXRlbXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG5ldyB2aXNpYmxlIGl0ZW1zLlxuICogQHByaXZhdGVcbiAqL1xuR3JvdXAucHJvdG90eXBlLl91cGRhdGVWaXNpYmxlSXRlbXMgPSBmdW5jdGlvbihvcmRlcmVkSXRlbXMsIG9sZFZpc2libGVJdGVtcywgcmFuZ2UpIHtcbiAgdmFyIHZpc2libGVJdGVtcyA9IFtdO1xuICB2YXIgdmlzaWJsZUl0ZW1zTG9va3VwID0ge307IC8vIHdlIGtlZXAgdGhpcyB0byBxdWlja2x5IGxvb2sgdXAgaWYgYW4gaXRlbSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgbGlzdCB3aXRob3V0IHVzaW5nIGluZGV4T2Ygb24gdmlzaWJsZUl0ZW1zXG4gIHZhciBpbnRlcnZhbCA9IChyYW5nZS5lbmQgLSByYW5nZS5zdGFydCkgLyA0O1xuICB2YXIgbG93ZXJCb3VuZCA9IHJhbmdlLnN0YXJ0IC0gaW50ZXJ2YWw7XG4gIHZhciB1cHBlckJvdW5kID0gcmFuZ2UuZW5kICsgaW50ZXJ2YWw7XG4gIHZhciBpdGVtLCBpO1xuXG4gIC8vIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBkbyB0aGUgYmluYXJ5IHNlYXJjaC5cbiAgdmFyIHNlYXJjaEZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgICAgICAodmFsdWUgPCBsb3dlckJvdW5kKSAge3JldHVybiAtMTt9XG4gICAgZWxzZSBpZiAodmFsdWUgPD0gdXBwZXJCb3VuZCkge3JldHVybiAgMDt9XG4gICAgZWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAge3JldHVybiAgMTt9XG4gIH1cblxuICAvLyBmaXJzdCBjaGVjayBpZiB0aGUgaXRlbXMgdGhhdCB3ZXJlIGluIHZpZXcgcHJldmlvdXNseSBhcmUgc3RpbGwgaW4gdmlldy5cbiAgLy8gSU1QT1JUQU5UOiB0aGlzIGhhbmRsZXMgdGhlIGNhc2UgZm9yIHRoZSBpdGVtcyB3aXRoIHN0YXJ0ZGF0ZSBiZWZvcmUgdGhlIHdpbmRvdyBhbmQgZW5kZGF0ZSBhZnRlciB0aGUgd2luZG93IVxuICAvLyBhbHNvIGNsZWFucyB1cCBpbnZpc2libGUgaXRlbXMuXG4gIGlmIChvbGRWaXNpYmxlSXRlbXMubGVuZ3RoID4gMCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBvbGRWaXNpYmxlSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2NoZWNrSWZWaXNpYmxlV2l0aFJlZmVyZW5jZShvbGRWaXNpYmxlSXRlbXNbaV0sIHZpc2libGVJdGVtcywgdmlzaWJsZUl0ZW1zTG9va3VwLCByYW5nZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gd2UgZG8gYSBiaW5hcnkgc2VhcmNoIGZvciB0aGUgaXRlbXMgdGhhdCBoYXZlIG9ubHkgc3RhcnQgdmFsdWVzLlxuICB2YXIgaW5pdGlhbFBvc0J5U3RhcnQgPSB1dGlsLmJpbmFyeVNlYXJjaEN1c3RvbShvcmRlcmVkSXRlbXMuYnlTdGFydCwgc2VhcmNoRnVuY3Rpb24sICdkYXRhJywnc3RhcnQnKTtcblxuICAvLyB0cmFjZSB0aGUgdmlzaWJsZSBpdGVtcyBmcm9tIHRoZSBpbml0YWwgc3RhcnQgcG9zIGJvdGggd2F5cyB1bnRpbCBhbiBpbnZpc2libGUgaXRlbSBpcyBmb3VuZCwgd2Ugb25seSBsb29rIGF0IHRoZSBzdGFydCB2YWx1ZXMuXG4gIHRoaXMuX3RyYWNlVmlzaWJsZShpbml0aWFsUG9zQnlTdGFydCwgb3JkZXJlZEl0ZW1zLmJ5U3RhcnQsIHZpc2libGVJdGVtcywgdmlzaWJsZUl0ZW1zTG9va3VwLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiAoaXRlbS5kYXRhLnN0YXJ0IDwgbG93ZXJCb3VuZCB8fCBpdGVtLmRhdGEuc3RhcnQgPiB1cHBlckJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gaWYgdGhlIHdpbmRvdyBoYXMgY2hhbmdlZCBwcm9ncmFtbWF0aWNhbGx5IHdpdGhvdXQgb3ZlcmxhcHBpbmcgdGhlIG9sZCB3aW5kb3csIHRoZSByYW5nZWQgaXRlbXMgd2l0aCBzdGFydCA8IGxvd2VyQm91bmQgYW5kIGVuZCA+IHVwcGVyYm91bmQgYXJlIG5vdCBzaG93bi5cbiAgLy8gV2UgdGhlcmVmb3JlIGhhdmUgdG8gYnJ1dGUgZm9yY2UgY2hlY2sgYWxsIGl0ZW1zIGluIHRoZSBieUVuZCBsaXN0XG4gIGlmICh0aGlzLmNoZWNrUmFuZ2VkSXRlbXMgPT0gdHJ1ZSkge1xuICAgIHRoaXMuY2hlY2tSYW5nZWRJdGVtcyA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvcmRlcmVkSXRlbXMuYnlFbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2NoZWNrSWZWaXNpYmxlV2l0aFJlZmVyZW5jZShvcmRlcmVkSXRlbXMuYnlFbmRbaV0sIHZpc2libGVJdGVtcywgdmlzaWJsZUl0ZW1zTG9va3VwLCByYW5nZSk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIHdlIGRvIGEgYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGl0ZW1zIHRoYXQgaGF2ZSBkZWZpbmVkIGVuZCB0aW1lcy5cbiAgICB2YXIgaW5pdGlhbFBvc0J5RW5kID0gdXRpbC5iaW5hcnlTZWFyY2hDdXN0b20ob3JkZXJlZEl0ZW1zLmJ5RW5kLCBzZWFyY2hGdW5jdGlvbiwgJ2RhdGEnLCdlbmQnKTtcblxuICAgIC8vIHRyYWNlIHRoZSB2aXNpYmxlIGl0ZW1zIGZyb20gdGhlIGluaXRhbCBzdGFydCBwb3MgYm90aCB3YXlzIHVudGlsIGFuIGludmlzaWJsZSBpdGVtIGlzIGZvdW5kLCB3ZSBvbmx5IGxvb2sgYXQgdGhlIGVuZCB2YWx1ZXMuXG4gICAgdGhpcy5fdHJhY2VWaXNpYmxlKGluaXRpYWxQb3NCeUVuZCwgb3JkZXJlZEl0ZW1zLmJ5RW5kLCB2aXNpYmxlSXRlbXMsIHZpc2libGVJdGVtc0xvb2t1cCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAoaXRlbS5kYXRhLmVuZCA8IGxvd2VyQm91bmQgfHwgaXRlbS5kYXRhLmVuZCA+IHVwcGVyQm91bmQpO1xuICAgIH0pO1xuICB9XG5cblxuICAvLyBmaW5hbGx5LCB3ZSByZXBvc2l0aW9uIGFsbCB0aGUgdmlzaWJsZSBpdGVtcy5cbiAgZm9yIChpID0gMDsgaSA8IHZpc2libGVJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgIGl0ZW0gPSB2aXNpYmxlSXRlbXNbaV07XG4gICAgaWYgKCFpdGVtLmRpc3BsYXllZCkgaXRlbS5zaG93KCk7XG4gICAgLy8gcmVwb3NpdGlvbiBpdGVtIGhvcml6b250YWxseVxuICAgIGl0ZW0ucmVwb3NpdGlvblgoKTtcbiAgfVxuXG4gIC8vIGRlYnVnXG4gIC8vY29uc29sZS5sb2coXCJuZXcgbGluZVwiKVxuICAvL2lmICh0aGlzLmdyb3VwSWQgPT0gbnVsbCkge1xuICAvLyAgZm9yIChpID0gMDsgaSA8IG9yZGVyZWRJdGVtcy5ieVN0YXJ0Lmxlbmd0aDsgaSsrKSB7XG4gIC8vICAgIGl0ZW0gPSBvcmRlcmVkSXRlbXMuYnlTdGFydFtpXS5kYXRhO1xuICAvLyAgICBjb25zb2xlLmxvZygnc3RhcnQnLGksaW5pdGlhbFBvc0J5U3RhcnQsIGl0ZW0uc3RhcnQudmFsdWVPZigpLCBpdGVtLmNvbnRlbnQsIGl0ZW0uc3RhcnQgPj0gbG93ZXJCb3VuZCAmJiBpdGVtLnN0YXJ0IDw9IHVwcGVyQm91bmQsaSA9PSBpbml0aWFsUG9zQnlTdGFydCA/IFwiPC0tLS0tLS0tLS0tLS0tLS0tLS0gSEVSRUVFRVwiIDogXCJcIilcbiAgLy8gIH1cbiAgLy8gIGZvciAoaSA9IDA7IGkgPCBvcmRlcmVkSXRlbXMuYnlFbmQubGVuZ3RoOyBpKyspIHtcbiAgLy8gICAgaXRlbSA9IG9yZGVyZWRJdGVtcy5ieUVuZFtpXS5kYXRhO1xuICAvLyAgICBjb25zb2xlLmxvZygncmFuZ2VFbmQnLGksaW5pdGlhbFBvc0J5RW5kLCBpdGVtLmVuZC52YWx1ZU9mKCksIGl0ZW0uY29udGVudCwgaXRlbS5lbmQgPj0gcmFuZ2Uuc3RhcnQgJiYgaXRlbS5lbmQgPD0gcmFuZ2UuZW5kLGkgPT0gaW5pdGlhbFBvc0J5RW5kID8gXCI8LS0tLS0tLS0tLS0tLS0tLS0tLSBIRVJFRUVFXCIgOiBcIlwiKVxuICAvLyAgfVxuICAvL31cblxuICByZXR1cm4gdmlzaWJsZUl0ZW1zO1xufTtcblxuR3JvdXAucHJvdG90eXBlLl90cmFjZVZpc2libGUgPSBmdW5jdGlvbiAoaW5pdGlhbFBvcywgaXRlbXMsIHZpc2libGVJdGVtcywgdmlzaWJsZUl0ZW1zTG9va3VwLCBicmVha0NvbmRpdGlvbikge1xuICB2YXIgaXRlbTtcbiAgdmFyIGk7XG5cbiAgaWYgKGluaXRpYWxQb3MgIT0gLTEpIHtcbiAgICBmb3IgKGkgPSBpbml0aWFsUG9zOyBpID49IDA7IGktLSkge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgaWYgKGJyZWFrQ29uZGl0aW9uKGl0ZW0pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh2aXNpYmxlSXRlbXNMb29rdXBbaXRlbS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZpc2libGVJdGVtc0xvb2t1cFtpdGVtLmlkXSA9IHRydWU7XG4gICAgICAgICAgdmlzaWJsZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSBpbml0aWFsUG9zICsgMTsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICBpZiAoYnJlYWtDb25kaXRpb24oaXRlbSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHZpc2libGVJdGVtc0xvb2t1cFtpdGVtLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmlzaWJsZUl0ZW1zTG9va3VwW2l0ZW0uaWRdID0gdHJ1ZTtcbiAgICAgICAgICB2aXNpYmxlSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogdGhpcyBmdW5jdGlvbiBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhlIF9jaGVja0lmSW52aXNpYmxlKCkgYnV0IGl0IGRvZXMgbm90XG4gKiByZXR1cm4gYm9vbGVhbnMsIGhpZGVzIHRoZSBpdGVtIGlmIGl0IHNob3VsZCBub3QgYmUgc2VlbiBhbmQgYWx3YXlzIGFkZHMgdG9cbiAqIHRoZSB2aXNpYmxlSXRlbXMuXG4gKiB0aGlzIG9uZSBpcyBmb3IgYnJ1dGUgZm9yY2luZyBhbmQgaGlkaW5nLlxuICpcbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHBhcmFtIHtBcnJheX0gdmlzaWJsZUl0ZW1zXG4gKiBAcGFyYW0ge3tzdGFydDpudW1iZXIsIGVuZDpudW1iZXJ9fSByYW5nZVxuICogQHByaXZhdGVcbiAqL1xuR3JvdXAucHJvdG90eXBlLl9jaGVja0lmVmlzaWJsZSA9IGZ1bmN0aW9uKGl0ZW0sIHZpc2libGVJdGVtcywgcmFuZ2UpIHtcbiAgICBpZiAoaXRlbS5pc1Zpc2libGUocmFuZ2UpKSB7XG4gICAgICBpZiAoIWl0ZW0uZGlzcGxheWVkKSBpdGVtLnNob3coKTtcbiAgICAgIC8vIHJlcG9zaXRpb24gaXRlbSBob3Jpem9udGFsbHlcbiAgICAgIGl0ZW0ucmVwb3NpdGlvblgoKTtcbiAgICAgIHZpc2libGVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChpdGVtLmRpc3BsYXllZCkgaXRlbS5oaWRlKCk7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIHRoaXMgZnVuY3Rpb24gaXMgdmVyeSBzaW1pbGFyIHRvIHRoZSBfY2hlY2tJZkludmlzaWJsZSgpIGJ1dCBpdCBkb2VzIG5vdFxuICogcmV0dXJuIGJvb2xlYW5zLCBoaWRlcyB0aGUgaXRlbSBpZiBpdCBzaG91bGQgbm90IGJlIHNlZW4gYW5kIGFsd2F5cyBhZGRzIHRvXG4gKiB0aGUgdmlzaWJsZUl0ZW1zLlxuICogdGhpcyBvbmUgaXMgZm9yIGJydXRlIGZvcmNpbmcgYW5kIGhpZGluZy5cbiAqXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7QXJyYXl9IHZpc2libGVJdGVtc1xuICogQHBhcmFtIHt7c3RhcnQ6bnVtYmVyLCBlbmQ6bnVtYmVyfX0gcmFuZ2VcbiAqIEBwcml2YXRlXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5fY2hlY2tJZlZpc2libGVXaXRoUmVmZXJlbmNlID0gZnVuY3Rpb24oaXRlbSwgdmlzaWJsZUl0ZW1zLCB2aXNpYmxlSXRlbXNMb29rdXAsIHJhbmdlKSB7XG4gIGlmIChpdGVtLmlzVmlzaWJsZShyYW5nZSkpIHtcbiAgICBpZiAodmlzaWJsZUl0ZW1zTG9va3VwW2l0ZW0uaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZpc2libGVJdGVtc0xvb2t1cFtpdGVtLmlkXSA9IHRydWU7XG4gICAgICB2aXNpYmxlSXRlbXMucHVzaChpdGVtKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKGl0ZW0uZGlzcGxheWVkKSBpdGVtLmhpZGUoKTtcbiAgfVxufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gR3JvdXA7XG4iXX0=
},{"../../util":46,"../Stack":29,"./item/RangeItem":43}],37:[function(require,module,exports){
'use strict';

var Hammer = require('../../module/hammer');
var util = require('../../util');
var DataSet = require('../../DataSet');
var DataView = require('../../DataView');
var TimeStep = require('../TimeStep');
var Component = require('./Component');
var Group = require('./Group');
var BackgroundGroup = require('./BackgroundGroup');
var BoxItem = require('./item/BoxItem');
var PointItem = require('./item/PointItem');
var RangeItem = require('./item/RangeItem');
var BackgroundItem = require('./item/BackgroundItem');

var UNGROUPED = '__ungrouped__'; // reserved group id for ungrouped items
var BACKGROUND = '__background__'; // reserved group id for background items without group

/**
 * An ItemSet holds a set of items and ranges which can be displayed in a
 * range. The width is determined by the parent of the ItemSet, and the height
 * is determined by the size of the items.
 * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
 * @param {Object} [options]      See ItemSet.setOptions for the available options.
 * @constructor ItemSet
 * @extends Component
 */
function ItemSet(body, options) {
  this.body = body;

  this.defaultOptions = {
    type: null, // 'box', 'point', 'range', 'background'
    orientation: {
      item: 'bottom' // item orientation: 'top' or 'bottom'
    },
    align: 'auto', // alignment of box items
    stack: true,
    groupOrderSwap: function groupOrderSwap(fromGroup, toGroup, groups) {
      var targetOrder = toGroup.order;
      toGroup.order = fromGroup.order;
      fromGroup.order = targetOrder;
    },
    groupOrder: 'order',

    selectable: true,
    multiselect: false,

    editable: {
      updateTime: false,
      updateGroup: false,
      add: false,
      remove: false
    },

    groupEditable: {
      order: false,
      add: false,
      remove: false
    },

    snap: TimeStep.snap,

    onAdd: function onAdd(item, callback) {
      callback(item);
    },
    onUpdate: function onUpdate(item, callback) {
      callback(item);
    },
    onMove: function onMove(item, callback) {
      callback(item);
    },
    onRemove: function onRemove(item, callback) {
      callback(item);
    },
    onMoving: function onMoving(item, callback) {
      callback(item);
    },
    onAddGroup: function onAddGroup(item, callback) {
      callback(item);
    },
    onMoveGroup: function onMoveGroup(item, callback) {
      callback(item);
    },
    onRemoveGroup: function onRemoveGroup(item, callback) {
      callback(item);
    },

    margin: {
      item: {
        horizontal: 10,
        vertical: 10
      },
      axis: 20
    }
  };

  // options is shared by this ItemSet and all its items
  this.options = util.extend({}, this.defaultOptions);

  // options for getting items from the DataSet with the correct type
  this.itemOptions = {
    type: { start: 'Date', end: 'Date' }
  };

  this.conversion = {
    toScreen: body.util.toScreen,
    toTime: body.util.toTime
  };
  this.dom = {};
  this.props = {};
  this.hammer = null;

  var me = this;
  this.itemsData = null; // DataSet
  this.groupsData = null; // DataSet

  // listeners for the DataSet of the items
  this.itemListeners = {
    'add': function add(event, params, senderId) {
      me._onAdd(params.items);
    },
    'update': function update(event, params, senderId) {
      me._onUpdate(params.items);
    },
    'remove': function remove(event, params, senderId) {
      me._onRemove(params.items);
    }
  };

  // listeners for the DataSet of the groups
  this.groupListeners = {
    'add': function add(event, params, senderId) {
      me._onAddGroups(params.items);
    },
    'update': function update(event, params, senderId) {
      me._onUpdateGroups(params.items);
    },
    'remove': function remove(event, params, senderId) {
      me._onRemoveGroups(params.items);
    }
  };

  this.items = {}; // object with an Item for every data item
  this.groups = {}; // Group object for every group
  this.groupIds = [];

  this.selection = []; // list with the ids of all selected nodes
  this.stackDirty = true; // if true, all items will be restacked on next redraw

  this.touchParams = {}; // stores properties while dragging
  this.groupTouchParams = {};
  // create the HTML DOM

  this._create();

  this.setOptions(options);
}

ItemSet.prototype = new Component();

// available item types will be registered here
ItemSet.types = {
  background: BackgroundItem,
  box: BoxItem,
  range: RangeItem,
  point: PointItem
};

/**
 * Create the HTML DOM for the ItemSet
 */
ItemSet.prototype._create = function () {
  var frame = document.createElement('div');
  frame.className = 'vis-itemset';
  frame['timeline-itemset'] = this;
  this.dom.frame = frame;

  // create background panel
  var background = document.createElement('div');
  background.className = 'vis-background';
  frame.appendChild(background);
  this.dom.background = background;

  // create foreground panel
  var foreground = document.createElement('div');
  foreground.className = 'vis-foreground';
  frame.appendChild(foreground);
  this.dom.foreground = foreground;

  // create axis panel
  var axis = document.createElement('div');
  axis.className = 'vis-axis';
  this.dom.axis = axis;

  // create labelset
  var labelSet = document.createElement('div');
  labelSet.className = 'vis-labelset';
  this.dom.labelSet = labelSet;

  // create ungrouped Group
  this._updateUngrouped();

  // create background Group
  var backgroundGroup = new BackgroundGroup(BACKGROUND, null, this);
  backgroundGroup.show();
  this.groups[BACKGROUND] = backgroundGroup;

  // attach event listeners
  // Note: we bind to the centerContainer for the case where the height
  //       of the center container is larger than of the ItemSet, so we
  //       can click in the empty area to create a new item or deselect an item.
  this.hammer = new Hammer(this.body.dom.centerContainer);

  // drag items when selected
  this.hammer.on('hammer.input', (function (event) {
    if (event.isFirst) {
      this._onTouch(event);
    }
  }).bind(this));
  this.hammer.on('panstart', this._onDragStart.bind(this));
  this.hammer.on('panmove', this._onDrag.bind(this));
  this.hammer.on('panend', this._onDragEnd.bind(this));
  this.hammer.get('pan').set({ threshold: 5, direction: 30 }); // 30 is ALL_DIRECTIONS in hammer.

  // single select (or unselect) when tapping an item
  this.hammer.on('tap', this._onSelectItem.bind(this));

  // multi select when holding mouse/touch, or on ctrl+click
  this.hammer.on('press', this._onMultiSelectItem.bind(this));

  // add item on doubletap
  this.hammer.on('doubletap', this._onAddItem.bind(this));

  this.groupHammer = new Hammer(this.body.dom.leftContainer);
  this.groupHammer.on('panstart', this._onGroupDragStart.bind(this));
  this.groupHammer.on('panmove', this._onGroupDrag.bind(this));
  this.groupHammer.on('panend', this._onGroupDragEnd.bind(this));
  this.groupHammer.get('pan').set({ threshold: 5, direction: 30 });

  // attach to the DOM
  this.show();
};

/**
 * Set options for the ItemSet. Existing options will be extended/overwritten.
 * @param {Object} [options] The following options are available:
 *                           {String} type
 *                              Default type for the items. Choose from 'box'
 *                              (default), 'point', 'range', or 'background'.
 *                              The default style can be overwritten by
 *                              individual items.
 *                           {String} align
 *                              Alignment for the items, only applicable for
 *                              BoxItem. Choose 'center' (default), 'left', or
 *                              'right'.
 *                           {String} orientation.item
 *                              Orientation of the item set. Choose 'top' or
 *                              'bottom' (default).
 *                           {Function} groupOrder
 *                              A sorting function for ordering groups
 *                           {Boolean} stack
 *                              If true (default), items will be stacked on
 *                              top of each other.
 *                           {Number} margin.axis
 *                              Margin between the axis and the items in pixels.
 *                              Default is 20.
 *                           {Number} margin.item.horizontal
 *                              Horizontal margin between items in pixels.
 *                              Default is 10.
 *                           {Number} margin.item.vertical
 *                              Vertical Margin between items in pixels.
 *                              Default is 10.
 *                           {Number} margin.item
 *                              Margin between items in pixels in both horizontal
 *                              and vertical direction. Default is 10.
 *                           {Number} margin
 *                              Set margin for both axis and items in pixels.
 *                           {Boolean} selectable
 *                              If true (default), items can be selected.
 *                           {Boolean} multiselect
 *                              If true, multiple items can be selected.
 *                              False by default.
 *                           {Boolean} editable
 *                              Set all editable options to true or false
 *                           {Boolean} editable.updateTime
 *                              Allow dragging an item to an other moment in time
 *                           {Boolean} editable.updateGroup
 *                              Allow dragging an item to an other group
 *                           {Boolean} editable.add
 *                              Allow creating new items on double tap
 *                           {Boolean} editable.remove
 *                              Allow removing items by clicking the delete button
 *                              top right of a selected item.
 *                           {Function(item: Item, callback: Function)} onAdd
 *                              Callback function triggered when an item is about to be added:
 *                              when the user double taps an empty space in the Timeline.
 *                           {Function(item: Item, callback: Function)} onUpdate
 *                              Callback function fired when an item is about to be updated.
 *                              This function typically has to show a dialog where the user
 *                              change the item. If not implemented, nothing happens.
 *                           {Function(item: Item, callback: Function)} onMove
 *                              Fired when an item has been moved. If not implemented,
 *                              the move action will be accepted.
 *                           {Function(item: Item, callback: Function)} onRemove
 *                              Fired when an item is about to be deleted.
 *                              If not implemented, the item will be always removed.
 */
ItemSet.prototype.setOptions = function (options) {
  if (options) {
    // copy all options that we know
    var fields = ['type', 'align', 'order', 'stack', 'selectable', 'multiselect', 'groupOrder', 'dataAttributes', 'template', 'groupTemplate', 'hide', 'snap', 'groupOrderSwap'];
    util.selectiveExtend(fields, this.options, options);

    if ('orientation' in options) {
      if (typeof options.orientation === 'string') {
        this.options.orientation.item = options.orientation === 'top' ? 'top' : 'bottom';
      } else if (typeof options.orientation === 'object' && 'item' in options.orientation) {
        this.options.orientation.item = options.orientation.item;
      }
    }

    if ('margin' in options) {
      if (typeof options.margin === 'number') {
        this.options.margin.axis = options.margin;
        this.options.margin.item.horizontal = options.margin;
        this.options.margin.item.vertical = options.margin;
      } else if (typeof options.margin === 'object') {
        util.selectiveExtend(['axis'], this.options.margin, options.margin);
        if ('item' in options.margin) {
          if (typeof options.margin.item === 'number') {
            this.options.margin.item.horizontal = options.margin.item;
            this.options.margin.item.vertical = options.margin.item;
          } else if (typeof options.margin.item === 'object') {
            util.selectiveExtend(['horizontal', 'vertical'], this.options.margin.item, options.margin.item);
          }
        }
      }
    }

    if ('editable' in options) {
      if (typeof options.editable === 'boolean') {
        this.options.editable.updateTime = options.editable;
        this.options.editable.updateGroup = options.editable;
        this.options.editable.add = options.editable;
        this.options.editable.remove = options.editable;
      } else if (typeof options.editable === 'object') {
        util.selectiveExtend(['updateTime', 'updateGroup', 'add', 'remove'], this.options.editable, options.editable);
      }
    }

    if ('groupEditable' in options) {
      if (typeof options.groupEditable === 'boolean') {
        this.options.groupEditable.order = options.groupEditable;
        this.options.groupEditable.add = options.groupEditable;
        this.options.groupEditable.remove = options.groupEditable;
      } else if (typeof options.groupEditable === 'object') {
        util.selectiveExtend(['order', 'add', 'remove'], this.options.groupEditable, options.groupEditable);
      }
    }

    // callback functions
    var addCallback = (function (name) {
      var fn = options[name];
      if (fn) {
        if (!(fn instanceof Function)) {
          throw new Error('option ' + name + ' must be a function ' + name + '(item, callback)');
        }
        this.options[name] = fn;
      }
    }).bind(this);
    ['onAdd', 'onUpdate', 'onRemove', 'onMove', 'onMoving', 'onAddGroup', 'onMoveGroup', 'onRemoveGroup'].forEach(addCallback);

    // force the itemSet to refresh: options like orientation and margins may be changed
    this.markDirty();
  }
};

/**
 * Mark the ItemSet dirty so it will refresh everything with next redraw.
 * Optionally, all items can be marked as dirty and be refreshed.
 * @param {{refreshItems: boolean}} [options]
 */
ItemSet.prototype.markDirty = function (options) {
  this.groupIds = [];
  this.stackDirty = true;

  if (options && options.refreshItems) {
    util.forEach(this.items, function (item) {
      item.dirty = true;
      if (item.displayed) item.redraw();
    });
  }
};

/**
 * Destroy the ItemSet
 */
ItemSet.prototype.destroy = function () {
  this.hide();
  this.setItems(null);
  this.setGroups(null);

  this.hammer = null;

  this.body = null;
  this.conversion = null;
};

/**
 * Hide the component from the DOM
 */
ItemSet.prototype.hide = function () {
  // remove the frame containing the items
  if (this.dom.frame.parentNode) {
    this.dom.frame.parentNode.removeChild(this.dom.frame);
  }

  // remove the axis with dots
  if (this.dom.axis.parentNode) {
    this.dom.axis.parentNode.removeChild(this.dom.axis);
  }

  // remove the labelset containing all group labels
  if (this.dom.labelSet.parentNode) {
    this.dom.labelSet.parentNode.removeChild(this.dom.labelSet);
  }
};

/**
 * Show the component in the DOM (when not already visible).
 * @return {Boolean} changed
 */
ItemSet.prototype.show = function () {
  // show frame containing the items
  if (!this.dom.frame.parentNode) {
    this.body.dom.center.appendChild(this.dom.frame);
  }

  // show axis with dots
  if (!this.dom.axis.parentNode) {
    this.body.dom.backgroundVertical.appendChild(this.dom.axis);
  }

  // show labelset containing labels
  if (!this.dom.labelSet.parentNode) {
    this.body.dom.left.appendChild(this.dom.labelSet);
  }
};

/**
 * Set selected items by their id. Replaces the current selection
 * Unknown id's are silently ignored.
 * @param {string[] | string} [ids] An array with zero or more id's of the items to be
 *                                  selected, or a single item id. If ids is undefined
 *                                  or an empty array, all items will be unselected.
 */
ItemSet.prototype.setSelection = function (ids) {
  var i, ii, id, item;

  if (ids == undefined) ids = [];
  if (!Array.isArray(ids)) ids = [ids];

  // unselect currently selected items
  for (i = 0, ii = this.selection.length; i < ii; i++) {
    id = this.selection[i];
    item = this.items[id];
    if (item) item.unselect();
  }

  // select items
  this.selection = [];
  for (i = 0, ii = ids.length; i < ii; i++) {
    id = ids[i];
    item = this.items[id];
    if (item) {
      this.selection.push(id);
      item.select();
    }
  }
};

/**
 * Get the selected items by their id
 * @return {Array} ids  The ids of the selected items
 */
ItemSet.prototype.getSelection = function () {
  return this.selection.concat([]);
};

/**
 * Get the id's of the currently visible items.
 * @returns {Array} The ids of the visible items
 */
ItemSet.prototype.getVisibleItems = function () {
  var range = this.body.range.getRange();
  var left = this.body.util.toScreen(range.start);
  var right = this.body.util.toScreen(range.end);

  var ids = [];
  for (var groupId in this.groups) {
    if (this.groups.hasOwnProperty(groupId)) {
      var group = this.groups[groupId];
      var rawVisibleItems = group.visibleItems;

      // filter the "raw" set with visibleItems into a set which is really
      // visible by pixels
      for (var i = 0; i < rawVisibleItems.length; i++) {
        var item = rawVisibleItems[i];
        // TODO: also check whether visible vertically
        if (item.left < right && item.left + item.width > left) {
          ids.push(item.id);
        }
      }
    }
  }

  return ids;
};

/**
 * Deselect a selected item
 * @param {String | Number} id
 * @private
 */
ItemSet.prototype._deselect = function (id) {
  var selection = this.selection;
  for (var i = 0, ii = selection.length; i < ii; i++) {
    if (selection[i] == id) {
      // non-strict comparison!
      selection.splice(i, 1);
      break;
    }
  }
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
ItemSet.prototype.redraw = function () {
  var margin = this.options.margin,
      range = this.body.range,
      asSize = util.option.asSize,
      options = this.options,
      orientation = options.orientation.item,
      resized = false,
      frame = this.dom.frame;

  // recalculate absolute position (before redrawing groups)
  this.props.top = this.body.domProps.top.height + this.body.domProps.border.top;
  this.props.left = this.body.domProps.left.width + this.body.domProps.border.left;

  // update class name
  frame.className = 'vis-itemset';

  // reorder the groups (if needed)
  resized = this._orderGroups() || resized;

  // check whether zoomed (in that case we need to re-stack everything)
  // TODO: would be nicer to get this as a trigger from Range
  var visibleInterval = range.end - range.start;
  var zoomed = visibleInterval != this.lastVisibleInterval || this.props.width != this.props.lastWidth;
  if (zoomed) this.stackDirty = true;
  this.lastVisibleInterval = visibleInterval;
  this.props.lastWidth = this.props.width;

  var restack = this.stackDirty;
  var firstGroup = this._firstGroup();
  var firstMargin = {
    item: margin.item,
    axis: margin.axis
  };
  var nonFirstMargin = {
    item: margin.item,
    axis: margin.item.vertical / 2
  };
  var height = 0;
  var minHeight = margin.axis + margin.item.vertical;

  // redraw the background group
  this.groups[BACKGROUND].redraw(range, nonFirstMargin, restack);

  // redraw all regular groups
  util.forEach(this.groups, function (group) {
    var groupMargin = group == firstGroup ? firstMargin : nonFirstMargin;
    var groupResized = group.redraw(range, groupMargin, restack);
    resized = groupResized || resized;
    height += group.height;
  });
  height = Math.max(height, minHeight);
  this.stackDirty = false;

  // update frame height
  frame.style.height = asSize(height);

  // calculate actual size
  this.props.width = frame.offsetWidth;
  this.props.height = height;

  // reposition axis
  this.dom.axis.style.top = asSize(orientation == 'top' ? this.body.domProps.top.height + this.body.domProps.border.top : this.body.domProps.top.height + this.body.domProps.centerContainer.height);
  this.dom.axis.style.left = '0';

  // check if this component is resized
  resized = this._isResized() || resized;

  return resized;
};

/**
 * Get the first group, aligned with the axis
 * @return {Group | null} firstGroup
 * @private
 */
ItemSet.prototype._firstGroup = function () {
  var firstGroupIndex = this.options.orientation.item == 'top' ? 0 : this.groupIds.length - 1;
  var firstGroupId = this.groupIds[firstGroupIndex];
  var firstGroup = this.groups[firstGroupId] || this.groups[UNGROUPED];

  return firstGroup || null;
};

/**
 * Create or delete the group holding all ungrouped items. This group is used when
 * there are no groups specified.
 * @protected
 */
ItemSet.prototype._updateUngrouped = function () {
  var ungrouped = this.groups[UNGROUPED];
  var background = this.groups[BACKGROUND];
  var item, itemId;

  if (this.groupsData) {
    // remove the group holding all ungrouped items
    if (ungrouped) {
      ungrouped.hide();
      delete this.groups[UNGROUPED];

      for (itemId in this.items) {
        if (this.items.hasOwnProperty(itemId)) {
          item = this.items[itemId];
          item.parent && item.parent.remove(item);
          var groupId = this._getGroupId(item.data);
          var group = this.groups[groupId];
          group && group.add(item) || item.hide();
        }
      }
    }
  } else {
    // create a group holding all (unfiltered) items
    if (!ungrouped) {
      var id = null;
      var data = null;
      ungrouped = new Group(id, data, this);
      this.groups[UNGROUPED] = ungrouped;

      for (itemId in this.items) {
        if (this.items.hasOwnProperty(itemId)) {
          item = this.items[itemId];
          ungrouped.add(item);
        }
      }

      ungrouped.show();
    }
  }
};

/**
 * Get the element for the labelset
 * @return {HTMLElement} labelSet
 */
ItemSet.prototype.getLabelSet = function () {
  return this.dom.labelSet;
};

/**
 * Set items
 * @param {vis.DataSet | null} items
 */
ItemSet.prototype.setItems = function (items) {
  var me = this,
      ids,
      oldItemsData = this.itemsData;

  // replace the dataset
  if (!items) {
    this.itemsData = null;
  } else if (items instanceof DataSet || items instanceof DataView) {
    this.itemsData = items;
  } else {
    throw new TypeError('Data must be an instance of DataSet or DataView');
  }

  if (oldItemsData) {
    // unsubscribe from old dataset
    util.forEach(this.itemListeners, function (callback, event) {
      oldItemsData.off(event, callback);
    });

    // remove all drawn items
    ids = oldItemsData.getIds();
    this._onRemove(ids);
  }

  if (this.itemsData) {
    // subscribe to new dataset
    var id = this.id;
    util.forEach(this.itemListeners, function (callback, event) {
      me.itemsData.on(event, callback, id);
    });

    // add all new items
    ids = this.itemsData.getIds();
    this._onAdd(ids);

    // update the group holding all ungrouped items
    this._updateUngrouped();
  }
};

/**
 * Get the current items
 * @returns {vis.DataSet | null}
 */
ItemSet.prototype.getItems = function () {
  return this.itemsData;
};

/**
 * Set groups
 * @param {vis.DataSet} groups
 */
ItemSet.prototype.setGroups = function (groups) {
  var me = this,
      ids;

  // unsubscribe from current dataset
  if (this.groupsData) {
    util.forEach(this.groupListeners, function (callback, event) {
      me.groupsData.off(event, callback);
    });

    // remove all drawn groups
    ids = this.groupsData.getIds();
    this.groupsData = null;
    this._onRemoveGroups(ids); // note: this will cause a redraw
  }

  // replace the dataset
  if (!groups) {
    this.groupsData = null;
  } else if (groups instanceof DataSet || groups instanceof DataView) {
    this.groupsData = groups;
  } else {
    throw new TypeError('Data must be an instance of DataSet or DataView');
  }

  if (this.groupsData) {
    // subscribe to new dataset
    var id = this.id;
    util.forEach(this.groupListeners, function (callback, event) {
      me.groupsData.on(event, callback, id);
    });

    // draw all ms
    ids = this.groupsData.getIds();
    this._onAddGroups(ids);
  }

  // update the group holding all ungrouped items
  this._updateUngrouped();

  // update the order of all items in each group
  this._order();

  this.body.emitter.emit('change', { queue: true });
};

/**
 * Get the current groups
 * @returns {vis.DataSet | null} groups
 */
ItemSet.prototype.getGroups = function () {
  return this.groupsData;
};

/**
 * Remove an item by its id
 * @param {String | Number} id
 */
ItemSet.prototype.removeItem = function (id) {
  var item = this.itemsData.get(id),
      dataset = this.itemsData.getDataSet();

  if (item) {
    // confirm deletion
    this.options.onRemove(item, function (item) {
      if (item) {
        // remove by id here, it is possible that an item has no id defined
        // itself, so better not delete by the item itself
        dataset.remove(id);
      }
    });
  }
};

/**
 * Get the time of an item based on it's data and options.type
 * @param {Object} itemData
 * @returns {string} Returns the type
 * @private
 */
ItemSet.prototype._getType = function (itemData) {
  return itemData.type || this.options.type || (itemData.end ? 'range' : 'box');
};

/**
 * Get the group id for an item
 * @param {Object} itemData
 * @returns {string} Returns the groupId
 * @private
 */
ItemSet.prototype._getGroupId = function (itemData) {
  var type = this._getType(itemData);
  if (type == 'background' && itemData.group == undefined) {
    return BACKGROUND;
  } else {
    return this.groupsData ? itemData.group : UNGROUPED;
  }
};

/**
 * Handle updated items
 * @param {Number[]} ids
 * @protected
 */
ItemSet.prototype._onUpdate = function (ids) {
  var me = this;

  ids.forEach((function (id) {
    var itemData = me.itemsData.get(id, me.itemOptions);
    var item = me.items[id];
    var type = me._getType(itemData);

    var constructor = ItemSet.types[type];
    var selected;

    if (item) {
      // update item
      if (!constructor || !(item instanceof constructor)) {
        // item type has changed, delete the item and recreate it
        selected = item.selected; // preserve selection of this item
        me._removeItem(item);
        item = null;
      } else {
        me._updateItem(item, itemData);
      }
    }

    if (!item) {
      // create item
      if (constructor) {
        item = new constructor(itemData, me.conversion, me.options);
        item.id = id; // TODO: not so nice setting id afterwards
        me._addItem(item);
        if (selected) {
          this.selection.push(id);
          item.select();
        }
      } else if (type == 'rangeoverflow') {
        // TODO: deprecated since version 2.1.0 (or 3.0.0?). cleanup some day
        throw new TypeError('Item type "rangeoverflow" is deprecated. Use css styling instead: ' + '.vis-item.vis-range .vis-item-content {overflow: visible;}');
      } else {
        throw new TypeError('Unknown item type "' + type + '"');
      }
    }
  }).bind(this));

  this._order();
  this.stackDirty = true; // force re-stacking of all items next redraw
  this.body.emitter.emit('change', { queue: true });
};

/**
 * Handle added items
 * @param {Number[]} ids
 * @protected
 */
ItemSet.prototype._onAdd = ItemSet.prototype._onUpdate;

/**
 * Handle removed items
 * @param {Number[]} ids
 * @protected
 */
ItemSet.prototype._onRemove = function (ids) {
  var count = 0;
  var me = this;
  ids.forEach(function (id) {
    var item = me.items[id];
    if (item) {
      count++;
      me._removeItem(item);
    }
  });

  if (count) {
    // update order
    this._order();
    this.stackDirty = true; // force re-stacking of all items next redraw
    this.body.emitter.emit('change', { queue: true });
  }
};

/**
 * Update the order of item in all groups
 * @private
 */
ItemSet.prototype._order = function () {
  // reorder the items in all groups
  // TODO: optimization: only reorder groups affected by the changed items
  util.forEach(this.groups, function (group) {
    group.order();
  });
};

/**
 * Handle updated groups
 * @param {Number[]} ids
 * @private
 */
ItemSet.prototype._onUpdateGroups = function (ids) {
  this._onAddGroups(ids);
};

/**
 * Handle changed groups (added or updated)
 * @param {Number[]} ids
 * @private
 */
ItemSet.prototype._onAddGroups = function (ids) {
  var me = this;

  ids.forEach(function (id) {
    var groupData = me.groupsData.get(id);
    var group = me.groups[id];

    if (!group) {
      // check for reserved ids
      if (id == UNGROUPED || id == BACKGROUND) {
        throw new Error('Illegal group id. ' + id + ' is a reserved id.');
      }

      var groupOptions = Object.create(me.options);
      util.extend(groupOptions, {
        height: null
      });

      group = new Group(id, groupData, me);
      me.groups[id] = group;

      // add items with this groupId to the new group
      for (var itemId in me.items) {
        if (me.items.hasOwnProperty(itemId)) {
          var item = me.items[itemId];
          if (item.data.group == id) {
            group.add(item);
          }
        }
      }

      group.order();
      group.show();
    } else {
      // update group
      group.setData(groupData);
    }
  });

  this.body.emitter.emit('change', { queue: true });
};

/**
 * Handle removed groups
 * @param {Number[]} ids
 * @private
 */
ItemSet.prototype._onRemoveGroups = function (ids) {
  var groups = this.groups;
  ids.forEach(function (id) {
    var group = groups[id];

    if (group) {
      group.hide();
      delete groups[id];
    }
  });

  this.markDirty();

  this.body.emitter.emit('change', { queue: true });
};

/**
 * Reorder the groups if needed
 * @return {boolean} changed
 * @private
 */
ItemSet.prototype._orderGroups = function () {
  if (this.groupsData) {
    // reorder the groups
    var groupIds = this.groupsData.getIds({
      order: this.options.groupOrder
    });

    var changed = !util.equalArray(groupIds, this.groupIds);
    if (changed) {
      // hide all groups, removes them from the DOM
      var groups = this.groups;
      groupIds.forEach(function (groupId) {
        groups[groupId].hide();
      });

      // show the groups again, attach them to the DOM in correct order
      groupIds.forEach(function (groupId) {
        groups[groupId].show();
      });

      this.groupIds = groupIds;
    }

    return changed;
  } else {
    return false;
  }
};

/**
 * Add a new item
 * @param {Item} item
 * @private
 */
ItemSet.prototype._addItem = function (item) {
  this.items[item.id] = item;

  // add to group
  var groupId = this._getGroupId(item.data);
  var group = this.groups[groupId];
  if (group) group.add(item);
};

/**
 * Update an existing item
 * @param {Item} item
 * @param {Object} itemData
 * @private
 */
ItemSet.prototype._updateItem = function (item, itemData) {
  var oldGroupId = item.data.group;
  var oldSubGroupId = item.data.subgroup;

  // update the items data (will redraw the item when displayed)
  item.setData(itemData);

  // update group
  if (oldGroupId != item.data.group || oldSubGroupId != item.data.subgroup) {
    var oldGroup = this.groups[oldGroupId];
    if (oldGroup) oldGroup.remove(item);

    var groupId = this._getGroupId(item.data);
    var group = this.groups[groupId];
    if (group) group.add(item);
  }
};

/**
 * Delete an item from the ItemSet: remove it from the DOM, from the map
 * with items, and from the map with visible items, and from the selection
 * @param {Item} item
 * @private
 */
ItemSet.prototype._removeItem = function (item) {
  // remove from DOM
  item.hide();

  // remove from items
  delete this.items[item.id];

  // remove from selection
  var index = this.selection.indexOf(item.id);
  if (index != -1) this.selection.splice(index, 1);

  // remove from group
  item.parent && item.parent.remove(item);
};

/**
 * Create an array containing all items being a range (having an end date)
 * @param array
 * @returns {Array}
 * @private
 */
ItemSet.prototype._constructByEndArray = function (array) {
  var endArray = [];

  for (var i = 0; i < array.length; i++) {
    if (array[i] instanceof RangeItem) {
      endArray.push(array[i]);
    }
  }
  return endArray;
};

/**
 * Register the clicked item on touch, before dragStart is initiated.
 *
 * dragStart is initiated from a mousemove event, AFTER the mouse/touch is
 * already moving. Therefore, the mouse/touch can sometimes be above an other
 * DOM element than the item itself.
 *
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onTouch = function (event) {
  // store the touched item, used in _onDragStart
  this.touchParams.item = this.itemFromTarget(event);
  this.touchParams.dragLeftItem = event.target.dragLeftItem || false;
  this.touchParams.dragRightItem = event.target.dragRightItem || false;
  this.touchParams.itemProps = null;
};

/**
 * Given an group id, returns the index it has.
 *
 * @param {Number} groupID
 * @private
 */
ItemSet.prototype._getGroupIndex = function (groupId) {
  for (var i = 0; i < this.groupIds.length; i++) {
    if (groupId == this.groupIds[i]) return i;
  }
};

/**
 * Start dragging the selected events
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDragStart = function (event) {
  var item = this.touchParams.item || null;
  var me = this;
  var props;

  if (item && item.selected) {

    if (!this.options.editable.updateTime && !this.options.editable.updateGroup && !item.editable) {
      return;
    }

    // override options.editable
    if (item.editable === false) {
      return;
    }

    var dragLeftItem = this.touchParams.dragLeftItem;
    var dragRightItem = this.touchParams.dragRightItem;

    if (dragLeftItem) {
      props = {
        item: dragLeftItem,
        initialX: event.center.x,
        dragLeft: true,
        data: this._cloneItemData(item.data)
      };

      this.touchParams.itemProps = [props];
    } else if (dragRightItem) {
      props = {
        item: dragRightItem,
        initialX: event.center.x,
        dragRight: true,
        data: this._cloneItemData(item.data)
      };

      this.touchParams.itemProps = [props];
    } else {
      this.touchParams.selectedItem = item;

      var baseGroupIndex = this._getGroupIndex(item.data.group);

      this.touchParams.itemProps = this.getSelection().map((function (id) {
        var item = me.items[id];
        var groupIndex = me._getGroupIndex(item.data.group);
        return {
          item: item,
          initialX: event.center.x,
          groupOffset: baseGroupIndex - groupIndex,
          data: this._cloneItemData(item.data)
        };
      }).bind(this));
    }

    event.stopPropagation();
  } else if (this.options.editable.add && (event.srcEvent.ctrlKey || event.srcEvent.metaKey)) {
    // create a new range item when dragging with ctrl key down
    this._onDragStartAddItem(event);
  }
};

/**
 * Start creating a new range item by dragging.
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDragStartAddItem = function (event) {
  var snap = this.options.snap || null;
  var xAbs = util.getAbsoluteLeft(this.dom.frame);
  var x = event.center.x - xAbs - 10; // minus 10 to compensate for the drag starting as soon as you've moved 10px
  var time = this.body.util.toTime(x);
  var scale = this.body.util.getScale();
  var step = this.body.util.getStep();
  var start = snap ? snap(time, scale, step) : start;
  var end = start;

  var itemData = {
    type: 'range',
    start: start,
    end: end,
    content: 'new item'
  };

  var id = util.randomUUID();
  itemData[this.itemsData._fieldId] = id;

  var group = this.groupFromTarget(event);
  if (group) {
    itemData.group = group.groupId;
  }

  var newItem = new RangeItem(itemData, this.conversion, this.options);
  newItem.id = id; // TODO: not so nice setting id afterwards
  newItem.data = this._cloneItemData(itemData);
  this._addItem(newItem);

  var props = {
    item: newItem,
    dragRight: true,
    initialX: event.center.x,
    data: newItem.data
  };
  this.touchParams.itemProps = [props];

  event.stopPropagation();
};

/**
 * Drag selected items
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDrag = function (event) {
  if (this.touchParams.itemProps) {
    event.stopPropagation();

    var me = this;
    var snap = this.options.snap || null;
    var xOffset = this.body.dom.root.offsetLeft + this.body.domProps.left.width;
    var scale = this.body.util.getScale();
    var step = this.body.util.getStep();

    //only calculate the new group for the item that's actually dragged
    var selectedItem = this.touchParams.selectedItem;
    var updateGroupAllowed = me.options.editable.updateGroup;
    var newGroupBase = null;
    if (updateGroupAllowed && selectedItem) {
      if (selectedItem.data.group != undefined) {
        // drag from one group to another
        var group = me.groupFromTarget(event);
        if (group) {
          //we know the offset for all items, so the new group for all items
          //will be relative to this one.
          newGroupBase = this._getGroupIndex(group.groupId);
        }
      }
    }

    // move
    this.touchParams.itemProps.forEach((function (props) {
      var current = me.body.util.toTime(event.center.x - xOffset);
      var initial = me.body.util.toTime(props.initialX - xOffset);
      var offset = current - initial; // ms

      var itemData = this._cloneItemData(props.item.data); // clone the data
      if (props.item.editable === false) {
        return;
      }

      var updateTimeAllowed = me.options.editable.updateTime || props.item.editable === true;

      if (updateTimeAllowed) {
        if (props.dragLeft) {
          // drag left side of a range item
          if (itemData.start != undefined) {
            var initialStart = util.convert(props.data.start, 'Date');
            var start = new Date(initialStart.valueOf() + offset);
            // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
            itemData.start = snap ? snap(start, scale, step) : start;
          }
        } else if (props.dragRight) {
          // drag right side of a range item
          if (itemData.end != undefined) {
            var initialEnd = util.convert(props.data.end, 'Date');
            var end = new Date(initialEnd.valueOf() + offset);
            // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
            itemData.end = snap ? snap(end, scale, step) : end;
          }
        } else {
          // drag both start and end
          if (itemData.start != undefined) {
            var initialStart = util.convert(props.data.start, 'Date').valueOf();
            var start = new Date(initialStart + offset);

            if (itemData.end != undefined) {
              var initialEnd = util.convert(props.data.end, 'Date');
              var duration = initialEnd.valueOf() - initialStart.valueOf();

              // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
              itemData.start = snap ? snap(start, scale, step) : start;
              itemData.end = new Date(itemData.start.valueOf() + duration);
            } else {
              // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
              itemData.start = snap ? snap(start, scale, step) : start;
            }
          }
        }
      }

      var updateGroupAllowed = me.options.editable.updateGroup || props.item.editable === true;

      if (updateGroupAllowed && !props.dragLeft && !props.dragRight && newGroupBase != null) {
        if (itemData.group != undefined) {
          var newOffset = newGroupBase - props.groupOffset;

          //make sure we stay in bounds
          newOffset = Math.max(0, newOffset);
          newOffset = Math.min(me.groupIds.length - 1, newOffset);

          itemData.group = me.groupIds[newOffset];
        }
      }

      // confirm moving the item
      itemData = this._cloneItemData(itemData); // convert start and end to the correct type
      me.options.onMoving(itemData, (function (itemData) {
        if (itemData) {
          props.item.setData(this._cloneItemData(itemData, 'Date'));
        }
      }).bind(this));
    }).bind(this));

    this.stackDirty = true; // force re-stacking of all items next redraw
    this.body.emitter.emit('change');
  }
};

/**
 * Move an item to another group
 * @param {Item} item
 * @param {String | Number} groupId
 * @private
 */
ItemSet.prototype._moveToGroup = function (item, groupId) {
  var group = this.groups[groupId];
  if (group && group.groupId != item.data.group) {
    var oldGroup = item.parent;
    oldGroup.remove(item);
    oldGroup.order();
    group.add(item);
    group.order();

    item.data.group = group.groupId;
  }
};

/**
 * End of dragging selected items
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDragEnd = function (event) {
  if (this.touchParams.itemProps) {
    event.stopPropagation();

    var me = this;
    var dataset = this.itemsData.getDataSet();
    var itemProps = this.touchParams.itemProps;
    this.touchParams.itemProps = null;

    itemProps.forEach((function (props) {
      var id = props.item.id;
      var exists = me.itemsData.get(id, me.itemOptions) != null;

      if (!exists) {
        // add a new item
        me.options.onAdd(props.item.data, function (itemData) {
          me._removeItem(props.item); // remove temporary item
          if (itemData) {
            me.itemsData.getDataSet().add(itemData);
          }

          // force re-stacking of all items next redraw
          me.stackDirty = true;
          me.body.emitter.emit('change');
        });
      } else {
        // update existing item
        var itemData = this._cloneItemData(props.item.data); // convert start and end to the correct type
        me.options.onMove(itemData, function (itemData) {
          if (itemData) {
            // apply changes
            itemData[dataset._fieldId] = id; // ensure the item contains its id (can be undefined)
            dataset.update(itemData);
          } else {
            // restore original values
            props.item.setData(props.data);

            me.stackDirty = true; // force re-stacking of all items next redraw
            me.body.emitter.emit('change');
          }
        });
      }
    }).bind(this));
  }
};

ItemSet.prototype._onGroupDragStart = function (event) {
  if (this.options.groupEditable.order) {
    this.groupTouchParams.group = this.groupFromTarget(event);

    if (this.groupTouchParams.group) {
      event.stopPropagation();

      this.groupTouchParams.originalOrder = this.groupsData.getIds({
        order: this.options.groupOrder
      });
    }
  }
};

ItemSet.prototype._onGroupDrag = function (event) {
  if (this.options.groupEditable.order && this.groupTouchParams.group) {
    event.stopPropagation();

    // drag from one group to another
    var group = this.groupFromTarget(event);

    // try to avoid toggling when groups differ in height
    if (group && group.height != this.groupTouchParams.group.height) {
      var movingUp = group.top < this.groupTouchParams.group.top;
      var clientY = event.center ? event.center.y : event.clientY;
      var targetGroupTop = util.getAbsoluteTop(group.dom.foreground);
      var draggedGroupHeight = this.groupTouchParams.group.height;
      if (movingUp) {
        // skip swapping the groups when the dragged group is not below clientY afterwards
        if (targetGroupTop + draggedGroupHeight < clientY) {
          return;
        }
      } else {
        var targetGroupHeight = group.height;
        // skip swapping the groups when the dragged group is not below clientY afterwards
        if (targetGroupTop + targetGroupHeight - draggedGroupHeight > clientY) {
          return;
        }
      }
    }

    if (group && group != this.groupTouchParams.group) {
      var groupsData = this.groupsData;
      var targetGroup = groupsData.get(group.groupId);
      var draggedGroup = groupsData.get(this.groupTouchParams.group.groupId);

      // switch groups
      if (draggedGroup && targetGroup) {
        this.options.groupOrderSwap(draggedGroup, targetGroup, this.groupsData);
        this.groupsData.update(draggedGroup);
        this.groupsData.update(targetGroup);
      }

      // fetch current order of groups
      var newOrder = this.groupsData.getIds({
        order: this.options.groupOrder
      });

      // in case of changes since _onGroupDragStart
      if (!util.equalArray(newOrder, this.groupTouchParams.originalOrder)) {
        var groupsData = this.groupsData;
        var origOrder = this.groupTouchParams.originalOrder;
        var draggedId = this.groupTouchParams.group.groupId;
        var numGroups = Math.min(origOrder.length, newOrder.length);
        var curPos = 0;
        var newOffset = 0;
        var orgOffset = 0;
        while (curPos < numGroups) {
          // as long as the groups are where they should be step down along the groups order
          while (curPos + newOffset < numGroups && curPos + orgOffset < numGroups && newOrder[curPos + newOffset] == origOrder[curPos + orgOffset]) {
            curPos++;
          }

          // all ok
          if (curPos + newOffset >= numGroups) {
            break;
          }

          // not all ok
          // if dragged group was move upwards everything below should have an offset
          if (newOrder[curPos + newOffset] == draggedId) {
            newOffset = 1;
            continue;
          }
          // if dragged group was move downwards everything above should have an offset
          else if (origOrder[curPos + orgOffset] == draggedId) {
              orgOffset = 1;
              continue;
            }
            // found a group (apart from dragged group) that has the wrong position -> switch with the
            // group at the position where other one should be, fix index arrays and continue
            else {
                var slippedPosition = newOrder.indexOf(origOrder[curPos + orgOffset]);
                var switchGroup = groupsData.get(newOrder[curPos + newOffset]);
                var shouldBeGroup = groupsData.get(origOrder[curPos + orgOffset]);
                this.options.groupOrderSwap(switchGroup, shouldBeGroup, groupsData);
                groupsData.update(switchGroup);
                groupsData.update(shouldBeGroup);

                var switchGroupId = newOrder[curPos + newOffset];
                newOrder[curPos + newOffset] = origOrder[curPos + orgOffset];
                newOrder[slippedPosition] = switchGroupId;

                curPos++;
              }
        }
      }
    }
  }
};

ItemSet.prototype._onGroupDragEnd = function (event) {
  if (this.options.groupEditable.order && this.groupTouchParams.group) {
    event.stopPropagation();

    // update existing group
    var me = this;
    var id = me.groupTouchParams.group.groupId;
    var dataset = me.groupsData.getDataSet();
    var groupData = util.extend({}, dataset.get(id)); // clone the data
    me.options.onMoveGroup(groupData, function (groupData) {
      if (groupData) {
        // apply changes
        groupData[dataset._fieldId] = id; // ensure the group contains its id (can be undefined)
        dataset.update(groupData);
      } else {

        // fetch current order of groups
        var newOrder = dataset.getIds({
          order: me.options.groupOrder
        });

        // restore original order
        if (!util.equalArray(newOrder, me.groupTouchParams.originalOrder)) {
          var origOrder = me.groupTouchParams.originalOrder;
          var numGroups = Math.min(origOrder.length, newOrder.length);
          var curPos = 0;
          while (curPos < numGroups) {
            // as long as the groups are where they should be step down along the groups order
            while (curPos < numGroups && newOrder[curPos] == origOrder[curPos]) {
              curPos++;
            }

            // all ok
            if (curPos >= numGroups) {
              break;
            }

            // found a group that has the wrong position -> switch with the
            // group at the position where other one should be, fix index arrays and continue
            var slippedPosition = newOrder.indexOf(origOrder[curPos]);
            var switchGroup = dataset.get(newOrder[curPos]);
            var shouldBeGroup = dataset.get(origOrder[curPos]);
            me.options.groupOrderSwap(switchGroup, shouldBeGroup, dataset);
            groupsData.update(switchGroup);
            groupsData.update(shouldBeGroup);

            var switchGroupId = newOrder[curPos];
            newOrder[curPos] = origOrder[curPos];
            newOrder[slippedPosition] = switchGroupId;

            curPos++;
          }
        }
      }
    });

    me.body.emitter.emit('groupDragged', { groupId: id });
  }
};

/**
 * Handle selecting/deselecting an item when tapping it
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onSelectItem = function (event) {
  if (!this.options.selectable) return;

  var ctrlKey = event.srcEvent && (event.srcEvent.ctrlKey || event.srcEvent.metaKey);
  var shiftKey = event.srcEvent && event.srcEvent.shiftKey;
  if (ctrlKey || shiftKey) {
    this._onMultiSelectItem(event);
    return;
  }

  var oldSelection = this.getSelection();

  var item = this.itemFromTarget(event);
  var selection = item ? [item.id] : [];
  this.setSelection(selection);

  var newSelection = this.getSelection();

  // emit a select event,
  // except when old selection is empty and new selection is still empty
  if (newSelection.length > 0 || oldSelection.length > 0) {
    this.body.emitter.emit('select', {
      items: newSelection,
      event: event
    });
  }
};

/**
 * Handle creation and updates of an item on double tap
 * @param event
 * @private
 */
ItemSet.prototype._onAddItem = function (event) {
  if (!this.options.selectable) return;
  if (!this.options.editable.add) return;

  var me = this;
  var snap = this.options.snap || null;
  var item = this.itemFromTarget(event);

  event.stopPropagation();

  if (item) {
    // update item

    // execute async handler to update the item (or cancel it)
    var itemData = me.itemsData.get(item.id); // get a clone of the data from the dataset
    this.options.onUpdate(itemData, function (itemData) {
      if (itemData) {
        me.itemsData.getDataSet().update(itemData);
      }
    });
  } else {
    // add item
    var xAbs = util.getAbsoluteLeft(this.dom.frame);
    var x = event.center.x - xAbs;
    var start = this.body.util.toTime(x);
    var scale = this.body.util.getScale();
    var step = this.body.util.getStep();

    var newItemData = {
      start: snap ? snap(start, scale, step) : start,
      content: 'new item'
    };

    // when default type is a range, add a default end date to the new item
    if (this.options.type === 'range') {
      var end = this.body.util.toTime(x + this.props.width / 5);
      newItemData.end = snap ? snap(end, scale, step) : end;
    }

    newItemData[this.itemsData._fieldId] = util.randomUUID();

    var group = this.groupFromTarget(event);
    if (group) {
      newItemData.group = group.groupId;
    }

    // execute async handler to customize (or cancel) adding an item
    newItemData = this._cloneItemData(newItemData); // convert start and end to the correct type
    this.options.onAdd(newItemData, function (item) {
      if (item) {
        me.itemsData.getDataSet().add(item);
        // TODO: need to trigger a redraw?
      }
    });
  }
};

/**
 * Handle selecting/deselecting multiple items when holding an item
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onMultiSelectItem = function (event) {
  if (!this.options.selectable) return;

  var item = this.itemFromTarget(event);

  if (item) {
    // multi select items (if allowed)

    var selection = this.options.multiselect ? this.getSelection() // take current selection
    : []; // deselect current selection

    var shiftKey = event.srcEvent && event.srcEvent.shiftKey || false;

    if (shiftKey && this.options.multiselect) {
      // select all items between the old selection and the tapped item

      // determine the selection range
      selection.push(item.id);
      var range = ItemSet._getItemRange(this.itemsData.get(selection, this.itemOptions));

      // select all items within the selection range
      selection = [];
      for (var id in this.items) {
        if (this.items.hasOwnProperty(id)) {
          var _item = this.items[id];
          var start = _item.data.start;
          var end = _item.data.end !== undefined ? _item.data.end : start;

          if (start >= range.min && end <= range.max && !(_item instanceof BackgroundItem)) {
            selection.push(_item.id); // do not use id but item.id, id itself is stringified
          }
        }
      }
    } else {
        // add/remove this item from the current selection
        var index = selection.indexOf(item.id);
        if (index == -1) {
          // item is not yet selected -> select it
          selection.push(item.id);
        } else {
          // item is already selected -> deselect it
          selection.splice(index, 1);
        }
      }

    this.setSelection(selection);

    this.body.emitter.emit('select', {
      items: this.getSelection(),
      event: event
    });
  }
};

/**
 * Calculate the time range of a list of items
 * @param {Array.<Object>} itemsData
 * @return {{min: Date, max: Date}} Returns the range of the provided items
 * @private
 */
ItemSet._getItemRange = function (itemsData) {
  var max = null;
  var min = null;

  itemsData.forEach(function (data) {
    if (min == null || data.start < min) {
      min = data.start;
    }

    if (data.end != undefined) {
      if (max == null || data.end > max) {
        max = data.end;
      }
    } else {
      if (max == null || data.start > max) {
        max = data.start;
      }
    }
  });

  return {
    min: min,
    max: max
  };
};

/**
 * Find an item from an event target:
 * searches for the attribute 'timeline-item' in the event target's element tree
 * @param {Event} event
 * @return {Item | null} item
 */
ItemSet.prototype.itemFromTarget = function (event) {
  var target = event.target;
  while (target) {
    if (target.hasOwnProperty('timeline-item')) {
      return target['timeline-item'];
    }
    target = target.parentNode;
  }

  return null;
};

/**
 * Find the Group from an event target:
 * searches for the attribute 'timeline-group' in the event target's element tree
 * @param {Event} event
 * @return {Group | null} group
 */
ItemSet.prototype.groupFromTarget = function (event) {
  var clientY = event.center ? event.center.y : event.clientY;
  for (var i = 0; i < this.groupIds.length; i++) {
    var groupId = this.groupIds[i];
    var group = this.groups[groupId];
    var foreground = group.dom.foreground;
    var top = util.getAbsoluteTop(foreground);
    if (clientY > top && clientY < top + foreground.offsetHeight) {
      return group;
    }

    if (this.options.orientation.item === 'top') {
      if (i === this.groupIds.length - 1 && clientY > top) {
        return group;
      }
    } else {
      if (i === 0 && clientY < top + foreground.offset) {
        return group;
      }
    }
  }

  return null;
};

/**
 * Find the ItemSet from an event target:
 * searches for the attribute 'timeline-itemset' in the event target's element tree
 * @param {Event} event
 * @return {ItemSet | null} item
 */
ItemSet.itemSetFromTarget = function (event) {
  var target = event.target;
  while (target) {
    if (target.hasOwnProperty('timeline-itemset')) {
      return target['timeline-itemset'];
    }
    target = target.parentNode;
  }

  return null;
};

/**
 * Clone the data of an item, and "normalize" it: convert the start and end date
 * to the type (Date, Moment, ...) configured in the DataSet. If not configured,
 * start and end are converted to Date.
 * @param {Object} itemData, typically `item.data`
 * @param {string} [type]  Optional Date type. If not provided, the type from the DataSet is taken
 * @return {Object} The cloned object
 * @private
 */
ItemSet.prototype._cloneItemData = function (itemData, type) {
  var clone = util.extend({}, itemData);

  if (!type) {
    // convert start and end date to the type (Date, Moment, ...) configured in the DataSet
    type = this.itemsData.getDataSet()._options.type;
  }

  if (clone.start != undefined) {
    clone.start = util.convert(clone.start, type && type.start || 'Date');
  }
  if (clone.end != undefined) {
    clone.end = util.convert(clone.end, type && type.end || 'Date');
  }

  return clone;
};

module.exports = ItemSet;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L0l0ZW1TZXQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQztBQUM1QyxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDakMsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQ3ZDLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0FBQ3pDLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN0QyxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDdkMsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQy9CLElBQUksZUFBZSxHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQ25ELElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0FBQ3hDLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQzVDLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQzVDLElBQUksY0FBYyxHQUFHLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDOztBQUd0RCxJQUFJLFNBQVMsR0FBRyxlQUFlLENBQUM7QUFDaEMsSUFBSSxVQUFVLEdBQUcsZ0JBQWdCLENBQUM7Ozs7Ozs7Ozs7O0FBV2xDLFNBQVMsT0FBTyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUU7QUFDOUIsTUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7O0FBRWpCLE1BQUksQ0FBQyxjQUFjLEdBQUc7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RCxNQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQzs7QUFFdEMsTUFBSSxDQUFDLElBQUksRUFBRTs7QUFFVCxRQUFJLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO0dBQ2xEOztBQUVELE1BQUksS0FBSyxDQUFDLEtBQUssSUFBSSxTQUFTLEVBQUU7QUFDNUIsU0FBSyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsSUFBSSxJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksTUFBTSxDQUFDLENBQUM7R0FDdkU7QUFDRCxNQUFJLEtBQUssQ0FBQyxHQUFHLElBQUksU0FBUyxFQUFFO0FBQzFCLFNBQUssQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFHLElBQUksSUFBSSxJQUFJLENBQUMsR0FBRyxJQUFJLE1BQU0sQ0FBQyxDQUFDO0dBQ2xFOztBQUVELFNBQU8sS0FBSyxDQUFDO0NBQ2QsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyIsImZpbGUiOiIvVXNlcnMvZGFyaW4vRGV2ZWxvcG1lbnQvbWFwc3Rvcnkvc3RvcnktdG9vbHMtdmlld2VyL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9JdGVtU2V0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEhhbW1lciA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZS9oYW1tZXInKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIERhdGFTZXQgPSByZXF1aXJlKCcuLi8uLi9EYXRhU2V0Jyk7XG52YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuLi8uLi9EYXRhVmlldycpO1xudmFyIFRpbWVTdGVwID0gcmVxdWlyZSgnLi4vVGltZVN0ZXAnKTtcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuL0NvbXBvbmVudCcpO1xudmFyIEdyb3VwID0gcmVxdWlyZSgnLi9Hcm91cCcpO1xudmFyIEJhY2tncm91bmRHcm91cCA9IHJlcXVpcmUoJy4vQmFja2dyb3VuZEdyb3VwJyk7XG52YXIgQm94SXRlbSA9IHJlcXVpcmUoJy4vaXRlbS9Cb3hJdGVtJyk7XG52YXIgUG9pbnRJdGVtID0gcmVxdWlyZSgnLi9pdGVtL1BvaW50SXRlbScpO1xudmFyIFJhbmdlSXRlbSA9IHJlcXVpcmUoJy4vaXRlbS9SYW5nZUl0ZW0nKTtcbnZhciBCYWNrZ3JvdW5kSXRlbSA9IHJlcXVpcmUoJy4vaXRlbS9CYWNrZ3JvdW5kSXRlbScpO1xuXG5cbnZhciBVTkdST1VQRUQgPSAnX191bmdyb3VwZWRfXyc7ICAgLy8gcmVzZXJ2ZWQgZ3JvdXAgaWQgZm9yIHVuZ3JvdXBlZCBpdGVtc1xudmFyIEJBQ0tHUk9VTkQgPSAnX19iYWNrZ3JvdW5kX18nOyAvLyByZXNlcnZlZCBncm91cCBpZCBmb3IgYmFja2dyb3VuZCBpdGVtcyB3aXRob3V0IGdyb3VwXG5cbi8qKlxuICogQW4gSXRlbVNldCBob2xkcyBhIHNldCBvZiBpdGVtcyBhbmQgcmFuZ2VzIHdoaWNoIGNhbiBiZSBkaXNwbGF5ZWQgaW4gYVxuICogcmFuZ2UuIFRoZSB3aWR0aCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBwYXJlbnQgb2YgdGhlIEl0ZW1TZXQsIGFuZCB0aGUgaGVpZ2h0XG4gKiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBzaXplIG9mIHRoZSBpdGVtcy5cbiAqIEBwYXJhbSB7e2RvbTogT2JqZWN0LCBkb21Qcm9wczogT2JqZWN0LCBlbWl0dGVyOiBFbWl0dGVyLCByYW5nZTogUmFuZ2V9fSBib2R5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgU2VlIEl0ZW1TZXQuc2V0T3B0aW9ucyBmb3IgdGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuICogQGNvbnN0cnVjdG9yIEl0ZW1TZXRcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5mdW5jdGlvbiBJdGVtU2V0KGJvZHksIG9wdGlvbnMpIHtcbiAgdGhpcy5ib2R5ID0gYm9keTtcblxuICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIHR5cGU6IG51bGwsICAvLyAnYm94JywgJ3BvaW50JywgJ3JhbmdlJywgJ2JhY2tncm91bmQnXG4gICAgb3JpZW50YXRpb246IHtcbiAgICAgIGl0ZW06ICdib3R0b20nICAgLy8gaXRlbSBvcmllbnRhdGlvbjogJ3RvcCcgb3IgJ2JvdHRvbSdcbiAgICB9LFxuICAgIGFsaWduOiAnYXV0bycsIC8vIGFsaWdubWVudCBvZiBib3ggaXRlbXNcbiAgICBzdGFjazogdHJ1ZSxcbiAgICBncm91cE9yZGVyU3dhcDogZnVuY3Rpb24oZnJvbUdyb3VwLCB0b0dyb3VwLCBncm91cHMpIHtcbiAgICBcdHZhciB0YXJnZXRPcmRlciA9IHRvR3JvdXAub3JkZXI7XG4gICAgXHR0b0dyb3VwLm9yZGVyID0gZnJvbUdyb3VwLm9yZGVyO1xuICAgIFx0ZnJvbUdyb3VwLm9yZGVyID0gdGFyZ2V0T3JkZXI7XG4gICAgfSxcbiAgICBncm91cE9yZGVyOiAnb3JkZXInLFxuXG4gICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICBtdWx0aXNlbGVjdDogZmFsc2UsXG5cbiAgICBlZGl0YWJsZToge1xuICAgICAgdXBkYXRlVGltZTogZmFsc2UsXG4gICAgICB1cGRhdGVHcm91cDogZmFsc2UsXG4gICAgICBhZGQ6IGZhbHNlLFxuICAgICAgcmVtb3ZlOiBmYWxzZVxuICAgIH0sXG5cbiAgICBncm91cEVkaXRhYmxlOiB7XG4gICAgICBvcmRlcjogZmFsc2UsXG4gICAgICBhZGQ6IGZhbHNlLFxuICAgICAgcmVtb3ZlOiBmYWxzZVxuICAgIH0sICAgIFxuICAgIFxuICAgIHNuYXA6IFRpbWVTdGVwLnNuYXAsXG5cbiAgICBvbkFkZDogZnVuY3Rpb24gKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICB9LFxuICAgIG9uVXBkYXRlOiBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgIH0sXG4gICAgb25Nb3ZlOiBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgIH0sXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uIChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgfSxcbiAgICBvbk1vdmluZzogZnVuY3Rpb24gKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICB9LFxuICAgIG9uQWRkR3JvdXA6IGZ1bmN0aW9uIChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgfSxcbiAgICBvbk1vdmVHcm91cDogZnVuY3Rpb24gKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICB9LFxuICAgIG9uUmVtb3ZlR3JvdXA6IGZ1bmN0aW9uIChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgfSxcblxuICAgIG1hcmdpbjoge1xuICAgICAgaXRlbToge1xuICAgICAgICBob3Jpem9udGFsOiAxMCxcbiAgICAgICAgdmVydGljYWw6IDEwXG4gICAgICB9LFxuICAgICAgYXhpczogMjBcbiAgICB9XG4gIH07XG5cbiAgLy8gb3B0aW9ucyBpcyBzaGFyZWQgYnkgdGhpcyBJdGVtU2V0IGFuZCBhbGwgaXRzIGl0ZW1zXG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAvLyBvcHRpb25zIGZvciBnZXR0aW5nIGl0ZW1zIGZyb20gdGhlIERhdGFTZXQgd2l0aCB0aGUgY29ycmVjdCB0eXBlXG4gIHRoaXMuaXRlbU9wdGlvbnMgPSB7XG4gICAgdHlwZToge3N0YXJ0OiAnRGF0ZScsIGVuZDogJ0RhdGUnfVxuICB9O1xuXG4gIHRoaXMuY29udmVyc2lvbiA9IHtcbiAgICB0b1NjcmVlbjogYm9keS51dGlsLnRvU2NyZWVuLFxuICAgIHRvVGltZTogYm9keS51dGlsLnRvVGltZVxuICB9O1xuICB0aGlzLmRvbSA9IHt9O1xuICB0aGlzLnByb3BzID0ge307XG4gIHRoaXMuaGFtbWVyID0gbnVsbDtcblxuICB2YXIgbWUgPSB0aGlzO1xuICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7ICAgIC8vIERhdGFTZXRcbiAgdGhpcy5ncm91cHNEYXRhID0gbnVsbDsgICAvLyBEYXRhU2V0XG5cbiAgLy8gbGlzdGVuZXJzIGZvciB0aGUgRGF0YVNldCBvZiB0aGUgaXRlbXNcbiAgdGhpcy5pdGVtTGlzdGVuZXJzID0ge1xuICAgICdhZGQnOiBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgIG1lLl9vbkFkZChwYXJhbXMuaXRlbXMpO1xuICAgIH0sXG4gICAgJ3VwZGF0ZSc6IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgbWUuX29uVXBkYXRlKHBhcmFtcy5pdGVtcyk7XG4gICAgfSxcbiAgICAncmVtb3ZlJzogZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICBtZS5fb25SZW1vdmUocGFyYW1zLml0ZW1zKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gbGlzdGVuZXJzIGZvciB0aGUgRGF0YVNldCBvZiB0aGUgZ3JvdXBzXG4gIHRoaXMuZ3JvdXBMaXN0ZW5lcnMgPSB7XG4gICAgJ2FkZCc6IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgbWUuX29uQWRkR3JvdXBzKHBhcmFtcy5pdGVtcyk7XG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICBtZS5fb25VcGRhdGVHcm91cHMocGFyYW1zLml0ZW1zKTtcbiAgICB9LFxuICAgICdyZW1vdmUnOiBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgIG1lLl9vblJlbW92ZUdyb3VwcyhwYXJhbXMuaXRlbXMpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLml0ZW1zID0ge307ICAgICAgLy8gb2JqZWN0IHdpdGggYW4gSXRlbSBmb3IgZXZlcnkgZGF0YSBpdGVtXG4gIHRoaXMuZ3JvdXBzID0ge307ICAgICAvLyBHcm91cCBvYmplY3QgZm9yIGV2ZXJ5IGdyb3VwXG4gIHRoaXMuZ3JvdXBJZHMgPSBbXTtcblxuICB0aGlzLnNlbGVjdGlvbiA9IFtdOyAgLy8gbGlzdCB3aXRoIHRoZSBpZHMgb2YgYWxsIHNlbGVjdGVkIG5vZGVzXG4gIHRoaXMuc3RhY2tEaXJ0eSA9IHRydWU7IC8vIGlmIHRydWUsIGFsbCBpdGVtcyB3aWxsIGJlIHJlc3RhY2tlZCBvbiBuZXh0IHJlZHJhd1xuXG4gIHRoaXMudG91Y2hQYXJhbXMgPSB7fTsgLy8gc3RvcmVzIHByb3BlcnRpZXMgd2hpbGUgZHJhZ2dpbmdcbiAgdGhpcy5ncm91cFRvdWNoUGFyYW1zID0ge307XG4gIC8vIGNyZWF0ZSB0aGUgSFRNTCBET01cblxuICB0aGlzLl9jcmVhdGUoKTtcblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG59XG5cbkl0ZW1TZXQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4vLyBhdmFpbGFibGUgaXRlbSB0eXBlcyB3aWxsIGJlIHJlZ2lzdGVyZWQgaGVyZVxuSXRlbVNldC50eXBlcyA9IHtcbiAgYmFja2dyb3VuZDogQmFja2dyb3VuZEl0ZW0sXG4gIGJveDogQm94SXRlbSxcbiAgcmFuZ2U6IFJhbmdlSXRlbSxcbiAgcG9pbnQ6IFBvaW50SXRlbVxufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIEhUTUwgRE9NIGZvciB0aGUgSXRlbVNldFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKXtcbiAgdmFyIGZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtaXRlbXNldCc7XG4gIGZyYW1lWyd0aW1lbGluZS1pdGVtc2V0J10gPSB0aGlzO1xuICB0aGlzLmRvbS5mcmFtZSA9IGZyYW1lO1xuXG4gIC8vIGNyZWF0ZSBiYWNrZ3JvdW5kIHBhbmVsXG4gIHZhciBiYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGJhY2tncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy1iYWNrZ3JvdW5kJztcbiAgZnJhbWUuYXBwZW5kQ2hpbGQoYmFja2dyb3VuZCk7XG4gIHRoaXMuZG9tLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuXG4gIC8vIGNyZWF0ZSBmb3JlZ3JvdW5kIHBhbmVsXG4gIHZhciBmb3JlZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGZvcmVncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy1mb3JlZ3JvdW5kJztcbiAgZnJhbWUuYXBwZW5kQ2hpbGQoZm9yZWdyb3VuZCk7XG4gIHRoaXMuZG9tLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kO1xuXG4gIC8vIGNyZWF0ZSBheGlzIHBhbmVsXG4gIHZhciBheGlzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGF4aXMuY2xhc3NOYW1lID0gJ3Zpcy1heGlzJztcbiAgdGhpcy5kb20uYXhpcyA9IGF4aXM7XG5cbiAgLy8gY3JlYXRlIGxhYmVsc2V0XG4gIHZhciBsYWJlbFNldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBsYWJlbFNldC5jbGFzc05hbWUgPSAndmlzLWxhYmVsc2V0JztcbiAgdGhpcy5kb20ubGFiZWxTZXQgPSBsYWJlbFNldDtcblxuICAvLyBjcmVhdGUgdW5ncm91cGVkIEdyb3VwXG4gIHRoaXMuX3VwZGF0ZVVuZ3JvdXBlZCgpO1xuXG4gIC8vIGNyZWF0ZSBiYWNrZ3JvdW5kIEdyb3VwXG4gIHZhciBiYWNrZ3JvdW5kR3JvdXAgPSBuZXcgQmFja2dyb3VuZEdyb3VwKEJBQ0tHUk9VTkQsIG51bGwsIHRoaXMpO1xuICBiYWNrZ3JvdW5kR3JvdXAuc2hvdygpO1xuICB0aGlzLmdyb3Vwc1tCQUNLR1JPVU5EXSA9IGJhY2tncm91bmRHcm91cDtcblxuICAvLyBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzXG4gIC8vIE5vdGU6IHdlIGJpbmQgdG8gdGhlIGNlbnRlckNvbnRhaW5lciBmb3IgdGhlIGNhc2Ugd2hlcmUgdGhlIGhlaWdodFxuICAvLyAgICAgICBvZiB0aGUgY2VudGVyIGNvbnRhaW5lciBpcyBsYXJnZXIgdGhhbiBvZiB0aGUgSXRlbVNldCwgc28gd2VcbiAgLy8gICAgICAgY2FuIGNsaWNrIGluIHRoZSBlbXB0eSBhcmVhIHRvIGNyZWF0ZSBhIG5ldyBpdGVtIG9yIGRlc2VsZWN0IGFuIGl0ZW0uXG4gIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLmJvZHkuZG9tLmNlbnRlckNvbnRhaW5lcik7XG5cbiAgLy8gZHJhZyBpdGVtcyB3aGVuIHNlbGVjdGVkXG4gIHRoaXMuaGFtbWVyLm9uKCdoYW1tZXIuaW5wdXQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuaXNGaXJzdCkge1xuICAgICAgdGhpcy5fb25Ub3VjaChldmVudCk7XG4gICAgfVxuICB9LmJpbmQodGhpcykpO1xuICB0aGlzLmhhbW1lci5vbigncGFuc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5oYW1tZXIub24oJ3Bhbm1vdmUnLCAgdGhpcy5fb25EcmFnLmJpbmQodGhpcykpO1xuICB0aGlzLmhhbW1lci5vbigncGFuZW5kJywgICB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKSk7XG4gIHRoaXMuaGFtbWVyLmdldCgncGFuJykuc2V0KHt0aHJlc2hvbGQ6NSwgZGlyZWN0aW9uOjMwfSk7IC8vIDMwIGlzIEFMTF9ESVJFQ1RJT05TIGluIGhhbW1lci5cblxuICAvLyBzaW5nbGUgc2VsZWN0IChvciB1bnNlbGVjdCkgd2hlbiB0YXBwaW5nIGFuIGl0ZW1cbiAgdGhpcy5oYW1tZXIub24oJ3RhcCcsICB0aGlzLl9vblNlbGVjdEl0ZW0uYmluZCh0aGlzKSk7XG5cbiAgLy8gbXVsdGkgc2VsZWN0IHdoZW4gaG9sZGluZyBtb3VzZS90b3VjaCwgb3Igb24gY3RybCtjbGlja1xuICB0aGlzLmhhbW1lci5vbigncHJlc3MnLCB0aGlzLl9vbk11bHRpU2VsZWN0SXRlbS5iaW5kKHRoaXMpKTtcblxuICAvLyBhZGQgaXRlbSBvbiBkb3VibGV0YXBcbiAgdGhpcy5oYW1tZXIub24oJ2RvdWJsZXRhcCcsIHRoaXMuX29uQWRkSXRlbS5iaW5kKHRoaXMpKTtcblxuICB0aGlzLmdyb3VwSGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLmJvZHkuZG9tLmxlZnRDb250YWluZXIpO1xuICB0aGlzLmdyb3VwSGFtbWVyLm9uKCdwYW5zdGFydCcsIHRoaXMuX29uR3JvdXBEcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gIHRoaXMuZ3JvdXBIYW1tZXIub24oJ3Bhbm1vdmUnLCAgdGhpcy5fb25Hcm91cERyYWcuYmluZCh0aGlzKSk7XG4gIHRoaXMuZ3JvdXBIYW1tZXIub24oJ3BhbmVuZCcsICAgdGhpcy5fb25Hcm91cERyYWdFbmQuYmluZCh0aGlzKSk7XG4gIHRoaXMuZ3JvdXBIYW1tZXIuZ2V0KCdwYW4nKS5zZXQoe3RocmVzaG9sZDo1LCBkaXJlY3Rpb246MzB9KTtcbiAgXG4gIC8vIGF0dGFjaCB0byB0aGUgRE9NXG4gIHRoaXMuc2hvdygpO1xufTtcblxuLyoqXG4gKiBTZXQgb3B0aW9ucyBmb3IgdGhlIEl0ZW1TZXQuIEV4aXN0aW5nIG9wdGlvbnMgd2lsbCBiZSBleHRlbmRlZC9vdmVyd3JpdHRlbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBhdmFpbGFibGU6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IHR5cGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB0eXBlIGZvciB0aGUgaXRlbXMuIENob29zZSBmcm9tICdib3gnXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkZWZhdWx0KSwgJ3BvaW50JywgJ3JhbmdlJywgb3IgJ2JhY2tncm91bmQnLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCBzdHlsZSBjYW4gYmUgb3ZlcndyaXR0ZW4gYnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kaXZpZHVhbCBpdGVtcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gYWxpZ25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxpZ25tZW50IGZvciB0aGUgaXRlbXMsIG9ubHkgYXBwbGljYWJsZSBmb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQm94SXRlbS4gQ2hvb3NlICdjZW50ZXInIChkZWZhdWx0KSwgJ2xlZnQnLCBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmlnaHQnLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBvcmllbnRhdGlvbi5pdGVtXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9yaWVudGF0aW9uIG9mIHRoZSBpdGVtIHNldC4gQ2hvb3NlICd0b3AnIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdib3R0b20nIChkZWZhdWx0KS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Z1bmN0aW9ufSBncm91cE9yZGVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgc29ydGluZyBmdW5jdGlvbiBmb3Igb3JkZXJpbmcgZ3JvdXBzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBzdGFja1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgaXRlbXMgd2lsbCBiZSBzdGFja2VkIG9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCBvZiBlYWNoIG90aGVyLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtYXJnaW4uYXhpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXJnaW4gYmV0d2VlbiB0aGUgYXhpcyBhbmQgdGhlIGl0ZW1zIGluIHBpeGVscy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyAyMC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWFyZ2luLml0ZW0uaG9yaXpvbnRhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIb3Jpem9udGFsIG1hcmdpbiBiZXR3ZWVuIGl0ZW1zIGluIHBpeGVscy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyAxMC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWFyZ2luLml0ZW0udmVydGljYWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVydGljYWwgTWFyZ2luIGJldHdlZW4gaXRlbXMgaW4gcGl4ZWxzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGlzIDEwLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtYXJnaW4uaXRlbVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXJnaW4gYmV0d2VlbiBpdGVtcyBpbiBwaXhlbHMgaW4gYm90aCBob3Jpem9udGFsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCB2ZXJ0aWNhbCBkaXJlY3Rpb24uIERlZmF1bHQgaXMgMTAuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IG1hcmdpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXQgbWFyZ2luIGZvciBib3RoIGF4aXMgYW5kIGl0ZW1zIGluIHBpeGVscy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IHNlbGVjdGFibGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIGl0ZW1zIGNhbiBiZSBzZWxlY3RlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IG11bHRpc2VsZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUsIG11bHRpcGxlIGl0ZW1zIGNhbiBiZSBzZWxlY3RlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRmFsc2UgYnkgZGVmYXVsdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IGVkaXRhYmxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldCBhbGwgZWRpdGFibGUgb3B0aW9ucyB0byB0cnVlIG9yIGZhbHNlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBlZGl0YWJsZS51cGRhdGVUaW1lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsbG93IGRyYWdnaW5nIGFuIGl0ZW0gdG8gYW4gb3RoZXIgbW9tZW50IGluIHRpbWVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IGVkaXRhYmxlLnVwZGF0ZUdyb3VwXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsbG93IGRyYWdnaW5nIGFuIGl0ZW0gdG8gYW4gb3RoZXIgZ3JvdXBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IGVkaXRhYmxlLmFkZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbGxvdyBjcmVhdGluZyBuZXcgaXRlbXMgb24gZG91YmxlIHRhcFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gZWRpdGFibGUucmVtb3ZlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsbG93IHJlbW92aW5nIGl0ZW1zIGJ5IGNsaWNraW5nIHRoZSBkZWxldGUgYnV0dG9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCByaWdodCBvZiBhIHNlbGVjdGVkIGl0ZW0uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtGdW5jdGlvbihpdGVtOiBJdGVtLCBjYWxsYmFjazogRnVuY3Rpb24pfSBvbkFkZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgd2hlbiBhbiBpdGVtIGlzIGFib3V0IHRvIGJlIGFkZGVkOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuIHRoZSB1c2VyIGRvdWJsZSB0YXBzIGFuIGVtcHR5IHNwYWNlIGluIHRoZSBUaW1lbGluZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Z1bmN0aW9uKGl0ZW06IEl0ZW0sIGNhbGxiYWNrOiBGdW5jdGlvbil9IG9uVXBkYXRlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbGxiYWNrIGZ1bmN0aW9uIGZpcmVkIHdoZW4gYW4gaXRlbSBpcyBhYm91dCB0byBiZSB1cGRhdGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIGZ1bmN0aW9uIHR5cGljYWxseSBoYXMgdG8gc2hvdyBhIGRpYWxvZyB3aGVyZSB0aGUgdXNlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgdGhlIGl0ZW0uIElmIG5vdCBpbXBsZW1lbnRlZCwgbm90aGluZyBoYXBwZW5zLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7RnVuY3Rpb24oaXRlbTogSXRlbSwgY2FsbGJhY2s6IEZ1bmN0aW9uKX0gb25Nb3ZlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpcmVkIHdoZW4gYW4gaXRlbSBoYXMgYmVlbiBtb3ZlZC4gSWYgbm90IGltcGxlbWVudGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbW92ZSBhY3Rpb24gd2lsbCBiZSBhY2NlcHRlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Z1bmN0aW9uKGl0ZW06IEl0ZW0sIGNhbGxiYWNrOiBGdW5jdGlvbil9IG9uUmVtb3ZlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpcmVkIHdoZW4gYW4gaXRlbSBpcyBhYm91dCB0byBiZSBkZWxldGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBub3QgaW1wbGVtZW50ZWQsIHRoZSBpdGVtIHdpbGwgYmUgYWx3YXlzIHJlbW92ZWQuXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgLy8gY29weSBhbGwgb3B0aW9ucyB0aGF0IHdlIGtub3dcbiAgICB2YXIgZmllbGRzID0gWyd0eXBlJywgJ2FsaWduJywgJ29yZGVyJywgJ3N0YWNrJywgJ3NlbGVjdGFibGUnLCAnbXVsdGlzZWxlY3QnLCAnZ3JvdXBPcmRlcicsICdkYXRhQXR0cmlidXRlcycsICd0ZW1wbGF0ZScsICdncm91cFRlbXBsYXRlJywgJ2hpZGUnLCAnc25hcCcsICdncm91cE9yZGVyU3dhcCddO1xuICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGlmICgnb3JpZW50YXRpb24nIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gPSBvcHRpb25zLm9yaWVudGF0aW9uID09PSAndG9wJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ29iamVjdCcgJiYgJ2l0ZW0nIGluIG9wdGlvbnMub3JpZW50YXRpb24pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gPSBvcHRpb25zLm9yaWVudGF0aW9uLml0ZW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCdtYXJnaW4nIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXJnaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5tYXJnaW4uYXhpcyA9IG9wdGlvbnMubWFyZ2luO1xuICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0uaG9yaXpvbnRhbCA9IG9wdGlvbnMubWFyZ2luO1xuICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0udmVydGljYWwgPSBvcHRpb25zLm1hcmdpbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLm1hcmdpbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoWydheGlzJ10sIHRoaXMub3B0aW9ucy5tYXJnaW4sIG9wdGlvbnMubWFyZ2luKTtcbiAgICAgICAgaWYgKCdpdGVtJyBpbiBvcHRpb25zLm1hcmdpbikge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXJnaW4uaXRlbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tYXJnaW4uaXRlbS5ob3Jpem9udGFsID0gb3B0aW9ucy5tYXJnaW4uaXRlbTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tYXJnaW4uaXRlbS52ZXJ0aWNhbCA9IG9wdGlvbnMubWFyZ2luLml0ZW07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLm1hcmdpbi5pdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoWydob3Jpem9udGFsJywgJ3ZlcnRpY2FsJ10sIHRoaXMub3B0aW9ucy5tYXJnaW4uaXRlbSwgb3B0aW9ucy5tYXJnaW4uaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCdlZGl0YWJsZScgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmVkaXRhYmxlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgID0gb3B0aW9ucy5lZGl0YWJsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZUdyb3VwID0gb3B0aW9ucy5lZGl0YWJsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRhYmxlLmFkZCAgICAgICAgID0gb3B0aW9ucy5lZGl0YWJsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnJlbW92ZSAgICAgID0gb3B0aW9ucy5lZGl0YWJsZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmVkaXRhYmxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbJ3VwZGF0ZVRpbWUnLCAndXBkYXRlR3JvdXAnLCAnYWRkJywgJ3JlbW92ZSddLCB0aGlzLm9wdGlvbnMuZWRpdGFibGUsIG9wdGlvbnMuZWRpdGFibGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoJ2dyb3VwRWRpdGFibGUnIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5ncm91cEVkaXRhYmxlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmdyb3VwRWRpdGFibGUub3JkZXIgID0gb3B0aW9ucy5ncm91cEVkaXRhYmxlO1xuICAgICAgICB0aGlzLm9wdGlvbnMuZ3JvdXBFZGl0YWJsZS5hZGQgICAgPSBvcHRpb25zLmdyb3VwRWRpdGFibGU7XG4gICAgICAgIHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLnJlbW92ZSA9IG9wdGlvbnMuZ3JvdXBFZGl0YWJsZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmdyb3VwRWRpdGFibGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFsnb3JkZXInLCAnYWRkJywgJ3JlbW92ZSddLCB0aGlzLm9wdGlvbnMuZ3JvdXBFZGl0YWJsZSwgb3B0aW9ucy5ncm91cEVkaXRhYmxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxsYmFjayBmdW5jdGlvbnNcbiAgICB2YXIgYWRkQ2FsbGJhY2sgPSAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBmbiA9IG9wdGlvbnNbbmFtZV07XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgaWYgKCEoZm4gaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbiAnICsgbmFtZSArICcgbXVzdCBiZSBhIGZ1bmN0aW9uICcgKyBuYW1lICsgJyhpdGVtLCBjYWxsYmFjayknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbbmFtZV0gPSBmbjtcbiAgICAgIH1cbiAgICB9KS5iaW5kKHRoaXMpO1xuICAgIFsnb25BZGQnLCAnb25VcGRhdGUnLCAnb25SZW1vdmUnLCAnb25Nb3ZlJywgJ29uTW92aW5nJywgJ29uQWRkR3JvdXAnLCAnb25Nb3ZlR3JvdXAnLCAnb25SZW1vdmVHcm91cCddLmZvckVhY2goYWRkQ2FsbGJhY2spO1xuXG4gICAgLy8gZm9yY2UgdGhlIGl0ZW1TZXQgdG8gcmVmcmVzaDogb3B0aW9ucyBsaWtlIG9yaWVudGF0aW9uIGFuZCBtYXJnaW5zIG1heSBiZSBjaGFuZ2VkXG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNYXJrIHRoZSBJdGVtU2V0IGRpcnR5IHNvIGl0IHdpbGwgcmVmcmVzaCBldmVyeXRoaW5nIHdpdGggbmV4dCByZWRyYXcuXG4gKiBPcHRpb25hbGx5LCBhbGwgaXRlbXMgY2FuIGJlIG1hcmtlZCBhcyBkaXJ0eSBhbmQgYmUgcmVmcmVzaGVkLlxuICogQHBhcmFtIHt7cmVmcmVzaEl0ZW1zOiBib29sZWFufX0gW29wdGlvbnNdXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLm1hcmtEaXJ0eSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5ncm91cElkcyA9IFtdO1xuICB0aGlzLnN0YWNrRGlydHkgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVmcmVzaEl0ZW1zKSB7XG4gICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpdGVtLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIGlmIChpdGVtLmRpc3BsYXllZCkgaXRlbS5yZWRyYXcoKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBJdGVtU2V0XG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5oaWRlKCk7XG4gIHRoaXMuc2V0SXRlbXMobnVsbCk7XG4gIHRoaXMuc2V0R3JvdXBzKG51bGwpO1xuXG4gIHRoaXMuaGFtbWVyID0gbnVsbDtcblxuICB0aGlzLmJvZHkgPSBudWxsO1xuICB0aGlzLmNvbnZlcnNpb24gPSBudWxsO1xufTtcblxuLyoqXG4gKiBIaWRlIHRoZSBjb21wb25lbnQgZnJvbSB0aGUgRE9NXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gcmVtb3ZlIHRoZSBmcmFtZSBjb250YWluaW5nIHRoZSBpdGVtc1xuICBpZiAodGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuZG9tLmZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uZnJhbWUpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHRoZSBheGlzIHdpdGggZG90c1xuICBpZiAodGhpcy5kb20uYXhpcy5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5kb20uYXhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmF4aXMpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHRoZSBsYWJlbHNldCBjb250YWluaW5nIGFsbCBncm91cCBsYWJlbHNcbiAgaWYgKHRoaXMuZG9tLmxhYmVsU2V0LnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLmRvbS5sYWJlbFNldC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmxhYmVsU2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBTaG93IHRoZSBjb21wb25lbnQgaW4gdGhlIERPTSAod2hlbiBub3QgYWxyZWFkeSB2aXNpYmxlKS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAvLyBzaG93IGZyYW1lIGNvbnRhaW5pbmcgdGhlIGl0ZW1zXG4gIGlmICghdGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuYm9keS5kb20uY2VudGVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLmZyYW1lKTtcbiAgfVxuXG4gIC8vIHNob3cgYXhpcyB3aXRoIGRvdHNcbiAgaWYgKCF0aGlzLmRvbS5heGlzLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLmJvZHkuZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5heGlzKTtcbiAgfVxuXG4gIC8vIHNob3cgbGFiZWxzZXQgY29udGFpbmluZyBsYWJlbHNcbiAgaWYgKCF0aGlzLmRvbS5sYWJlbFNldC5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5ib2R5LmRvbS5sZWZ0LmFwcGVuZENoaWxkKHRoaXMuZG9tLmxhYmVsU2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgc2VsZWN0ZWQgaXRlbXMgYnkgdGhlaXIgaWQuIFJlcGxhY2VzIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICogVW5rbm93biBpZCdzIGFyZSBzaWxlbnRseSBpZ25vcmVkLlxuICogQHBhcmFtIHtzdHJpbmdbXSB8IHN0cmluZ30gW2lkc10gQW4gYXJyYXkgd2l0aCB6ZXJvIG9yIG1vcmUgaWQncyBvZiB0aGUgaXRlbXMgdG8gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLCBvciBhIHNpbmdsZSBpdGVtIGlkLiBJZiBpZHMgaXMgdW5kZWZpbmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhbiBlbXB0eSBhcnJheSwgYWxsIGl0ZW1zIHdpbGwgYmUgdW5zZWxlY3RlZC5cbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oaWRzKSB7XG4gIHZhciBpLCBpaSwgaWQsIGl0ZW07XG5cbiAgaWYgKGlkcyA9PSB1bmRlZmluZWQpIGlkcyA9IFtdO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoaWRzKSkgaWRzID0gW2lkc107XG5cbiAgLy8gdW5zZWxlY3QgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zXG4gIGZvciAoaSA9IDAsIGlpID0gdGhpcy5zZWxlY3Rpb24ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGlkID0gdGhpcy5zZWxlY3Rpb25baV07XG4gICAgaXRlbSA9IHRoaXMuaXRlbXNbaWRdO1xuICAgIGlmIChpdGVtKSBpdGVtLnVuc2VsZWN0KCk7XG4gIH1cblxuICAvLyBzZWxlY3QgaXRlbXNcbiAgdGhpcy5zZWxlY3Rpb24gPSBbXTtcbiAgZm9yIChpID0gMCwgaWkgPSBpZHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGlkID0gaWRzW2ldO1xuICAgIGl0ZW0gPSB0aGlzLml0ZW1zW2lkXTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdGhpcy5zZWxlY3Rpb24ucHVzaChpZCk7XG4gICAgICBpdGVtLnNlbGVjdCgpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNlbGVjdGVkIGl0ZW1zIGJ5IHRoZWlyIGlkXG4gKiBAcmV0dXJuIHtBcnJheX0gaWRzICBUaGUgaWRzIG9mIHRoZSBzZWxlY3RlZCBpdGVtc1xuICovXG5JdGVtU2V0LnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmNvbmNhdChbXSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaWQncyBvZiB0aGUgY3VycmVudGx5IHZpc2libGUgaXRlbXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBpZHMgb2YgdGhlIHZpc2libGUgaXRlbXNcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuZ2V0VmlzaWJsZUl0ZW1zID0gZnVuY3Rpb24oKSB7XG4gIHZhciByYW5nZSA9IHRoaXMuYm9keS5yYW5nZS5nZXRSYW5nZSgpO1xuICB2YXIgbGVmdCAgPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbihyYW5nZS5zdGFydCk7XG4gIHZhciByaWdodCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKHJhbmdlLmVuZCk7XG5cbiAgdmFyIGlkcyA9IFtdO1xuICBmb3IgKHZhciBncm91cElkIGluIHRoaXMuZ3JvdXBzKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGdyb3VwSWQpKSB7XG4gICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgICAgIHZhciByYXdWaXNpYmxlSXRlbXMgPSBncm91cC52aXNpYmxlSXRlbXM7XG5cbiAgICAgIC8vIGZpbHRlciB0aGUgXCJyYXdcIiBzZXQgd2l0aCB2aXNpYmxlSXRlbXMgaW50byBhIHNldCB3aGljaCBpcyByZWFsbHlcbiAgICAgIC8vIHZpc2libGUgYnkgcGl4ZWxzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd1Zpc2libGVJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9IHJhd1Zpc2libGVJdGVtc1tpXTtcbiAgICAgICAgLy8gVE9ETzogYWxzbyBjaGVjayB3aGV0aGVyIHZpc2libGUgdmVydGljYWxseVxuICAgICAgICBpZiAoKGl0ZW0ubGVmdCA8IHJpZ2h0KSAmJiAoaXRlbS5sZWZ0ICsgaXRlbS53aWR0aCA+IGxlZnQpKSB7XG4gICAgICAgICAgaWRzLnB1c2goaXRlbS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaWRzO1xufTtcblxuLyoqXG4gKiBEZXNlbGVjdCBhIHNlbGVjdGVkIGl0ZW1cbiAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBpZFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX2Rlc2VsZWN0ID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBzZWxlY3Rpb24ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGlmIChzZWxlY3Rpb25baV0gPT0gaWQpIHsgLy8gbm9uLXN0cmljdCBjb21wYXJpc29uIVxuICAgICAgc2VsZWN0aW9uLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXBhaW50IHRoZSBjb21wb25lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtYXJnaW4gPSB0aGlzLm9wdGlvbnMubWFyZ2luLFxuICAgICAgcmFuZ2UgPSB0aGlzLmJvZHkucmFuZ2UsXG4gICAgICBhc1NpemUgPSB1dGlsLm9wdGlvbi5hc1NpemUsXG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgb3JpZW50YXRpb24gPSBvcHRpb25zLm9yaWVudGF0aW9uLml0ZW0sXG4gICAgICByZXNpemVkID0gZmFsc2UsXG4gICAgICBmcmFtZSA9IHRoaXMuZG9tLmZyYW1lO1xuXG4gIC8vIHJlY2FsY3VsYXRlIGFic29sdXRlIHBvc2l0aW9uIChiZWZvcmUgcmVkcmF3aW5nIGdyb3VwcylcbiAgdGhpcy5wcm9wcy50b3AgPSB0aGlzLmJvZHkuZG9tUHJvcHMudG9wLmhlaWdodCArIHRoaXMuYm9keS5kb21Qcm9wcy5ib3JkZXIudG9wO1xuICB0aGlzLnByb3BzLmxlZnQgPSB0aGlzLmJvZHkuZG9tUHJvcHMubGVmdC53aWR0aCArIHRoaXMuYm9keS5kb21Qcm9wcy5ib3JkZXIubGVmdDtcblxuICAvLyB1cGRhdGUgY2xhc3MgbmFtZVxuICBmcmFtZS5jbGFzc05hbWUgPSAndmlzLWl0ZW1zZXQnO1xuXG4gIC8vIHJlb3JkZXIgdGhlIGdyb3VwcyAoaWYgbmVlZGVkKVxuICByZXNpemVkID0gdGhpcy5fb3JkZXJHcm91cHMoKSB8fCByZXNpemVkO1xuXG4gIC8vIGNoZWNrIHdoZXRoZXIgem9vbWVkIChpbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byByZS1zdGFjayBldmVyeXRoaW5nKVxuICAvLyBUT0RPOiB3b3VsZCBiZSBuaWNlciB0byBnZXQgdGhpcyBhcyBhIHRyaWdnZXIgZnJvbSBSYW5nZVxuICB2YXIgdmlzaWJsZUludGVydmFsID0gcmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQ7XG4gIHZhciB6b29tZWQgPSAodmlzaWJsZUludGVydmFsICE9IHRoaXMubGFzdFZpc2libGVJbnRlcnZhbCkgfHwgKHRoaXMucHJvcHMud2lkdGggIT0gdGhpcy5wcm9wcy5sYXN0V2lkdGgpO1xuICBpZiAoem9vbWVkKSB0aGlzLnN0YWNrRGlydHkgPSB0cnVlO1xuICB0aGlzLmxhc3RWaXNpYmxlSW50ZXJ2YWwgPSB2aXNpYmxlSW50ZXJ2YWw7XG4gIHRoaXMucHJvcHMubGFzdFdpZHRoID0gdGhpcy5wcm9wcy53aWR0aDtcblxuICB2YXIgcmVzdGFjayA9IHRoaXMuc3RhY2tEaXJ0eTtcbiAgdmFyIGZpcnN0R3JvdXAgPSB0aGlzLl9maXJzdEdyb3VwKCk7XG4gIHZhciBmaXJzdE1hcmdpbiA9IHtcbiAgICBpdGVtOiBtYXJnaW4uaXRlbSxcbiAgICBheGlzOiBtYXJnaW4uYXhpc1xuICB9O1xuICB2YXIgbm9uRmlyc3RNYXJnaW4gPSB7XG4gICAgaXRlbTogbWFyZ2luLml0ZW0sXG4gICAgYXhpczogbWFyZ2luLml0ZW0udmVydGljYWwgLyAyXG4gIH07XG4gIHZhciBoZWlnaHQgPSAwO1xuICB2YXIgbWluSGVpZ2h0ID0gbWFyZ2luLmF4aXMgKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbDtcblxuICAvLyByZWRyYXcgdGhlIGJhY2tncm91bmQgZ3JvdXBcbiAgdGhpcy5ncm91cHNbQkFDS0dST1VORF0ucmVkcmF3KHJhbmdlLCBub25GaXJzdE1hcmdpbiwgcmVzdGFjayk7XG5cbiAgLy8gcmVkcmF3IGFsbCByZWd1bGFyIGdyb3Vwc1xuICB1dGlsLmZvckVhY2godGhpcy5ncm91cHMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgIHZhciBncm91cE1hcmdpbiA9IChncm91cCA9PSBmaXJzdEdyb3VwKSA/IGZpcnN0TWFyZ2luIDogbm9uRmlyc3RNYXJnaW47XG4gICAgdmFyIGdyb3VwUmVzaXplZCA9IGdyb3VwLnJlZHJhdyhyYW5nZSwgZ3JvdXBNYXJnaW4sIHJlc3RhY2spO1xuICAgIHJlc2l6ZWQgPSBncm91cFJlc2l6ZWQgfHwgcmVzaXplZDtcbiAgICBoZWlnaHQgKz0gZ3JvdXAuaGVpZ2h0O1xuICB9KTtcbiAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBtaW5IZWlnaHQpO1xuICB0aGlzLnN0YWNrRGlydHkgPSBmYWxzZTtcblxuICAvLyB1cGRhdGUgZnJhbWUgaGVpZ2h0XG4gIGZyYW1lLnN0eWxlLmhlaWdodCAgPSBhc1NpemUoaGVpZ2h0KTtcblxuICAvLyBjYWxjdWxhdGUgYWN0dWFsIHNpemVcbiAgdGhpcy5wcm9wcy53aWR0aCA9IGZyYW1lLm9mZnNldFdpZHRoO1xuICB0aGlzLnByb3BzLmhlaWdodCA9IGhlaWdodDtcblxuICAvLyByZXBvc2l0aW9uIGF4aXNcbiAgdGhpcy5kb20uYXhpcy5zdHlsZS50b3AgPSBhc1NpemUoKG9yaWVudGF0aW9uID09ICd0b3AnKSA/XG4gICAgICAodGhpcy5ib2R5LmRvbVByb3BzLnRvcC5oZWlnaHQgKyB0aGlzLmJvZHkuZG9tUHJvcHMuYm9yZGVyLnRvcCkgOlxuICAgICAgKHRoaXMuYm9keS5kb21Qcm9wcy50b3AuaGVpZ2h0ICsgdGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQpKTtcbiAgdGhpcy5kb20uYXhpcy5zdHlsZS5sZWZ0ID0gJzAnO1xuXG4gIC8vIGNoZWNrIGlmIHRoaXMgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAgcmVzaXplZCA9IHRoaXMuX2lzUmVzaXplZCgpIHx8IHJlc2l6ZWQ7XG5cbiAgcmV0dXJuIHJlc2l6ZWQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZmlyc3QgZ3JvdXAsIGFsaWduZWQgd2l0aCB0aGUgYXhpc1xuICogQHJldHVybiB7R3JvdXAgfCBudWxsfSBmaXJzdEdyb3VwXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fZmlyc3RHcm91cCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlyc3RHcm91cEluZGV4ID0gKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtID09ICd0b3AnKSA/IDAgOiAodGhpcy5ncm91cElkcy5sZW5ndGggLSAxKTtcbiAgdmFyIGZpcnN0R3JvdXBJZCA9IHRoaXMuZ3JvdXBJZHNbZmlyc3RHcm91cEluZGV4XTtcbiAgdmFyIGZpcnN0R3JvdXAgPSB0aGlzLmdyb3Vwc1tmaXJzdEdyb3VwSWRdIHx8IHRoaXMuZ3JvdXBzW1VOR1JPVVBFRF07XG5cbiAgcmV0dXJuIGZpcnN0R3JvdXAgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIG9yIGRlbGV0ZSB0aGUgZ3JvdXAgaG9sZGluZyBhbGwgdW5ncm91cGVkIGl0ZW1zLiBUaGlzIGdyb3VwIGlzIHVzZWQgd2hlblxuICogdGhlcmUgYXJlIG5vIGdyb3VwcyBzcGVjaWZpZWQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl91cGRhdGVVbmdyb3VwZWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHVuZ3JvdXBlZCA9IHRoaXMuZ3JvdXBzW1VOR1JPVVBFRF07XG4gIHZhciBiYWNrZ3JvdW5kID0gdGhpcy5ncm91cHNbQkFDS0dST1VORF07XG4gIHZhciBpdGVtLCBpdGVtSWQ7XG5cbiAgaWYgKHRoaXMuZ3JvdXBzRGF0YSkge1xuICAgIC8vIHJlbW92ZSB0aGUgZ3JvdXAgaG9sZGluZyBhbGwgdW5ncm91cGVkIGl0ZW1zXG4gICAgaWYgKHVuZ3JvdXBlZCkge1xuICAgICAgdW5ncm91cGVkLmhpZGUoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1tVTkdST1VQRURdO1xuXG4gICAgICBmb3IgKGl0ZW1JZCBpbiB0aGlzLml0ZW1zKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zLmhhc093blByb3BlcnR5KGl0ZW1JZCkpIHtcbiAgICAgICAgICBpdGVtID0gdGhpcy5pdGVtc1tpdGVtSWRdO1xuICAgICAgICAgIGl0ZW0ucGFyZW50ICYmIGl0ZW0ucGFyZW50LnJlbW92ZShpdGVtKTtcbiAgICAgICAgICB2YXIgZ3JvdXBJZCA9IHRoaXMuX2dldEdyb3VwSWQoaXRlbS5kYXRhKTtcbiAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgICAgICAgICBncm91cCAmJiBncm91cC5hZGQoaXRlbSkgfHwgaXRlbS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gY3JlYXRlIGEgZ3JvdXAgaG9sZGluZyBhbGwgKHVuZmlsdGVyZWQpIGl0ZW1zXG4gICAgaWYgKCF1bmdyb3VwZWQpIHtcbiAgICAgIHZhciBpZCA9IG51bGw7XG4gICAgICB2YXIgZGF0YSA9IG51bGw7XG4gICAgICB1bmdyb3VwZWQgPSBuZXcgR3JvdXAoaWQsIGRhdGEsIHRoaXMpO1xuICAgICAgdGhpcy5ncm91cHNbVU5HUk9VUEVEXSA9IHVuZ3JvdXBlZDtcblxuICAgICAgZm9yIChpdGVtSWQgaW4gdGhpcy5pdGVtcykge1xuICAgICAgICBpZiAodGhpcy5pdGVtcy5oYXNPd25Qcm9wZXJ0eShpdGVtSWQpKSB7XG4gICAgICAgICAgaXRlbSA9IHRoaXMuaXRlbXNbaXRlbUlkXTtcbiAgICAgICAgICB1bmdyb3VwZWQuYWRkKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVuZ3JvdXBlZC5zaG93KCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZWxlbWVudCBmb3IgdGhlIGxhYmVsc2V0XG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gbGFiZWxTZXRcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuZ2V0TGFiZWxTZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZG9tLmxhYmVsU2V0O1xufTtcblxuLyoqXG4gKiBTZXQgaXRlbXNcbiAqIEBwYXJhbSB7dmlzLkRhdGFTZXQgfCBudWxsfSBpdGVtc1xuICovXG5JdGVtU2V0LnByb3RvdHlwZS5zZXRJdGVtcyA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gIHZhciBtZSA9IHRoaXMsXG4gICAgICBpZHMsXG4gICAgICBvbGRJdGVtc0RhdGEgPSB0aGlzLml0ZW1zRGF0YTtcblxuICAvLyByZXBsYWNlIHRoZSBkYXRhc2V0XG4gIGlmICghaXRlbXMpIHtcbiAgICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7XG4gIH1cbiAgZWxzZSBpZiAoaXRlbXMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IGl0ZW1zIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICB0aGlzLml0ZW1zRGF0YSA9IGl0ZW1zO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RhdGEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBEYXRhU2V0IG9yIERhdGFWaWV3Jyk7XG4gIH1cblxuICBpZiAob2xkSXRlbXNEYXRhKSB7XG4gICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBvbGQgZGF0YXNldFxuICAgIHV0aWwuZm9yRWFjaCh0aGlzLml0ZW1MaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgIG9sZEl0ZW1zRGF0YS5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICB9KTtcblxuICAgIC8vIHJlbW92ZSBhbGwgZHJhd24gaXRlbXNcbiAgICBpZHMgPSBvbGRJdGVtc0RhdGEuZ2V0SWRzKCk7XG4gICAgdGhpcy5fb25SZW1vdmUoaWRzKTtcbiAgfVxuXG4gIGlmICh0aGlzLml0ZW1zRGF0YSkge1xuICAgIC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbUxpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgbWUuaXRlbXNEYXRhLm9uKGV2ZW50LCBjYWxsYmFjaywgaWQpO1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIGFsbCBuZXcgaXRlbXNcbiAgICBpZHMgPSB0aGlzLml0ZW1zRGF0YS5nZXRJZHMoKTtcbiAgICB0aGlzLl9vbkFkZChpZHMpO1xuXG4gICAgLy8gdXBkYXRlIHRoZSBncm91cCBob2xkaW5nIGFsbCB1bmdyb3VwZWQgaXRlbXNcbiAgICB0aGlzLl91cGRhdGVVbmdyb3VwZWQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgaXRlbXNcbiAqIEByZXR1cm5zIHt2aXMuRGF0YVNldCB8IG51bGx9XG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLmdldEl0ZW1zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLml0ZW1zRGF0YTtcbn07XG5cbi8qKlxuICogU2V0IGdyb3Vwc1xuICogQHBhcmFtIHt2aXMuRGF0YVNldH0gZ3JvdXBzXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLnNldEdyb3VwcyA9IGZ1bmN0aW9uKGdyb3Vwcykge1xuICB2YXIgbWUgPSB0aGlzLFxuICAgICAgaWRzO1xuXG4gIC8vIHVuc3Vic2NyaWJlIGZyb20gY3VycmVudCBkYXRhc2V0XG4gIGlmICh0aGlzLmdyb3Vwc0RhdGEpIHtcbiAgICB1dGlsLmZvckVhY2godGhpcy5ncm91cExpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgbWUuZ3JvdXBzRGF0YS5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICB9KTtcblxuICAgIC8vIHJlbW92ZSBhbGwgZHJhd24gZ3JvdXBzXG4gICAgaWRzID0gdGhpcy5ncm91cHNEYXRhLmdldElkcygpO1xuICAgIHRoaXMuZ3JvdXBzRGF0YSA9IG51bGw7XG4gICAgdGhpcy5fb25SZW1vdmVHcm91cHMoaWRzKTsgLy8gbm90ZTogdGhpcyB3aWxsIGNhdXNlIGEgcmVkcmF3XG4gIH1cblxuICAvLyByZXBsYWNlIHRoZSBkYXRhc2V0XG4gIGlmICghZ3JvdXBzKSB7XG4gICAgdGhpcy5ncm91cHNEYXRhID0gbnVsbDtcbiAgfVxuICBlbHNlIGlmIChncm91cHMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IGdyb3VwcyBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgdGhpcy5ncm91cHNEYXRhID0gZ3JvdXBzO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RhdGEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBEYXRhU2V0IG9yIERhdGFWaWV3Jyk7XG4gIH1cblxuICBpZiAodGhpcy5ncm91cHNEYXRhKSB7XG4gICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICB1dGlsLmZvckVhY2godGhpcy5ncm91cExpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgbWUuZ3JvdXBzRGF0YS5vbihldmVudCwgY2FsbGJhY2ssIGlkKTtcbiAgICB9KTtcblxuICAgIC8vIGRyYXcgYWxsIG1zXG4gICAgaWRzID0gdGhpcy5ncm91cHNEYXRhLmdldElkcygpO1xuICAgIHRoaXMuX29uQWRkR3JvdXBzKGlkcyk7XG4gIH1cblxuICAvLyB1cGRhdGUgdGhlIGdyb3VwIGhvbGRpbmcgYWxsIHVuZ3JvdXBlZCBpdGVtc1xuICB0aGlzLl91cGRhdGVVbmdyb3VwZWQoKTtcblxuICAvLyB1cGRhdGUgdGhlIG9yZGVyIG9mIGFsbCBpdGVtcyBpbiBlYWNoIGdyb3VwXG4gIHRoaXMuX29yZGVyKCk7XG5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywge3F1ZXVlOiB0cnVlfSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBncm91cHNcbiAqIEByZXR1cm5zIHt2aXMuRGF0YVNldCB8IG51bGx9IGdyb3Vwc1xuICovXG5JdGVtU2V0LnByb3RvdHlwZS5nZXRHcm91cHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZ3JvdXBzRGF0YTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gYnkgaXRzIGlkXG4gKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gaWRcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBpdGVtID0gdGhpcy5pdGVtc0RhdGEuZ2V0KGlkKSxcbiAgICAgIGRhdGFzZXQgPSB0aGlzLml0ZW1zRGF0YS5nZXREYXRhU2V0KCk7XG5cbiAgaWYgKGl0ZW0pIHtcbiAgICAvLyBjb25maXJtIGRlbGV0aW9uXG4gICAgdGhpcy5vcHRpb25zLm9uUmVtb3ZlKGl0ZW0sIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICAvLyByZW1vdmUgYnkgaWQgaGVyZSwgaXQgaXMgcG9zc2libGUgdGhhdCBhbiBpdGVtIGhhcyBubyBpZCBkZWZpbmVkXG4gICAgICAgIC8vIGl0c2VsZiwgc28gYmV0dGVyIG5vdCBkZWxldGUgYnkgdGhlIGl0ZW0gaXRzZWxmXG4gICAgICAgIGRhdGFzZXQucmVtb3ZlKGlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHRpbWUgb2YgYW4gaXRlbSBiYXNlZCBvbiBpdCdzIGRhdGEgYW5kIG9wdGlvbnMudHlwZVxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW1EYXRhXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fZ2V0VHlwZSA9IGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICByZXR1cm4gaXRlbURhdGEudHlwZSB8fCB0aGlzLm9wdGlvbnMudHlwZSB8fCAoaXRlbURhdGEuZW5kID8gJ3JhbmdlJyA6ICdib3gnKTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGdyb3VwIGlkIGZvciBhbiBpdGVtXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbURhdGFcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGdyb3VwSWRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9nZXRHcm91cElkID0gZnVuY3Rpb24gKGl0ZW1EYXRhKSB7XG4gIHZhciB0eXBlID0gdGhpcy5fZ2V0VHlwZShpdGVtRGF0YSk7XG4gIGlmICh0eXBlID09ICdiYWNrZ3JvdW5kJyAmJiBpdGVtRGF0YS5ncm91cCA9PSB1bmRlZmluZWQpIHtcbiAgIHJldHVybiBCQUNLR1JPVU5EO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmdyb3Vwc0RhdGEgPyBpdGVtRGF0YS5ncm91cCA6IFVOR1JPVVBFRDtcbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGUgdXBkYXRlZCBpdGVtc1xuICogQHBhcmFtIHtOdW1iZXJbXX0gaWRzXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vblVwZGF0ZSA9IGZ1bmN0aW9uKGlkcykge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtRGF0YSA9IG1lLml0ZW1zRGF0YS5nZXQoaWQsIG1lLml0ZW1PcHRpb25zKTtcbiAgICB2YXIgaXRlbSA9IG1lLml0ZW1zW2lkXTtcbiAgICB2YXIgdHlwZSA9IG1lLl9nZXRUeXBlKGl0ZW1EYXRhKTtcblxuICAgIHZhciBjb25zdHJ1Y3RvciA9IEl0ZW1TZXQudHlwZXNbdHlwZV07XG4gICAgdmFyIHNlbGVjdGVkO1xuXG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIC8vIHVwZGF0ZSBpdGVtXG4gICAgICBpZiAoIWNvbnN0cnVjdG9yIHx8ICEoaXRlbSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSkge1xuICAgICAgICAvLyBpdGVtIHR5cGUgaGFzIGNoYW5nZWQsIGRlbGV0ZSB0aGUgaXRlbSBhbmQgcmVjcmVhdGUgaXRcbiAgICAgICAgc2VsZWN0ZWQgPSBpdGVtLnNlbGVjdGVkOyAvLyBwcmVzZXJ2ZSBzZWxlY3Rpb24gb2YgdGhpcyBpdGVtXG4gICAgICAgIG1lLl9yZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgICBpdGVtID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtZS5fdXBkYXRlSXRlbShpdGVtLCBpdGVtRGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICAvLyBjcmVhdGUgaXRlbVxuICAgICAgaWYgKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGl0ZW0gPSBuZXcgY29uc3RydWN0b3IoaXRlbURhdGEsIG1lLmNvbnZlcnNpb24sIG1lLm9wdGlvbnMpO1xuICAgICAgICBpdGVtLmlkID0gaWQ7IC8vIFRPRE86IG5vdCBzbyBuaWNlIHNldHRpbmcgaWQgYWZ0ZXJ3YXJkc1xuICAgICAgICBtZS5fYWRkSXRlbShpdGVtKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb24ucHVzaChpZCk7XG4gICAgICAgICAgaXRlbS5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZSA9PSAncmFuZ2VvdmVyZmxvdycpIHtcbiAgICAgICAgLy8gVE9ETzogZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS4wIChvciAzLjAuMD8pLiBjbGVhbnVwIHNvbWUgZGF5XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0l0ZW0gdHlwZSBcInJhbmdlb3ZlcmZsb3dcIiBpcyBkZXByZWNhdGVkLiBVc2UgY3NzIHN0eWxpbmcgaW5zdGVhZDogJyArXG4gICAgICAgICAgICAnLnZpcy1pdGVtLnZpcy1yYW5nZSAudmlzLWl0ZW0tY29udGVudCB7b3ZlcmZsb3c6IHZpc2libGU7fScpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gaXRlbSB0eXBlIFwiJyArIHR5cGUgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgdGhpcy5fb3JkZXIoKTtcbiAgdGhpcy5zdGFja0RpcnR5ID0gdHJ1ZTsgLy8gZm9yY2UgcmUtc3RhY2tpbmcgb2YgYWxsIGl0ZW1zIG5leHQgcmVkcmF3XG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2NoYW5nZScsIHtxdWV1ZTogdHJ1ZX0pO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgYWRkZWQgaXRlbXNcbiAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICogQHByb3RlY3RlZFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25BZGQgPSBJdGVtU2V0LnByb3RvdHlwZS5fb25VcGRhdGU7XG5cbi8qKlxuICogSGFuZGxlIHJlbW92ZWQgaXRlbXNcbiAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICogQHByb3RlY3RlZFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25SZW1vdmUgPSBmdW5jdGlvbihpZHMpIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIG1lID0gdGhpcztcbiAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBtZS5pdGVtc1tpZF07XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGNvdW50Kys7XG4gICAgICBtZS5fcmVtb3ZlSXRlbShpdGVtKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChjb3VudCkge1xuICAgIC8vIHVwZGF0ZSBvcmRlclxuICAgIHRoaXMuX29yZGVyKCk7XG4gICAgdGhpcy5zdGFja0RpcnR5ID0gdHJ1ZTsgLy8gZm9yY2UgcmUtc3RhY2tpbmcgb2YgYWxsIGl0ZW1zIG5leHQgcmVkcmF3XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywge3F1ZXVlOiB0cnVlfSk7XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBvcmRlciBvZiBpdGVtIGluIGFsbCBncm91cHNcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vcmRlciA9IGZ1bmN0aW9uKCkge1xuICAvLyByZW9yZGVyIHRoZSBpdGVtcyBpbiBhbGwgZ3JvdXBzXG4gIC8vIFRPRE86IG9wdGltaXphdGlvbjogb25seSByZW9yZGVyIGdyb3VwcyBhZmZlY3RlZCBieSB0aGUgY2hhbmdlZCBpdGVtc1xuICB1dGlsLmZvckVhY2godGhpcy5ncm91cHMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgIGdyb3VwLm9yZGVyKCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgdXBkYXRlZCBncm91cHNcbiAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uVXBkYXRlR3JvdXBzID0gZnVuY3Rpb24oaWRzKSB7XG4gIHRoaXMuX29uQWRkR3JvdXBzKGlkcyk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBjaGFuZ2VkIGdyb3VwcyAoYWRkZWQgb3IgdXBkYXRlZClcbiAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uQWRkR3JvdXBzID0gZnVuY3Rpb24oaWRzKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGdyb3VwRGF0YSA9IG1lLmdyb3Vwc0RhdGEuZ2V0KGlkKTtcbiAgICB2YXIgZ3JvdXAgPSBtZS5ncm91cHNbaWRdO1xuXG4gICAgaWYgKCFncm91cCkge1xuICAgICAgLy8gY2hlY2sgZm9yIHJlc2VydmVkIGlkc1xuICAgICAgaWYgKGlkID09IFVOR1JPVVBFRCB8fCBpZCA9PSBCQUNLR1JPVU5EKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBncm91cCBpZC4gJyArIGlkICsgJyBpcyBhIHJlc2VydmVkIGlkLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ3JvdXBPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShtZS5vcHRpb25zKTtcbiAgICAgIHV0aWwuZXh0ZW5kKGdyb3VwT3B0aW9ucywge1xuICAgICAgICBoZWlnaHQ6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICBncm91cCA9IG5ldyBHcm91cChpZCwgZ3JvdXBEYXRhLCBtZSk7XG4gICAgICBtZS5ncm91cHNbaWRdID0gZ3JvdXA7XG5cbiAgICAgIC8vIGFkZCBpdGVtcyB3aXRoIHRoaXMgZ3JvdXBJZCB0byB0aGUgbmV3IGdyb3VwXG4gICAgICBmb3IgKHZhciBpdGVtSWQgaW4gbWUuaXRlbXMpIHtcbiAgICAgICAgaWYgKG1lLml0ZW1zLmhhc093blByb3BlcnR5KGl0ZW1JZCkpIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IG1lLml0ZW1zW2l0ZW1JZF07XG4gICAgICAgICAgaWYgKGl0ZW0uZGF0YS5ncm91cCA9PSBpZCkge1xuICAgICAgICAgICAgZ3JvdXAuYWRkKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBncm91cC5vcmRlcigpO1xuICAgICAgZ3JvdXAuc2hvdygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZSBncm91cFxuICAgICAgZ3JvdXAuc2V0RGF0YShncm91cERhdGEpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywge3F1ZXVlOiB0cnVlfSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSByZW1vdmVkIGdyb3Vwc1xuICogQHBhcmFtIHtOdW1iZXJbXX0gaWRzXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25SZW1vdmVHcm91cHMgPSBmdW5jdGlvbihpZHMpIHtcbiAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZ3JvdXAgPSBncm91cHNbaWRdO1xuXG4gICAgaWYgKGdyb3VwKSB7XG4gICAgICBncm91cC5oaWRlKCk7XG4gICAgICBkZWxldGUgZ3JvdXBzW2lkXTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMubWFya0RpcnR5KCk7XG5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywge3F1ZXVlOiB0cnVlfSk7XG59O1xuXG4vKipcbiAqIFJlb3JkZXIgdGhlIGdyb3VwcyBpZiBuZWVkZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGNoYW5nZWRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vcmRlckdyb3VwcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZ3JvdXBzRGF0YSkge1xuICAgIC8vIHJlb3JkZXIgdGhlIGdyb3Vwc1xuICAgIHZhciBncm91cElkcyA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoe1xuICAgICAgb3JkZXI6IHRoaXMub3B0aW9ucy5ncm91cE9yZGVyXG4gICAgfSk7XG5cbiAgICB2YXIgY2hhbmdlZCA9ICF1dGlsLmVxdWFsQXJyYXkoZ3JvdXBJZHMsIHRoaXMuZ3JvdXBJZHMpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAvLyBoaWRlIGFsbCBncm91cHMsIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSBET01cbiAgICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcbiAgICAgIGdyb3VwSWRzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwSWQpIHtcbiAgICAgICAgZ3JvdXBzW2dyb3VwSWRdLmhpZGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBzaG93IHRoZSBncm91cHMgYWdhaW4sIGF0dGFjaCB0aGVtIHRvIHRoZSBET00gaW4gY29ycmVjdCBvcmRlclxuICAgICAgZ3JvdXBJZHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXBJZCkge1xuICAgICAgICBncm91cHNbZ3JvdXBJZF0uc2hvdygpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZ3JvdXBJZHMgPSBncm91cElkcztcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGEgbmV3IGl0ZW1cbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX2FkZEl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gIHRoaXMuaXRlbXNbaXRlbS5pZF0gPSBpdGVtO1xuXG4gIC8vIGFkZCB0byBncm91cFxuICB2YXIgZ3JvdXBJZCA9IHRoaXMuX2dldEdyb3VwSWQoaXRlbS5kYXRhKTtcbiAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gIGlmIChncm91cCkgZ3JvdXAuYWRkKGl0ZW0pO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgYW4gZXhpc3RpbmcgaXRlbVxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbURhdGFcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl91cGRhdGVJdGVtID0gZnVuY3Rpb24oaXRlbSwgaXRlbURhdGEpIHtcbiAgdmFyIG9sZEdyb3VwSWQgPSBpdGVtLmRhdGEuZ3JvdXA7XG4gIHZhciBvbGRTdWJHcm91cElkID0gaXRlbS5kYXRhLnN1Ymdyb3VwO1xuXG4gIC8vIHVwZGF0ZSB0aGUgaXRlbXMgZGF0YSAod2lsbCByZWRyYXcgdGhlIGl0ZW0gd2hlbiBkaXNwbGF5ZWQpXG4gIGl0ZW0uc2V0RGF0YShpdGVtRGF0YSk7XG5cbiAgLy8gdXBkYXRlIGdyb3VwXG4gIGlmIChvbGRHcm91cElkICE9IGl0ZW0uZGF0YS5ncm91cCB8fCBvbGRTdWJHcm91cElkICE9IGl0ZW0uZGF0YS5zdWJncm91cCkge1xuICAgIHZhciBvbGRHcm91cCA9IHRoaXMuZ3JvdXBzW29sZEdyb3VwSWRdO1xuICAgIGlmIChvbGRHcm91cCkgb2xkR3JvdXAucmVtb3ZlKGl0ZW0pO1xuXG4gICAgdmFyIGdyb3VwSWQgPSB0aGlzLl9nZXRHcm91cElkKGl0ZW0uZGF0YSk7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gICAgaWYgKGdyb3VwKSBncm91cC5hZGQoaXRlbSk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVsZXRlIGFuIGl0ZW0gZnJvbSB0aGUgSXRlbVNldDogcmVtb3ZlIGl0IGZyb20gdGhlIERPTSwgZnJvbSB0aGUgbWFwXG4gKiB3aXRoIGl0ZW1zLCBhbmQgZnJvbSB0aGUgbWFwIHdpdGggdmlzaWJsZSBpdGVtcywgYW5kIGZyb20gdGhlIHNlbGVjdGlvblxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgLy8gcmVtb3ZlIGZyb20gRE9NXG4gIGl0ZW0uaGlkZSgpO1xuXG4gIC8vIHJlbW92ZSBmcm9tIGl0ZW1zXG4gIGRlbGV0ZSB0aGlzLml0ZW1zW2l0ZW0uaWRdO1xuXG4gIC8vIHJlbW92ZSBmcm9tIHNlbGVjdGlvblxuICB2YXIgaW5kZXggPSB0aGlzLnNlbGVjdGlvbi5pbmRleE9mKGl0ZW0uaWQpO1xuICBpZiAoaW5kZXggIT0gLTEpIHRoaXMuc2VsZWN0aW9uLnNwbGljZShpbmRleCwgMSk7XG5cbiAgLy8gcmVtb3ZlIGZyb20gZ3JvdXBcbiAgaXRlbS5wYXJlbnQgJiYgaXRlbS5wYXJlbnQucmVtb3ZlKGl0ZW0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgaXRlbXMgYmVpbmcgYSByYW5nZSAoaGF2aW5nIGFuIGVuZCBkYXRlKVxuICogQHBhcmFtIGFycmF5XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fY29uc3RydWN0QnlFbmRBcnJheSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gIHZhciBlbmRBcnJheSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyYXlbaV0gaW5zdGFuY2VvZiBSYW5nZUl0ZW0pIHtcbiAgICAgIGVuZEFycmF5LnB1c2goYXJyYXlbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5kQXJyYXk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIHRoZSBjbGlja2VkIGl0ZW0gb24gdG91Y2gsIGJlZm9yZSBkcmFnU3RhcnQgaXMgaW5pdGlhdGVkLlxuICpcbiAqIGRyYWdTdGFydCBpcyBpbml0aWF0ZWQgZnJvbSBhIG1vdXNlbW92ZSBldmVudCwgQUZURVIgdGhlIG1vdXNlL3RvdWNoIGlzXG4gKiBhbHJlYWR5IG1vdmluZy4gVGhlcmVmb3JlLCB0aGUgbW91c2UvdG91Y2ggY2FuIHNvbWV0aW1lcyBiZSBhYm92ZSBhbiBvdGhlclxuICogRE9NIGVsZW1lbnQgdGhhbiB0aGUgaXRlbSBpdHNlbGYuXG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vblRvdWNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIHN0b3JlIHRoZSB0b3VjaGVkIGl0ZW0sIHVzZWQgaW4gX29uRHJhZ1N0YXJ0XG4gIHRoaXMudG91Y2hQYXJhbXMuaXRlbSA9IHRoaXMuaXRlbUZyb21UYXJnZXQoZXZlbnQpO1xuICB0aGlzLnRvdWNoUGFyYW1zLmRyYWdMZWZ0SXRlbSA9IGV2ZW50LnRhcmdldC5kcmFnTGVmdEl0ZW0gfHwgZmFsc2U7XG4gIHRoaXMudG91Y2hQYXJhbXMuZHJhZ1JpZ2h0SXRlbSA9IGV2ZW50LnRhcmdldC5kcmFnUmlnaHRJdGVtIHx8IGZhbHNlO1xuICB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcyA9IG51bGw7XG59O1xuXG5cbi8qKlxuICogR2l2ZW4gYW4gZ3JvdXAgaWQsIHJldHVybnMgdGhlIGluZGV4IGl0IGhhcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZ3JvdXBJRFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX2dldEdyb3VwSW5kZXggPSBmdW5jdGlvbihncm91cElkKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChncm91cElkID09IHRoaXMuZ3JvdXBJZHNbaV0pXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0IGRyYWdnaW5nIHRoZSBzZWxlY3RlZCBldmVudHNcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLnRvdWNoUGFyYW1zLml0ZW0gfHwgbnVsbDtcbiAgdmFyIG1lID0gdGhpcztcbiAgdmFyIHByb3BzO1xuXG4gIGlmIChpdGVtICYmIGl0ZW0uc2VsZWN0ZWQpIHtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgJiZcbiAgICAgICAgIXRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCAmJlxuICAgICAgICAhaXRlbS5lZGl0YWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG92ZXJyaWRlIG9wdGlvbnMuZWRpdGFibGVcbiAgICBpZiAoaXRlbS5lZGl0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZHJhZ0xlZnRJdGVtID0gdGhpcy50b3VjaFBhcmFtcy5kcmFnTGVmdEl0ZW07XG4gICAgdmFyIGRyYWdSaWdodEl0ZW0gPSB0aGlzLnRvdWNoUGFyYW1zLmRyYWdSaWdodEl0ZW07XG5cbiAgICBpZiAoZHJhZ0xlZnRJdGVtKSB7XG4gICAgICBwcm9wcyA9IHtcbiAgICAgICAgaXRlbTogZHJhZ0xlZnRJdGVtLFxuICAgICAgICBpbml0aWFsWDogZXZlbnQuY2VudGVyLngsXG4gICAgICAgIGRyYWdMZWZ0OiAgdHJ1ZSxcbiAgICAgICAgZGF0YTogdGhpcy5fY2xvbmVJdGVtRGF0YShpdGVtLmRhdGEpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcyA9IFtwcm9wc107XG4gICAgfVxuICAgIGVsc2UgaWYgKGRyYWdSaWdodEl0ZW0pIHtcbiAgICAgIHByb3BzID0ge1xuICAgICAgICBpdGVtOiBkcmFnUmlnaHRJdGVtLFxuICAgICAgICBpbml0aWFsWDogZXZlbnQuY2VudGVyLngsXG4gICAgICAgIGRyYWdSaWdodDogdHJ1ZSxcbiAgICAgICAgZGF0YTogdGhpcy5fY2xvbmVJdGVtRGF0YShpdGVtLmRhdGEpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcyA9IFtwcm9wc107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy50b3VjaFBhcmFtcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuXG4gICAgICB2YXIgYmFzZUdyb3VwSW5kZXggPSB0aGlzLl9nZXRHcm91cEluZGV4KGl0ZW0uZGF0YS5ncm91cCk7XG5cbiAgICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gdGhpcy5nZXRTZWxlY3Rpb24oKS5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBpdGVtID0gbWUuaXRlbXNbaWRdO1xuICAgICAgICB2YXIgZ3JvdXBJbmRleCA9IG1lLl9nZXRHcm91cEluZGV4KGl0ZW0uZGF0YS5ncm91cCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICBpbml0aWFsWDogZXZlbnQuY2VudGVyLngsXG4gICAgICAgICAgZ3JvdXBPZmZzZXQ6IGJhc2VHcm91cEluZGV4LWdyb3VwSW5kZXgsXG4gICAgICAgICAgZGF0YTogdGhpcy5fY2xvbmVJdGVtRGF0YShpdGVtLmRhdGEpXG4gICAgICAgIH07XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG4gIGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lZGl0YWJsZS5hZGQgJiYgKGV2ZW50LnNyY0V2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc3JjRXZlbnQubWV0YUtleSkpIHtcbiAgICAvLyBjcmVhdGUgYSBuZXcgcmFuZ2UgaXRlbSB3aGVuIGRyYWdnaW5nIHdpdGggY3RybCBrZXkgZG93blxuICAgIHRoaXMuX29uRHJhZ1N0YXJ0QWRkSXRlbShldmVudCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnQgY3JlYXRpbmcgYSBuZXcgcmFuZ2UgaXRlbSBieSBkcmFnZ2luZy5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25EcmFnU3RhcnRBZGRJdGVtID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBzbmFwID0gdGhpcy5vcHRpb25zLnNuYXAgfHwgbnVsbDtcbiAgdmFyIHhBYnMgPSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmRvbS5mcmFtZSk7XG4gIHZhciB4ID0gZXZlbnQuY2VudGVyLnggLSB4QWJzIC0gMTA7ICAvLyBtaW51cyAxMCB0byBjb21wZW5zYXRlIGZvciB0aGUgZHJhZyBzdGFydGluZyBhcyBzb29uIGFzIHlvdSd2ZSBtb3ZlZCAxMHB4XG4gIHZhciB0aW1lID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKHgpO1xuICB2YXIgc2NhbGUgPSB0aGlzLmJvZHkudXRpbC5nZXRTY2FsZSgpO1xuICB2YXIgc3RlcCA9IHRoaXMuYm9keS51dGlsLmdldFN0ZXAoKTtcbiAgdmFyIHN0YXJ0ID0gc25hcCA/IHNuYXAodGltZSwgc2NhbGUsIHN0ZXApIDogc3RhcnQ7XG4gIHZhciBlbmQgPSBzdGFydDtcblxuICB2YXIgaXRlbURhdGEgPSB7XG4gICAgdHlwZTogJ3JhbmdlJyxcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmQsXG4gICAgY29udGVudDogJ25ldyBpdGVtJ1xuICB9O1xuXG4gIHZhciBpZCA9IHV0aWwucmFuZG9tVVVJRCgpO1xuICBpdGVtRGF0YVt0aGlzLml0ZW1zRGF0YS5fZmllbGRJZF0gPSBpZDtcblxuICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwRnJvbVRhcmdldChldmVudCk7XG4gIGlmIChncm91cCkge1xuICAgIGl0ZW1EYXRhLmdyb3VwID0gZ3JvdXAuZ3JvdXBJZDtcbiAgfVxuXG4gIHZhciBuZXdJdGVtID0gbmV3IFJhbmdlSXRlbShpdGVtRGF0YSwgdGhpcy5jb252ZXJzaW9uLCB0aGlzLm9wdGlvbnMpO1xuICBuZXdJdGVtLmlkID0gaWQ7IC8vIFRPRE86IG5vdCBzbyBuaWNlIHNldHRpbmcgaWQgYWZ0ZXJ3YXJkc1xuICBuZXdJdGVtLmRhdGEgPSB0aGlzLl9jbG9uZUl0ZW1EYXRhKGl0ZW1EYXRhKTtcbiAgdGhpcy5fYWRkSXRlbShuZXdJdGVtKTtcblxuICB2YXIgcHJvcHMgPSB7XG4gICAgaXRlbTogbmV3SXRlbSxcbiAgICBkcmFnUmlnaHQ6IHRydWUsXG4gICAgaW5pdGlhbFg6IGV2ZW50LmNlbnRlci54LFxuICAgIGRhdGE6IG5ld0l0ZW0uZGF0YVxuICB9O1xuICB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcyA9IFtwcm9wc107XG5cbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59O1xuXG4vKipcbiAqIERyYWcgc2VsZWN0ZWQgaXRlbXNcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICh0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcykge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgc25hcCA9IHRoaXMub3B0aW9ucy5zbmFwIHx8IG51bGw7XG4gICAgdmFyIHhPZmZzZXQgPSB0aGlzLmJvZHkuZG9tLnJvb3Qub2Zmc2V0TGVmdCArIHRoaXMuYm9keS5kb21Qcm9wcy5sZWZ0LndpZHRoO1xuICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS51dGlsLmdldFNjYWxlKCk7XG4gICAgdmFyIHN0ZXAgPSB0aGlzLmJvZHkudXRpbC5nZXRTdGVwKCk7XG5cbiAgICAvL29ubHkgY2FsY3VsYXRlIHRoZSBuZXcgZ3JvdXAgZm9yIHRoZSBpdGVtIHRoYXQncyBhY3R1YWxseSBkcmFnZ2VkXG4gICAgdmFyIHNlbGVjdGVkSXRlbSA9IHRoaXMudG91Y2hQYXJhbXMuc2VsZWN0ZWRJdGVtO1xuICAgIHZhciB1cGRhdGVHcm91cEFsbG93ZWQgPSBtZS5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZUdyb3VwO1xuICAgIHZhciBuZXdHcm91cEJhc2UgPSBudWxsO1xuICAgIGlmICh1cGRhdGVHcm91cEFsbG93ZWQgJiYgc2VsZWN0ZWRJdGVtKSB7XG4gICAgICBpZiAoc2VsZWN0ZWRJdGVtLmRhdGEuZ3JvdXAgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGRyYWcgZnJvbSBvbmUgZ3JvdXAgdG8gYW5vdGhlclxuICAgICAgICB2YXIgZ3JvdXAgPSBtZS5ncm91cEZyb21UYXJnZXQoZXZlbnQpO1xuICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAvL3dlIGtub3cgdGhlIG9mZnNldCBmb3IgYWxsIGl0ZW1zLCBzbyB0aGUgbmV3IGdyb3VwIGZvciBhbGwgaXRlbXNcbiAgICAgICAgICAvL3dpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcyBvbmUuXG4gICAgICAgICAgbmV3R3JvdXBCYXNlID0gdGhpcy5fZ2V0R3JvdXBJbmRleChncm91cC5ncm91cElkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1vdmVcbiAgICB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgdmFyIGN1cnJlbnQgPSBtZS5ib2R5LnV0aWwudG9UaW1lKGV2ZW50LmNlbnRlci54IC0geE9mZnNldCk7XG4gICAgICB2YXIgaW5pdGlhbCA9IG1lLmJvZHkudXRpbC50b1RpbWUocHJvcHMuaW5pdGlhbFggLSB4T2Zmc2V0KTtcbiAgICAgIHZhciBvZmZzZXQgPSBjdXJyZW50IC0gaW5pdGlhbDsgLy8gbXNcblxuICAgICAgdmFyIGl0ZW1EYXRhID0gdGhpcy5fY2xvbmVJdGVtRGF0YShwcm9wcy5pdGVtLmRhdGEpOyAvLyBjbG9uZSB0aGUgZGF0YVxuICAgICAgaWYgKHByb3BzLml0ZW0uZWRpdGFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZVRpbWVBbGxvd2VkID0gbWUub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lIHx8XG4gICAgICAgICAgcHJvcHMuaXRlbS5lZGl0YWJsZSA9PT0gdHJ1ZTtcblxuICAgICAgaWYgKHVwZGF0ZVRpbWVBbGxvd2VkKSB7XG4gICAgICAgIGlmIChwcm9wcy5kcmFnTGVmdCkge1xuICAgICAgICAgIC8vIGRyYWcgbGVmdCBzaWRlIG9mIGEgcmFuZ2UgaXRlbVxuICAgICAgICAgIGlmIChpdGVtRGF0YS5zdGFydCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBpbml0aWFsU3RhcnQgPSB1dGlsLmNvbnZlcnQocHJvcHMuZGF0YS5zdGFydCwgJ0RhdGUnKTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKGluaXRpYWxTdGFydC52YWx1ZU9mKCkgKyBvZmZzZXQpO1xuICAgICAgICAgICAgLy8gVE9ETzogcGFzcyBhIE1vbWVudCBpbnN0ZWFkIG9mIGEgRGF0ZSB0byBzbmFwKCkuIChCcmVha2luZyBjaGFuZ2UpXG4gICAgICAgICAgICBpdGVtRGF0YS5zdGFydCA9IHNuYXAgPyBzbmFwKHN0YXJ0LCBzY2FsZSwgc3RlcCkgOiBzdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvcHMuZHJhZ1JpZ2h0KSB7XG4gICAgICAgICAgLy8gZHJhZyByaWdodCBzaWRlIG9mIGEgcmFuZ2UgaXRlbVxuICAgICAgICAgIGlmIChpdGVtRGF0YS5lbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbEVuZCA9IHV0aWwuY29udmVydChwcm9wcy5kYXRhLmVuZCwgJ0RhdGUnKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBuZXcgRGF0ZShpbml0aWFsRW5kLnZhbHVlT2YoKSArIG9mZnNldCk7XG4gICAgICAgICAgICAvLyBUT0RPOiBwYXNzIGEgTW9tZW50IGluc3RlYWQgb2YgYSBEYXRlIHRvIHNuYXAoKS4gKEJyZWFraW5nIGNoYW5nZSlcbiAgICAgICAgICAgIGl0ZW1EYXRhLmVuZCA9IHNuYXAgPyBzbmFwKGVuZCwgc2NhbGUsIHN0ZXApIDogZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBkcmFnIGJvdGggc3RhcnQgYW5kIGVuZFxuICAgICAgICAgIGlmIChpdGVtRGF0YS5zdGFydCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBpbml0aWFsU3RhcnQgPSB1dGlsLmNvbnZlcnQocHJvcHMuZGF0YS5zdGFydCwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZShpbml0aWFsU3RhcnQgKyBvZmZzZXQpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbURhdGEuZW5kICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgaW5pdGlhbEVuZCA9IHV0aWwuY29udmVydChwcm9wcy5kYXRhLmVuZCwgJ0RhdGUnKTtcbiAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uICA9IGluaXRpYWxFbmQudmFsdWVPZigpIC0gaW5pdGlhbFN0YXJ0LnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgICAvLyBUT0RPOiBwYXNzIGEgTW9tZW50IGluc3RlYWQgb2YgYSBEYXRlIHRvIHNuYXAoKS4gKEJyZWFraW5nIGNoYW5nZSlcbiAgICAgICAgICAgICAgaXRlbURhdGEuc3RhcnQgPSBzbmFwID8gc25hcChzdGFydCwgc2NhbGUsIHN0ZXApIDogc3RhcnQ7XG4gICAgICAgICAgICAgIGl0ZW1EYXRhLmVuZCAgID0gbmV3IERhdGUoaXRlbURhdGEuc3RhcnQudmFsdWVPZigpICsgZHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFRPRE86IHBhc3MgYSBNb21lbnQgaW5zdGVhZCBvZiBhIERhdGUgdG8gc25hcCgpLiAoQnJlYWtpbmcgY2hhbmdlKVxuICAgICAgICAgICAgICBpdGVtRGF0YS5zdGFydCA9IHNuYXAgPyBzbmFwKHN0YXJ0LCBzY2FsZSwgc3RlcCkgOiBzdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZUdyb3VwQWxsb3dlZCA9IG1lLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXAgfHxcbiAgICAgICAgICBwcm9wcy5pdGVtLmVkaXRhYmxlID09PSB0cnVlO1xuXG4gICAgICBpZiAodXBkYXRlR3JvdXBBbGxvd2VkICYmICghcHJvcHMuZHJhZ0xlZnQgJiYgIXByb3BzLmRyYWdSaWdodCkgJiYgbmV3R3JvdXBCYXNlIT1udWxsKSB7XG4gICAgICAgIGlmIChpdGVtRGF0YS5ncm91cCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbmV3T2Zmc2V0ID0gbmV3R3JvdXBCYXNlIC0gcHJvcHMuZ3JvdXBPZmZzZXQ7XG5cbiAgICAgICAgICAvL21ha2Ugc3VyZSB3ZSBzdGF5IGluIGJvdW5kc1xuICAgICAgICAgIG5ld09mZnNldCA9IE1hdGgubWF4KDAsIG5ld09mZnNldCk7XG4gICAgICAgICAgbmV3T2Zmc2V0ID0gTWF0aC5taW4obWUuZ3JvdXBJZHMubGVuZ3RoLTEsIG5ld09mZnNldCk7XG5cbiAgICAgICAgICBpdGVtRGF0YS5ncm91cCA9IG1lLmdyb3VwSWRzW25ld09mZnNldF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY29uZmlybSBtb3ZpbmcgdGhlIGl0ZW1cbiAgICAgIGl0ZW1EYXRhID0gdGhpcy5fY2xvbmVJdGVtRGF0YShpdGVtRGF0YSk7ICAvLyBjb252ZXJ0IHN0YXJ0IGFuZCBlbmQgdG8gdGhlIGNvcnJlY3QgdHlwZVxuICAgICAgbWUub3B0aW9ucy5vbk1vdmluZyhpdGVtRGF0YSwgZnVuY3Rpb24gKGl0ZW1EYXRhKSB7XG4gICAgICAgIGlmIChpdGVtRGF0YSkge1xuICAgICAgICAgIHByb3BzLml0ZW0uc2V0RGF0YSh0aGlzLl9jbG9uZUl0ZW1EYXRhKGl0ZW1EYXRhLCAnRGF0ZScpKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5zdGFja0RpcnR5ID0gdHJ1ZTsgLy8gZm9yY2UgcmUtc3RhY2tpbmcgb2YgYWxsIGl0ZW1zIG5leHQgcmVkcmF3XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogTW92ZSBhbiBpdGVtIHRvIGFub3RoZXIgZ3JvdXBcbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGdyb3VwSWRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9tb3ZlVG9Hcm91cCA9IGZ1bmN0aW9uKGl0ZW0sIGdyb3VwSWQpIHtcbiAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gIGlmIChncm91cCAmJiBncm91cC5ncm91cElkICE9IGl0ZW0uZGF0YS5ncm91cCkge1xuICAgIHZhciBvbGRHcm91cCA9IGl0ZW0ucGFyZW50O1xuICAgIG9sZEdyb3VwLnJlbW92ZShpdGVtKTtcbiAgICBvbGRHcm91cC5vcmRlcigpO1xuICAgIGdyb3VwLmFkZChpdGVtKTtcbiAgICBncm91cC5vcmRlcigpO1xuXG4gICAgaXRlbS5kYXRhLmdyb3VwID0gZ3JvdXAuZ3JvdXBJZDtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmQgb2YgZHJhZ2dpbmcgc2VsZWN0ZWQgaXRlbXNcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICh0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcykge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgZGF0YXNldCA9IHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKTtcbiAgICB2YXIgaXRlbVByb3BzID0gdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMgO1xuICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gbnVsbDtcblxuICAgIGl0ZW1Qcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgdmFyIGlkID0gcHJvcHMuaXRlbS5pZDtcbiAgICAgIHZhciBleGlzdHMgPSBtZS5pdGVtc0RhdGEuZ2V0KGlkLCBtZS5pdGVtT3B0aW9ucykgIT0gbnVsbDtcblxuICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgLy8gYWRkIGEgbmV3IGl0ZW1cbiAgICAgICAgbWUub3B0aW9ucy5vbkFkZChwcm9wcy5pdGVtLmRhdGEsIGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgICAgICAgIG1lLl9yZW1vdmVJdGVtKHByb3BzLml0ZW0pOyAvLyByZW1vdmUgdGVtcG9yYXJ5IGl0ZW1cbiAgICAgICAgICBpZiAoaXRlbURhdGEpIHtcbiAgICAgICAgICAgIG1lLml0ZW1zRGF0YS5nZXREYXRhU2V0KCkuYWRkKGl0ZW1EYXRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBmb3JjZSByZS1zdGFja2luZyBvZiBhbGwgaXRlbXMgbmV4dCByZWRyYXdcbiAgICAgICAgICBtZS5zdGFja0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICBtZS5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHVwZGF0ZSBleGlzdGluZyBpdGVtXG4gICAgICAgIHZhciBpdGVtRGF0YSA9IHRoaXMuX2Nsb25lSXRlbURhdGEocHJvcHMuaXRlbS5kYXRhKTsgLy8gY29udmVydCBzdGFydCBhbmQgZW5kIHRvIHRoZSBjb3JyZWN0IHR5cGVcbiAgICAgICAgbWUub3B0aW9ucy5vbk1vdmUoaXRlbURhdGEsIGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgICAgICAgIGlmIChpdGVtRGF0YSkge1xuICAgICAgICAgICAgLy8gYXBwbHkgY2hhbmdlc1xuICAgICAgICAgICAgaXRlbURhdGFbZGF0YXNldC5fZmllbGRJZF0gPSBpZDsgLy8gZW5zdXJlIHRoZSBpdGVtIGNvbnRhaW5zIGl0cyBpZCAoY2FuIGJlIHVuZGVmaW5lZClcbiAgICAgICAgICAgIGRhdGFzZXQudXBkYXRlKGl0ZW1EYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIHZhbHVlc1xuICAgICAgICAgICAgcHJvcHMuaXRlbS5zZXREYXRhKHByb3BzLmRhdGEpO1xuXG4gICAgICAgICAgICBtZS5zdGFja0RpcnR5ID0gdHJ1ZTsgLy8gZm9yY2UgcmUtc3RhY2tpbmcgb2YgYWxsIGl0ZW1zIG5leHQgcmVkcmF3XG4gICAgICAgICAgICBtZS5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG59O1xuXG5JdGVtU2V0LnByb3RvdHlwZS5fb25Hcm91cERyYWdTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRpZiAodGhpcy5vcHRpb25zLmdyb3VwRWRpdGFibGUub3JkZXIpIHtcblx0XHR0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXAgPSB0aGlzLmdyb3VwRnJvbVRhcmdldChldmVudCk7XG5cdFx0XG5cdFx0aWYgKHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cCkge1xuXHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcblx0XHRcdHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5vcmlnaW5hbE9yZGVyID0gdGhpcy5ncm91cHNEYXRhLmdldElkcyh7XG5cdFx0XHQgICAgb3JkZXI6IHRoaXMub3B0aW9ucy5ncm91cE9yZGVyXG5cdFx0ICAgIH0pO1xuXHRcdH1cblx0fVxufVxuXG5JdGVtU2V0LnByb3RvdHlwZS5fb25Hcm91cERyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0aWYgKHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLm9yZGVyICYmIHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cCkge1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFxuXHRcdC8vIGRyYWcgZnJvbSBvbmUgZ3JvdXAgdG8gYW5vdGhlclxuXHRcdHZhciBncm91cCA9IHRoaXMuZ3JvdXBGcm9tVGFyZ2V0KGV2ZW50KTtcblx0XHRcblx0XHQvLyB0cnkgdG8gYXZvaWQgdG9nZ2xpbmcgd2hlbiBncm91cHMgZGlmZmVyIGluIGhlaWdodFxuXHRcdGlmIChncm91cCAmJiBncm91cC5oZWlnaHQgIT0gdGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwLmhlaWdodCkge1xuXHRcdFx0dmFyIG1vdmluZ1VwID0gKGdyb3VwLnRvcCA8IHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cC50b3ApO1xuXHRcdFx0dmFyIGNsaWVudFkgPSBldmVudC5jZW50ZXIgPyBldmVudC5jZW50ZXIueSA6IGV2ZW50LmNsaWVudFk7XG5cdFx0XHR2YXIgdGFyZ2V0R3JvdXBUb3AgPSB1dGlsLmdldEFic29sdXRlVG9wKGdyb3VwLmRvbS5mb3JlZ3JvdW5kKTtcblx0XHRcdHZhciBkcmFnZ2VkR3JvdXBIZWlnaHQgPSB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXAuaGVpZ2h0O1xuXHRcdFx0aWYgKG1vdmluZ1VwKSB7XG5cdFx0XHRcdC8vIHNraXAgc3dhcHBpbmcgdGhlIGdyb3VwcyB3aGVuIHRoZSBkcmFnZ2VkIGdyb3VwIGlzIG5vdCBiZWxvdyBjbGllbnRZIGFmdGVyd2FyZHNcblx0XHRcdFx0aWYgKHRhcmdldEdyb3VwVG9wICsgZHJhZ2dlZEdyb3VwSGVpZ2h0IDwgY2xpZW50WSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHRhcmdldEdyb3VwSGVpZ2h0ID0gZ3JvdXAuaGVpZ2h0O1xuXHRcdFx0XHQvLyBza2lwIHN3YXBwaW5nIHRoZSBncm91cHMgd2hlbiB0aGUgZHJhZ2dlZCBncm91cCBpcyBub3QgYmVsb3cgY2xpZW50WSBhZnRlcndhcmRzXG5cdFx0XHRcdGlmICh0YXJnZXRHcm91cFRvcCArIHRhcmdldEdyb3VwSGVpZ2h0IC0gZHJhZ2dlZEdyb3VwSGVpZ2h0ID4gY2xpZW50WSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRpZiAoZ3JvdXAgJiYgZ3JvdXAgIT0gdGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwKSB7XG5cdFx0XHR2YXIgZ3JvdXBzRGF0YSA9IHRoaXMuZ3JvdXBzRGF0YTtcblx0XHRcdHZhciB0YXJnZXRHcm91cCA9IGdyb3Vwc0RhdGEuZ2V0KGdyb3VwLmdyb3VwSWQpO1xuXHRcdFx0dmFyIGRyYWdnZWRHcm91cCA9IGdyb3Vwc0RhdGEuZ2V0KHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cC5ncm91cElkKTtcblx0XHRcdFxuXHRcdFx0Ly8gc3dpdGNoIGdyb3Vwc1xuXHRcdFx0aWYgKGRyYWdnZWRHcm91cCAmJiB0YXJnZXRHcm91cCkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMuZ3JvdXBPcmRlclN3YXAoZHJhZ2dlZEdyb3VwLCB0YXJnZXRHcm91cCwgdGhpcy5ncm91cHNEYXRhKTtcblx0XHRcdFx0dGhpcy5ncm91cHNEYXRhLnVwZGF0ZShkcmFnZ2VkR3JvdXApO1xuXHRcdFx0XHR0aGlzLmdyb3Vwc0RhdGEudXBkYXRlKHRhcmdldEdyb3VwKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gZmV0Y2ggY3VycmVudCBvcmRlciBvZiBncm91cHNcblx0XHRcdHZhciBuZXdPcmRlciA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoe1xuXHRcdFx0ICAgIG9yZGVyOiB0aGlzLm9wdGlvbnMuZ3JvdXBPcmRlclxuXHRcdCAgICB9KTtcblx0XHRcdFxuXHRcdFx0Ly8gaW4gY2FzZSBvZiBjaGFuZ2VzIHNpbmNlIF9vbkdyb3VwRHJhZ1N0YXJ0XG5cdFx0XHRpZiAoIXV0aWwuZXF1YWxBcnJheShuZXdPcmRlciwgdGhpcy5ncm91cFRvdWNoUGFyYW1zLm9yaWdpbmFsT3JkZXIpKSB7XG5cdFx0XHRcdHZhciBncm91cHNEYXRhID0gdGhpcy5ncm91cHNEYXRhO1xuXHRcdFx0XHR2YXIgb3JpZ09yZGVyID0gdGhpcy5ncm91cFRvdWNoUGFyYW1zLm9yaWdpbmFsT3JkZXI7XG5cdFx0XHRcdHZhciBkcmFnZ2VkSWQgPSB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXAuZ3JvdXBJZDtcblx0XHRcdFx0dmFyIG51bUdyb3VwcyA9IE1hdGgubWluKG9yaWdPcmRlci5sZW5ndGgsIG5ld09yZGVyLmxlbmd0aCk7XG5cdFx0XHRcdHZhciBjdXJQb3MgPSAwO1xuXHRcdFx0XHR2YXIgbmV3T2Zmc2V0ID0gMDtcblx0XHRcdFx0dmFyIG9yZ09mZnNldCA9IDA7XG5cdFx0XHRcdHdoaWxlIChjdXJQb3MgPCBudW1Hcm91cHMpIHtcblx0XHRcdFx0XHQvLyBhcyBsb25nIGFzIHRoZSBncm91cHMgYXJlIHdoZXJlIHRoZXkgc2hvdWxkIGJlIHN0ZXAgZG93biBhbG9uZyB0aGUgZ3JvdXBzIG9yZGVyXG5cdFx0XHRcdFx0d2hpbGUgKChjdXJQb3MrbmV3T2Zmc2V0KSA8IG51bUdyb3VwcyBcblx0XHRcdFx0XHRcdCYmIChjdXJQb3Mrb3JnT2Zmc2V0KSA8IG51bUdyb3VwcyBcblx0XHRcdFx0XHRcdCYmIG5ld09yZGVyW2N1clBvcytuZXdPZmZzZXRdID09IG9yaWdPcmRlcltjdXJQb3Mrb3JnT2Zmc2V0XSkge1xuXHRcdFx0XHRcdFx0Y3VyUG9zKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIGFsbCBva1xuXHRcdFx0XHRcdGlmIChjdXJQb3MrbmV3T2Zmc2V0ID49IG51bUdyb3Vwcykge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIG5vdCBhbGwgb2tcblx0XHRcdFx0XHQvLyBpZiBkcmFnZ2VkIGdyb3VwIHdhcyBtb3ZlIHVwd2FyZHMgZXZlcnl0aGluZyBiZWxvdyBzaG91bGQgaGF2ZSBhbiBvZmZzZXRcblx0XHRcdFx0XHRpZiAobmV3T3JkZXJbY3VyUG9zK25ld09mZnNldF0gPT0gZHJhZ2dlZElkKSB7XG5cdFx0XHRcdFx0XHRuZXdPZmZzZXQgPSAxO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGlmIGRyYWdnZWQgZ3JvdXAgd2FzIG1vdmUgZG93bndhcmRzIGV2ZXJ5dGhpbmcgYWJvdmUgc2hvdWxkIGhhdmUgYW4gb2Zmc2V0XG5cdFx0XHRcdFx0ZWxzZSBpZiAob3JpZ09yZGVyW2N1clBvcytvcmdPZmZzZXRdID09IGRyYWdnZWRJZCkge1xuXHRcdFx0XHRcdFx0b3JnT2Zmc2V0ID0gMTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH0gXG5cdFx0XHRcdFx0Ly8gZm91bmQgYSBncm91cCAoYXBhcnQgZnJvbSBkcmFnZ2VkIGdyb3VwKSB0aGF0IGhhcyB0aGUgd3JvbmcgcG9zaXRpb24gLT4gc3dpdGNoIHdpdGggdGhlIFxuXHRcdFx0XHRcdC8vIGdyb3VwIGF0IHRoZSBwb3NpdGlvbiB3aGVyZSBvdGhlciBvbmUgc2hvdWxkIGJlLCBmaXggaW5kZXggYXJyYXlzIGFuZCBjb250aW51ZVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIHNsaXBwZWRQb3NpdGlvbiA9IG5ld09yZGVyLmluZGV4T2Yob3JpZ09yZGVyW2N1clBvcytvcmdPZmZzZXRdKVxuXHRcdFx0XHRcdFx0dmFyIHN3aXRjaEdyb3VwID0gZ3JvdXBzRGF0YS5nZXQobmV3T3JkZXJbY3VyUG9zK25ld09mZnNldF0pO1xuXHRcdFx0XHRcdFx0dmFyIHNob3VsZEJlR3JvdXAgPSBncm91cHNEYXRhLmdldChvcmlnT3JkZXJbY3VyUG9zK29yZ09mZnNldF0pO1xuXHRcdFx0XHRcdFx0dGhpcy5vcHRpb25zLmdyb3VwT3JkZXJTd2FwKHN3aXRjaEdyb3VwLCBzaG91bGRCZUdyb3VwLCBncm91cHNEYXRhKTtcblx0XHRcdFx0XHRcdGdyb3Vwc0RhdGEudXBkYXRlKHN3aXRjaEdyb3VwKTtcblx0XHRcdFx0XHRcdGdyb3Vwc0RhdGEudXBkYXRlKHNob3VsZEJlR3JvdXApO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR2YXIgc3dpdGNoR3JvdXBJZCA9IG5ld09yZGVyW2N1clBvcytuZXdPZmZzZXRdO1xuXHRcdFx0XHRcdFx0bmV3T3JkZXJbY3VyUG9zK25ld09mZnNldF0gPSBvcmlnT3JkZXJbY3VyUG9zK29yZ09mZnNldF07XG5cdFx0XHRcdFx0XHRuZXdPcmRlcltzbGlwcGVkUG9zaXRpb25dID0gc3dpdGNoR3JvdXBJZDtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Y3VyUG9zKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9XG5cdH1cbn1cblxuSXRlbVNldC5wcm90b3R5cGUuX29uR3JvdXBEcmFnRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdGlmICh0aGlzLm9wdGlvbnMuZ3JvdXBFZGl0YWJsZS5vcmRlciAmJiB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXApIHtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcblx0XHQvLyB1cGRhdGUgZXhpc3RpbmcgZ3JvdXBcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpZCA9IG1lLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXAuZ3JvdXBJZDtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdyb3Vwc0RhdGEuZ2V0RGF0YVNldCgpO1xuICAgICAgICB2YXIgZ3JvdXBEYXRhID0gdXRpbC5leHRlbmQoe30sIGRhdGFzZXQuZ2V0KGlkKSk7IC8vIGNsb25lIHRoZSBkYXRhXG4gICAgICAgIG1lLm9wdGlvbnMub25Nb3ZlR3JvdXAoZ3JvdXBEYXRhLCBmdW5jdGlvbiAoZ3JvdXBEYXRhKSB7XG4gICAgICAgICAgaWYgKGdyb3VwRGF0YSkge1xuICAgICAgICAgICAgLy8gYXBwbHkgY2hhbmdlc1xuICAgICAgICBcdGdyb3VwRGF0YVtkYXRhc2V0Ll9maWVsZElkXSA9IGlkOyAvLyBlbnN1cmUgdGhlIGdyb3VwIGNvbnRhaW5zIGl0cyBpZCAoY2FuIGJlIHVuZGVmaW5lZClcbiAgICAgICAgICAgIGRhdGFzZXQudXBkYXRlKGdyb3VwRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICBcdCAgXG4gICAgICAgIFx0Ly8gZmV0Y2ggY3VycmVudCBvcmRlciBvZiBncm91cHNcbiAgXHRcdFx0dmFyIG5ld09yZGVyID0gZGF0YXNldC5nZXRJZHMoe1xuICBcdFx0XHQgICAgb3JkZXI6IG1lLm9wdGlvbnMuZ3JvdXBPcmRlclxuICBcdFx0ICAgIH0pO1xuICAgICAgICBcdCAgXG4gICAgICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIG9yZGVyXG4gICAgICAgIFx0aWYgKCF1dGlsLmVxdWFsQXJyYXkobmV3T3JkZXIsIG1lLmdyb3VwVG91Y2hQYXJhbXMub3JpZ2luYWxPcmRlcikpIHtcbiAgICAgICAgXHRcdHZhciBvcmlnT3JkZXIgPSBtZS5ncm91cFRvdWNoUGFyYW1zLm9yaWdpbmFsT3JkZXI7XG4gIFx0XHRcdFx0dmFyIG51bUdyb3VwcyA9IE1hdGgubWluKG9yaWdPcmRlci5sZW5ndGgsIG5ld09yZGVyLmxlbmd0aCk7XG4gIFx0XHRcdFx0dmFyIGN1clBvcyA9IDA7XG4gIFx0XHRcdFx0d2hpbGUgKGN1clBvcyA8IG51bUdyb3Vwcykge1xuICBcdFx0XHRcdFx0Ly8gYXMgbG9uZyBhcyB0aGUgZ3JvdXBzIGFyZSB3aGVyZSB0aGV5IHNob3VsZCBiZSBzdGVwIGRvd24gYWxvbmcgdGhlIGdyb3VwcyBvcmRlclxuICBcdFx0XHRcdFx0d2hpbGUgKGN1clBvcyA8IG51bUdyb3VwcyAmJiBuZXdPcmRlcltjdXJQb3NdID09IG9yaWdPcmRlcltjdXJQb3NdKSB7XG4gIFx0XHRcdFx0XHQgICAgY3VyUG9zKys7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRcbiAgXHRcdFx0XHRcdC8vIGFsbCBva1xuICBcdFx0XHRcdFx0aWYgKGN1clBvcyA+PSBudW1Hcm91cHMpIHtcbiAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRcbiAgXHRcdFx0XHRcdC8vIGZvdW5kIGEgZ3JvdXAgdGhhdCBoYXMgdGhlIHdyb25nIHBvc2l0aW9uIC0+IHN3aXRjaCB3aXRoIHRoZSBcbiAgXHRcdFx0XHRcdC8vIGdyb3VwIGF0IHRoZSBwb3NpdGlvbiB3aGVyZSBvdGhlciBvbmUgc2hvdWxkIGJlLCBmaXggaW5kZXggYXJyYXlzIGFuZCBjb250aW51ZVxuICBcdFx0XHRcdFx0dmFyIHNsaXBwZWRQb3NpdGlvbiA9IG5ld09yZGVyLmluZGV4T2Yob3JpZ09yZGVyW2N1clBvc10pXG4gIFx0XHRcdFx0XHR2YXIgc3dpdGNoR3JvdXAgPSBkYXRhc2V0LmdldChuZXdPcmRlcltjdXJQb3NdKTtcbiAgXHRcdFx0XHRcdHZhciBzaG91bGRCZUdyb3VwID0gZGF0YXNldC5nZXQob3JpZ09yZGVyW2N1clBvc10pO1xuICBcdFx0XHRcdFx0bWUub3B0aW9ucy5ncm91cE9yZGVyU3dhcChzd2l0Y2hHcm91cCwgc2hvdWxkQmVHcm91cCwgZGF0YXNldCk7XG4gIFx0XHRcdFx0XHRncm91cHNEYXRhLnVwZGF0ZShzd2l0Y2hHcm91cCk7XG5cdFx0XHRcdFx0Z3JvdXBzRGF0YS51cGRhdGUoc2hvdWxkQmVHcm91cCk7XG4gIFx0XHRcdFx0XHRcdFxuICBcdFx0XHRcdFx0dmFyIHN3aXRjaEdyb3VwSWQgPSBuZXdPcmRlcltjdXJQb3NdO1xuICBcdFx0XHRcdFx0bmV3T3JkZXJbY3VyUG9zXSA9IG9yaWdPcmRlcltjdXJQb3NdO1xuICBcdFx0XHRcdFx0bmV3T3JkZXJbc2xpcHBlZFBvc2l0aW9uXSA9IHN3aXRjaEdyb3VwSWQ7XG4gIFx0XHRcdFx0XHRcdFxuICBcdFx0XHRcdFx0Y3VyUG9zKys7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgbWUuYm9keS5lbWl0dGVyLmVtaXQoJ2dyb3VwRHJhZ2dlZCcsIHsgZ3JvdXBJZDogaWQgfSk7XG5cdH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgc2VsZWN0aW5nL2Rlc2VsZWN0aW5nIGFuIGl0ZW0gd2hlbiB0YXBwaW5nIGl0XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uU2VsZWN0SXRlbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5zZWxlY3RhYmxlKSByZXR1cm47XG5cbiAgdmFyIGN0cmxLZXkgID0gZXZlbnQuc3JjRXZlbnQgJiYgKGV2ZW50LnNyY0V2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc3JjRXZlbnQubWV0YUtleSk7XG4gIHZhciBzaGlmdEtleSA9IGV2ZW50LnNyY0V2ZW50ICYmIGV2ZW50LnNyY0V2ZW50LnNoaWZ0S2V5O1xuICBpZiAoY3RybEtleSB8fCBzaGlmdEtleSkge1xuICAgIHRoaXMuX29uTXVsdGlTZWxlY3RJdGVtKGV2ZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb2xkU2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuICB2YXIgaXRlbSA9IHRoaXMuaXRlbUZyb21UYXJnZXQoZXZlbnQpO1xuICB2YXIgc2VsZWN0aW9uID0gaXRlbSA/IFtpdGVtLmlkXSA6IFtdO1xuICB0aGlzLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuXG4gIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG4gIC8vIGVtaXQgYSBzZWxlY3QgZXZlbnQsXG4gIC8vIGV4Y2VwdCB3aGVuIG9sZCBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIG5ldyBzZWxlY3Rpb24gaXMgc3RpbGwgZW1wdHlcbiAgaWYgKG5ld1NlbGVjdGlvbi5sZW5ndGggPiAwIHx8IG9sZFNlbGVjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnc2VsZWN0Jywge1xuICAgICAgaXRlbXM6IG5ld1NlbGVjdGlvbixcbiAgICAgIGV2ZW50OiBldmVudFxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZSBjcmVhdGlvbiBhbmQgdXBkYXRlcyBvZiBhbiBpdGVtIG9uIGRvdWJsZSB0YXBcbiAqIEBwYXJhbSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uQWRkSXRlbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5zZWxlY3RhYmxlKSByZXR1cm47XG4gIGlmICghdGhpcy5vcHRpb25zLmVkaXRhYmxlLmFkZCkgcmV0dXJuO1xuXG4gIHZhciBtZSA9IHRoaXM7XG4gIHZhciBzbmFwID0gdGhpcy5vcHRpb25zLnNuYXAgfHwgbnVsbDtcbiAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1Gcm9tVGFyZ2V0KGV2ZW50KTtcblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICBpZiAoaXRlbSkge1xuICAgIC8vIHVwZGF0ZSBpdGVtXG5cbiAgICAvLyBleGVjdXRlIGFzeW5jIGhhbmRsZXIgdG8gdXBkYXRlIHRoZSBpdGVtIChvciBjYW5jZWwgaXQpXG4gICAgdmFyIGl0ZW1EYXRhID0gbWUuaXRlbXNEYXRhLmdldChpdGVtLmlkKTsgLy8gZ2V0IGEgY2xvbmUgb2YgdGhlIGRhdGEgZnJvbSB0aGUgZGF0YXNldFxuICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShpdGVtRGF0YSwgZnVuY3Rpb24gKGl0ZW1EYXRhKSB7XG4gICAgICBpZiAoaXRlbURhdGEpIHtcbiAgICAgICAgbWUuaXRlbXNEYXRhLmdldERhdGFTZXQoKS51cGRhdGUoaXRlbURhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIGFkZCBpdGVtXG4gICAgdmFyIHhBYnMgPSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmRvbS5mcmFtZSk7XG4gICAgdmFyIHggPSBldmVudC5jZW50ZXIueCAtIHhBYnM7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKHgpO1xuICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS51dGlsLmdldFNjYWxlKCk7XG4gICAgdmFyIHN0ZXAgPSB0aGlzLmJvZHkudXRpbC5nZXRTdGVwKCk7XG5cbiAgICB2YXIgbmV3SXRlbURhdGEgPSB7XG4gICAgICBzdGFydDogc25hcCA/IHNuYXAoc3RhcnQsIHNjYWxlLCBzdGVwKSA6IHN0YXJ0LFxuICAgICAgY29udGVudDogJ25ldyBpdGVtJ1xuICAgIH07XG5cbiAgICAvLyB3aGVuIGRlZmF1bHQgdHlwZSBpcyBhIHJhbmdlLCBhZGQgYSBkZWZhdWx0IGVuZCBkYXRlIHRvIHRoZSBuZXcgaXRlbVxuICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gJ3JhbmdlJykge1xuICAgICAgdmFyIGVuZCA9IHRoaXMuYm9keS51dGlsLnRvVGltZSh4ICsgdGhpcy5wcm9wcy53aWR0aCAvIDUpO1xuICAgICAgbmV3SXRlbURhdGEuZW5kID0gc25hcCA/IHNuYXAoZW5kLCBzY2FsZSwgc3RlcCkgOiBlbmQ7XG4gICAgfVxuXG4gICAgbmV3SXRlbURhdGFbdGhpcy5pdGVtc0RhdGEuX2ZpZWxkSWRdID0gdXRpbC5yYW5kb21VVUlEKCk7XG5cbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwRnJvbVRhcmdldChldmVudCk7XG4gICAgaWYgKGdyb3VwKSB7XG4gICAgICBuZXdJdGVtRGF0YS5ncm91cCA9IGdyb3VwLmdyb3VwSWQ7XG4gICAgfVxuXG4gICAgLy8gZXhlY3V0ZSBhc3luYyBoYW5kbGVyIHRvIGN1c3RvbWl6ZSAob3IgY2FuY2VsKSBhZGRpbmcgYW4gaXRlbVxuICAgIG5ld0l0ZW1EYXRhID0gdGhpcy5fY2xvbmVJdGVtRGF0YShuZXdJdGVtRGF0YSk7ICAgICAvLyBjb252ZXJ0IHN0YXJ0IGFuZCBlbmQgdG8gdGhlIGNvcnJlY3QgdHlwZVxuICAgIHRoaXMub3B0aW9ucy5vbkFkZChuZXdJdGVtRGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIG1lLml0ZW1zRGF0YS5nZXREYXRhU2V0KCkuYWRkKGl0ZW0pO1xuICAgICAgICAvLyBUT0RPOiBuZWVkIHRvIHRyaWdnZXIgYSByZWRyYXc/XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlIHNlbGVjdGluZy9kZXNlbGVjdGluZyBtdWx0aXBsZSBpdGVtcyB3aGVuIGhvbGRpbmcgYW4gaXRlbVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vbk11bHRpU2VsZWN0SXRlbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5zZWxlY3RhYmxlKSByZXR1cm47XG5cbiAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1Gcm9tVGFyZ2V0KGV2ZW50KTtcblxuICBpZiAoaXRlbSkge1xuICAgIC8vIG11bHRpIHNlbGVjdCBpdGVtcyAoaWYgYWxsb3dlZClcblxuICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLm9wdGlvbnMubXVsdGlzZWxlY3RcbiAgICAgID8gdGhpcy5nZXRTZWxlY3Rpb24oKSAvLyB0YWtlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICA6IFtdOyAgICAgICAgICAgICAgICAgLy8gZGVzZWxlY3QgY3VycmVudCBzZWxlY3Rpb25cblxuICAgIHZhciBzaGlmdEtleSA9IGV2ZW50LnNyY0V2ZW50ICYmIGV2ZW50LnNyY0V2ZW50LnNoaWZ0S2V5IHx8IGZhbHNlO1xuXG4gICAgaWYgKHNoaWZ0S2V5ICYmIHRoaXMub3B0aW9ucy5tdWx0aXNlbGVjdCkge1xuICAgICAgLy8gc2VsZWN0IGFsbCBpdGVtcyBiZXR3ZWVuIHRoZSBvbGQgc2VsZWN0aW9uIGFuZCB0aGUgdGFwcGVkIGl0ZW1cblxuICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBzZWxlY3Rpb24gcmFuZ2VcbiAgICAgIHNlbGVjdGlvbi5wdXNoKGl0ZW0uaWQpO1xuICAgICAgdmFyIHJhbmdlID0gSXRlbVNldC5fZ2V0SXRlbVJhbmdlKHRoaXMuaXRlbXNEYXRhLmdldChzZWxlY3Rpb24sIHRoaXMuaXRlbU9wdGlvbnMpKTtcblxuICAgICAgLy8gc2VsZWN0IGFsbCBpdGVtcyB3aXRoaW4gdGhlIHNlbGVjdGlvbiByYW5nZVxuICAgICAgc2VsZWN0aW9uID0gW107XG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLml0ZW1zKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIHZhciBfaXRlbSA9IHRoaXMuaXRlbXNbaWRdO1xuICAgICAgICAgIHZhciBzdGFydCA9IF9pdGVtLmRhdGEuc3RhcnQ7XG4gICAgICAgICAgdmFyIGVuZCA9IChfaXRlbS5kYXRhLmVuZCAhPT0gdW5kZWZpbmVkKSA/IF9pdGVtLmRhdGEuZW5kIDogc3RhcnQ7XG5cbiAgICAgICAgICBpZiAoc3RhcnQgPj0gcmFuZ2UubWluICYmXG4gICAgICAgICAgICAgIGVuZCA8PSByYW5nZS5tYXggJiZcbiAgICAgICAgICAgICAgIShfaXRlbSBpbnN0YW5jZW9mIEJhY2tncm91bmRJdGVtKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uLnB1c2goX2l0ZW0uaWQpOyAvLyBkbyBub3QgdXNlIGlkIGJ1dCBpdGVtLmlkLCBpZCBpdHNlbGYgaXMgc3RyaW5naWZpZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBhZGQvcmVtb3ZlIHRoaXMgaXRlbSBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgdmFyIGluZGV4ID0gc2VsZWN0aW9uLmluZGV4T2YoaXRlbS5pZCk7XG4gICAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgICAgLy8gaXRlbSBpcyBub3QgeWV0IHNlbGVjdGVkIC0+IHNlbGVjdCBpdFxuICAgICAgICBzZWxlY3Rpb24ucHVzaChpdGVtLmlkKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBpdGVtIGlzIGFscmVhZHkgc2VsZWN0ZWQgLT4gZGVzZWxlY3QgaXRcbiAgICAgICAgc2VsZWN0aW9uLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcblxuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3NlbGVjdCcsIHtcbiAgICAgIGl0ZW1zOiB0aGlzLmdldFNlbGVjdGlvbigpLFxuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSB0aW1lIHJhbmdlIG9mIGEgbGlzdCBvZiBpdGVtc1xuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gaXRlbXNEYXRhXG4gKiBAcmV0dXJuIHt7bWluOiBEYXRlLCBtYXg6IERhdGV9fSBSZXR1cm5zIHRoZSByYW5nZSBvZiB0aGUgcHJvdmlkZWQgaXRlbXNcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQuX2dldEl0ZW1SYW5nZSA9IGZ1bmN0aW9uKGl0ZW1zRGF0YSkge1xuICB2YXIgbWF4ID0gbnVsbDtcbiAgdmFyIG1pbiA9IG51bGw7XG5cbiAgaXRlbXNEYXRhLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAobWluID09IG51bGwgfHwgZGF0YS5zdGFydCA8IG1pbikge1xuICAgICAgbWluID0gZGF0YS5zdGFydDtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5lbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAobWF4ID09IG51bGwgfHwgZGF0YS5lbmQgPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gZGF0YS5lbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKG1heCA9PSBudWxsIHx8IGRhdGEuc3RhcnQgPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gZGF0YS5zdGFydDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXhcbiAgfVxufTtcblxuLyoqXG4gKiBGaW5kIGFuIGl0ZW0gZnJvbSBhbiBldmVudCB0YXJnZXQ6XG4gKiBzZWFyY2hlcyBmb3IgdGhlIGF0dHJpYnV0ZSAndGltZWxpbmUtaXRlbScgaW4gdGhlIGV2ZW50IHRhcmdldCdzIGVsZW1lbnQgdHJlZVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge0l0ZW0gfCBudWxsfSBpdGVtXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLml0ZW1Gcm9tVGFyZ2V0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgd2hpbGUgKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuaGFzT3duUHJvcGVydHkoJ3RpbWVsaW5lLWl0ZW0nKSkge1xuICAgICAgcmV0dXJuIHRhcmdldFsndGltZWxpbmUtaXRlbSddO1xuICAgIH1cbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBHcm91cCBmcm9tIGFuIGV2ZW50IHRhcmdldDpcbiAqIHNlYXJjaGVzIGZvciB0aGUgYXR0cmlidXRlICd0aW1lbGluZS1ncm91cCcgaW4gdGhlIGV2ZW50IHRhcmdldCdzIGVsZW1lbnQgdHJlZVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge0dyb3VwIHwgbnVsbH0gZ3JvdXBcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuZ3JvdXBGcm9tVGFyZ2V0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdmFyIGNsaWVudFkgPSBldmVudC5jZW50ZXIgPyBldmVudC5jZW50ZXIueSA6IGV2ZW50LmNsaWVudFk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBncm91cElkID0gdGhpcy5ncm91cElkc1tpXTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgICB2YXIgZm9yZWdyb3VuZCA9IGdyb3VwLmRvbS5mb3JlZ3JvdW5kO1xuICAgIHZhciB0b3AgPSB1dGlsLmdldEFic29sdXRlVG9wKGZvcmVncm91bmQpO1xuICAgIGlmIChjbGllbnRZID4gdG9wICYmIGNsaWVudFkgPCB0b3AgKyBmb3JlZ3JvdW5kLm9mZnNldEhlaWdodCkge1xuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSA9PT0gJ3RvcCcpIHtcbiAgICAgIGlmIChpID09PSB0aGlzLmdyb3VwSWRzLmxlbmd0aCAtIDEgJiYgY2xpZW50WSA+IHRvcCkge1xuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGkgPT09IDAgJiYgY2xpZW50WSA8IHRvcCArIGZvcmVncm91bmQub2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogRmluZCB0aGUgSXRlbVNldCBmcm9tIGFuIGV2ZW50IHRhcmdldDpcbiAqIHNlYXJjaGVzIGZvciB0aGUgYXR0cmlidXRlICd0aW1lbGluZS1pdGVtc2V0JyBpbiB0aGUgZXZlbnQgdGFyZ2V0J3MgZWxlbWVudCB0cmVlXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybiB7SXRlbVNldCB8IG51bGx9IGl0ZW1cbiAqL1xuSXRlbVNldC5pdGVtU2V0RnJvbVRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIHdoaWxlICh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KCd0aW1lbGluZS1pdGVtc2V0JykpIHtcbiAgICAgIHJldHVybiB0YXJnZXRbJ3RpbWVsaW5lLWl0ZW1zZXQnXTtcbiAgICB9XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xvbmUgdGhlIGRhdGEgb2YgYW4gaXRlbSwgYW5kIFwibm9ybWFsaXplXCIgaXQ6IGNvbnZlcnQgdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZVxuICogdG8gdGhlIHR5cGUgKERhdGUsIE1vbWVudCwgLi4uKSBjb25maWd1cmVkIGluIHRoZSBEYXRhU2V0LiBJZiBub3QgY29uZmlndXJlZCxcbiAqIHN0YXJ0IGFuZCBlbmQgYXJlIGNvbnZlcnRlZCB0byBEYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW1EYXRhLCB0eXBpY2FsbHkgYGl0ZW0uZGF0YWBcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gIE9wdGlvbmFsIERhdGUgdHlwZS4gSWYgbm90IHByb3ZpZGVkLCB0aGUgdHlwZSBmcm9tIHRoZSBEYXRhU2V0IGlzIHRha2VuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZWQgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fY2xvbmVJdGVtRGF0YSA9IGZ1bmN0aW9uIChpdGVtRGF0YSwgdHlwZSkge1xuICB2YXIgY2xvbmUgPSB1dGlsLmV4dGVuZCh7fSwgaXRlbURhdGEpO1xuXG4gIGlmICghdHlwZSkge1xuICAgIC8vIGNvbnZlcnQgc3RhcnQgYW5kIGVuZCBkYXRlIHRvIHRoZSB0eXBlIChEYXRlLCBNb21lbnQsIC4uLikgY29uZmlndXJlZCBpbiB0aGUgRGF0YVNldFxuICAgIHR5cGUgPSB0aGlzLml0ZW1zRGF0YS5nZXREYXRhU2V0KCkuX29wdGlvbnMudHlwZTtcbiAgfVxuXG4gIGlmIChjbG9uZS5zdGFydCAhPSB1bmRlZmluZWQpIHtcbiAgICBjbG9uZS5zdGFydCA9IHV0aWwuY29udmVydChjbG9uZS5zdGFydCwgdHlwZSAmJiB0eXBlLnN0YXJ0IHx8ICdEYXRlJyk7XG4gIH1cbiAgaWYgKGNsb25lLmVuZCAhPSB1bmRlZmluZWQpIHtcbiAgICBjbG9uZS5lbmQgPSB1dGlsLmNvbnZlcnQoY2xvbmUuZW5kICwgdHlwZSAmJiB0eXBlLmVuZCB8fCAnRGF0ZScpO1xuICB9XG5cbiAgcmV0dXJuIGNsb25lO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJdGVtU2V0O1xuIl19
},{"../../DataSet":15,"../../DataView":16,"../../module/hammer":19,"../../util":46,"../TimeStep":30,"./BackgroundGroup":32,"./Component":33,"./Group":36,"./item/BackgroundItem":39,"./item/BoxItem":40,"./item/PointItem":42,"./item/RangeItem":43}],38:[function(require,module,exports){
'use strict';

var util = require('../../util');
var Component = require('./Component');
var TimeStep = require('../TimeStep');
var DateUtil = require('../DateUtil');
var moment = require('../../module/moment');

/**
 * A horizontal time axis
 * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
 * @param {Object} [options]        See TimeAxis.setOptions for the available
 *                                  options.
 * @constructor TimeAxis
 * @extends Component
 */
function TimeAxis(body, options) {
  this.dom = {
    foreground: null,
    lines: [],
    majorTexts: [],
    minorTexts: [],
    redundant: {
      lines: [],
      majorTexts: [],
      minorTexts: []
    }
  };
  this.props = {
    range: {
      start: 0,
      end: 0,
      minimumStep: 0
    },
    lineTop: 0
  };

  this.defaultOptions = {
    orientation: {
      axis: 'bottom'
    }, // axis orientation: 'top' or 'bottom'
    showMinorLabels: true,
    showMajorLabels: true,
    format: TimeStep.FORMAT,
    moment: moment,
    timeAxis: null
  };
  this.options = util.extend({}, this.defaultOptions);

  this.body = body;

  // create the HTML DOM
  this._create();

  this.setOptions(options);
}

TimeAxis.prototype = new Component();

/**
 * Set options for the TimeAxis.
 * Parameters will be merged in current options.
 * @param {Object} options  Available options:
 *                          {string} [orientation.axis]
 *                          {boolean} [showMinorLabels]
 *                          {boolean} [showMajorLabels]
 */
TimeAxis.prototype.setOptions = function (options) {
  if (options) {
    // copy all options that we know
    util.selectiveExtend(['showMinorLabels', 'showMajorLabels', 'hiddenDates', 'timeAxis', 'moment'], this.options, options);

    // deep copy the format options
    util.selectiveDeepExtend(['format'], this.options, options);

    if ('orientation' in options) {
      if (typeof options.orientation === 'string') {
        this.options.orientation.axis = options.orientation;
      } else if (typeof options.orientation === 'object' && 'axis' in options.orientation) {
        this.options.orientation.axis = options.orientation.axis;
      }
    }

    // apply locale to moment.js
    // TODO: not so nice, this is applied globally to moment.js
    if ('locale' in options) {
      if (typeof moment.locale === 'function') {
        // moment.js 2.8.1+
        moment.locale(options.locale);
      } else {
        moment.lang(options.locale);
      }
    }
  }
};

/**
 * Create the HTML DOM for the TimeAxis
 */
TimeAxis.prototype._create = function () {
  this.dom.foreground = document.createElement('div');
  this.dom.background = document.createElement('div');

  this.dom.foreground.className = 'vis-time-axis vis-foreground';
  this.dom.background.className = 'vis-time-axis vis-background';
};

/**
 * Destroy the TimeAxis
 */
TimeAxis.prototype.destroy = function () {
  // remove from DOM
  if (this.dom.foreground.parentNode) {
    this.dom.foreground.parentNode.removeChild(this.dom.foreground);
  }
  if (this.dom.background.parentNode) {
    this.dom.background.parentNode.removeChild(this.dom.background);
  }

  this.body = null;
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
TimeAxis.prototype.redraw = function () {
  var props = this.props;
  var foreground = this.dom.foreground;
  var background = this.dom.background;

  // determine the correct parent DOM element (depending on option orientation)
  var parent = this.options.orientation.axis == 'top' ? this.body.dom.top : this.body.dom.bottom;
  var parentChanged = foreground.parentNode !== parent;

  // calculate character width and height
  this._calculateCharSize();

  // TODO: recalculate sizes only needed when parent is resized or options is changed
  var showMinorLabels = this.options.showMinorLabels && this.options.orientation.axis !== 'none';
  var showMajorLabels = this.options.showMajorLabels && this.options.orientation.axis !== 'none';

  // determine the width and height of the elemens for the axis
  props.minorLabelHeight = showMinorLabels ? props.minorCharHeight : 0;
  props.majorLabelHeight = showMajorLabels ? props.majorCharHeight : 0;
  props.height = props.minorLabelHeight + props.majorLabelHeight;
  props.width = foreground.offsetWidth;

  props.minorLineHeight = this.body.domProps.root.height - props.majorLabelHeight - (this.options.orientation.axis == 'top' ? this.body.domProps.bottom.height : this.body.domProps.top.height);
  props.minorLineWidth = 1; // TODO: really calculate width
  props.majorLineHeight = props.minorLineHeight + props.majorLabelHeight;
  props.majorLineWidth = 1; // TODO: really calculate width

  //  take foreground and background offline while updating (is almost twice as fast)
  var foregroundNextSibling = foreground.nextSibling;
  var backgroundNextSibling = background.nextSibling;
  foreground.parentNode && foreground.parentNode.removeChild(foreground);
  background.parentNode && background.parentNode.removeChild(background);

  foreground.style.height = this.props.height + 'px';

  this._repaintLabels();

  // put DOM online again (at the same place)
  if (foregroundNextSibling) {
    parent.insertBefore(foreground, foregroundNextSibling);
  } else {
    parent.appendChild(foreground);
  }
  if (backgroundNextSibling) {
    this.body.dom.backgroundVertical.insertBefore(background, backgroundNextSibling);
  } else {
    this.body.dom.backgroundVertical.appendChild(background);
  }

  return this._isResized() || parentChanged;
};

/**
 * Repaint major and minor text labels and vertical grid lines
 * @private
 */
TimeAxis.prototype._repaintLabels = function () {
  var orientation = this.options.orientation.axis;

  // calculate range and step (step such that we have space for 7 characters per label)
  var start = util.convert(this.body.range.start, 'Number');
  var end = util.convert(this.body.range.end, 'Number');
  var timeLabelsize = this.body.util.toTime((this.props.minorCharWidth || 10) * 7).valueOf();
  var minimumStep = timeLabelsize - DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this.body.range, timeLabelsize);
  minimumStep -= this.body.util.toTime(0).valueOf();

  var step = new TimeStep(new Date(start), new Date(end), minimumStep, this.body.hiddenDates);
  step.setMoment(this.options.moment);
  if (this.options.format) {
    step.setFormat(this.options.format);
  }
  if (this.options.timeAxis) {
    step.setScale(this.options.timeAxis);
  }
  this.step = step;

  // Move all DOM elements to a "redundant" list, where they
  // can be picked for re-use, and clear the lists with lines and texts.
  // At the end of the function _repaintLabels, left over elements will be cleaned up
  var dom = this.dom;
  dom.redundant.lines = dom.lines;
  dom.redundant.majorTexts = dom.majorTexts;
  dom.redundant.minorTexts = dom.minorTexts;
  dom.lines = [];
  dom.majorTexts = [];
  dom.minorTexts = [];

  var current;
  var next;
  var x;
  var xNext;
  var isMajor;
  var width;
  var line;
  var labelMinor;
  var xFirstMajorLabel = undefined;
  var max = 0;
  var className;

  step.start();
  next = step.getCurrent();
  xNext = this.body.util.toScreen(next);
  while (step.hasNext() && max < 1000) {
    max++;

    isMajor = step.isMajor();
    className = step.getClassName();
    labelMinor = step.getLabelMinor();

    current = next;
    x = xNext;

    step.next();
    next = step.getCurrent();
    xNext = this.body.util.toScreen(next);

    width = xNext - x;
    var labelFits = (labelMinor.length + 1) * this.props.minorCharWidth < width;

    if (this.options.showMinorLabels && labelFits) {
      this._repaintMinorText(x, labelMinor, orientation, className);
    }

    if (isMajor && this.options.showMajorLabels) {
      if (x > 0) {
        if (xFirstMajorLabel == undefined) {
          xFirstMajorLabel = x;
        }
        this._repaintMajorText(x, step.getLabelMajor(), orientation, className);
      }
      line = this._repaintMajorLine(x, width, orientation, className);
    } else {
      if (labelFits) {
        line = this._repaintMinorLine(x, width, orientation, className);
      } else {
        if (line) {
          line.style.width = parseInt(line.style.width) + width + 'px';
        }
      }
    }
  }

  // create a major label on the left when needed
  if (this.options.showMajorLabels) {
    var leftTime = this.body.util.toTime(0),
        leftText = step.getLabelMajor(leftTime),
        widthText = leftText.length * (this.props.majorCharWidth || 10) + 10; // upper bound estimation

    if (xFirstMajorLabel == undefined || widthText < xFirstMajorLabel) {
      this._repaintMajorText(0, leftText, orientation, className);
    }
  }

  // Cleanup leftover DOM elements from the redundant list
  util.forEach(this.dom.redundant, function (arr) {
    while (arr.length) {
      var elem = arr.pop();
      if (elem && elem.parentNode) {
        elem.parentNode.removeChild(elem);
      }
    }
  });
};

/**
 * Create a minor label for the axis at position x
 * @param {Number} x
 * @param {String} text
 * @param {String} orientation   "top" or "bottom" (default)
 * @param {String} className
 * @return {Element} Returns the HTML element of the created label
 * @private
 */
TimeAxis.prototype._repaintMinorText = function (x, text, orientation, className) {
  // reuse redundant label
  var label = this.dom.redundant.minorTexts.shift();

  if (!label) {
    // create new label
    var content = document.createTextNode('');
    label = document.createElement('div');
    label.appendChild(content);
    this.dom.foreground.appendChild(label);
  }
  this.dom.minorTexts.push(label);

  label.childNodes[0].nodeValue = text;

  label.style.top = orientation == 'top' ? this.props.majorLabelHeight + 'px' : '0';
  label.style.left = x + 'px';
  label.className = 'vis-text vis-minor ' + className;
  //label.title = title;  // TODO: this is a heavy operation

  return label;
};

/**
 * Create a Major label for the axis at position x
 * @param {Number} x
 * @param {String} text
 * @param {String} orientation   "top" or "bottom" (default)
 * @param {String} className
 * @return {Element} Returns the HTML element of the created label
 * @private
 */
TimeAxis.prototype._repaintMajorText = function (x, text, orientation, className) {
  // reuse redundant label
  var label = this.dom.redundant.majorTexts.shift();

  if (!label) {
    // create label
    var content = document.createTextNode(text);
    label = document.createElement('div');
    label.appendChild(content);
    this.dom.foreground.appendChild(label);
  }
  this.dom.majorTexts.push(label);

  label.childNodes[0].nodeValue = text;
  label.className = 'vis-text vis-major ' + className;
  //label.title = title; // TODO: this is a heavy operation

  label.style.top = orientation == 'top' ? '0' : this.props.minorLabelHeight + 'px';
  label.style.left = x + 'px';

  return label;
};

/**
 * Create a minor line for the axis at position x
 * @param {Number} x
 * @param {Number} width
 * @param {String} orientation   "top" or "bottom" (default)
 * @param {String} className
 * @return {Element} Returns the created line
 * @private
 */
TimeAxis.prototype._repaintMinorLine = function (x, width, orientation, className) {
  // reuse redundant line
  var line = this.dom.redundant.lines.shift();
  if (!line) {
    // create vertical line
    line = document.createElement('div');
    this.dom.background.appendChild(line);
  }
  this.dom.lines.push(line);

  var props = this.props;
  if (orientation == 'top') {
    line.style.top = props.majorLabelHeight + 'px';
  } else {
    line.style.top = this.body.domProps.top.height + 'px';
  }
  line.style.height = props.minorLineHeight + 'px';
  line.style.left = x - props.minorLineWidth / 2 + 'px';
  line.style.width = width + 'px';

  line.className = 'vis-grid vis-vertical vis-minor ' + className;

  return line;
};

/**
 * Create a Major line for the axis at position x
 * @param {Number} x
 * @param {Number} width
 * @param {String} orientation   "top" or "bottom" (default)
 * @param {String} className
 * @return {Element} Returns the created line
 * @private
 */
TimeAxis.prototype._repaintMajorLine = function (x, width, orientation, className) {
  // reuse redundant line
  var line = this.dom.redundant.lines.shift();
  if (!line) {
    // create vertical line
    line = document.createElement('div');
    this.dom.background.appendChild(line);
  }
  this.dom.lines.push(line);

  var props = this.props;
  if (orientation == 'top') {
    line.style.top = '0';
  } else {
    line.style.top = this.body.domProps.top.height + 'px';
  }
  line.style.left = x - props.majorLineWidth / 2 + 'px';
  line.style.height = props.majorLineHeight + 'px';
  line.style.width = width + 'px';

  line.className = 'vis-grid vis-vertical vis-major ' + className;

  return line;
};

/**
 * Determine the size of text on the axis (both major and minor axis).
 * The size is calculated only once and then cached in this.props.
 * @private
 */
TimeAxis.prototype._calculateCharSize = function () {
  // Note: We calculate char size with every redraw. Size may change, for
  // example when any of the timelines parents had display:none for example.

  // determine the char width and height on the minor axis
  if (!this.dom.measureCharMinor) {
    this.dom.measureCharMinor = document.createElement('DIV');
    this.dom.measureCharMinor.className = 'vis-text vis-minor vis-measure';
    this.dom.measureCharMinor.style.position = 'absolute';

    this.dom.measureCharMinor.appendChild(document.createTextNode('0'));
    this.dom.foreground.appendChild(this.dom.measureCharMinor);
  }
  this.props.minorCharHeight = this.dom.measureCharMinor.clientHeight;
  this.props.minorCharWidth = this.dom.measureCharMinor.clientWidth;

  // determine the char width and height on the major axis
  if (!this.dom.measureCharMajor) {
    this.dom.measureCharMajor = document.createElement('DIV');
    this.dom.measureCharMajor.className = 'vis-text vis-major vis-measure';
    this.dom.measureCharMajor.style.position = 'absolute';

    this.dom.measureCharMajor.appendChild(document.createTextNode('0'));
    this.dom.foreground.appendChild(this.dom.measureCharMajor);
  }
  this.props.majorCharHeight = this.dom.measureCharMajor.clientHeight;
  this.props.majorCharWidth = this.dom.measureCharMajor.clientWidth;
};

module.exports = TimeAxis;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L1RpbWVBeGlzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ2pDLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN2QyxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDdEMsSUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3RDLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDOzs7Ozs7Ozs7O0FBVTVDLFNBQVMsUUFBUSxDQUFFLElBQUksRUFBRSxPQUFPLEVBQUU7QUFDaEMsTUFBSSxDQUFDLEdBQUcsR0FBRztBQUNULGNBQVUsRUFBRSxJQUFJO0FBQ2hCLFNBQUssRUFBRSxFQUFFO0FBQ1QsY0FBVSxFQUFFLEVBQUU7QUFDZCxjQUFVLEVBQUUsRUFBRTtBQUNkLGFBQVMsRUFBRTtBQUNULFdBQUssRUFBRSxFQUFFO0FBQ1QsZ0JBQVUsRUFBRSxFQUFFO0FBQ2QsZ0JBQVUsRUFBRSxFQUFFO0tBQ2Y7R0FDRixDQUFDO0FBQ0YsTUFBSSxDQUFDLEtBQUssR0FBRztBQUNYLFNBQUssRUFBRTtBQUNMLFdBQUssRUFBRSxDQUFDO0FBQ1IsU0FBRyxFQUFFLENBQUM7QUFDTixpQkFBVyxFQUFFLENBQUM7S0FDZjtBQUNELFdBQU8sRUFBRSxDQUFDO0dBQ1gsQ0FBQzs7QUFFRixNQUFJLENBQUMsY0FBYyxHQUFHO0FBQ3BCLGVBQVcsRUFBRTtBQUNYLFVBQUksRUFBRSxRQUFRO0tBQ2Y7QUFDRCxtQkFBZSxFQUFFLElBQUk7QUFDckIsbUJBQWUsRUFBRSxJQUFJO0FBQ3JCLFVBQU0sRUFBRSxR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O0FBQzlCLFFBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMxRCxRQUFJLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLFNBQVMsR0FBRyxnQ0FBZ0MsQ0FBQztBQUN2RSxRQUFJLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDOztBQUV0RCxRQUFJLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDcEUsUUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztHQUM1RDtBQUNELE1BQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxDQUFDO0FBQ3BFLE1BQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDO0NBQ25FLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMiLCJmaWxlIjoiL1VzZXJzL2RhcmluL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzLXZpZXdlci9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvVGltZUF4aXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuL0NvbXBvbmVudCcpO1xudmFyIFRpbWVTdGVwID0gcmVxdWlyZSgnLi4vVGltZVN0ZXAnKTtcbnZhciBEYXRlVXRpbCA9IHJlcXVpcmUoJy4uL0RhdGVVdGlsJyk7XG52YXIgbW9tZW50ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlL21vbWVudCcpO1xuXG4vKipcbiAqIEEgaG9yaXpvbnRhbCB0aW1lIGF4aXNcbiAqIEBwYXJhbSB7e2RvbTogT2JqZWN0LCBkb21Qcm9wczogT2JqZWN0LCBlbWl0dGVyOiBFbWl0dGVyLCByYW5nZTogUmFuZ2V9fSBib2R5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBTZWUgVGltZUF4aXMuc2V0T3B0aW9ucyBmb3IgdGhlIGF2YWlsYWJsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5cbiAqIEBjb25zdHJ1Y3RvciBUaW1lQXhpc1xuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIFRpbWVBeGlzIChib2R5LCBvcHRpb25zKSB7XG4gIHRoaXMuZG9tID0ge1xuICAgIGZvcmVncm91bmQ6IG51bGwsXG4gICAgbGluZXM6IFtdLFxuICAgIG1ham9yVGV4dHM6IFtdLFxuICAgIG1pbm9yVGV4dHM6IFtdLFxuICAgIHJlZHVuZGFudDoge1xuICAgICAgbGluZXM6IFtdLFxuICAgICAgbWFqb3JUZXh0czogW10sXG4gICAgICBtaW5vclRleHRzOiBbXVxuICAgIH1cbiAgfTtcbiAgdGhpcy5wcm9wcyA9IHtcbiAgICByYW5nZToge1xuICAgICAgc3RhcnQ6IDAsXG4gICAgICBlbmQ6IDAsXG4gICAgICBtaW5pbXVtU3RlcDogMFxuICAgIH0sXG4gICAgbGluZVRvcDogMFxuICB9O1xuXG4gIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgb3JpZW50YXRpb246IHtcbiAgICAgIGF4aXM6ICdib3R0b20nXG4gICAgfSwgIC8vIGF4aXMgb3JpZW50YXRpb246ICd0b3AnIG9yICdib3R0b20nXG4gICAgc2hvd01pbm9yTGFiZWxzOiB0cnVlLFxuICAgIHNob3dNYWpvckxhYmVsczogdHJ1ZSxcbiAgICBmb3JtYXQ6IFRpbWVTdGVwLkZPUk1BVCxcbiAgICBtb21lbnQ6IG1vbWVudCxcbiAgICB0aW1lQXhpczogbnVsbFxuICB9O1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAvLyBjcmVhdGUgdGhlIEhUTUwgRE9NXG4gIHRoaXMuX2NyZWF0ZSgpO1xuXG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbn1cblxuVGltZUF4aXMucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4vKipcbiAqIFNldCBvcHRpb25zIGZvciB0aGUgVGltZUF4aXMuXG4gKiBQYXJhbWV0ZXJzIHdpbGwgYmUgbWVyZ2VkIGluIGN1cnJlbnQgb3B0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBbb3JpZW50YXRpb24uYXhpc11cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB7Ym9vbGVhbn0gW3Nob3dNaW5vckxhYmVsc11cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB7Ym9vbGVhbn0gW3Nob3dNYWpvckxhYmVsc11cbiAqL1xuVGltZUF4aXMucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgLy8gY29weSBhbGwgb3B0aW9ucyB0aGF0IHdlIGtub3dcbiAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbXG4gICAgICAnc2hvd01pbm9yTGFiZWxzJyxcbiAgICAgICdzaG93TWFqb3JMYWJlbHMnLFxuICAgICAgJ2hpZGRlbkRhdGVzJyxcbiAgICAgICd0aW1lQXhpcycsXG4gICAgICAnbW9tZW50J1xuICAgIF0sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAvLyBkZWVwIGNvcHkgdGhlIGZvcm1hdCBvcHRpb25zXG4gICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKFsnZm9ybWF0J10sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBpZiAoJ29yaWVudGF0aW9uJyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMub3JpZW50YXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID0gb3B0aW9ucy5vcmllbnRhdGlvbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLm9yaWVudGF0aW9uID09PSAnb2JqZWN0JyAmJiAnYXhpcycgaW4gb3B0aW9ucy5vcmllbnRhdGlvbikge1xuICAgICAgICB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyA9IG9wdGlvbnMub3JpZW50YXRpb24uYXhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhcHBseSBsb2NhbGUgdG8gbW9tZW50LmpzXG4gICAgLy8gVE9ETzogbm90IHNvIG5pY2UsIHRoaXMgaXMgYXBwbGllZCBnbG9iYWxseSB0byBtb21lbnQuanNcbiAgICBpZiAoJ2xvY2FsZScgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBtb21lbnQubG9jYWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG1vbWVudC5qcyAyLjguMStcbiAgICAgICAgbW9tZW50LmxvY2FsZShvcHRpb25zLmxvY2FsZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbW9tZW50Lmxhbmcob3B0aW9ucy5sb2NhbGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIEhUTUwgRE9NIGZvciB0aGUgVGltZUF4aXNcbiAqL1xuVGltZUF4aXMucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kb20uZm9yZWdyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgdGhpcy5kb20uZm9yZWdyb3VuZC5jbGFzc05hbWUgPSAndmlzLXRpbWUtYXhpcyB2aXMtZm9yZWdyb3VuZCc7XG4gIHRoaXMuZG9tLmJhY2tncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy10aW1lLWF4aXMgdmlzLWJhY2tncm91bmQnO1xufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBUaW1lQXhpc1xuICovXG5UaW1lQXhpcy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAvLyByZW1vdmUgZnJvbSBET01cbiAgaWYgKHRoaXMuZG9tLmZvcmVncm91bmQucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuZG9tLmZvcmVncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5mb3JlZ3JvdW5kKTtcbiAgfVxuICBpZiAodGhpcy5kb20uYmFja2dyb3VuZC5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5kb20uYmFja2dyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmJhY2tncm91bmQpO1xuICB9XG5cbiAgdGhpcy5ib2R5ID0gbnVsbDtcbn07XG5cbi8qKlxuICogUmVwYWludCB0aGUgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gKi9cblRpbWVBeGlzLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gIHZhciBmb3JlZ3JvdW5kID0gdGhpcy5kb20uZm9yZWdyb3VuZDtcbiAgdmFyIGJhY2tncm91bmQgPSB0aGlzLmRvbS5iYWNrZ3JvdW5kO1xuXG4gIC8vIGRldGVybWluZSB0aGUgY29ycmVjdCBwYXJlbnQgRE9NIGVsZW1lbnQgKGRlcGVuZGluZyBvbiBvcHRpb24gb3JpZW50YXRpb24pXG4gIHZhciBwYXJlbnQgPSAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXMgPT0gJ3RvcCcpID8gdGhpcy5ib2R5LmRvbS50b3AgOiB0aGlzLmJvZHkuZG9tLmJvdHRvbTtcbiAgdmFyIHBhcmVudENoYW5nZWQgPSAoZm9yZWdyb3VuZC5wYXJlbnROb2RlICE9PSBwYXJlbnQpO1xuXG4gIC8vIGNhbGN1bGF0ZSBjaGFyYWN0ZXIgd2lkdGggYW5kIGhlaWdodFxuICB0aGlzLl9jYWxjdWxhdGVDaGFyU2l6ZSgpO1xuXG4gIC8vIFRPRE86IHJlY2FsY3VsYXRlIHNpemVzIG9ubHkgbmVlZGVkIHdoZW4gcGFyZW50IGlzIHJlc2l6ZWQgb3Igb3B0aW9ucyBpcyBjaGFuZ2VkXG4gIHZhciBzaG93TWlub3JMYWJlbHMgPSB0aGlzLm9wdGlvbnMuc2hvd01pbm9yTGFiZWxzICYmIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzICE9PSAnbm9uZSc7XG4gIHZhciBzaG93TWFqb3JMYWJlbHMgPSB0aGlzLm9wdGlvbnMuc2hvd01ham9yTGFiZWxzICYmIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzICE9PSAnbm9uZSc7XG5cbiAgLy8gZGV0ZXJtaW5lIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBlbGVtZW5zIGZvciB0aGUgYXhpc1xuICBwcm9wcy5taW5vckxhYmVsSGVpZ2h0ID0gc2hvd01pbm9yTGFiZWxzID8gcHJvcHMubWlub3JDaGFySGVpZ2h0IDogMDtcbiAgcHJvcHMubWFqb3JMYWJlbEhlaWdodCA9IHNob3dNYWpvckxhYmVscyA/IHByb3BzLm1ham9yQ2hhckhlaWdodCA6IDA7XG4gIHByb3BzLmhlaWdodCA9IHByb3BzLm1pbm9yTGFiZWxIZWlnaHQgKyBwcm9wcy5tYWpvckxhYmVsSGVpZ2h0O1xuICBwcm9wcy53aWR0aCA9IGZvcmVncm91bmQub2Zmc2V0V2lkdGg7XG5cbiAgcHJvcHMubWlub3JMaW5lSGVpZ2h0ID0gdGhpcy5ib2R5LmRvbVByb3BzLnJvb3QuaGVpZ2h0IC0gcHJvcHMubWFqb3JMYWJlbEhlaWdodCAtXG4gICAgICAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXMgPT0gJ3RvcCcgPyB0aGlzLmJvZHkuZG9tUHJvcHMuYm90dG9tLmhlaWdodCA6IHRoaXMuYm9keS5kb21Qcm9wcy50b3AuaGVpZ2h0KTtcbiAgcHJvcHMubWlub3JMaW5lV2lkdGggPSAxOyAvLyBUT0RPOiByZWFsbHkgY2FsY3VsYXRlIHdpZHRoXG4gIHByb3BzLm1ham9yTGluZUhlaWdodCA9IHByb3BzLm1pbm9yTGluZUhlaWdodCArIHByb3BzLm1ham9yTGFiZWxIZWlnaHQ7XG4gIHByb3BzLm1ham9yTGluZVdpZHRoID0gMTsgLy8gVE9ETzogcmVhbGx5IGNhbGN1bGF0ZSB3aWR0aFxuXG4gIC8vICB0YWtlIGZvcmVncm91bmQgYW5kIGJhY2tncm91bmQgb2ZmbGluZSB3aGlsZSB1cGRhdGluZyAoaXMgYWxtb3N0IHR3aWNlIGFzIGZhc3QpXG4gIHZhciBmb3JlZ3JvdW5kTmV4dFNpYmxpbmcgPSBmb3JlZ3JvdW5kLm5leHRTaWJsaW5nO1xuICB2YXIgYmFja2dyb3VuZE5leHRTaWJsaW5nID0gYmFja2dyb3VuZC5uZXh0U2libGluZztcbiAgZm9yZWdyb3VuZC5wYXJlbnROb2RlICYmIGZvcmVncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChmb3JlZ3JvdW5kKTtcbiAgYmFja2dyb3VuZC5wYXJlbnROb2RlICYmIGJhY2tncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiYWNrZ3JvdW5kKTtcblxuICBmb3JlZ3JvdW5kLnN0eWxlLmhlaWdodCA9IHRoaXMucHJvcHMuaGVpZ2h0ICsgJ3B4JztcblxuICB0aGlzLl9yZXBhaW50TGFiZWxzKCk7XG5cbiAgLy8gcHV0IERPTSBvbmxpbmUgYWdhaW4gKGF0IHRoZSBzYW1lIHBsYWNlKVxuICBpZiAoZm9yZWdyb3VuZE5leHRTaWJsaW5nKSB7XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShmb3JlZ3JvdW5kLCBmb3JlZ3JvdW5kTmV4dFNpYmxpbmcpO1xuICB9XG4gIGVsc2Uge1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChmb3JlZ3JvdW5kKVxuICB9XG4gIGlmIChiYWNrZ3JvdW5kTmV4dFNpYmxpbmcpIHtcbiAgICB0aGlzLmJvZHkuZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5pbnNlcnRCZWZvcmUoYmFja2dyb3VuZCwgYmFja2dyb3VuZE5leHRTaWJsaW5nKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmJvZHkuZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5hcHBlbmRDaGlsZChiYWNrZ3JvdW5kKVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2lzUmVzaXplZCgpIHx8IHBhcmVudENoYW5nZWQ7XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgbWFqb3IgYW5kIG1pbm9yIHRleHQgbGFiZWxzIGFuZCB2ZXJ0aWNhbCBncmlkIGxpbmVzXG4gKiBAcHJpdmF0ZVxuICovXG5UaW1lQXhpcy5wcm90b3R5cGUuX3JlcGFpbnRMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzO1xuXG4gIC8vIGNhbGN1bGF0ZSByYW5nZSBhbmQgc3RlcCAoc3RlcCBzdWNoIHRoYXQgd2UgaGF2ZSBzcGFjZSBmb3IgNyBjaGFyYWN0ZXJzIHBlciBsYWJlbClcbiAgdmFyIHN0YXJ0ID0gdXRpbC5jb252ZXJ0KHRoaXMuYm9keS5yYW5nZS5zdGFydCwgJ051bWJlcicpO1xuICB2YXIgZW5kID0gdXRpbC5jb252ZXJ0KHRoaXMuYm9keS5yYW5nZS5lbmQsICdOdW1iZXInKTtcbiAgdmFyIHRpbWVMYWJlbHNpemUgPSB0aGlzLmJvZHkudXRpbC50b1RpbWUoKHRoaXMucHJvcHMubWlub3JDaGFyV2lkdGggfHwgMTApICogNykudmFsdWVPZigpO1xuICB2YXIgbWluaW11bVN0ZXAgPSB0aW1lTGFiZWxzaXplIC0gRGF0ZVV0aWwuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUodGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLmJvZHkucmFuZ2UsIHRpbWVMYWJlbHNpemUpO1xuICBtaW5pbXVtU3RlcCAtPSB0aGlzLmJvZHkudXRpbC50b1RpbWUoMCkudmFsdWVPZigpO1xuXG4gIHZhciBzdGVwID0gbmV3IFRpbWVTdGVwKG5ldyBEYXRlKHN0YXJ0KSwgbmV3IERhdGUoZW5kKSwgbWluaW11bVN0ZXAsIHRoaXMuYm9keS5oaWRkZW5EYXRlcyk7XG4gIHN0ZXAuc2V0TW9tZW50KHRoaXMub3B0aW9ucy5tb21lbnQpO1xuICBpZiAodGhpcy5vcHRpb25zLmZvcm1hdCkge1xuICAgIHN0ZXAuc2V0Rm9ybWF0KHRoaXMub3B0aW9ucy5mb3JtYXQpO1xuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMudGltZUF4aXMpIHtcbiAgICBzdGVwLnNldFNjYWxlKHRoaXMub3B0aW9ucy50aW1lQXhpcyk7XG4gIH1cbiAgdGhpcy5zdGVwID0gc3RlcDtcblxuICAvLyBNb3ZlIGFsbCBET00gZWxlbWVudHMgdG8gYSBcInJlZHVuZGFudFwiIGxpc3QsIHdoZXJlIHRoZXlcbiAgLy8gY2FuIGJlIHBpY2tlZCBmb3IgcmUtdXNlLCBhbmQgY2xlYXIgdGhlIGxpc3RzIHdpdGggbGluZXMgYW5kIHRleHRzLlxuICAvLyBBdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvbiBfcmVwYWludExhYmVscywgbGVmdCBvdmVyIGVsZW1lbnRzIHdpbGwgYmUgY2xlYW5lZCB1cFxuICB2YXIgZG9tID0gdGhpcy5kb207XG4gIGRvbS5yZWR1bmRhbnQubGluZXMgPSBkb20ubGluZXM7XG4gIGRvbS5yZWR1bmRhbnQubWFqb3JUZXh0cyA9IGRvbS5tYWpvclRleHRzO1xuICBkb20ucmVkdW5kYW50Lm1pbm9yVGV4dHMgPSBkb20ubWlub3JUZXh0cztcbiAgZG9tLmxpbmVzID0gW107XG4gIGRvbS5tYWpvclRleHRzID0gW107XG4gIGRvbS5taW5vclRleHRzID0gW107XG5cbiAgdmFyIGN1cnJlbnQ7XG4gIHZhciBuZXh0O1xuICB2YXIgeDtcbiAgdmFyIHhOZXh0O1xuICB2YXIgaXNNYWpvcjtcbiAgdmFyIHdpZHRoO1xuICB2YXIgbGluZTtcbiAgdmFyIGxhYmVsTWlub3I7XG4gIHZhciB4Rmlyc3RNYWpvckxhYmVsID0gdW5kZWZpbmVkO1xuICB2YXIgbWF4ID0gMDtcbiAgdmFyIGNsYXNzTmFtZTtcblxuICBzdGVwLnN0YXJ0KCk7XG4gIG5leHQgPSBzdGVwLmdldEN1cnJlbnQoKTtcbiAgeE5leHQgPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbihuZXh0KTtcbiAgd2hpbGUgKHN0ZXAuaGFzTmV4dCgpICYmIG1heCA8IDEwMDApIHtcbiAgICBtYXgrKztcblxuICAgIGlzTWFqb3IgPSBzdGVwLmlzTWFqb3IoKTtcbiAgICBjbGFzc05hbWUgPSBzdGVwLmdldENsYXNzTmFtZSgpO1xuICAgIGxhYmVsTWlub3IgPSBzdGVwLmdldExhYmVsTWlub3IoKTtcblxuICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgIHggPSB4TmV4dDtcblxuICAgIHN0ZXAubmV4dCgpO1xuICAgIG5leHQgPSBzdGVwLmdldEN1cnJlbnQoKTtcbiAgICB4TmV4dCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKG5leHQpO1xuXG4gICAgd2lkdGggPSB4TmV4dCAtIHg7XG4gICAgdmFyIGxhYmVsRml0cyA9IChsYWJlbE1pbm9yLmxlbmd0aCArIDEpICogdGhpcy5wcm9wcy5taW5vckNoYXJXaWR0aCA8IHdpZHRoO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaG93TWlub3JMYWJlbHMgJiYgbGFiZWxGaXRzKSB7XG4gICAgICB0aGlzLl9yZXBhaW50TWlub3JUZXh0KHgsIGxhYmVsTWlub3IsIG9yaWVudGF0aW9uLCBjbGFzc05hbWUpO1xuICAgIH1cblxuICAgIGlmIChpc01ham9yICYmIHRoaXMub3B0aW9ucy5zaG93TWFqb3JMYWJlbHMpIHtcbiAgICAgIGlmICh4ID4gMCkge1xuICAgICAgICBpZiAoeEZpcnN0TWFqb3JMYWJlbCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB4Rmlyc3RNYWpvckxhYmVsID0geDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXBhaW50TWFqb3JUZXh0KHgsIHN0ZXAuZ2V0TGFiZWxNYWpvcigpLCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICAgIGxpbmUgPSB0aGlzLl9yZXBhaW50TWFqb3JMaW5lKHgsIHdpZHRoLCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAobGFiZWxGaXRzKSB7XG4gICAgICAgIGxpbmUgPSB0aGlzLl9yZXBhaW50TWlub3JMaW5lKHgsIHdpZHRoLCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgIGxpbmUuc3R5bGUud2lkdGggPSAocGFyc2VJbnQgKGxpbmUuc3R5bGUud2lkdGgpICsgd2lkdGgpICsgJ3B4J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gY3JlYXRlIGEgbWFqb3IgbGFiZWwgb24gdGhlIGxlZnQgd2hlbiBuZWVkZWRcbiAgaWYgKHRoaXMub3B0aW9ucy5zaG93TWFqb3JMYWJlbHMpIHtcbiAgICB2YXIgbGVmdFRpbWUgPSB0aGlzLmJvZHkudXRpbC50b1RpbWUoMCksXG4gICAgICAgIGxlZnRUZXh0ID0gc3RlcC5nZXRMYWJlbE1ham9yKGxlZnRUaW1lKSxcbiAgICAgICAgd2lkdGhUZXh0ID0gbGVmdFRleHQubGVuZ3RoICogKHRoaXMucHJvcHMubWFqb3JDaGFyV2lkdGggfHwgMTApICsgMTA7IC8vIHVwcGVyIGJvdW5kIGVzdGltYXRpb25cblxuICAgIGlmICh4Rmlyc3RNYWpvckxhYmVsID09IHVuZGVmaW5lZCB8fCB3aWR0aFRleHQgPCB4Rmlyc3RNYWpvckxhYmVsKSB7XG4gICAgICB0aGlzLl9yZXBhaW50TWFqb3JUZXh0KDAsIGxlZnRUZXh0LCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbnVwIGxlZnRvdmVyIERPTSBlbGVtZW50cyBmcm9tIHRoZSByZWR1bmRhbnQgbGlzdFxuICB1dGlsLmZvckVhY2godGhpcy5kb20ucmVkdW5kYW50LCBmdW5jdGlvbiAoYXJyKSB7XG4gICAgd2hpbGUgKGFyci5sZW5ndGgpIHtcbiAgICAgIHZhciBlbGVtID0gYXJyLnBvcCgpO1xuICAgICAgaWYgKGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBtaW5vciBsYWJlbCBmb3IgdGhlIGF4aXMgYXQgcG9zaXRpb24geFxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge1N0cmluZ30gb3JpZW50YXRpb24gICBcInRvcFwiIG9yIFwiYm90dG9tXCIgKGRlZmF1bHQpXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgb2YgdGhlIGNyZWF0ZWQgbGFiZWxcbiAqIEBwcml2YXRlXG4gKi9cblRpbWVBeGlzLnByb3RvdHlwZS5fcmVwYWludE1pbm9yVGV4dCA9IGZ1bmN0aW9uICh4LCB0ZXh0LCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKSB7XG4gIC8vIHJldXNlIHJlZHVuZGFudCBsYWJlbFxuICB2YXIgbGFiZWwgPSB0aGlzLmRvbS5yZWR1bmRhbnQubWlub3JUZXh0cy5zaGlmdCgpO1xuXG4gIGlmICghbGFiZWwpIHtcbiAgICAvLyBjcmVhdGUgbmV3IGxhYmVsXG4gICAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBsYWJlbC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICB0aGlzLmRvbS5mb3JlZ3JvdW5kLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgfVxuICB0aGlzLmRvbS5taW5vclRleHRzLnB1c2gobGFiZWwpO1xuXG4gIGxhYmVsLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlID0gdGV4dDtcblxuICBsYWJlbC5zdHlsZS50b3AgPSAob3JpZW50YXRpb24gPT0gJ3RvcCcpID8gKHRoaXMucHJvcHMubWFqb3JMYWJlbEhlaWdodCArICdweCcpIDogJzAnO1xuICBsYWJlbC5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gIGxhYmVsLmNsYXNzTmFtZSA9ICd2aXMtdGV4dCB2aXMtbWlub3IgJyArIGNsYXNzTmFtZTtcbiAgLy9sYWJlbC50aXRsZSA9IHRpdGxlOyAgLy8gVE9ETzogdGhpcyBpcyBhIGhlYXZ5IG9wZXJhdGlvblxuXG4gIHJldHVybiBsYWJlbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgTWFqb3IgbGFiZWwgZm9yIHRoZSBheGlzIGF0IHBvc2l0aW9uIHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtTdHJpbmd9IG9yaWVudGF0aW9uICAgXCJ0b3BcIiBvciBcImJvdHRvbVwiIChkZWZhdWx0KVxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybiB7RWxlbWVudH0gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IG9mIHRoZSBjcmVhdGVkIGxhYmVsXG4gKiBAcHJpdmF0ZVxuICovXG5UaW1lQXhpcy5wcm90b3R5cGUuX3JlcGFpbnRNYWpvclRleHQgPSBmdW5jdGlvbiAoeCwgdGV4dCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSkge1xuICAvLyByZXVzZSByZWR1bmRhbnQgbGFiZWxcbiAgdmFyIGxhYmVsID0gdGhpcy5kb20ucmVkdW5kYW50Lm1ham9yVGV4dHMuc2hpZnQoKTtcblxuICBpZiAoIWxhYmVsKSB7XG4gICAgLy8gY3JlYXRlIGxhYmVsXG4gICAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxhYmVsLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIHRoaXMuZG9tLmZvcmVncm91bmQuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICB9XG4gIHRoaXMuZG9tLm1ham9yVGV4dHMucHVzaChsYWJlbCk7XG5cbiAgbGFiZWwuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUgPSB0ZXh0O1xuICBsYWJlbC5jbGFzc05hbWUgPSAndmlzLXRleHQgdmlzLW1ham9yICcgKyBjbGFzc05hbWU7XG4gIC8vbGFiZWwudGl0bGUgPSB0aXRsZTsgLy8gVE9ETzogdGhpcyBpcyBhIGhlYXZ5IG9wZXJhdGlvblxuXG4gIGxhYmVsLnN0eWxlLnRvcCA9IChvcmllbnRhdGlvbiA9PSAndG9wJykgPyAnMCcgOiAodGhpcy5wcm9wcy5taW5vckxhYmVsSGVpZ2h0ICArICdweCcpO1xuICBsYWJlbC5zdHlsZS5sZWZ0ID0geCArICdweCc7XG5cbiAgcmV0dXJuIGxhYmVsO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBtaW5vciBsaW5lIGZvciB0aGUgYXhpcyBhdCBwb3NpdGlvbiB4XG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge1N0cmluZ30gb3JpZW50YXRpb24gICBcInRvcFwiIG9yIFwiYm90dG9tXCIgKGRlZmF1bHQpXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIHRoZSBjcmVhdGVkIGxpbmVcbiAqIEBwcml2YXRlXG4gKi9cblRpbWVBeGlzLnByb3RvdHlwZS5fcmVwYWludE1pbm9yTGluZSA9IGZ1bmN0aW9uICh4LCB3aWR0aCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSkge1xuICAvLyByZXVzZSByZWR1bmRhbnQgbGluZVxuICB2YXIgbGluZSA9IHRoaXMuZG9tLnJlZHVuZGFudC5saW5lcy5zaGlmdCgpO1xuICBpZiAoIWxpbmUpIHtcbiAgICAvLyBjcmVhdGUgdmVydGljYWwgbGluZVxuICAgIGxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKGxpbmUpO1xuICB9XG4gIHRoaXMuZG9tLmxpbmVzLnB1c2gobGluZSk7XG5cbiAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgaWYgKG9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgbGluZS5zdHlsZS50b3AgPSBwcm9wcy5tYWpvckxhYmVsSGVpZ2h0ICsgJ3B4JztcbiAgfVxuICBlbHNlIHtcbiAgICBsaW5lLnN0eWxlLnRvcCA9IHRoaXMuYm9keS5kb21Qcm9wcy50b3AuaGVpZ2h0ICsgJ3B4JztcbiAgfVxuICBsaW5lLnN0eWxlLmhlaWdodCA9IHByb3BzLm1pbm9yTGluZUhlaWdodCArICdweCc7XG4gIGxpbmUuc3R5bGUubGVmdCA9ICh4IC0gcHJvcHMubWlub3JMaW5lV2lkdGggLyAyKSArICdweCc7XG4gIGxpbmUuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cbiAgbGluZS5jbGFzc05hbWUgPSAndmlzLWdyaWQgdmlzLXZlcnRpY2FsIHZpcy1taW5vciAnICsgY2xhc3NOYW1lO1xuXG4gIHJldHVybiBsaW5lO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBNYWpvciBsaW5lIGZvciB0aGUgYXhpcyBhdCBwb3NpdGlvbiB4XG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge1N0cmluZ30gb3JpZW50YXRpb24gICBcInRvcFwiIG9yIFwiYm90dG9tXCIgKGRlZmF1bHQpXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIHRoZSBjcmVhdGVkIGxpbmVcbiAqIEBwcml2YXRlXG4gKi9cblRpbWVBeGlzLnByb3RvdHlwZS5fcmVwYWludE1ham9yTGluZSA9IGZ1bmN0aW9uICh4LCB3aWR0aCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSkge1xuICAvLyByZXVzZSByZWR1bmRhbnQgbGluZVxuICB2YXIgbGluZSA9IHRoaXMuZG9tLnJlZHVuZGFudC5saW5lcy5zaGlmdCgpO1xuICBpZiAoIWxpbmUpIHtcbiAgICAvLyBjcmVhdGUgdmVydGljYWwgbGluZVxuICAgIGxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKGxpbmUpO1xuICB9XG4gIHRoaXMuZG9tLmxpbmVzLnB1c2gobGluZSk7XG5cbiAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgaWYgKG9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgbGluZS5zdHlsZS50b3AgPSAnMCc7XG4gIH1cbiAgZWxzZSB7XG4gICAgbGluZS5zdHlsZS50b3AgPSB0aGlzLmJvZHkuZG9tUHJvcHMudG9wLmhlaWdodCArICdweCc7XG4gIH1cbiAgbGluZS5zdHlsZS5sZWZ0ID0gKHggLSBwcm9wcy5tYWpvckxpbmVXaWR0aCAvIDIpICsgJ3B4JztcbiAgbGluZS5zdHlsZS5oZWlnaHQgPSBwcm9wcy5tYWpvckxpbmVIZWlnaHQgKyAncHgnO1xuICBsaW5lLnN0eWxlLndpZHRoID0gd2lkdGggICsgJ3B4JztcblxuICBsaW5lLmNsYXNzTmFtZSA9ICd2aXMtZ3JpZCB2aXMtdmVydGljYWwgdmlzLW1ham9yICcgKyBjbGFzc05hbWU7XG5cbiAgcmV0dXJuIGxpbmU7XG59O1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgc2l6ZSBvZiB0ZXh0IG9uIHRoZSBheGlzIChib3RoIG1ham9yIGFuZCBtaW5vciBheGlzKS5cbiAqIFRoZSBzaXplIGlzIGNhbGN1bGF0ZWQgb25seSBvbmNlIGFuZCB0aGVuIGNhY2hlZCBpbiB0aGlzLnByb3BzLlxuICogQHByaXZhdGVcbiAqL1xuVGltZUF4aXMucHJvdG90eXBlLl9jYWxjdWxhdGVDaGFyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gTm90ZTogV2UgY2FsY3VsYXRlIGNoYXIgc2l6ZSB3aXRoIGV2ZXJ5IHJlZHJhdy4gU2l6ZSBtYXkgY2hhbmdlLCBmb3JcbiAgLy8gZXhhbXBsZSB3aGVuIGFueSBvZiB0aGUgdGltZWxpbmVzIHBhcmVudHMgaGFkIGRpc3BsYXk6bm9uZSBmb3IgZXhhbXBsZS5cblxuICAvLyBkZXRlcm1pbmUgdGhlIGNoYXIgd2lkdGggYW5kIGhlaWdodCBvbiB0aGUgbWlub3IgYXhpc1xuICBpZiAoIXRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IpIHtcbiAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vci5jbGFzc05hbWUgPSAndmlzLXRleHQgdmlzLW1pbm9yIHZpcy1tZWFzdXJlJztcbiAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJzAnKSk7XG4gICAgdGhpcy5kb20uZm9yZWdyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yKTtcbiAgfVxuICB0aGlzLnByb3BzLm1pbm9yQ2hhckhlaWdodCA9IHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IuY2xpZW50SGVpZ2h0O1xuICB0aGlzLnByb3BzLm1pbm9yQ2hhcldpZHRoID0gdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vci5jbGllbnRXaWR0aDtcblxuICAvLyBkZXRlcm1pbmUgdGhlIGNoYXIgd2lkdGggYW5kIGhlaWdodCBvbiB0aGUgbWFqb3IgYXhpc1xuICBpZiAoIXRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3IpIHtcbiAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvci5jbGFzc05hbWUgPSAndmlzLXRleHQgdmlzLW1ham9yIHZpcy1tZWFzdXJlJztcbiAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3IuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJzAnKSk7XG4gICAgdGhpcy5kb20uZm9yZWdyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yKTtcbiAgfVxuICB0aGlzLnByb3BzLm1ham9yQ2hhckhlaWdodCA9IHRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3IuY2xpZW50SGVpZ2h0O1xuICB0aGlzLnByb3BzLm1ham9yQ2hhcldpZHRoID0gdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvci5jbGllbnRXaWR0aDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZUF4aXM7XG4iXX0=
},{"../../module/moment":20,"../../util":46,"../DateUtil":27,"../TimeStep":30,"./Component":33}],39:[function(require,module,exports){
'use strict';

var Hammer = require('../../../module/hammer');
var Item = require('./Item');
var BackgroundGroup = require('../BackgroundGroup');
var RangeItem = require('./RangeItem');

/**
 * @constructor BackgroundItem
 * @extends Item
 * @param {Object} data             Object containing parameters start, end
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe options
 */
// TODO: implement support for the BackgroundItem just having a start, then being displayed as a sort of an annotation
function BackgroundItem(data, conversion, options) {
  this.props = {
    content: {
      width: 0
    }
  };
  this.overflow = false; // if contents can overflow (css styling), this flag is set to true

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data.id);
    }
    if (data.end == undefined) {
      throw new Error('Property "end" missing in item ' + data.id);
    }
  }

  Item.call(this, data, conversion, options);
}

BackgroundItem.prototype = new Item(null, null, null);

BackgroundItem.prototype.baseClassName = 'vis-item vis-background';
BackgroundItem.prototype.stack = false;

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
BackgroundItem.prototype.isVisible = function (range) {
  // determine visibility
  return this.data.start < range.end && this.data.end > range.start;
};

/**
 * Repaint the item
 */
BackgroundItem.prototype.redraw = function () {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // background box
    dom.box = document.createElement('div');
    // className is updated in redraw()

    // frame box (to prevent the item contents from overflowing
    dom.frame = document.createElement('div');
    dom.frame.className = 'vis-item-overflow';
    dom.box.appendChild(dom.frame);

    // contents box
    dom.content = document.createElement('div');
    dom.content.className = 'vis-item-content';
    dom.frame.appendChild(dom.content);

    // Note: we do NOT attach this item as attribute to the DOM,
    //       such that background items cannot be selected
    //dom.box['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.box.parentNode) {
    var background = this.parent.dom.background;
    if (!background) {
      throw new Error('Cannot redraw item: parent has no background container element');
    }
    background.appendChild(dom.box);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.content);
    this._updateDataAttributes(this.dom.content);
    this._updateStyle(this.dom.box);

    // update class
    var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '');
    dom.box.className = this.baseClassName + className;

    // determine from css whether this box has overflow
    this.overflow = window.getComputedStyle(dom.content).overflow !== 'hidden';

    // recalculate size
    this.props.content.width = this.dom.content.offsetWidth;
    this.height = 0; // set height zero, so this item will be ignored when stacking items

    this.dirty = false;
  }
};

/**
 * Show the item in the DOM (when not already visible). The items DOM will
 * be created when needed.
 */
BackgroundItem.prototype.show = RangeItem.prototype.show;

/**
 * Hide the item from the DOM (when visible)
 * @return {Boolean} changed
 */
BackgroundItem.prototype.hide = RangeItem.prototype.hide;

/**
 * Reposition the item horizontally
 * @Override
 */
BackgroundItem.prototype.repositionX = RangeItem.prototype.repositionX;

/**
 * Reposition the item vertically
 * @Override
 */
BackgroundItem.prototype.repositionY = function (margin) {
  var onTop = this.options.orientation.item === 'top';
  this.dom.content.style.top = onTop ? '' : '0';
  this.dom.content.style.bottom = onTop ? '0' : '';
  var height;

  // special positioning for subgroups
  if (this.data.subgroup !== undefined) {
    // TODO: instead of calculating the top position of the subgroups here for every BackgroundItem, calculate the top of the subgroup once in Itemset

    var itemSubgroup = this.data.subgroup;
    var subgroups = this.parent.subgroups;
    var subgroupIndex = subgroups[itemSubgroup].index;
    // if the orientation is top, we need to take the difference in height into account.
    if (onTop == true) {
      // the first subgroup will have to account for the distance from the top to the first item.
      height = this.parent.subgroups[itemSubgroup].height + margin.item.vertical;
      height += subgroupIndex == 0 ? margin.axis - 0.5 * margin.item.vertical : 0;
      var newTop = this.parent.top;
      for (var subgroup in subgroups) {
        if (subgroups.hasOwnProperty(subgroup)) {
          if (subgroups[subgroup].visible == true && subgroups[subgroup].index < subgroupIndex) {
            newTop += subgroups[subgroup].height + margin.item.vertical;
          }
        }
      }

      // the others will have to be offset downwards with this same distance.
      newTop += subgroupIndex != 0 ? margin.axis - 0.5 * margin.item.vertical : 0;
      this.dom.box.style.top = newTop + 'px';
      this.dom.box.style.bottom = '';
    }
    // and when the orientation is bottom:
    else {
        var newTop = this.parent.top;
        var totalHeight = 0;
        for (var subgroup in subgroups) {
          if (subgroups.hasOwnProperty(subgroup)) {
            if (subgroups[subgroup].visible == true) {
              var newHeight = subgroups[subgroup].height + margin.item.vertical;
              totalHeight += newHeight;
              if (subgroups[subgroup].index > subgroupIndex) {
                newTop += newHeight;
              }
            }
          }
        }
        height = this.parent.subgroups[itemSubgroup].height + margin.item.vertical;
        this.dom.box.style.top = this.parent.height - totalHeight + newTop + 'px';
        this.dom.box.style.bottom = '';
      }
  }
  // and in the case of no subgroups:
  else {
      // we want backgrounds with groups to only show in groups.
      if (this.parent instanceof BackgroundGroup) {
        // if the item is not in a group:
        height = Math.max(this.parent.height, this.parent.itemSet.body.domProps.center.height, this.parent.itemSet.body.domProps.centerContainer.height);
        this.dom.box.style.top = onTop ? '0' : '';
        this.dom.box.style.bottom = onTop ? '' : '0';
      } else {
        height = this.parent.height;
        // same alignment for items when orientation is top or bottom
        this.dom.box.style.top = this.parent.top + 'px';
        this.dom.box.style.bottom = '';
      }
    }
  this.dom.box.style.height = height + 'px';
};

module.exports = BackgroundItem;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L2l0ZW0vQmFja2dyb3VuZEl0ZW0uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsd0JBQXdCLENBQUMsQ0FBQztBQUMvQyxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDN0IsSUFBSSxlQUFlLEdBQUcsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFDcEQsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7O0FBYXZDLFNBQVMsY0FBYyxDQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFO0FBQ2xELE1BQUksQ0FBQyxLQUFLLEdBQUc7QUFDWCxXQUFPLEVBQUU7QUFDUCxXQUFLLEVBQUUsQ0FBQztLQUNUO0dBQ0YsQ0FBQztBQUNGLE1BQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDOzs7QUFHdEIsTUFBSSxJQUFJLEVBQUU7QUFDUixRQUFJLElBQUksQ0FBQyxLQUFLLElBQUksU0FBUyxFQUFFO0FBQzNCLFlBQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQ2hFO0FBQ0QsUUFBSSxJQUFJLENBQUMsR0FBRyxJQUFJLFNBQVMsRUFBRTtBQUN6QixZQUFNLElBQUksS0FBSyxDQUFDLGlDQUFpQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUM5RDtHQUNGOztBQUVELE1BQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7Q0FDNUM7O0FBRUQsY0FBYyxDQUFDLFNBQVMsR0FBRyxJQUFJLElBQUksQ0FBRSxJQUFJLEVB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TSxDQUFDLE1BQU0sRUFDaEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUMvQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUM5RCxZQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQzFDLFlBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsS0FBSyxHQUFHLEVBQUUsR0FBRyxHQUFHLENBQUM7T0FDOUMsTUFDSTtBQUNILGNBQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQzs7QUFFNUIsWUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7QUFDaEQsWUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUM7T0FDaEM7S0FDRjtBQUNELE1BQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsTUFBTSxHQUFHLElBQUksQ0FBQztDQUMzQyxDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsY0FBYyxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L2l0ZW0vQmFja2dyb3VuZEl0ZW0uanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSGFtbWVyID0gcmVxdWlyZSgnLi4vLi4vLi4vbW9kdWxlL2hhbW1lcicpO1xudmFyIEl0ZW0gPSByZXF1aXJlKCcuL0l0ZW0nKTtcbnZhciBCYWNrZ3JvdW5kR3JvdXAgPSByZXF1aXJlKCcuLi9CYWNrZ3JvdW5kR3JvdXAnKTtcbnZhciBSYW5nZUl0ZW0gPSByZXF1aXJlKCcuL1JhbmdlSXRlbScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBCYWNrZ3JvdW5kSXRlbVxuICogQGV4dGVuZHMgSXRlbVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBzdGFydCwgZW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LCBjbGFzc05hbWUuXG4gKiBAcGFyYW0ge3t0b1NjcmVlbjogZnVuY3Rpb24sIHRvVGltZTogZnVuY3Rpb259fSBjb252ZXJzaW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb252ZXJzaW9uIGZ1bmN0aW9ucyBmcm9tIHRpbWUgdG8gc2NyZWVuIGFuZCB2aWNlIHZlcnNhXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGRlc2NyaWJlIG9wdGlvbnNcbiAqL1xuLy8gVE9ETzogaW1wbGVtZW50IHN1cHBvcnQgZm9yIHRoZSBCYWNrZ3JvdW5kSXRlbSBqdXN0IGhhdmluZyBhIHN0YXJ0LCB0aGVuIGJlaW5nIGRpc3BsYXllZCBhcyBhIHNvcnQgb2YgYW4gYW5ub3RhdGlvblxuZnVuY3Rpb24gQmFja2dyb3VuZEl0ZW0gKGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpIHtcbiAgdGhpcy5wcm9wcyA9IHtcbiAgICBjb250ZW50OiB7XG4gICAgICB3aWR0aDogMFxuICAgIH1cbiAgfTtcbiAgdGhpcy5vdmVyZmxvdyA9IGZhbHNlOyAvLyBpZiBjb250ZW50cyBjYW4gb3ZlcmZsb3cgKGNzcyBzdHlsaW5nKSwgdGhpcyBmbGFnIGlzIHNldCB0byB0cnVlXG5cbiAgLy8gdmFsaWRhdGUgZGF0YVxuICBpZiAoZGF0YSkge1xuICAgIGlmIChkYXRhLnN0YXJ0ID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcInN0YXJ0XCIgbWlzc2luZyBpbiBpdGVtICcgKyBkYXRhLmlkKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuZW5kID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcImVuZFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgZGF0YS5pZCk7XG4gICAgfVxuICB9XG5cbiAgSXRlbS5jYWxsKHRoaXMsIGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpO1xufVxuXG5CYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUgPSBuZXcgSXRlbSAobnVsbCwgbnVsbCwgbnVsbCk7XG5cbkJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5iYXNlQ2xhc3NOYW1lID0gJ3Zpcy1pdGVtIHZpcy1iYWNrZ3JvdW5kJztcbkJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5zdGFjayA9IGZhbHNlO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhpcyBpdGVtIGlzIHZpc2libGUgaW5zaWRlIGdpdmVuIHJhbmdlXG4gKiBAcmV0dXJucyB7e3N0YXJ0OiBOdW1iZXIsIGVuZDogTnVtYmVyfX0gcmFuZ2Ugd2l0aCBhIHRpbWVzdGFtcCBmb3Igc3RhcnQgYW5kIGVuZFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmlzaWJsZVxuICovXG5CYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgLy8gZGV0ZXJtaW5lIHZpc2liaWxpdHlcbiAgcmV0dXJuICh0aGlzLmRhdGEuc3RhcnQgPCByYW5nZS5lbmQpICYmICh0aGlzLmRhdGEuZW5kID4gcmFuZ2Uuc3RhcnQpO1xufTtcblxuLyoqXG4gKiBSZXBhaW50IHRoZSBpdGVtXG4gKi9cbkJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICBpZiAoIWRvbSkge1xuICAgIC8vIGNyZWF0ZSBET01cbiAgICB0aGlzLmRvbSA9IHt9O1xuICAgIGRvbSA9IHRoaXMuZG9tO1xuXG4gICAgLy8gYmFja2dyb3VuZCBib3hcbiAgICBkb20uYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgLy8gY2xhc3NOYW1lIGlzIHVwZGF0ZWQgaW4gcmVkcmF3KClcblxuICAgIC8vIGZyYW1lIGJveCAodG8gcHJldmVudCB0aGUgaXRlbSBjb250ZW50cyBmcm9tIG92ZXJmbG93aW5nXG4gICAgZG9tLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9tLmZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtaXRlbS1vdmVyZmxvdyc7XG4gICAgZG9tLmJveC5hcHBlbmRDaGlsZChkb20uZnJhbWUpO1xuXG4gICAgLy8gY29udGVudHMgYm94XG4gICAgZG9tLmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20uY29udGVudC5jbGFzc05hbWUgPSAndmlzLWl0ZW0tY29udGVudCc7XG4gICAgZG9tLmZyYW1lLmFwcGVuZENoaWxkKGRvbS5jb250ZW50KTtcblxuICAgIC8vIE5vdGU6IHdlIGRvIE5PVCBhdHRhY2ggdGhpcyBpdGVtIGFzIGF0dHJpYnV0ZSB0byB0aGUgRE9NLFxuICAgIC8vICAgICAgIHN1Y2ggdGhhdCBiYWNrZ3JvdW5kIGl0ZW1zIGNhbm5vdCBiZSBzZWxlY3RlZFxuICAgIC8vZG9tLmJveFsndGltZWxpbmUtaXRlbSddID0gdGhpcztcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG5cbiAgLy8gYXBwZW5kIERPTSB0byBwYXJlbnQgRE9NXG4gIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogbm8gcGFyZW50IGF0dGFjaGVkJyk7XG4gIH1cbiAgaWYgKCFkb20uYm94LnBhcmVudE5vZGUpIHtcbiAgICB2YXIgYmFja2dyb3VuZCA9IHRoaXMucGFyZW50LmRvbS5iYWNrZ3JvdW5kO1xuICAgIGlmICghYmFja2dyb3VuZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IHBhcmVudCBoYXMgbm8gYmFja2dyb3VuZCBjb250YWluZXIgZWxlbWVudCcpO1xuICAgIH1cbiAgICBiYWNrZ3JvdW5kLmFwcGVuZENoaWxkKGRvbS5ib3gpO1xuICB9XG4gIHRoaXMuZGlzcGxheWVkID0gdHJ1ZTtcblxuICAvLyBVcGRhdGUgRE9NIHdoZW4gaXRlbSBpcyBtYXJrZWQgZGlydHkuIEFuIGl0ZW0gaXMgbWFya2VkIGRpcnR5IHdoZW46XG4gIC8vIC0gdGhlIGl0ZW0gaXMgbm90IHlldCByZW5kZXJlZFxuICAvLyAtIHRoZSBpdGVtJ3MgZGF0YSBpcyBjaGFuZ2VkXG4gIC8vIC0gdGhlIGl0ZW0gaXMgc2VsZWN0ZWQvZGVzZWxlY3RlZFxuICBpZiAodGhpcy5kaXJ0eSkge1xuICAgIHRoaXMuX3VwZGF0ZUNvbnRlbnRzKHRoaXMuZG9tLmNvbnRlbnQpO1xuICAgIHRoaXMuX3VwZGF0ZVRpdGxlKHRoaXMuZG9tLmNvbnRlbnQpO1xuICAgIHRoaXMuX3VwZGF0ZURhdGFBdHRyaWJ1dGVzKHRoaXMuZG9tLmNvbnRlbnQpO1xuICAgIHRoaXMuX3VwZGF0ZVN0eWxlKHRoaXMuZG9tLmJveCk7XG5cbiAgICAvLyB1cGRhdGUgY2xhc3NcbiAgICB2YXIgY2xhc3NOYW1lID0gKHRoaXMuZGF0YS5jbGFzc05hbWUgPyAoJyAnICsgdGhpcy5kYXRhLmNsYXNzTmFtZSkgOiAnJykgK1xuICAgICAgICAodGhpcy5zZWxlY3RlZCA/ICcgdmlzLXNlbGVjdGVkJyA6ICcnKTtcbiAgICBkb20uYm94LmNsYXNzTmFtZSA9IHRoaXMuYmFzZUNsYXNzTmFtZSArIGNsYXNzTmFtZTtcblxuICAgIC8vIGRldGVybWluZSBmcm9tIGNzcyB3aGV0aGVyIHRoaXMgYm94IGhhcyBvdmVyZmxvd1xuICAgIHRoaXMub3ZlcmZsb3cgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20uY29udGVudCkub3ZlcmZsb3cgIT09ICdoaWRkZW4nO1xuXG4gICAgLy8gcmVjYWxjdWxhdGUgc2l6ZVxuICAgIHRoaXMucHJvcHMuY29udGVudC53aWR0aCA9IHRoaXMuZG9tLmNvbnRlbnQub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSAwOyAvLyBzZXQgaGVpZ2h0IHplcm8sIHNvIHRoaXMgaXRlbSB3aWxsIGJlIGlnbm9yZWQgd2hlbiBzdGFja2luZyBpdGVtc1xuXG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFNob3cgdGhlIGl0ZW0gaW4gdGhlIERPTSAod2hlbiBub3QgYWxyZWFkeSB2aXNpYmxlKS4gVGhlIGl0ZW1zIERPTSB3aWxsXG4gKiBiZSBjcmVhdGVkIHdoZW4gbmVlZGVkLlxuICovXG5CYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUuc2hvdyA9IFJhbmdlSXRlbS5wcm90b3R5cGUuc2hvdztcblxuLyoqXG4gKiBIaWRlIHRoZSBpdGVtIGZyb20gdGhlIERPTSAod2hlbiB2aXNpYmxlKVxuICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICovXG5CYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUuaGlkZSA9IFJhbmdlSXRlbS5wcm90b3R5cGUuaGlkZTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBpdGVtIGhvcml6b250YWxseVxuICogQE92ZXJyaWRlXG4gKi9cbkJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWCA9IFJhbmdlSXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblg7XG5cbi8qKlxuICogUmVwb3NpdGlvbiB0aGUgaXRlbSB2ZXJ0aWNhbGx5XG4gKiBAT3ZlcnJpZGVcbiAqL1xuQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25ZID0gZnVuY3Rpb24obWFyZ2luKSB7XG4gIHZhciBvblRvcCA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtID09PSAndG9wJztcbiAgdGhpcy5kb20uY29udGVudC5zdHlsZS50b3AgPSBvblRvcCA/ICcnIDogJzAnO1xuICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLmJvdHRvbSA9IG9uVG9wID8gJzAnIDogJyc7XG4gIHZhciBoZWlnaHQ7XG5cbiAgLy8gc3BlY2lhbCBwb3NpdGlvbmluZyBmb3Igc3ViZ3JvdXBzXG4gIGlmICh0aGlzLmRhdGEuc3ViZ3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFRPRE86IGluc3RlYWQgb2YgY2FsY3VsYXRpbmcgdGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgc3ViZ3JvdXBzIGhlcmUgZm9yIGV2ZXJ5IEJhY2tncm91bmRJdGVtLCBjYWxjdWxhdGUgdGhlIHRvcCBvZiB0aGUgc3ViZ3JvdXAgb25jZSBpbiBJdGVtc2V0XG5cbiAgICB2YXIgaXRlbVN1Ymdyb3VwID0gdGhpcy5kYXRhLnN1Ymdyb3VwO1xuICAgIHZhciBzdWJncm91cHMgPSB0aGlzLnBhcmVudC5zdWJncm91cHM7XG4gICAgdmFyIHN1Ymdyb3VwSW5kZXggPSBzdWJncm91cHNbaXRlbVN1Ymdyb3VwXS5pbmRleDtcbiAgICAvLyBpZiB0aGUgb3JpZW50YXRpb24gaXMgdG9wLCB3ZSBuZWVkIHRvIHRha2UgdGhlIGRpZmZlcmVuY2UgaW4gaGVpZ2h0IGludG8gYWNjb3VudC5cbiAgICBpZiAob25Ub3AgPT0gdHJ1ZSkge1xuICAgICAgLy8gdGhlIGZpcnN0IHN1Ymdyb3VwIHdpbGwgaGF2ZSB0byBhY2NvdW50IGZvciB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgdG9wIHRvIHRoZSBmaXJzdCBpdGVtLlxuICAgICAgaGVpZ2h0ID0gdGhpcy5wYXJlbnQuc3ViZ3JvdXBzW2l0ZW1TdWJncm91cF0uaGVpZ2h0ICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG4gICAgICBoZWlnaHQgKz0gc3ViZ3JvdXBJbmRleCA9PSAwID8gbWFyZ2luLmF4aXMgLSAwLjUqbWFyZ2luLml0ZW0udmVydGljYWwgOiAwO1xuICAgICAgdmFyIG5ld1RvcCA9IHRoaXMucGFyZW50LnRvcDtcbiAgICAgIGZvciAodmFyIHN1Ymdyb3VwIGluIHN1Ymdyb3Vwcykge1xuICAgICAgICBpZiAoc3ViZ3JvdXBzLmhhc093blByb3BlcnR5KHN1Ymdyb3VwKSkge1xuICAgICAgICAgIGlmIChzdWJncm91cHNbc3ViZ3JvdXBdLnZpc2libGUgPT0gdHJ1ZSAmJiBzdWJncm91cHNbc3ViZ3JvdXBdLmluZGV4IDwgc3ViZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgbmV3VG9wICs9IHN1Ymdyb3Vwc1tzdWJncm91cF0uaGVpZ2h0ICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZSBvdGhlcnMgd2lsbCBoYXZlIHRvIGJlIG9mZnNldCBkb3dud2FyZHMgd2l0aCB0aGlzIHNhbWUgZGlzdGFuY2UuXG4gICAgICBuZXdUb3AgKz0gc3ViZ3JvdXBJbmRleCAhPSAwID8gbWFyZ2luLmF4aXMgLSAwLjUgKiBtYXJnaW4uaXRlbS52ZXJ0aWNhbCA6IDA7XG4gICAgICB0aGlzLmRvbS5ib3guc3R5bGUudG9wID0gbmV3VG9wICsgJ3B4JztcbiAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5ib3R0b20gPSAnJztcbiAgICB9XG4gICAgLy8gYW5kIHdoZW4gdGhlIG9yaWVudGF0aW9uIGlzIGJvdHRvbTpcbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdUb3AgPSB0aGlzLnBhcmVudC50b3A7XG4gICAgICB2YXIgdG90YWxIZWlnaHQgPSAwO1xuICAgICAgZm9yICh2YXIgc3ViZ3JvdXAgaW4gc3ViZ3JvdXBzKSB7XG4gICAgICAgIGlmIChzdWJncm91cHMuaGFzT3duUHJvcGVydHkoc3ViZ3JvdXApKSB7XG4gICAgICAgICAgaWYgKHN1Ymdyb3Vwc1tzdWJncm91cF0udmlzaWJsZSA9PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gc3ViZ3JvdXBzW3N1Ymdyb3VwXS5oZWlnaHQgKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbDtcbiAgICAgICAgICAgIHRvdGFsSGVpZ2h0ICs9IG5ld0hlaWdodDtcbiAgICAgICAgICAgIGlmIChzdWJncm91cHNbc3ViZ3JvdXBdLmluZGV4ID4gc3ViZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgICBuZXdUb3AgKz0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGVpZ2h0ID0gdGhpcy5wYXJlbnQuc3ViZ3JvdXBzW2l0ZW1TdWJncm91cF0uaGVpZ2h0ICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG4gICAgICB0aGlzLmRvbS5ib3guc3R5bGUudG9wID0gKHRoaXMucGFyZW50LmhlaWdodCAtIHRvdGFsSGVpZ2h0ICsgbmV3VG9wKSArICdweCc7XG4gICAgICB0aGlzLmRvbS5ib3guc3R5bGUuYm90dG9tID0gJyc7XG4gICAgfVxuICB9XG4gIC8vIGFuZCBpbiB0aGUgY2FzZSBvZiBubyBzdWJncm91cHM6XG4gIGVsc2Uge1xuICAgIC8vIHdlIHdhbnQgYmFja2dyb3VuZHMgd2l0aCBncm91cHMgdG8gb25seSBzaG93IGluIGdyb3Vwcy5cbiAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBCYWNrZ3JvdW5kR3JvdXApIHtcbiAgICAgIC8vIGlmIHRoZSBpdGVtIGlzIG5vdCBpbiBhIGdyb3VwOlxuICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5wYXJlbnQuaGVpZ2h0LFxuICAgICAgICAgIHRoaXMucGFyZW50Lml0ZW1TZXQuYm9keS5kb21Qcm9wcy5jZW50ZXIuaGVpZ2h0LFxuICAgICAgICAgIHRoaXMucGFyZW50Lml0ZW1TZXQuYm9keS5kb21Qcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0KTtcbiAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS50b3AgPSBvblRvcCA/ICcwJyA6ICcnO1xuICAgICAgdGhpcy5kb20uYm94LnN0eWxlLmJvdHRvbSA9IG9uVG9wID8gJycgOiAnMCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gdGhpcy5wYXJlbnQuaGVpZ2h0O1xuICAgICAgLy8gc2FtZSBhbGlnbm1lbnQgZm9yIGl0ZW1zIHdoZW4gb3JpZW50YXRpb24gaXMgdG9wIG9yIGJvdHRvbVxuICAgICAgdGhpcy5kb20uYm94LnN0eWxlLnRvcCA9IHRoaXMucGFyZW50LnRvcCArICdweCc7XG4gICAgICB0aGlzLmRvbS5ib3guc3R5bGUuYm90dG9tID0gJyc7XG4gICAgfVxuICB9XG4gIHRoaXMuZG9tLmJveC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrZ3JvdW5kSXRlbTtcbiJdfQ==
},{"../../../module/hammer":19,"../BackgroundGroup":32,"./Item":41,"./RangeItem":43}],40:[function(require,module,exports){
'use strict';

var Item = require('./Item');
var util = require('../../../util');

/**
 * @constructor BoxItem
 * @extends Item
 * @param {Object} data             Object containing parameters start
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe available options
 */
function BoxItem(data, conversion, options) {
  this.props = {
    dot: {
      width: 0,
      height: 0
    },
    line: {
      width: 0,
      height: 0
    }
  };

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data);
    }
  }

  Item.call(this, data, conversion, options);
}

BoxItem.prototype = new Item(null, null, null);

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
BoxItem.prototype.isVisible = function (range) {
  // determine visibility
  // TODO: account for the real width of the item. Right now we just add 1/4 to the window
  var interval = (range.end - range.start) / 4;
  return this.data.start > range.start - interval && this.data.start < range.end + interval;
};

/**
 * Repaint the item
 */
BoxItem.prototype.redraw = function () {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // create main box
    dom.box = document.createElement('DIV');

    // contents box (inside the background box). used for making margins
    dom.content = document.createElement('DIV');
    dom.content.className = 'vis-item-content';
    dom.box.appendChild(dom.content);

    // line to axis
    dom.line = document.createElement('DIV');
    dom.line.className = 'vis-line';

    // dot on axis
    dom.dot = document.createElement('DIV');
    dom.dot.className = 'vis-dot';

    // attach this item as attribute
    dom.box['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.box.parentNode) {
    var foreground = this.parent.dom.foreground;
    if (!foreground) throw new Error('Cannot redraw item: parent has no foreground container element');
    foreground.appendChild(dom.box);
  }
  if (!dom.line.parentNode) {
    var background = this.parent.dom.background;
    if (!background) throw new Error('Cannot redraw item: parent has no background container element');
    background.appendChild(dom.line);
  }
  if (!dom.dot.parentNode) {
    var axis = this.parent.dom.axis;
    if (!background) throw new Error('Cannot redraw item: parent has no axis container element');
    axis.appendChild(dom.dot);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.box);
    this._updateDataAttributes(this.dom.box);
    this._updateStyle(this.dom.box);

    var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

    // update class
    var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
    dom.box.className = 'vis-item vis-box' + className;
    dom.line.className = 'vis-item vis-line' + className;
    dom.dot.className = 'vis-item vis-dot' + className;

    // recalculate size
    this.props.dot.height = dom.dot.offsetHeight;
    this.props.dot.width = dom.dot.offsetWidth;
    this.props.line.width = dom.line.offsetWidth;
    this.width = dom.box.offsetWidth;
    this.height = dom.box.offsetHeight;

    this.dirty = false;
  }

  this._repaintDeleteButton(dom.box);
};

/**
 * Show the item in the DOM (when not already displayed). The items DOM will
 * be created when needed.
 */
BoxItem.prototype.show = function () {
  if (!this.displayed) {
    this.redraw();
  }
};

/**
 * Hide the item from the DOM (when visible)
 */
BoxItem.prototype.hide = function () {
  if (this.displayed) {
    var dom = this.dom;

    if (dom.box.parentNode) dom.box.parentNode.removeChild(dom.box);
    if (dom.line.parentNode) dom.line.parentNode.removeChild(dom.line);
    if (dom.dot.parentNode) dom.dot.parentNode.removeChild(dom.dot);

    this.displayed = false;
  }
};

/**
 * Reposition the item horizontally
 * @Override
 */
BoxItem.prototype.repositionX = function () {
  var start = this.conversion.toScreen(this.data.start);
  var align = this.options.align;
  var left;

  // calculate left position of the box
  if (align == 'right') {
    this.left = start - this.width;
  } else if (align == 'left') {
    this.left = start;
  } else {
    // default or 'center'
    this.left = start - this.width / 2;
  }

  // reposition box
  this.dom.box.style.left = this.left + 'px';

  // reposition line
  this.dom.line.style.left = start - this.props.line.width / 2 + 'px';

  // reposition dot
  this.dom.dot.style.left = start - this.props.dot.width / 2 + 'px';
};

/**
 * Reposition the item vertically
 * @Override
 */
BoxItem.prototype.repositionY = function () {
  var orientation = this.options.orientation.item;
  var box = this.dom.box;
  var line = this.dom.line;
  var dot = this.dom.dot;

  if (orientation == 'top') {
    box.style.top = (this.top || 0) + 'px';

    line.style.top = '0';
    line.style.height = this.parent.top + this.top + 1 + 'px';
    line.style.bottom = '';
  } else {
    // orientation 'bottom'
    var itemSetHeight = this.parent.itemSet.props.height; // TODO: this is nasty
    var lineHeight = itemSetHeight - this.parent.top - this.parent.height + this.top;

    box.style.top = (this.parent.height - this.top - this.height || 0) + 'px';
    line.style.top = itemSetHeight - lineHeight + 'px';
    line.style.bottom = '0';
  }

  dot.style.top = -this.props.dot.height / 2 + 'px';
};

/**
 * Return the width of the item left from its start date
 * @return {number}
 */
BoxItem.prototype.getWidthLeft = function () {
  return this.width / 2;
};

/**
 * Return the width of the item right from its start date
 * @return {number}
 */
BoxItem.prototype.getWidthRight = function () {
  return this.width / 2;
};

module.exports = BoxItem;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L2l0ZW0vQm94SXRlbS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM3QixJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7Ozs7Ozs7Ozs7OztBQVlwQyxTQUFTLE9BQU8sQ0FBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRTtBQUMzQyxNQUFJLENBQUMsS0FBSyxHQUFHO0FBQ1gsT0FBRyxFQUFFO0FBQ0gsV0FBSyxFQUFFLENBQUM7QUFDUixZQUFNLEVBQUUsQ0FBQztLQUNWO0FBQ0QsUUFBSSxFQUFFO0FBQ0osV0FBSyxFQUFFLENBQUM7QUFDUixZQUFNLEVBQUUsQ0FBQztLQUNWO0dBQ0YsQ0FBQzs7O0FBR0YsTUFBSSxJQUFJLEVBQUU7QUFDUixRQUFJLElBQUksQ0FBQyxLQUFLLElBQUksU0FBUyxFQUFFO0FBQzNCLFlBQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLEdBQUcsSUFBSSxDQUFDLENBQUM7S0FDN0Q7R0FDRjs7QUFFRCxNQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0NBQzVDOztBQUVELE9BQU8sQ0FBQyxTQUFTLEdBQUcsSUFBSSxJQUFJLENBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQzs7Ozs7OztBQU9oRCxPQUFPLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFTLEtBQUssRUFBRTs7O0FBRzVDLE1BQUksUUFBUSxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFBLEdBQUksQ0FBQyxDQUFDO0FBQzdDLFNBQU8s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RyxDQUFDO0dBQ3pCOztBQUVELEtBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLEFBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFJLElBQUksQ0FBQztDQUNyRCxDQUFDOzs7Ozs7QUFNRixPQUFPLENBQUMsU0FBUyxDQUFDLFlBQVksR0FBRyxZQUFZO0FBQzNDLFNBQU8sSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7Q0FDdkIsQ0FBQzs7Ozs7O0FBTUYsT0FBTyxDQUFDLFNBQVMsQ0FBQyxhQUFhLEdBQUcsWUFBWTtBQUM1QyxTQUFPLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0NBQ3ZCLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMiLCJmaWxlIjoiL1VzZXJzL2RhcmluL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzLXZpZXdlci9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvaXRlbS9Cb3hJdGVtLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEl0ZW0gPSByZXF1aXJlKCcuL0l0ZW0nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBCb3hJdGVtXG4gKiBAZXh0ZW5kcyBJdGVtXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIHN0YXJ0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LCBjbGFzc05hbWUuXG4gKiBAcGFyYW0ge3t0b1NjcmVlbjogZnVuY3Rpb24sIHRvVGltZTogZnVuY3Rpb259fSBjb252ZXJzaW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb252ZXJzaW9uIGZ1bmN0aW9ucyBmcm9tIHRpbWUgdG8gc2NyZWVuIGFuZCB2aWNlIHZlcnNhXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGRlc2NyaWJlIGF2YWlsYWJsZSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIEJveEl0ZW0gKGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpIHtcbiAgdGhpcy5wcm9wcyA9IHtcbiAgICBkb3Q6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfSxcbiAgICBsaW5lOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH1cbiAgfTtcblxuICAvLyB2YWxpZGF0ZSBkYXRhXG4gIGlmIChkYXRhKSB7XG4gICAgaWYgKGRhdGEuc3RhcnQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwic3RhcnRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIEl0ZW0uY2FsbCh0aGlzLCBkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKTtcbn1cblxuQm94SXRlbS5wcm90b3R5cGUgPSBuZXcgSXRlbSAobnVsbCwgbnVsbCwgbnVsbCk7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGlzIGl0ZW0gaXMgdmlzaWJsZSBpbnNpZGUgZ2l2ZW4gcmFuZ2VcbiAqIEByZXR1cm5zIHt7c3RhcnQ6IE51bWJlciwgZW5kOiBOdW1iZXJ9fSByYW5nZSB3aXRoIGEgdGltZXN0YW1wIGZvciBzdGFydCBhbmQgZW5kXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2aXNpYmxlXG4gKi9cbkJveEl0ZW0ucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gIC8vIGRldGVybWluZSB2aXNpYmlsaXR5XG4gIC8vIFRPRE86IGFjY291bnQgZm9yIHRoZSByZWFsIHdpZHRoIG9mIHRoZSBpdGVtLiBSaWdodCBub3cgd2UganVzdCBhZGQgMS80IHRvIHRoZSB3aW5kb3dcbiAgdmFyIGludGVydmFsID0gKHJhbmdlLmVuZCAtIHJhbmdlLnN0YXJ0KSAvIDQ7XG4gIHJldHVybiAodGhpcy5kYXRhLnN0YXJ0ID4gcmFuZ2Uuc3RhcnQgLSBpbnRlcnZhbCkgJiYgKHRoaXMuZGF0YS5zdGFydCA8IHJhbmdlLmVuZCArIGludGVydmFsKTtcbn07XG5cbi8qKlxuICogUmVwYWludCB0aGUgaXRlbVxuICovXG5Cb3hJdGVtLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICBpZiAoIWRvbSkge1xuICAgIC8vIGNyZWF0ZSBET01cbiAgICB0aGlzLmRvbSA9IHt9O1xuICAgIGRvbSA9IHRoaXMuZG9tO1xuXG4gICAgLy8gY3JlYXRlIG1haW4gYm94XG4gICAgZG9tLmJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuXG4gICAgLy8gY29udGVudHMgYm94IChpbnNpZGUgdGhlIGJhY2tncm91bmQgYm94KS4gdXNlZCBmb3IgbWFraW5nIG1hcmdpbnNcbiAgICBkb20uY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgIGRvbS5jb250ZW50LmNsYXNzTmFtZSA9ICd2aXMtaXRlbS1jb250ZW50JztcbiAgICBkb20uYm94LmFwcGVuZENoaWxkKGRvbS5jb250ZW50KTtcblxuICAgIC8vIGxpbmUgdG8gYXhpc1xuICAgIGRvbS5saW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgZG9tLmxpbmUuY2xhc3NOYW1lID0gJ3Zpcy1saW5lJztcblxuICAgIC8vIGRvdCBvbiBheGlzXG4gICAgZG9tLmRvdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgIGRvbS5kb3QuY2xhc3NOYW1lID0gJ3Zpcy1kb3QnO1xuXG4gICAgLy8gYXR0YWNoIHRoaXMgaXRlbSBhcyBhdHRyaWJ1dGVcbiAgICBkb20uYm94Wyd0aW1lbGluZS1pdGVtJ10gPSB0aGlzO1xuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cblxuICAvLyBhcHBlbmQgRE9NIHRvIHBhcmVudCBET01cbiAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBubyBwYXJlbnQgYXR0YWNoZWQnKTtcbiAgfVxuICBpZiAoIWRvbS5ib3gucGFyZW50Tm9kZSkge1xuICAgIHZhciBmb3JlZ3JvdW5kID0gdGhpcy5wYXJlbnQuZG9tLmZvcmVncm91bmQ7XG4gICAgaWYgKCFmb3JlZ3JvdW5kKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogcGFyZW50IGhhcyBubyBmb3JlZ3JvdW5kIGNvbnRhaW5lciBlbGVtZW50Jyk7XG4gICAgZm9yZWdyb3VuZC5hcHBlbmRDaGlsZChkb20uYm94KTtcbiAgfVxuICBpZiAoIWRvbS5saW5lLnBhcmVudE5vZGUpIHtcbiAgICB2YXIgYmFja2dyb3VuZCA9IHRoaXMucGFyZW50LmRvbS5iYWNrZ3JvdW5kO1xuICAgIGlmICghYmFja2dyb3VuZCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IHBhcmVudCBoYXMgbm8gYmFja2dyb3VuZCBjb250YWluZXIgZWxlbWVudCcpO1xuICAgIGJhY2tncm91bmQuYXBwZW5kQ2hpbGQoZG9tLmxpbmUpO1xuICB9XG4gIGlmICghZG9tLmRvdC5wYXJlbnROb2RlKSB7XG4gICAgdmFyIGF4aXMgPSB0aGlzLnBhcmVudC5kb20uYXhpcztcbiAgICBpZiAoIWJhY2tncm91bmQpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBwYXJlbnQgaGFzIG5vIGF4aXMgY29udGFpbmVyIGVsZW1lbnQnKTtcbiAgICBheGlzLmFwcGVuZENoaWxkKGRvbS5kb3QpO1xuICB9XG4gIHRoaXMuZGlzcGxheWVkID0gdHJ1ZTtcblxuICAvLyBVcGRhdGUgRE9NIHdoZW4gaXRlbSBpcyBtYXJrZWQgZGlydHkuIEFuIGl0ZW0gaXMgbWFya2VkIGRpcnR5IHdoZW46XG4gIC8vIC0gdGhlIGl0ZW0gaXMgbm90IHlldCByZW5kZXJlZFxuICAvLyAtIHRoZSBpdGVtJ3MgZGF0YSBpcyBjaGFuZ2VkXG4gIC8vIC0gdGhlIGl0ZW0gaXMgc2VsZWN0ZWQvZGVzZWxlY3RlZFxuICBpZiAodGhpcy5kaXJ0eSkge1xuICAgIHRoaXMuX3VwZGF0ZUNvbnRlbnRzKHRoaXMuZG9tLmNvbnRlbnQpO1xuICAgIHRoaXMuX3VwZGF0ZVRpdGxlKHRoaXMuZG9tLmJveCk7XG4gICAgdGhpcy5fdXBkYXRlRGF0YUF0dHJpYnV0ZXModGhpcy5kb20uYm94KTtcbiAgICB0aGlzLl91cGRhdGVTdHlsZSh0aGlzLmRvbS5ib3gpO1xuXG4gICAgdmFyIGVkaXRhYmxlID0gKHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lIHx8IFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXAgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0YWJsZSA9PT0gdHJ1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRhYmxlICE9PSBmYWxzZTtcblxuICAgIC8vIHVwZGF0ZSBjbGFzc1xuICAgIHZhciBjbGFzc05hbWUgPSAodGhpcy5kYXRhLmNsYXNzTmFtZT8gJyAnICsgdGhpcy5kYXRhLmNsYXNzTmFtZSA6ICcnKSArXG4gICAgICAgICh0aGlzLnNlbGVjdGVkID8gJyB2aXMtc2VsZWN0ZWQnIDogJycpICsgXG4gICAgICAgIChlZGl0YWJsZSA/ICcgdmlzLWVkaXRhYmxlJyA6ICcgdmlzLXJlYWRvbmx5Jyk7XG4gICAgZG9tLmJveC5jbGFzc05hbWUgPSAndmlzLWl0ZW0gdmlzLWJveCcgKyBjbGFzc05hbWU7XG4gICAgZG9tLmxpbmUuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtIHZpcy1saW5lJyArIGNsYXNzTmFtZTtcbiAgICBkb20uZG90LmNsYXNzTmFtZSAgPSAndmlzLWl0ZW0gdmlzLWRvdCcgKyBjbGFzc05hbWU7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBzaXplXG4gICAgdGhpcy5wcm9wcy5kb3QuaGVpZ2h0ID0gZG9tLmRvdC5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5wcm9wcy5kb3Qud2lkdGggPSBkb20uZG90Lm9mZnNldFdpZHRoO1xuICAgIHRoaXMucHJvcHMubGluZS53aWR0aCA9IGRvbS5saW5lLm9mZnNldFdpZHRoO1xuICAgIHRoaXMud2lkdGggPSBkb20uYm94Lm9mZnNldFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gZG9tLmJveC5vZmZzZXRIZWlnaHQ7XG5cbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH1cblxuICB0aGlzLl9yZXBhaW50RGVsZXRlQnV0dG9uKGRvbS5ib3gpO1xufTtcblxuLyoqXG4gKiBTaG93IHRoZSBpdGVtIGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgZGlzcGxheWVkKS4gVGhlIGl0ZW1zIERPTSB3aWxsXG4gKiBiZSBjcmVhdGVkIHdoZW4gbmVlZGVkLlxuICovXG5Cb3hJdGVtLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5kaXNwbGF5ZWQpIHtcbiAgICB0aGlzLnJlZHJhdygpO1xuICB9XG59O1xuXG4vKipcbiAqIEhpZGUgdGhlIGl0ZW0gZnJvbSB0aGUgRE9NICh3aGVuIHZpc2libGUpXG4gKi9cbkJveEl0ZW0ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuZGlzcGxheWVkKSB7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuXG4gICAgaWYgKGRvbS5ib3gucGFyZW50Tm9kZSkgICBkb20uYm94LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tLmJveCk7XG4gICAgaWYgKGRvbS5saW5lLnBhcmVudE5vZGUpICBkb20ubGluZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbS5saW5lKTtcbiAgICBpZiAoZG9tLmRvdC5wYXJlbnROb2RlKSAgIGRvbS5kb3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20uZG90KTtcblxuICAgIHRoaXMuZGlzcGxheWVkID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwb3NpdGlvbiB0aGUgaXRlbSBob3Jpem9udGFsbHlcbiAqIEBPdmVycmlkZVxuICovXG5Cb3hJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLmNvbnZlcnNpb24udG9TY3JlZW4odGhpcy5kYXRhLnN0YXJ0KTtcbiAgdmFyIGFsaWduID0gdGhpcy5vcHRpb25zLmFsaWduO1xuICB2YXIgbGVmdDtcblxuICAvLyBjYWxjdWxhdGUgbGVmdCBwb3NpdGlvbiBvZiB0aGUgYm94XG4gIGlmIChhbGlnbiA9PSAncmlnaHQnKSB7XG4gICAgdGhpcy5sZWZ0ID0gc3RhcnQgLSB0aGlzLndpZHRoO1xuICB9XG4gIGVsc2UgaWYgKGFsaWduID09ICdsZWZ0Jykge1xuICAgIHRoaXMubGVmdCA9IHN0YXJ0O1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIGRlZmF1bHQgb3IgJ2NlbnRlcidcbiAgICB0aGlzLmxlZnQgPSBzdGFydCAtIHRoaXMud2lkdGggLyAyO1xuICB9XG5cbiAgLy8gcmVwb3NpdGlvbiBib3hcbiAgdGhpcy5kb20uYm94LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyAncHgnO1xuXG4gIC8vIHJlcG9zaXRpb24gbGluZVxuICB0aGlzLmRvbS5saW5lLnN0eWxlLmxlZnQgPSAoc3RhcnQgLSB0aGlzLnByb3BzLmxpbmUud2lkdGggLyAyKSArICdweCc7XG5cbiAgLy8gcmVwb3NpdGlvbiBkb3RcbiAgdGhpcy5kb20uZG90LnN0eWxlLmxlZnQgPSAoc3RhcnQgLSB0aGlzLnByb3BzLmRvdC53aWR0aCAvIDIpICsgJ3B4Jztcbn07XG5cbi8qKlxuICogUmVwb3NpdGlvbiB0aGUgaXRlbSB2ZXJ0aWNhbGx5XG4gKiBAT3ZlcnJpZGVcbiAqL1xuQm94SXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG9yaWVudGF0aW9uID0gdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW07XG4gIHZhciBib3ggPSB0aGlzLmRvbS5ib3g7XG4gIHZhciBsaW5lID0gdGhpcy5kb20ubGluZTtcbiAgdmFyIGRvdCA9IHRoaXMuZG9tLmRvdDtcblxuICBpZiAob3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICBib3guc3R5bGUudG9wICAgICA9ICh0aGlzLnRvcCB8fCAwKSArICdweCc7XG5cbiAgICBsaW5lLnN0eWxlLnRvcCAgICA9ICcwJztcbiAgICBsaW5lLnN0eWxlLmhlaWdodCA9ICh0aGlzLnBhcmVudC50b3AgKyB0aGlzLnRvcCArIDEpICsgJ3B4JztcbiAgICBsaW5lLnN0eWxlLmJvdHRvbSA9ICcnO1xuICB9XG4gIGVsc2UgeyAvLyBvcmllbnRhdGlvbiAnYm90dG9tJ1xuICAgIHZhciBpdGVtU2V0SGVpZ2h0ID0gdGhpcy5wYXJlbnQuaXRlbVNldC5wcm9wcy5oZWlnaHQ7IC8vIFRPRE86IHRoaXMgaXMgbmFzdHlcbiAgICB2YXIgbGluZUhlaWdodCA9IGl0ZW1TZXRIZWlnaHQgLSB0aGlzLnBhcmVudC50b3AgLSB0aGlzLnBhcmVudC5oZWlnaHQgKyB0aGlzLnRvcDtcblxuICAgIGJveC5zdHlsZS50b3AgICAgID0gKHRoaXMucGFyZW50LmhlaWdodCAtIHRoaXMudG9wIC0gdGhpcy5oZWlnaHQgfHwgMCkgKyAncHgnO1xuICAgIGxpbmUuc3R5bGUudG9wICAgID0gKGl0ZW1TZXRIZWlnaHQgLSBsaW5lSGVpZ2h0KSArICdweCc7XG4gICAgbGluZS5zdHlsZS5ib3R0b20gPSAnMCc7XG4gIH1cblxuICBkb3Quc3R5bGUudG9wID0gKC10aGlzLnByb3BzLmRvdC5oZWlnaHQgLyAyKSArICdweCc7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgd2lkdGggb2YgdGhlIGl0ZW0gbGVmdCBmcm9tIGl0cyBzdGFydCBkYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkJveEl0ZW0ucHJvdG90eXBlLmdldFdpZHRoTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkdGggLyAyO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBpdGVtIHJpZ2h0IGZyb20gaXRzIHN0YXJ0IGRhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuQm94SXRlbS5wcm90b3R5cGUuZ2V0V2lkdGhSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkdGggLyAyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3hJdGVtO1xuIl19
},{"../../../util":46,"./Item":41}],41:[function(require,module,exports){
'use strict';

var Hammer = require('../../../module/hammer');
var util = require('../../../util');

/**
 * @constructor Item
 * @param {Object} data             Object containing (optional) parameters type,
 *                                  start, end, content, group, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} options          Configuration options
 *                                  // TODO: describe available options
 */
function Item(data, conversion, options) {
  this.id = null;
  this.parent = null;
  this.data = data;
  this.dom = null;
  this.conversion = conversion || {};
  this.options = options || {};

  this.selected = false;
  this.displayed = false;
  this.dirty = true;

  this.top = null;
  this.left = null;
  this.width = null;
  this.height = null;

  this.editable = null;
  if (this.data && this.data.hasOwnProperty('editable') && typeof this.data.editable === 'boolean') {
    this.editable = data.editable;
  }
}

Item.prototype.stack = true;

/**
 * Select current item
 */
Item.prototype.select = function () {
  this.selected = true;
  this.dirty = true;
  if (this.displayed) this.redraw();
};

/**
 * Unselect current item
 */
Item.prototype.unselect = function () {
  this.selected = false;
  this.dirty = true;
  if (this.displayed) this.redraw();
};

/**
 * Set data for the item. Existing data will be updated. The id should not
 * be changed. When the item is displayed, it will be redrawn immediately.
 * @param {Object} data
 */
Item.prototype.setData = function (data) {
  var groupChanged = data.group != undefined && this.data.group != data.group;
  if (groupChanged) {
    this.parent.itemSet._moveToGroup(this, data.group);
  }

  if (data.hasOwnProperty('editable') && typeof data.editable === 'boolean') {
    this.editable = data.editable;
  }

  this.data = data;
  this.dirty = true;
  if (this.displayed) this.redraw();
};

/**
 * Set a parent for the item
 * @param {ItemSet | Group} parent
 */
Item.prototype.setParent = function (parent) {
  if (this.displayed) {
    this.hide();
    this.parent = parent;
    if (this.parent) {
      this.show();
    }
  } else {
    this.parent = parent;
  }
};

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
Item.prototype.isVisible = function (range) {
  // Should be implemented by Item implementations
  return false;
};

/**
 * Show the Item in the DOM (when not already visible)
 * @return {Boolean} changed
 */
Item.prototype.show = function () {
  return false;
};

/**
 * Hide the Item from the DOM (when visible)
 * @return {Boolean} changed
 */
Item.prototype.hide = function () {
  return false;
};

/**
 * Repaint the item
 */
Item.prototype.redraw = function () {
  // should be implemented by the item
};

/**
 * Reposition the Item horizontally
 */
Item.prototype.repositionX = function () {
  // should be implemented by the item
};

/**
 * Reposition the Item vertically
 */
Item.prototype.repositionY = function () {
  // should be implemented by the item
};

/**
 * Repaint a delete button on the top right of the item when the item is selected
 * @param {HTMLElement} anchor
 * @protected
 */
Item.prototype._repaintDeleteButton = function (anchor) {
  var editable = (this.options.editable.remove || this.data.editable === true) && this.data.editable !== false;

  if (this.selected && editable && !this.dom.deleteButton) {
    // create and show button
    var me = this;

    var deleteButton = document.createElement('div');
    deleteButton.className = 'vis-delete';
    deleteButton.title = 'Delete this item';

    // TODO: be able to destroy the delete button
    new Hammer(deleteButton).on('tap', function (event) {
      event.stopPropagation();
      me.parent.removeFromDataSet(me);
    });

    anchor.appendChild(deleteButton);
    this.dom.deleteButton = deleteButton;
  } else if (!this.selected && this.dom.deleteButton) {
    // remove button
    if (this.dom.deleteButton.parentNode) {
      this.dom.deleteButton.parentNode.removeChild(this.dom.deleteButton);
    }
    this.dom.deleteButton = null;
  }
};

/**
 * Set HTML contents for the item
 * @param {Element} element   HTML element to fill with the contents
 * @private
 */
Item.prototype._updateContents = function (element) {
  var content;
  if (this.options.template) {
    var itemData = this.parent.itemSet.itemsData.get(this.id); // get a clone of the data from the dataset
    content = this.options.template(itemData);
  } else {
    content = this.data.content;
  }

  var changed = this._contentToString(this.content) !== this._contentToString(content);
  if (changed) {
    // only replace the content when changed
    if (content instanceof Element) {
      element.innerHTML = '';
      element.appendChild(content);
    } else if (content != undefined) {
      element.innerHTML = content;
    } else {
      if (!(this.data.type == 'background' && this.data.content === undefined)) {
        throw new Error('Property "content" missing in item ' + this.id);
      }
    }

    this.content = content;
  }
};

/**
 * Set HTML contents for the item
 * @param {Element} element   HTML element to fill with the contents
 * @private
 */
Item.prototype._updateTitle = function (element) {
  if (this.data.title != null) {
    element.title = this.data.title || '';
  } else {
    element.removeAttribute('vis-title');
  }
};

/**
 * Process dataAttributes timeline option and set as data- attributes on dom.content
 * @param {Element} element   HTML element to which the attributes will be attached
 * @private
 */
Item.prototype._updateDataAttributes = function (element) {
  if (this.options.dataAttributes && this.options.dataAttributes.length > 0) {
    var attributes = [];

    if (Array.isArray(this.options.dataAttributes)) {
      attributes = this.options.dataAttributes;
    } else if (this.options.dataAttributes == 'all') {
      attributes = Object.keys(this.data);
    } else {
      return;
    }

    for (var i = 0; i < attributes.length; i++) {
      var name = attributes[i];
      var value = this.data[name];

      if (value != null) {
        element.setAttribute('data-' + name, value);
      } else {
        element.removeAttribute('data-' + name);
      }
    }
  }
};

/**
 * Update custom styles of the element
 * @param element
 * @private
 */
Item.prototype._updateStyle = function (element) {
  // remove old styles
  if (this.style) {
    util.removeCssText(element, this.style);
    this.style = null;
  }

  // append new styles
  if (this.data.style) {
    util.addCssText(element, this.data.style);
    this.style = this.data.style;
  }
};

/**
 * Stringify the items contents
 * @param {string | Element | undefined} content
 * @returns {string | undefined}
 * @private
 */
Item.prototype._contentToString = function (content) {
  if (typeof content === 'string') return content;
  if (content && 'outerHTML' in content) return content.outerHTML;
  return content;
};

/**
 * Return the width of the item left from its start date
 * @return {number}
 */
Item.prototype.getWidthLeft = function () {
  return 0;
};

/**
 * Return the width of the item right from the max of its start and end date
 * @return {number}
 */
Item.prototype.getWidthRight = function () {
  return 0;
};

module.exports = Item;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L2l0ZW0vSXRlbS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0FBQy9DLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7QUFXcEMsU0FBUyxJQUFJLENBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUU7QUFDeEMsTUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUM7QUFDZixNQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztBQUNuQixNQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUNqQixNQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQztBQUNoQixNQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsSUFBSSxFQUFFLENBQUM7QUFDbkMsTUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLElBQUksRUFBRSxDQUFDOztBQUU3QixNQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztBQUN0QixNQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztBQUN2QixNQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzs7QUFFbEIsTUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7QUFDaEIsTUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7QUFDakIsTUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7QUFDbEIsTUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7O0FBRW5CLE1BQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO0FBQ3JCLE1BQUksSUFBSSxDQUFDLElBQUksSUFDVCxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxV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VixDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L2l0ZW0vSXRlbS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBIYW1tZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9tb2R1bGUvaGFtbWVyJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgSXRlbVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgKG9wdGlvbmFsKSBwYXJhbWV0ZXJzIHR5cGUsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCwgZW5kLCBjb250ZW50LCBncm91cCwgY2xhc3NOYW1lLlxuICogQHBhcmFtIHt7dG9TY3JlZW46IGZ1bmN0aW9uLCB0b1RpbWU6IGZ1bmN0aW9ufX0gY29udmVyc2lvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udmVyc2lvbiBmdW5jdGlvbnMgZnJvbSB0aW1lIHRvIHNjcmVlbiBhbmQgdmljZSB2ZXJzYVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZXNjcmliZSBhdmFpbGFibGUgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBJdGVtIChkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKSB7XG4gIHRoaXMuaWQgPSBudWxsO1xuICB0aGlzLnBhcmVudCA9IG51bGw7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuZG9tID0gbnVsbDtcbiAgdGhpcy5jb252ZXJzaW9uID0gY29udmVyc2lvbiB8fCB7fTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzcGxheWVkID0gZmFsc2U7XG4gIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gIHRoaXMudG9wID0gbnVsbDtcbiAgdGhpcy5sZWZ0ID0gbnVsbDtcbiAgdGhpcy53aWR0aCA9IG51bGw7XG4gIHRoaXMuaGVpZ2h0ID0gbnVsbDtcblxuICB0aGlzLmVkaXRhYmxlID0gbnVsbDtcbiAgaWYgKHRoaXMuZGF0YSAmJiBcbiAgICAgIHRoaXMuZGF0YS5oYXNPd25Qcm9wZXJ0eSgnZWRpdGFibGUnKSAmJiBcbiAgICAgIHR5cGVvZiB0aGlzLmRhdGEuZWRpdGFibGUgPT09ICdib29sZWFuJykge1xuICAgIHRoaXMuZWRpdGFibGUgPSBkYXRhLmVkaXRhYmxlO1xuICB9XG59XG5cbkl0ZW0ucHJvdG90eXBlLnN0YWNrID0gdHJ1ZTtcblxuLyoqXG4gKiBTZWxlY3QgY3VycmVudCBpdGVtXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIGlmICh0aGlzLmRpc3BsYXllZCkgdGhpcy5yZWRyYXcoKTtcbn07XG5cbi8qKlxuICogVW5zZWxlY3QgY3VycmVudCBpdGVtXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnVuc2VsZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIGlmICh0aGlzLmRpc3BsYXllZCkgdGhpcy5yZWRyYXcoKTtcbn07XG5cbi8qKlxuICogU2V0IGRhdGEgZm9yIHRoZSBpdGVtLiBFeGlzdGluZyBkYXRhIHdpbGwgYmUgdXBkYXRlZC4gVGhlIGlkIHNob3VsZCBub3RcbiAqIGJlIGNoYW5nZWQuIFdoZW4gdGhlIGl0ZW0gaXMgZGlzcGxheWVkLCBpdCB3aWxsIGJlIHJlZHJhd24gaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICovXG5JdGVtLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgZ3JvdXBDaGFuZ2VkID0gZGF0YS5ncm91cCAhPSB1bmRlZmluZWQgJiYgdGhpcy5kYXRhLmdyb3VwICE9IGRhdGEuZ3JvdXA7XG4gIGlmIChncm91cENoYW5nZWQpIHtcbiAgICB0aGlzLnBhcmVudC5pdGVtU2V0Ll9tb3ZlVG9Hcm91cCh0aGlzLCBkYXRhLmdyb3VwKTtcbiAgfVxuXG4gIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdlZGl0YWJsZScpICYmIHR5cGVvZiBkYXRhLmVkaXRhYmxlID09PSAnYm9vbGVhbicpIHtcbiAgICB0aGlzLmVkaXRhYmxlID0gZGF0YS5lZGl0YWJsZTtcbiAgfVxuXG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuZGlydHkgPSB0cnVlO1xuICBpZiAodGhpcy5kaXNwbGF5ZWQpIHRoaXMucmVkcmF3KCk7XG59O1xuXG4vKipcbiAqIFNldCBhIHBhcmVudCBmb3IgdGhlIGl0ZW1cbiAqIEBwYXJhbSB7SXRlbVNldCB8IEdyb3VwfSBwYXJlbnRcbiAqL1xuSXRlbS5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24ocGFyZW50KSB7XG4gIGlmICh0aGlzLmRpc3BsYXllZCkge1xuICAgIHRoaXMuaGlkZSgpO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhpcyBpdGVtIGlzIHZpc2libGUgaW5zaWRlIGdpdmVuIHJhbmdlXG4gKiBAcmV0dXJucyB7e3N0YXJ0OiBOdW1iZXIsIGVuZDogTnVtYmVyfX0gcmFuZ2Ugd2l0aCBhIHRpbWVzdGFtcCBmb3Igc3RhcnQgYW5kIGVuZFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmlzaWJsZVxuICovXG5JdGVtLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbihyYW5nZSkge1xuICAvLyBTaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgSXRlbSBpbXBsZW1lbnRhdGlvbnNcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBTaG93IHRoZSBJdGVtIGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgdmlzaWJsZSlcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAqL1xuSXRlbS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEhpZGUgdGhlIEl0ZW0gZnJvbSB0aGUgRE9NICh3aGVuIHZpc2libGUpXG4gKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gKi9cbkl0ZW0ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXBhaW50IHRoZSBpdGVtXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAvLyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIGl0ZW1cbn07XG5cbi8qKlxuICogUmVwb3NpdGlvbiB0aGUgSXRlbSBob3Jpem9udGFsbHlcbiAqL1xuSXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblggPSBmdW5jdGlvbigpIHtcbiAgLy8gc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBpdGVtXG59O1xuXG4vKipcbiAqIFJlcG9zaXRpb24gdGhlIEl0ZW0gdmVydGljYWxseVxuICovXG5JdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWSA9IGZ1bmN0aW9uKCkge1xuICAvLyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIGl0ZW1cbn07XG5cbi8qKlxuICogUmVwYWludCBhIGRlbGV0ZSBidXR0b24gb24gdGhlIHRvcCByaWdodCBvZiB0aGUgaXRlbSB3aGVuIHRoZSBpdGVtIGlzIHNlbGVjdGVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBhbmNob3JcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuSXRlbS5wcm90b3R5cGUuX3JlcGFpbnREZWxldGVCdXR0b24gPSBmdW5jdGlvbiAoYW5jaG9yKSB7XG4gIHZhciBlZGl0YWJsZSA9ICh0aGlzLm9wdGlvbnMuZWRpdGFibGUucmVtb3ZlIHx8IFxuICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmVkaXRhYmxlID09PSB0cnVlKSAmJlxuICAgICAgICAgICAgICAgICB0aGlzLmRhdGEuZWRpdGFibGUgIT09IGZhbHNlO1xuXG4gIGlmICh0aGlzLnNlbGVjdGVkICYmIGVkaXRhYmxlICYmICF0aGlzLmRvbS5kZWxldGVCdXR0b24pIHtcbiAgICAvLyBjcmVhdGUgYW5kIHNob3cgYnV0dG9uXG4gICAgdmFyIG1lID0gdGhpcztcblxuICAgIHZhciBkZWxldGVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZWxldGVCdXR0b24uY2xhc3NOYW1lID0gJ3Zpcy1kZWxldGUnO1xuICAgIGRlbGV0ZUJ1dHRvbi50aXRsZSA9ICdEZWxldGUgdGhpcyBpdGVtJztcblxuICAgIC8vIFRPRE86IGJlIGFibGUgdG8gZGVzdHJveSB0aGUgZGVsZXRlIGJ1dHRvblxuICAgIG5ldyBIYW1tZXIoZGVsZXRlQnV0dG9uKS5vbigndGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIG1lLnBhcmVudC5yZW1vdmVGcm9tRGF0YVNldChtZSk7XG4gICAgfSk7XG5cbiAgICBhbmNob3IuYXBwZW5kQ2hpbGQoZGVsZXRlQnV0dG9uKTtcbiAgICB0aGlzLmRvbS5kZWxldGVCdXR0b24gPSBkZWxldGVCdXR0b247XG4gIH1cbiAgZWxzZSBpZiAoIXRoaXMuc2VsZWN0ZWQgJiYgdGhpcy5kb20uZGVsZXRlQnV0dG9uKSB7XG4gICAgLy8gcmVtb3ZlIGJ1dHRvblxuICAgIGlmICh0aGlzLmRvbS5kZWxldGVCdXR0b24ucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20uZGVsZXRlQnV0dG9uLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uZGVsZXRlQnV0dG9uKTtcbiAgICB9XG4gICAgdGhpcy5kb20uZGVsZXRlQnV0dG9uID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgSFRNTCBjb250ZW50cyBmb3IgdGhlIGl0ZW1cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAgIEhUTUwgZWxlbWVudCB0byBmaWxsIHdpdGggdGhlIGNvbnRlbnRzXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtLnByb3RvdHlwZS5fdXBkYXRlQ29udGVudHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgY29udGVudDtcbiAgaWYgKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSkge1xuICAgIHZhciBpdGVtRGF0YSA9IHRoaXMucGFyZW50Lml0ZW1TZXQuaXRlbXNEYXRhLmdldCh0aGlzLmlkKTsgLy8gZ2V0IGEgY2xvbmUgb2YgdGhlIGRhdGEgZnJvbSB0aGUgZGF0YXNldFxuICAgIGNvbnRlbnQgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUoaXRlbURhdGEpO1xuICB9XG4gIGVsc2Uge1xuICAgIGNvbnRlbnQgPSB0aGlzLmRhdGEuY29udGVudDtcbiAgfVxuXG4gIHZhciBjaGFuZ2VkID0gdGhpcy5fY29udGVudFRvU3RyaW5nKHRoaXMuY29udGVudCkgIT09IHRoaXMuX2NvbnRlbnRUb1N0cmluZyhjb250ZW50KTtcbiAgaWYgKGNoYW5nZWQpIHtcbiAgICAvLyBvbmx5IHJlcGxhY2UgdGhlIGNvbnRlbnQgd2hlbiBjaGFuZ2VkXG4gICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICBlbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGVudCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoISh0aGlzLmRhdGEudHlwZSA9PSAnYmFja2dyb3VuZCcgJiYgdGhpcy5kYXRhLmNvbnRlbnQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcImNvbnRlbnRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIHRoaXMuaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IEhUTUwgY29udGVudHMgZm9yIHRoZSBpdGVtXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICBIVE1MIGVsZW1lbnQgdG8gZmlsbCB3aXRoIHRoZSBjb250ZW50c1xuICogQHByaXZhdGVcbiAqL1xuSXRlbS5wcm90b3R5cGUuX3VwZGF0ZVRpdGxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgaWYgKHRoaXMuZGF0YS50aXRsZSAhPSBudWxsKSB7XG4gICAgZWxlbWVudC50aXRsZSA9IHRoaXMuZGF0YS50aXRsZSB8fCAnJztcbiAgfVxuICBlbHNlIHtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndmlzLXRpdGxlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvY2VzcyBkYXRhQXR0cmlidXRlcyB0aW1lbGluZSBvcHRpb24gYW5kIHNldCBhcyBkYXRhLSBhdHRyaWJ1dGVzIG9uIGRvbS5jb250ZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICBIVE1MIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGF0dHJpYnV0ZXMgd2lsbCBiZSBhdHRhY2hlZFxuICogQHByaXZhdGVcbiAqL1xuIEl0ZW0ucHJvdG90eXBlLl91cGRhdGVEYXRhQXR0cmlidXRlcyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5kYXRhQXR0cmlidXRlcyAmJiB0aGlzLm9wdGlvbnMuZGF0YUF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBhdHRyaWJ1dGVzID0gW107XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuZGF0YUF0dHJpYnV0ZXMpKSB7XG4gICAgICBhdHRyaWJ1dGVzID0gdGhpcy5vcHRpb25zLmRhdGFBdHRyaWJ1dGVzO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZGF0YUF0dHJpYnV0ZXMgPT0gJ2FsbCcpIHtcbiAgICAgIGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyh0aGlzLmRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlc1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZGF0YVtuYW1lXTtcblxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS0nICsgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBjdXN0b20gc3R5bGVzIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0gZWxlbWVudFxuICogQHByaXZhdGVcbiAqL1xuSXRlbS5wcm90b3R5cGUuX3VwZGF0ZVN0eWxlID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAvLyByZW1vdmUgb2xkIHN0eWxlc1xuICBpZiAodGhpcy5zdHlsZSkge1xuICAgIHV0aWwucmVtb3ZlQ3NzVGV4dChlbGVtZW50LCB0aGlzLnN0eWxlKTtcbiAgICB0aGlzLnN0eWxlID0gbnVsbDtcbiAgfVxuXG4gIC8vIGFwcGVuZCBuZXcgc3R5bGVzXG4gIGlmICh0aGlzLmRhdGEuc3R5bGUpIHtcbiAgICB1dGlsLmFkZENzc1RleHQoZWxlbWVudCwgdGhpcy5kYXRhLnN0eWxlKTtcbiAgICB0aGlzLnN0eWxlID0gdGhpcy5kYXRhLnN0eWxlO1xuICB9XG59O1xuXG4vKipcbiAqIFN0cmluZ2lmeSB0aGUgaXRlbXMgY29udGVudHNcbiAqIEBwYXJhbSB7c3RyaW5nIHwgRWxlbWVudCB8IHVuZGVmaW5lZH0gY29udGVudFxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW0ucHJvdG90eXBlLl9jb250ZW50VG9TdHJpbmcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSByZXR1cm4gY29udGVudDtcbiAgaWYgKGNvbnRlbnQgJiYgJ291dGVySFRNTCcgaW4gY29udGVudCkgcmV0dXJuIGNvbnRlbnQub3V0ZXJIVE1MO1xuICByZXR1cm4gY29udGVudDtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgaXRlbSBsZWZ0IGZyb20gaXRzIHN0YXJ0IGRhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuSXRlbS5wcm90b3R5cGUuZ2V0V2lkdGhMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgaXRlbSByaWdodCBmcm9tIHRoZSBtYXggb2YgaXRzIHN0YXJ0IGFuZCBlbmQgZGF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5JdGVtLnByb3RvdHlwZS5nZXRXaWR0aFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gMDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSXRlbTtcbiJdfQ==
},{"../../../module/hammer":19,"../../../util":46}],42:[function(require,module,exports){
'use strict';

var Item = require('./Item');

/**
 * @constructor PointItem
 * @extends Item
 * @param {Object} data             Object containing parameters start
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe available options
 */
function PointItem(data, conversion, options) {
  this.props = {
    dot: {
      top: 0,
      width: 0,
      height: 0
    },
    content: {
      height: 0,
      marginLeft: 0
    }
  };

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data);
    }
  }

  Item.call(this, data, conversion, options);
}

PointItem.prototype = new Item(null, null, null);

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
PointItem.prototype.isVisible = function (range) {
  // determine visibility
  // TODO: account for the real width of the item. Right now we just add 1/4 to the window
  var interval = (range.end - range.start) / 4;
  return this.data.start > range.start - interval && this.data.start < range.end + interval;
};

/**
 * Repaint the item
 */
PointItem.prototype.redraw = function () {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // background box
    dom.point = document.createElement('div');
    // className is updated in redraw()

    // contents box, right from the dot
    dom.content = document.createElement('div');
    dom.content.className = 'vis-item-content';
    dom.point.appendChild(dom.content);

    // dot at start
    dom.dot = document.createElement('div');
    dom.point.appendChild(dom.dot);

    // attach this item as attribute
    dom.point['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.point.parentNode) {
    var foreground = this.parent.dom.foreground;
    if (!foreground) {
      throw new Error('Cannot redraw item: parent has no foreground container element');
    }
    foreground.appendChild(dom.point);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.point);
    this._updateDataAttributes(this.dom.point);
    this._updateStyle(this.dom.point);

    var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

    // update class
    var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
    dom.point.className = 'vis-item vis-point' + className;
    dom.dot.className = 'vis-item vis-dot' + className;

    // recalculate size of dot and contents
    this.props.dot.width = dom.dot.offsetWidth;
    this.props.dot.height = dom.dot.offsetHeight;
    this.props.content.height = dom.content.offsetHeight;

    // resize contents
    dom.content.style.marginLeft = 2 * this.props.dot.width + 'px';
    //dom.content.style.marginRight = ... + 'px'; // TODO: margin right

    // recalculate size
    this.width = dom.point.offsetWidth;
    this.height = dom.point.offsetHeight;

    // reposition the dot
    dom.dot.style.top = (this.height - this.props.dot.height) / 2 + 'px';
    dom.dot.style.left = this.props.dot.width / 2 + 'px';

    this.dirty = false;
  }

  this._repaintDeleteButton(dom.point);
};

/**
 * Show the item in the DOM (when not already visible). The items DOM will
 * be created when needed.
 */
PointItem.prototype.show = function () {
  if (!this.displayed) {
    this.redraw();
  }
};

/**
 * Hide the item from the DOM (when visible)
 */
PointItem.prototype.hide = function () {
  if (this.displayed) {
    if (this.dom.point.parentNode) {
      this.dom.point.parentNode.removeChild(this.dom.point);
    }

    this.displayed = false;
  }
};

/**
 * Reposition the item horizontally
 * @Override
 */
PointItem.prototype.repositionX = function () {
  var start = this.conversion.toScreen(this.data.start);

  this.left = start - this.props.dot.width;

  // reposition point
  this.dom.point.style.left = this.left + 'px';
};

/**
 * Reposition the item vertically
 * @Override
 */
PointItem.prototype.repositionY = function () {
  var orientation = this.options.orientation.item;
  var point = this.dom.point;

  if (orientation == 'top') {
    point.style.top = this.top + 'px';
  } else {
    point.style.top = this.parent.height - this.top - this.height + 'px';
  }
};

/**
 * Return the width of the item left from its start date
 * @return {number}
 */
PointItem.prototype.getWidthLeft = function () {
  return this.props.dot.width;
};

/**
 * Return the width of the item right from  its start date
 * @return {number}
 */
PointItem.prototype.getWidthRight = function () {
  return this.width - this.props.dot.width;
};

module.exports = PointItem;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L2l0ZW0vUG9pbnRJdGVtLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7QUFZN0IsU0FBUyxTQUFTLENBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUU7QUFDN0MsTUFBSSxDQUFDLEtBQUssR0FBRztBQUNYLE9BQUcsRUFBRTtBQUNILFNBQUcsRUFBRSxDQUFDO0FBQ04sV0FBSyxFQUFFLENBQUM7QUFDUixZQUFNLEVBQUUsQ0FBQztLQUNWO0FBQ0QsV0FBTyxFQUFFO0FBQ1AsWUFBTSxFQUFFLENBQUM7QUFDVCxnQkFBVSxFQUFFLENBQUM7S0FDZDtHQUNGLENBQUM7OztBQUdGLE1BQUksSUFBSSxFQUFFO0FBQ1IsUUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLFNBQVMsRUFBRTtBQUMzQixZQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxHQUFHLElBQUksQ0FBQyxDQUFDO0tBQzdEO0dBQ0Y7O0FBRUQsTUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztDQUM1Qzs7QUFFRCxTQUFTLENBQUMsU0FBUyxHQUFHLElBQUksSUFBSSxDQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7Ozs7Ozs7QUFPbEQsU0FBUyxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsVUFBUyxLQUFLLEVBQUU7OztBQUc5QyxNQUFJLFFBQVEsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQSxHQUFJLENBQUMsQ0FBQztBQUM3QyxTQUFPLEFBQUMsSUFBSSxDQUFDLElBQUksQ0FB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O0FBQ3hCLFNBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDO0dBQ25DLE1BQ0k7QUFDSCxTQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxBQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBSSxJQUFJLENBQUM7R0FDeEU7Q0FDRixDQUFDOzs7Ozs7QUFNRixTQUFTLENBQUMsU0FBUyxDQUFDLFlBQVksR0FBRyxZQUFZO0FBQzdDLFNBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDO0NBQzdCLENBQUM7Ozs7OztBQU1GLFNBQVMsQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFHLFlBQVk7QUFDOUMsU0FBTyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQztDQUMxQyxDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L2l0ZW0vUG9pbnRJdGVtLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEl0ZW0gPSByZXF1aXJlKCcuL0l0ZW0nKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgUG9pbnRJdGVtXG4gKiBAZXh0ZW5kcyBJdGVtXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIHN0YXJ0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LCBjbGFzc05hbWUuXG4gKiBAcGFyYW0ge3t0b1NjcmVlbjogZnVuY3Rpb24sIHRvVGltZTogZnVuY3Rpb259fSBjb252ZXJzaW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb252ZXJzaW9uIGZ1bmN0aW9ucyBmcm9tIHRpbWUgdG8gc2NyZWVuIGFuZCB2aWNlIHZlcnNhXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGRlc2NyaWJlIGF2YWlsYWJsZSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFBvaW50SXRlbSAoZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucykge1xuICB0aGlzLnByb3BzID0ge1xuICAgIGRvdDoge1xuICAgICAgdG9wOiAwLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9LFxuICAgIGNvbnRlbnQ6IHtcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIG1hcmdpbkxlZnQ6IDBcbiAgICB9XG4gIH07XG5cbiAgLy8gdmFsaWRhdGUgZGF0YVxuICBpZiAoZGF0YSkge1xuICAgIGlmIChkYXRhLnN0YXJ0ID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcInN0YXJ0XCIgbWlzc2luZyBpbiBpdGVtICcgKyBkYXRhKTtcbiAgICB9XG4gIH1cblxuICBJdGVtLmNhbGwodGhpcywgZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucyk7XG59XG5cblBvaW50SXRlbS5wcm90b3R5cGUgPSBuZXcgSXRlbSAobnVsbCwgbnVsbCwgbnVsbCk7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGlzIGl0ZW0gaXMgdmlzaWJsZSBpbnNpZGUgZ2l2ZW4gcmFuZ2VcbiAqIEByZXR1cm5zIHt7c3RhcnQ6IE51bWJlciwgZW5kOiBOdW1iZXJ9fSByYW5nZSB3aXRoIGEgdGltZXN0YW1wIGZvciBzdGFydCBhbmQgZW5kXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2aXNpYmxlXG4gKi9cblBvaW50SXRlbS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgLy8gZGV0ZXJtaW5lIHZpc2liaWxpdHlcbiAgLy8gVE9ETzogYWNjb3VudCBmb3IgdGhlIHJlYWwgd2lkdGggb2YgdGhlIGl0ZW0uIFJpZ2h0IG5vdyB3ZSBqdXN0IGFkZCAxLzQgdG8gdGhlIHdpbmRvd1xuICB2YXIgaW50ZXJ2YWwgPSAocmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQpIC8gNDtcbiAgcmV0dXJuICh0aGlzLmRhdGEuc3RhcnQgPiByYW5nZS5zdGFydCAtIGludGVydmFsKSAmJiAodGhpcy5kYXRhLnN0YXJ0IDwgcmFuZ2UuZW5kICsgaW50ZXJ2YWwpO1xufTtcblxuLyoqXG4gKiBSZXBhaW50IHRoZSBpdGVtXG4gKi9cblBvaW50SXRlbS5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgaWYgKCFkb20pIHtcbiAgICAvLyBjcmVhdGUgRE9NXG4gICAgdGhpcy5kb20gPSB7fTtcbiAgICBkb20gPSB0aGlzLmRvbTtcblxuICAgIC8vIGJhY2tncm91bmQgYm94XG4gICAgZG9tLnBvaW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgLy8gY2xhc3NOYW1lIGlzIHVwZGF0ZWQgaW4gcmVkcmF3KClcblxuICAgIC8vIGNvbnRlbnRzIGJveCwgcmlnaHQgZnJvbSB0aGUgZG90XG4gICAgZG9tLmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20uY29udGVudC5jbGFzc05hbWUgPSAndmlzLWl0ZW0tY29udGVudCc7XG4gICAgZG9tLnBvaW50LmFwcGVuZENoaWxkKGRvbS5jb250ZW50KTtcblxuICAgIC8vIGRvdCBhdCBzdGFydFxuICAgIGRvbS5kb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20ucG9pbnQuYXBwZW5kQ2hpbGQoZG9tLmRvdCk7XG5cbiAgICAvLyBhdHRhY2ggdGhpcyBpdGVtIGFzIGF0dHJpYnV0ZVxuICAgIGRvbS5wb2ludFsndGltZWxpbmUtaXRlbSddID0gdGhpcztcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG5cbiAgLy8gYXBwZW5kIERPTSB0byBwYXJlbnQgRE9NXG4gIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogbm8gcGFyZW50IGF0dGFjaGVkJyk7XG4gIH1cbiAgaWYgKCFkb20ucG9pbnQucGFyZW50Tm9kZSkge1xuICAgIHZhciBmb3JlZ3JvdW5kID0gdGhpcy5wYXJlbnQuZG9tLmZvcmVncm91bmQ7XG4gICAgaWYgKCFmb3JlZ3JvdW5kKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogcGFyZW50IGhhcyBubyBmb3JlZ3JvdW5kIGNvbnRhaW5lciBlbGVtZW50Jyk7XG4gICAgfVxuICAgIGZvcmVncm91bmQuYXBwZW5kQ2hpbGQoZG9tLnBvaW50KTtcbiAgfVxuICB0aGlzLmRpc3BsYXllZCA9IHRydWU7XG5cbiAgLy8gVXBkYXRlIERPTSB3aGVuIGl0ZW0gaXMgbWFya2VkIGRpcnR5LiBBbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eSB3aGVuOlxuICAvLyAtIHRoZSBpdGVtIGlzIG5vdCB5ZXQgcmVuZGVyZWRcbiAgLy8gLSB0aGUgaXRlbSdzIGRhdGEgaXMgY2hhbmdlZFxuICAvLyAtIHRoZSBpdGVtIGlzIHNlbGVjdGVkL2Rlc2VsZWN0ZWRcbiAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICB0aGlzLl91cGRhdGVDb250ZW50cyh0aGlzLmRvbS5jb250ZW50KTtcbiAgICB0aGlzLl91cGRhdGVUaXRsZSh0aGlzLmRvbS5wb2ludCk7XG4gICAgdGhpcy5fdXBkYXRlRGF0YUF0dHJpYnV0ZXModGhpcy5kb20ucG9pbnQpO1xuICAgIHRoaXMuX3VwZGF0ZVN0eWxlKHRoaXMuZG9tLnBvaW50KTtcblxuICAgIHZhciBlZGl0YWJsZSA9ICh0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSB8fCBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZUdyb3VwIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdGFibGUgPT09IHRydWUpICYmXG4gICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAvLyB1cGRhdGUgY2xhc3NcbiAgICB2YXIgY2xhc3NOYW1lID0gKHRoaXMuZGF0YS5jbGFzc05hbWUgPyAnICcgKyB0aGlzLmRhdGEuY2xhc3NOYW1lIDogJycpICtcbiAgICAgICAgKHRoaXMuc2VsZWN0ZWQgPyAnIHZpcy1zZWxlY3RlZCcgOiAnJykgK1xuICAgICAgICAoZWRpdGFibGUgPyAnIHZpcy1lZGl0YWJsZScgOiAnIHZpcy1yZWFkb25seScpO1xuICAgIGRvbS5wb2ludC5jbGFzc05hbWUgID0gJ3Zpcy1pdGVtIHZpcy1wb2ludCcgKyBjbGFzc05hbWU7XG4gICAgZG9tLmRvdC5jbGFzc05hbWUgID0gJ3Zpcy1pdGVtIHZpcy1kb3QnICsgY2xhc3NOYW1lO1xuXG4gICAgLy8gcmVjYWxjdWxhdGUgc2l6ZSBvZiBkb3QgYW5kIGNvbnRlbnRzXG4gICAgdGhpcy5wcm9wcy5kb3Qud2lkdGggPSBkb20uZG90Lm9mZnNldFdpZHRoO1xuICAgIHRoaXMucHJvcHMuZG90LmhlaWdodCA9IGRvbS5kb3Qub2Zmc2V0SGVpZ2h0O1xuICAgIHRoaXMucHJvcHMuY29udGVudC5oZWlnaHQgPSBkb20uY29udGVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAvLyByZXNpemUgY29udGVudHNcbiAgICBkb20uY29udGVudC5zdHlsZS5tYXJnaW5MZWZ0ID0gMiAqIHRoaXMucHJvcHMuZG90LndpZHRoICsgJ3B4JztcbiAgICAvL2RvbS5jb250ZW50LnN0eWxlLm1hcmdpblJpZ2h0ID0gLi4uICsgJ3B4JzsgLy8gVE9ETzogbWFyZ2luIHJpZ2h0XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBzaXplXG4gICAgdGhpcy53aWR0aCA9IGRvbS5wb2ludC5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGRvbS5wb2ludC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAvLyByZXBvc2l0aW9uIHRoZSBkb3RcbiAgICBkb20uZG90LnN0eWxlLnRvcCA9ICgodGhpcy5oZWlnaHQgLSB0aGlzLnByb3BzLmRvdC5oZWlnaHQpIC8gMikgKyAncHgnO1xuICAgIGRvbS5kb3Quc3R5bGUubGVmdCA9ICh0aGlzLnByb3BzLmRvdC53aWR0aCAvIDIpICsgJ3B4JztcblxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxuXG4gIHRoaXMuX3JlcGFpbnREZWxldGVCdXR0b24oZG9tLnBvaW50KTtcbn07XG5cbi8qKlxuICogU2hvdyB0aGUgaXRlbSBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IHZpc2libGUpLiBUaGUgaXRlbXMgRE9NIHdpbGxcbiAqIGJlIGNyZWF0ZWQgd2hlbiBuZWVkZWQuXG4gKi9cblBvaW50SXRlbS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZGlzcGxheWVkKSB7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBIaWRlIHRoZSBpdGVtIGZyb20gdGhlIERPTSAod2hlbiB2aXNpYmxlKVxuICovXG5Qb2ludEl0ZW0ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuZGlzcGxheWVkKSB7XG4gICAgaWYgKHRoaXMuZG9tLnBvaW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZG9tLnBvaW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20ucG9pbnQpO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGxheWVkID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwb3NpdGlvbiB0aGUgaXRlbSBob3Jpem9udGFsbHlcbiAqIEBPdmVycmlkZVxuICovXG5Qb2ludEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFydCA9IHRoaXMuY29udmVyc2lvbi50b1NjcmVlbih0aGlzLmRhdGEuc3RhcnQpO1xuXG4gIHRoaXMubGVmdCA9IHN0YXJ0IC0gdGhpcy5wcm9wcy5kb3Qud2lkdGg7XG5cbiAgLy8gcmVwb3NpdGlvbiBwb2ludFxuICB0aGlzLmRvbS5wb2ludC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgJ3B4Jztcbn07XG5cbi8qKlxuICogUmVwb3NpdGlvbiB0aGUgaXRlbSB2ZXJ0aWNhbGx5XG4gKiBAT3ZlcnJpZGVcbiAqL1xuUG9pbnRJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbTtcbiAgdmFyIHBvaW50ID0gdGhpcy5kb20ucG9pbnQ7XG5cbiAgaWYgKG9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgcG9pbnQuc3R5bGUudG9wID0gdGhpcy50b3AgKyAncHgnO1xuICB9XG4gIGVsc2Uge1xuICAgIHBvaW50LnN0eWxlLnRvcCA9ICh0aGlzLnBhcmVudC5oZWlnaHQgLSB0aGlzLnRvcCAtIHRoaXMuaGVpZ2h0KSArICdweCc7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgaXRlbSBsZWZ0IGZyb20gaXRzIHN0YXJ0IGRhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUG9pbnRJdGVtLnByb3RvdHlwZS5nZXRXaWR0aExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnByb3BzLmRvdC53aWR0aDtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgaXRlbSByaWdodCBmcm9tICBpdHMgc3RhcnQgZGF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5Qb2ludEl0ZW0ucHJvdG90eXBlLmdldFdpZHRoUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLndpZHRoIC0gdGhpcy5wcm9wcy5kb3Qud2lkdGg7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50SXRlbTtcbiJdfQ==
},{"./Item":41}],43:[function(require,module,exports){
'use strict';

var Hammer = require('../../../module/hammer');
var Item = require('./Item');

/**
 * @constructor RangeItem
 * @extends Item
 * @param {Object} data             Object containing parameters start, end
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe options
 */
function RangeItem(data, conversion, options) {
  this.props = {
    content: {
      width: 0
    }
  };
  this.overflow = false; // if contents can overflow (css styling), this flag is set to true

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data.id);
    }
    if (data.end == undefined) {
      throw new Error('Property "end" missing in item ' + data.id);
    }
  }

  Item.call(this, data, conversion, options);
}

RangeItem.prototype = new Item(null, null, null);

RangeItem.prototype.baseClassName = 'vis-item vis-range';

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
RangeItem.prototype.isVisible = function (range) {
  // determine visibility
  return this.data.start < range.end && this.data.end > range.start;
};

/**
 * Repaint the item
 */
RangeItem.prototype.redraw = function () {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // background box
    dom.box = document.createElement('div');
    // className is updated in redraw()

    // frame box (to prevent the item contents from overflowing
    dom.frame = document.createElement('div');
    dom.frame.className = 'vis-item-overflow';
    dom.box.appendChild(dom.frame);

    // contents box
    dom.content = document.createElement('div');
    dom.content.className = 'vis-item-content';
    dom.frame.appendChild(dom.content);

    // attach this item as attribute
    dom.box['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.box.parentNode) {
    var foreground = this.parent.dom.foreground;
    if (!foreground) {
      throw new Error('Cannot redraw item: parent has no foreground container element');
    }
    foreground.appendChild(dom.box);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.box);
    this._updateDataAttributes(this.dom.box);
    this._updateStyle(this.dom.box);

    var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

    // update class
    var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
    dom.box.className = this.baseClassName + className;

    // determine from css whether this box has overflow
    this.overflow = window.getComputedStyle(dom.frame).overflow !== 'hidden';

    // recalculate size
    // turn off max-width to be able to calculate the real width
    // this causes an extra browser repaint/reflow, but so be it
    this.dom.content.style.maxWidth = 'none';
    this.props.content.width = this.dom.content.offsetWidth;
    this.height = this.dom.box.offsetHeight;
    this.dom.content.style.maxWidth = '';

    this.dirty = false;
  }

  this._repaintDeleteButton(dom.box);
  this._repaintDragLeft();
  this._repaintDragRight();
};

/**
 * Show the item in the DOM (when not already visible). The items DOM will
 * be created when needed.
 */
RangeItem.prototype.show = function () {
  if (!this.displayed) {
    this.redraw();
  }
};

/**
 * Hide the item from the DOM (when visible)
 * @return {Boolean} changed
 */
RangeItem.prototype.hide = function () {
  if (this.displayed) {
    var box = this.dom.box;

    if (box.parentNode) {
      box.parentNode.removeChild(box);
    }

    this.displayed = false;
  }
};

/**
 * Reposition the item horizontally
 * @param {boolean} [limitSize=true] If true (default), the width of the range
 *                                   item will be limited, as the browser cannot
 *                                   display very wide divs. This means though
 *                                   that the applied left and width may
 *                                   not correspond to the ranges start and end
 * @Override
 */
RangeItem.prototype.repositionX = function (limitSize) {
  var parentWidth = this.parent.width;
  var start = this.conversion.toScreen(this.data.start);
  var end = this.conversion.toScreen(this.data.end);
  var contentLeft;
  var contentWidth;

  // limit the width of the range, as browsers cannot draw very wide divs
  if (limitSize === undefined || limitSize === true) {
    if (start < -parentWidth) {
      start = -parentWidth;
    }
    if (end > 2 * parentWidth) {
      end = 2 * parentWidth;
    }
  }
  var boxWidth = Math.max(end - start, 1);

  if (this.overflow) {
    this.left = start;
    this.width = boxWidth + this.props.content.width;
    contentWidth = this.props.content.width;

    // Note: The calculation of width is an optimistic calculation, giving
    //       a width which will not change when moving the Timeline
    //       So no re-stacking needed, which is nicer for the eye;
  } else {
      this.left = start;
      this.width = boxWidth;
      contentWidth = Math.min(end - start, this.props.content.width);
    }

  this.dom.box.style.left = this.left + 'px';
  this.dom.box.style.width = boxWidth + 'px';

  switch (this.options.align) {
    case 'left':
      this.dom.content.style.left = '0';
      break;

    case 'right':
      this.dom.content.style.left = Math.max(boxWidth - contentWidth, 0) + 'px';
      break;

    case 'center':
      this.dom.content.style.left = Math.max((boxWidth - contentWidth) / 2, 0) + 'px';
      break;

    default:
      // 'auto'
      // when range exceeds left of the window, position the contents at the left of the visible area
      if (this.overflow) {
        if (end > 0) {
          contentLeft = Math.max(-start, 0);
        } else {
          contentLeft = -contentWidth; // ensure it's not visible anymore
        }
      } else {
          if (start < 0) {
            contentLeft = -start;
          } else {
            contentLeft = 0;
          }
        }
      this.dom.content.style.left = contentLeft + 'px';
  }
};

/**
 * Reposition the item vertically
 * @Override
 */
RangeItem.prototype.repositionY = function () {
  var orientation = this.options.orientation.item;
  var box = this.dom.box;

  if (orientation == 'top') {
    box.style.top = this.top + 'px';
  } else {
    box.style.top = this.parent.height - this.top - this.height + 'px';
  }
};

/**
 * Repaint a drag area on the left side of the range when the range is selected
 * @protected
 */
RangeItem.prototype._repaintDragLeft = function () {
  if (this.selected && this.options.editable.updateTime && !this.dom.dragLeft) {
    // create and show drag area
    var dragLeft = document.createElement('div');
    dragLeft.className = 'vis-drag-left';
    dragLeft.dragLeftItem = this;

    this.dom.box.appendChild(dragLeft);
    this.dom.dragLeft = dragLeft;
  } else if (!this.selected && this.dom.dragLeft) {
    // delete drag area
    if (this.dom.dragLeft.parentNode) {
      this.dom.dragLeft.parentNode.removeChild(this.dom.dragLeft);
    }
    this.dom.dragLeft = null;
  }
};

/**
 * Repaint a drag area on the right side of the range when the range is selected
 * @protected
 */
RangeItem.prototype._repaintDragRight = function () {
  if (this.selected && this.options.editable.updateTime && !this.dom.dragRight) {
    // create and show drag area
    var dragRight = document.createElement('div');
    dragRight.className = 'vis-drag-right';
    dragRight.dragRightItem = this;

    this.dom.box.appendChild(dragRight);
    this.dom.dragRight = dragRight;
  } else if (!this.selected && this.dom.dragRight) {
    // delete drag area
    if (this.dom.dragRight.parentNode) {
      this.dom.dragRight.parentNode.removeChild(this.dom.dragRight);
    }
    this.dom.dragRight = null;
  }
};

module.exports = RangeItem;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L2l0ZW0vUmFuZ2VJdGVtLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLHdCQUF3QixDQUFDLENBQUM7QUFDL0MsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7QUFZN0IsU0FBUyxTQUFTLENBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUU7QUFDN0MsTUFBSSxDQUFDLEtBQUssR0FBRztBQUNYLFdBQU8sRUFBRTtBQUNQLFdBQUssRUFBRSxDQUFDO0tBQ1Q7R0FDRixDQUFDO0FBQ0YsTUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7OztBQUd0QixNQUFJLElBQUksRUFBRTtBQUNSLFFBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxTQUFTLEVBQUU7QUFDM0IsWUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDaEU7QUFDRCxRQUFJLElBQUksQ0FBQyxHQUFHLElBQUksU0FBUyxFQUFFO0FBQ3pCLFlBQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQzlEO0dBQ0Y7O0FBRUQsTUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztDQUM1Qzs7QUFFRCxTQUFTLENBQUMsU0FBUyxHQUFHLElBQUksSUFBSSxDQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7O0FBRWxELFNBQVMsQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFHLG9CQUFvQixDQUFDOzs7Ozs7O0FBT3pELFNBQVMsQ0FBQyxT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RyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNwQyxRQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7R0FDaEMsTUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRTs7QUFFN0MsUUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUU7QUFDakMsVUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQy9EO0FBQ0QsUUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO0dBQzNCO0NBQ0YsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQyIsImZpbGUiOiIvVXNlcnMvZGFyaW4vRGV2ZWxvcG1lbnQvbWFwc3Rvcnkvc3RvcnktdG9vbHMtdmlld2VyL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9pdGVtL1JhbmdlSXRlbS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBIYW1tZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9tb2R1bGUvaGFtbWVyJyk7XG52YXIgSXRlbSA9IHJlcXVpcmUoJy4vSXRlbScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBSYW5nZUl0ZW1cbiAqIEBleHRlbmRzIEl0ZW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgc3RhcnQsIGVuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCwgY2xhc3NOYW1lLlxuICogQHBhcmFtIHt7dG9TY3JlZW46IGZ1bmN0aW9uLCB0b1RpbWU6IGZ1bmN0aW9ufX0gY29udmVyc2lvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udmVyc2lvbiBmdW5jdGlvbnMgZnJvbSB0aW1lIHRvIHNjcmVlbiBhbmQgdmljZSB2ZXJzYVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZXNjcmliZSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFJhbmdlSXRlbSAoZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucykge1xuICB0aGlzLnByb3BzID0ge1xuICAgIGNvbnRlbnQ6IHtcbiAgICAgIHdpZHRoOiAwXG4gICAgfVxuICB9O1xuICB0aGlzLm92ZXJmbG93ID0gZmFsc2U7IC8vIGlmIGNvbnRlbnRzIGNhbiBvdmVyZmxvdyAoY3NzIHN0eWxpbmcpLCB0aGlzIGZsYWcgaXMgc2V0IHRvIHRydWVcblxuICAvLyB2YWxpZGF0ZSBkYXRhXG4gIGlmIChkYXRhKSB7XG4gICAgaWYgKGRhdGEuc3RhcnQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwic3RhcnRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIGRhdGEuaWQpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5lbmQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwiZW5kXCIgbWlzc2luZyBpbiBpdGVtICcgKyBkYXRhLmlkKTtcbiAgICB9XG4gIH1cblxuICBJdGVtLmNhbGwodGhpcywgZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucyk7XG59XG5cblJhbmdlSXRlbS5wcm90b3R5cGUgPSBuZXcgSXRlbSAobnVsbCwgbnVsbCwgbnVsbCk7XG5cblJhbmdlSXRlbS5wcm90b3R5cGUuYmFzZUNsYXNzTmFtZSA9ICd2aXMtaXRlbSB2aXMtcmFuZ2UnO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhpcyBpdGVtIGlzIHZpc2libGUgaW5zaWRlIGdpdmVuIHJhbmdlXG4gKiBAcmV0dXJucyB7e3N0YXJ0OiBOdW1iZXIsIGVuZDogTnVtYmVyfX0gcmFuZ2Ugd2l0aCBhIHRpbWVzdGFtcCBmb3Igc3RhcnQgYW5kIGVuZFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmlzaWJsZVxuICovXG5SYW5nZUl0ZW0ucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gIC8vIGRldGVybWluZSB2aXNpYmlsaXR5XG4gIHJldHVybiAodGhpcy5kYXRhLnN0YXJ0IDwgcmFuZ2UuZW5kKSAmJiAodGhpcy5kYXRhLmVuZCA+IHJhbmdlLnN0YXJ0KTtcbn07XG5cbi8qKlxuICogUmVwYWludCB0aGUgaXRlbVxuICovXG5SYW5nZUl0ZW0ucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZG9tID0gdGhpcy5kb207XG4gIGlmICghZG9tKSB7XG4gICAgLy8gY3JlYXRlIERPTVxuICAgIHRoaXMuZG9tID0ge307XG4gICAgZG9tID0gdGhpcy5kb207XG5cbiAgICAgIC8vIGJhY2tncm91bmQgYm94XG4gICAgZG9tLmJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIC8vIGNsYXNzTmFtZSBpcyB1cGRhdGVkIGluIHJlZHJhdygpXG5cbiAgICAvLyBmcmFtZSBib3ggKHRvIHByZXZlbnQgdGhlIGl0ZW0gY29udGVudHMgZnJvbSBvdmVyZmxvd2luZ1xuICAgIGRvbS5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvbS5mcmFtZS5jbGFzc05hbWUgPSAndmlzLWl0ZW0tb3ZlcmZsb3cnO1xuICAgIGRvbS5ib3guYXBwZW5kQ2hpbGQoZG9tLmZyYW1lKTtcblxuICAgIC8vIGNvbnRlbnRzIGJveFxuICAgIGRvbS5jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9tLmNvbnRlbnQuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLWNvbnRlbnQnO1xuICAgIGRvbS5mcmFtZS5hcHBlbmRDaGlsZChkb20uY29udGVudCk7XG5cbiAgICAvLyBhdHRhY2ggdGhpcyBpdGVtIGFzIGF0dHJpYnV0ZVxuICAgIGRvbS5ib3hbJ3RpbWVsaW5lLWl0ZW0nXSA9IHRoaXM7XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGFwcGVuZCBET00gdG8gcGFyZW50IERPTVxuICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IG5vIHBhcmVudCBhdHRhY2hlZCcpO1xuICB9XG4gIGlmICghZG9tLmJveC5wYXJlbnROb2RlKSB7XG4gICAgdmFyIGZvcmVncm91bmQgPSB0aGlzLnBhcmVudC5kb20uZm9yZWdyb3VuZDtcbiAgICBpZiAoIWZvcmVncm91bmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBwYXJlbnQgaGFzIG5vIGZvcmVncm91bmQgY29udGFpbmVyIGVsZW1lbnQnKTtcbiAgICB9XG4gICAgZm9yZWdyb3VuZC5hcHBlbmRDaGlsZChkb20uYm94KTtcbiAgfVxuICB0aGlzLmRpc3BsYXllZCA9IHRydWU7XG5cbiAgLy8gVXBkYXRlIERPTSB3aGVuIGl0ZW0gaXMgbWFya2VkIGRpcnR5LiBBbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eSB3aGVuOlxuICAvLyAtIHRoZSBpdGVtIGlzIG5vdCB5ZXQgcmVuZGVyZWRcbiAgLy8gLSB0aGUgaXRlbSdzIGRhdGEgaXMgY2hhbmdlZFxuICAvLyAtIHRoZSBpdGVtIGlzIHNlbGVjdGVkL2Rlc2VsZWN0ZWRcbiAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICB0aGlzLl91cGRhdGVDb250ZW50cyh0aGlzLmRvbS5jb250ZW50KTtcbiAgICB0aGlzLl91cGRhdGVUaXRsZSh0aGlzLmRvbS5ib3gpO1xuICAgIHRoaXMuX3VwZGF0ZURhdGFBdHRyaWJ1dGVzKHRoaXMuZG9tLmJveCk7XG4gICAgdGhpcy5fdXBkYXRlU3R5bGUodGhpcy5kb20uYm94KTtcblxuICAgIHZhciBlZGl0YWJsZSA9ICh0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSB8fCBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZUdyb3VwIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdGFibGUgPT09IHRydWUpICYmXG4gICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAvLyB1cGRhdGUgY2xhc3NcbiAgICB2YXIgY2xhc3NOYW1lID0gKHRoaXMuZGF0YS5jbGFzc05hbWUgPyAoJyAnICsgdGhpcy5kYXRhLmNsYXNzTmFtZSkgOiAnJykgK1xuICAgICAgICAodGhpcy5zZWxlY3RlZCA/ICcgdmlzLXNlbGVjdGVkJyA6ICcnKSArIFxuICAgICAgICAoZWRpdGFibGUgPyAnIHZpcy1lZGl0YWJsZScgOiAnIHZpcy1yZWFkb25seScpO1xuICAgIGRvbS5ib3guY2xhc3NOYW1lID0gdGhpcy5iYXNlQ2xhc3NOYW1lICsgY2xhc3NOYW1lO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGZyb20gY3NzIHdoZXRoZXIgdGhpcyBib3ggaGFzIG92ZXJmbG93XG4gICAgdGhpcy5vdmVyZmxvdyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbS5mcmFtZSkub3ZlcmZsb3cgIT09ICdoaWRkZW4nO1xuXG4gICAgLy8gcmVjYWxjdWxhdGUgc2l6ZVxuICAgIC8vIHR1cm4gb2ZmIG1heC13aWR0aCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSB0aGUgcmVhbCB3aWR0aFxuICAgIC8vIHRoaXMgY2F1c2VzIGFuIGV4dHJhIGJyb3dzZXIgcmVwYWludC9yZWZsb3csIGJ1dCBzbyBiZSBpdFxuICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUubWF4V2lkdGggPSAnbm9uZSc7XG4gICAgdGhpcy5wcm9wcy5jb250ZW50LndpZHRoID0gdGhpcy5kb20uY29udGVudC5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuZG9tLmJveC5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5tYXhXaWR0aCA9ICcnO1xuXG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9XG5cbiAgdGhpcy5fcmVwYWludERlbGV0ZUJ1dHRvbihkb20uYm94KTtcbiAgdGhpcy5fcmVwYWludERyYWdMZWZ0KCk7XG4gIHRoaXMuX3JlcGFpbnREcmFnUmlnaHQoKTtcbn07XG5cbi8qKlxuICogU2hvdyB0aGUgaXRlbSBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IHZpc2libGUpLiBUaGUgaXRlbXMgRE9NIHdpbGxcbiAqIGJlIGNyZWF0ZWQgd2hlbiBuZWVkZWQuXG4gKi9cblJhbmdlSXRlbS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZGlzcGxheWVkKSB7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBIaWRlIHRoZSBpdGVtIGZyb20gdGhlIERPTSAod2hlbiB2aXNpYmxlKVxuICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICovXG5SYW5nZUl0ZW0ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuZGlzcGxheWVkKSB7XG4gICAgdmFyIGJveCA9IHRoaXMuZG9tLmJveDtcblxuICAgIGlmIChib3gucGFyZW50Tm9kZSkge1xuICAgICAgYm94LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYm94KTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BsYXllZCA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gaG9yaXpvbnRhbGx5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtsaW1pdFNpemU9dHJ1ZV0gSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSB3aWR0aCBvZiB0aGUgcmFuZ2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtIHdpbGwgYmUgbGltaXRlZCwgYXMgdGhlIGJyb3dzZXIgY2Fubm90XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheSB2ZXJ5IHdpZGUgZGl2cy4gVGhpcyBtZWFucyB0aG91Z2hcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0IHRoZSBhcHBsaWVkIGxlZnQgYW5kIHdpZHRoIG1heVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBjb3JyZXNwb25kIHRvIHRoZSByYW5nZXMgc3RhcnQgYW5kIGVuZFxuICogQE92ZXJyaWRlXG4gKi9cblJhbmdlSXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblggPSBmdW5jdGlvbihsaW1pdFNpemUpIHtcbiAgdmFyIHBhcmVudFdpZHRoID0gdGhpcy5wYXJlbnQud2lkdGg7XG4gIHZhciBzdGFydCA9IHRoaXMuY29udmVyc2lvbi50b1NjcmVlbih0aGlzLmRhdGEuc3RhcnQpO1xuICB2YXIgZW5kID0gdGhpcy5jb252ZXJzaW9uLnRvU2NyZWVuKHRoaXMuZGF0YS5lbmQpO1xuICB2YXIgY29udGVudExlZnQ7XG4gIHZhciBjb250ZW50V2lkdGg7XG5cbiAgLy8gbGltaXQgdGhlIHdpZHRoIG9mIHRoZSByYW5nZSwgYXMgYnJvd3NlcnMgY2Fubm90IGRyYXcgdmVyeSB3aWRlIGRpdnNcbiAgaWYgKGxpbWl0U2l6ZSA9PT0gdW5kZWZpbmVkIHx8IGxpbWl0U2l6ZSA9PT0gdHJ1ZSkge1xuICAgIGlmIChzdGFydCA8IC1wYXJlbnRXaWR0aCkge1xuICAgICAgc3RhcnQgPSAtcGFyZW50V2lkdGg7XG4gICAgfVxuICAgIGlmIChlbmQgPiAyICogcGFyZW50V2lkdGgpIHtcbiAgICAgIGVuZCA9IDIgKiBwYXJlbnRXaWR0aDtcbiAgICB9XG4gIH1cbiAgdmFyIGJveFdpZHRoID0gTWF0aC5tYXgoZW5kIC0gc3RhcnQsIDEpO1xuXG4gIGlmICh0aGlzLm92ZXJmbG93KSB7XG4gICAgdGhpcy5sZWZ0ID0gc3RhcnQ7XG4gICAgdGhpcy53aWR0aCA9IGJveFdpZHRoICsgdGhpcy5wcm9wcy5jb250ZW50LndpZHRoO1xuICAgIGNvbnRlbnRXaWR0aCA9IHRoaXMucHJvcHMuY29udGVudC53aWR0aDtcblxuICAgIC8vIE5vdGU6IFRoZSBjYWxjdWxhdGlvbiBvZiB3aWR0aCBpcyBhbiBvcHRpbWlzdGljIGNhbGN1bGF0aW9uLCBnaXZpbmdcbiAgICAvLyAgICAgICBhIHdpZHRoIHdoaWNoIHdpbGwgbm90IGNoYW5nZSB3aGVuIG1vdmluZyB0aGUgVGltZWxpbmVcbiAgICAvLyAgICAgICBTbyBubyByZS1zdGFja2luZyBuZWVkZWQsIHdoaWNoIGlzIG5pY2VyIGZvciB0aGUgZXllO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMubGVmdCA9IHN0YXJ0O1xuICAgIHRoaXMud2lkdGggPSBib3hXaWR0aDtcbiAgICBjb250ZW50V2lkdGggPSBNYXRoLm1pbihlbmQgLSBzdGFydCwgdGhpcy5wcm9wcy5jb250ZW50LndpZHRoKTtcbiAgfVxuXG4gIHRoaXMuZG9tLmJveC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgJ3B4JztcbiAgdGhpcy5kb20uYm94LnN0eWxlLndpZHRoID0gYm94V2lkdGggKyAncHgnO1xuXG4gIHN3aXRjaCAodGhpcy5vcHRpb25zLmFsaWduKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUubGVmdCA9IE1hdGgubWF4KChib3hXaWR0aCAtIGNvbnRlbnRXaWR0aCksIDApICsgJ3B4JztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUubGVmdCA9IE1hdGgubWF4KChib3hXaWR0aCAtIGNvbnRlbnRXaWR0aCkgLyAyLCAwKSArICdweCc7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6IC8vICdhdXRvJ1xuICAgICAgLy8gd2hlbiByYW5nZSBleGNlZWRzIGxlZnQgb2YgdGhlIHdpbmRvdywgcG9zaXRpb24gdGhlIGNvbnRlbnRzIGF0IHRoZSBsZWZ0IG9mIHRoZSB2aXNpYmxlIGFyZWFcbiAgICAgIGlmICh0aGlzLm92ZXJmbG93KSB7XG4gICAgICAgIGlmIChlbmQgPiAwKSB7XG4gICAgICAgICAgY29udGVudExlZnQgPSBNYXRoLm1heCgtc3RhcnQsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnRlbnRMZWZ0ID0gLWNvbnRlbnRXaWR0aDsgLy8gZW5zdXJlIGl0J3Mgbm90IHZpc2libGUgYW55bW9yZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgIGNvbnRlbnRMZWZ0ID0gLXN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnRlbnRMZWZ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5sZWZ0ID0gY29udGVudExlZnQgKyAncHgnO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gdmVydGljYWxseVxuICogQE92ZXJyaWRlXG4gKi9cblJhbmdlSXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG9yaWVudGF0aW9uID0gdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW07XG4gIHZhciBib3ggPSB0aGlzLmRvbS5ib3g7XG5cbiAgaWYgKG9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgYm94LnN0eWxlLnRvcCA9IHRoaXMudG9wICsgJ3B4JztcbiAgfVxuICBlbHNlIHtcbiAgICBib3guc3R5bGUudG9wID0gKHRoaXMucGFyZW50LmhlaWdodCAtIHRoaXMudG9wIC0gdGhpcy5oZWlnaHQpICsgJ3B4JztcbiAgfVxufTtcblxuLyoqXG4gKiBSZXBhaW50IGEgZHJhZyBhcmVhIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHJhbmdlIHdoZW4gdGhlIHJhbmdlIGlzIHNlbGVjdGVkXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJhbmdlSXRlbS5wcm90b3R5cGUuX3JlcGFpbnREcmFnTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2VsZWN0ZWQgJiYgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgJiYgIXRoaXMuZG9tLmRyYWdMZWZ0KSB7XG4gICAgLy8gY3JlYXRlIGFuZCBzaG93IGRyYWcgYXJlYVxuICAgIHZhciBkcmFnTGVmdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRyYWdMZWZ0LmNsYXNzTmFtZSA9ICd2aXMtZHJhZy1sZWZ0JztcbiAgICBkcmFnTGVmdC5kcmFnTGVmdEl0ZW0gPSB0aGlzO1xuXG4gICAgdGhpcy5kb20uYm94LmFwcGVuZENoaWxkKGRyYWdMZWZ0KTtcbiAgICB0aGlzLmRvbS5kcmFnTGVmdCA9IGRyYWdMZWZ0O1xuICB9XG4gIGVsc2UgaWYgKCF0aGlzLnNlbGVjdGVkICYmIHRoaXMuZG9tLmRyYWdMZWZ0KSB7XG4gICAgLy8gZGVsZXRlIGRyYWcgYXJlYVxuICAgIGlmICh0aGlzLmRvbS5kcmFnTGVmdC5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmRvbS5kcmFnTGVmdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmRyYWdMZWZ0KTtcbiAgICB9XG4gICAgdGhpcy5kb20uZHJhZ0xlZnQgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgYSBkcmFnIGFyZWEgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHJhbmdlIHdoZW4gdGhlIHJhbmdlIGlzIHNlbGVjdGVkXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJhbmdlSXRlbS5wcm90b3R5cGUuX3JlcGFpbnREcmFnUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNlbGVjdGVkICYmIHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lICYmICF0aGlzLmRvbS5kcmFnUmlnaHQpIHtcbiAgICAvLyBjcmVhdGUgYW5kIHNob3cgZHJhZyBhcmVhXG4gICAgdmFyIGRyYWdSaWdodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRyYWdSaWdodC5jbGFzc05hbWUgPSAndmlzLWRyYWctcmlnaHQnO1xuICAgIGRyYWdSaWdodC5kcmFnUmlnaHRJdGVtID0gdGhpcztcblxuICAgIHRoaXMuZG9tLmJveC5hcHBlbmRDaGlsZChkcmFnUmlnaHQpO1xuICAgIHRoaXMuZG9tLmRyYWdSaWdodCA9IGRyYWdSaWdodDtcbiAgfVxuICBlbHNlIGlmICghdGhpcy5zZWxlY3RlZCAmJiB0aGlzLmRvbS5kcmFnUmlnaHQpIHtcbiAgICAvLyBkZWxldGUgZHJhZyBhcmVhXG4gICAgaWYgKHRoaXMuZG9tLmRyYWdSaWdodC5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmRvbS5kcmFnUmlnaHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5kcmFnUmlnaHQpO1xuICAgIH1cbiAgICB0aGlzLmRvbS5kcmFnUmlnaHQgPSBudWxsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlSXRlbTtcbiJdfQ==
},{"../../../module/hammer":19,"./Item":41}],44:[function(require,module,exports){
// English
'use strict';

exports['en'] = {
  current: 'current',
  time: 'time'
};
exports['en_EN'] = exports['en'];
exports['en_US'] = exports['en'];

// Dutch
exports['nl'] = {
  current: 'huidige',
  time: 'tijd'
};
exports['nl_NL'] = exports['nl'];
exports['nl_BE'] = exports['nl'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvbG9jYWxlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUc7QUFDZCxTQUFPLEVBQUUsU0FBUztBQUNsQixNQUFJLEVBQUUsTUFBTTtDQUNiLENBQUM7QUFDRixPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7OztBQUdqQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUc7QUFDZCxTQUFPLEVBQUUsU0FBUztBQUNsQixNQUFJLEVBQUUsTUFBTTtDQUNiLENBQUM7QUFDRixPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMiLCJmaWxlIjoiL1VzZXJzL2RhcmluL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzLXZpZXdlci9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9sb2NhbGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gRW5nbGlzaFxuZXhwb3J0c1snZW4nXSA9IHtcbiAgY3VycmVudDogJ2N1cnJlbnQnLFxuICB0aW1lOiAndGltZSdcbn07XG5leHBvcnRzWydlbl9FTiddID0gZXhwb3J0c1snZW4nXTtcbmV4cG9ydHNbJ2VuX1VTJ10gPSBleHBvcnRzWydlbiddO1xuXG4vLyBEdXRjaFxuZXhwb3J0c1snbmwnXSA9IHtcbiAgY3VycmVudDogJ2h1aWRpZ2UnLFxuICB0aW1lOiAndGlqZCdcbn07XG5leHBvcnRzWydubF9OTCddID0gZXhwb3J0c1snbmwnXTtcbmV4cG9ydHNbJ25sX0JFJ10gPSBleHBvcnRzWydubCddO1xuIl19
},{}],45:[function(require,module,exports){
/**
 * This object contains all possible options. It will check if the types are correct, if required if the option is one
 * of the allowed values.
 *
 * __any__ means that the name of the property does not matter.
 * __type__ is a required field for all objects and contains the allowed types of all objects
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var string = 'string';
var boolean = 'boolean';
var number = 'number';
var array = 'array';
var date = 'date';
var object = 'object'; // should only be in a __type__ property
var dom = 'dom';
var moment = 'moment';
var any = 'any';

var allOptions = {
  configure: {
    enabled: { boolean: boolean },
    filter: { boolean: boolean, 'function': 'function' },
    container: { dom: dom },
    __type__: { object: object, boolean: boolean, 'function': 'function' }
  },

  //globals :
  align: { string: string },
  autoResize: { boolean: boolean },
  throttleRedraw: { number: number },
  clickToUse: { boolean: boolean },
  dataAttributes: { string: string, array: array },
  editable: {
    add: { boolean: boolean, 'undefined': 'undefined' },
    remove: { boolean: boolean, 'undefined': 'undefined' },
    updateGroup: { boolean: boolean, 'undefined': 'undefined' },
    updateTime: { boolean: boolean, 'undefined': 'undefined' },
    __type__: { boolean: boolean, object: object }
  },
  end: { number: number, date: date, string: string, moment: moment },
  format: {
    minorLabels: {
      millisecond: { string: string, 'undefined': 'undefined' },
      second: { string: string, 'undefined': 'undefined' },
      minute: { string: string, 'undefined': 'undefined' },
      hour: { string: string, 'undefined': 'undefined' },
      weekday: { string: string, 'undefined': 'undefined' },
      day: { string: string, 'undefined': 'undefined' },
      month: { string: string, 'undefined': 'undefined' },
      year: { string: string, 'undefined': 'undefined' },
      __type__: { object: object }
    },
    majorLabels: {
      millisecond: { string: string, 'undefined': 'undefined' },
      second: { string: string, 'undefined': 'undefined' },
      minute: { string: string, 'undefined': 'undefined' },
      hour: { string: string, 'undefined': 'undefined' },
      weekday: { string: string, 'undefined': 'undefined' },
      day: { string: string, 'undefined': 'undefined' },
      month: { string: string, 'undefined': 'undefined' },
      year: { string: string, 'undefined': 'undefined' },
      __type__: { object: object }
    },
    __type__: { object: object }
  },
  moment: { 'function': 'function' },
  groupOrder: { string: string, 'function': 'function' },
  groupEditable: {
    add: { boolean: boolean, 'undefined': 'undefined' },
    remove: { boolean: boolean, 'undefined': 'undefined' },
    order: { boolean: boolean, 'undefined': 'undefined' },
    __type__: { boolean: boolean, object: object }
  },
  groupOrderSwap: { 'function': 'function' },
  height: { string: string, number: number },
  hiddenDates: {
    start: { date: date, number: number, string: string, moment: moment },
    end: { date: date, number: number, string: string, moment: moment },
    repeat: { string: string },
    __type__: { object: object, array: array }
  },
  locale: { string: string },
  locales: {
    __type__: { object: object }
  },
  margin: {
    axis: { number: number },
    item: {
      horizontal: { number: number, 'undefined': 'undefined' },
      vertical: { number: number, 'undefined': 'undefined' },
      __type__: { object: object, number: number }
    },
    __type__: { object: object, number: number }
  },
  max: { date: date, number: number, string: string, moment: moment },
  maxHeight: { number: number, string: string },
  min: { date: date, number: number, string: string, moment: moment },
  minHeight: { number: number, string: string },
  moveable: { boolean: boolean },
  multiselect: { boolean: boolean },
  onAdd: { 'function': 'function' },
  onUpdate: { 'function': 'function' },
  onMove: { 'function': 'function' },
  onMoving: { 'function': 'function' },
  onRemove: { 'function': 'function' },
  onAddGroup: { 'function': 'function' },
  onMoveGroup: { 'function': 'function' },
  onRemoveGroup: { 'function': 'function' },
  order: { 'function': 'function' },
  orientation: {
    axis: { string: string, 'undefined': 'undefined' },
    item: { string: string, 'undefined': 'undefined' },
    __type__: { string: string, object: object }
  },
  selectable: { boolean: boolean },
  showCurrentTime: { boolean: boolean },
  showMajorLabels: { boolean: boolean },
  showMinorLabels: { boolean: boolean },
  stack: { boolean: boolean },
  snap: { 'function': 'function', 'null': 'null' },
  start: { date: date, number: number, string: string, moment: moment },
  template: { 'function': 'function' },
  groupTemplate: { 'function': 'function' },
  timeAxis: {
    scale: { string: string, 'undefined': 'undefined' },
    step: { number: number, 'undefined': 'undefined' },
    __type__: { object: object }
  },
  type: { string: string },
  width: { string: string, number: number },
  zoomable: { boolean: boolean },
  zoomKey: { string: ['ctrlKey', 'altKey', 'metaKey', ''] },
  zoomMax: { number: number },
  zoomMin: { number: number },

  __type__: { object: object }
};

var configureOptions = {
  global: {
    align: ['center', 'left', 'right'],
    autoResize: true,
    throttleRedraw: [10, 0, 1000, 10],
    clickToUse: false,
    // dataAttributes: ['all'], // FIXME: can be 'all' or string[]
    editable: {
      add: false,
      remove: false,
      updateGroup: false,
      updateTime: false
    },
    end: '',
    format: {
      minorLabels: {
        millisecond: 'SSS',
        second: 's',
        minute: 'HH:mm',
        hour: 'HH:mm',
        weekday: 'ddd D',
        day: 'D',
        month: 'MMM',
        year: 'YYYY'
      },
      majorLabels: {
        millisecond: 'HH:mm:ss',
        second: 'D MMMM HH:mm',
        minute: 'ddd D MMMM',
        hour: 'ddd D MMMM',
        weekday: 'MMMM YYYY',
        day: 'MMMM YYYY',
        month: 'YYYY',
        year: ''
      }
    },

    //groupOrder: {string, 'function': 'function'},
    groupsDraggable: false,
    height: '',
    //hiddenDates: {object, array},
    locale: '',
    margin: {
      axis: [20, 0, 100, 1],
      item: {
        horizontal: [10, 0, 100, 1],
        vertical: [10, 0, 100, 1]
      }
    },
    max: '',
    maxHeight: '',
    min: '',
    minHeight: '',
    moveable: false,
    multiselect: false,
    //onAdd: {'function': 'function'},
    //onUpdate: {'function': 'function'},
    //onMove: {'function': 'function'},
    //onMoving: {'function': 'function'},
    //onRename: {'function': 'function'},
    //order: {'function': 'function'},
    orientation: {
      axis: ['both', 'bottom', 'top'],
      item: ['bottom', 'top']
    },
    selectable: true,
    showCurrentTime: false,
    showMajorLabels: true,
    showMinorLabels: true,
    stack: true,
    //snap: {'function': 'function', nada},
    start: '',
    //template: {'function': 'function'},
    //timeAxis: {
    //  scale: ['millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'month', 'year'],
    //  step: [1, 1, 10, 1]
    //},
    type: ['box', 'point', 'range', 'background'],
    width: '100%',
    zoomable: true,
    zoomKey: ['ctrlKey', 'altKey', 'metaKey', ''],
    zoomMax: [315360000000000, 10, 315360000000000, 1],
    zoomMin: [10, 10, 315360000000000, 1]
  }
};

exports.allOptions = allOptions;
exports.configureOptions = configureOptions;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvb3B0aW9uc1RpbWVsaW5lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQU9BLElBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQztBQUN0QixJQUFJLE9BQU8sR0FBRyxTQUFTLENBQUM7QUFDeEIsSUFBSSxNQUFNLEdBQUcsUUFBUSxDQUFDO0FBQ3RCLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQztBQUNwQixJQUFJLElBQUksR0FBRyxNQUFNLENBQUM7QUFDbEIsSUFBSSxNQUFNLEdBQUcsUUFBUSxDQUFDO0FBQ3RCLElBQUksR0FBRyxHQUFHLEtBQUssQ0FBQztBQUNoQixJQUFJLE1BQU0sR0FBRyxRQUFRLENBQUM7QUFDdEIsSUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDOztBQUdoQixJQUFJLFVBQVUsR0FBRztBQUNmLFdBQVMsRUFBRTtBQUNULFdBQU8sRUFBRSxFQUFDLE9BQU8sRUFBUCxPQUFPLEVBQUM7QUFDbEIsVUFBTSxFQUFFLEVBQUMsT0FBTyxFQUFQLE9BQU8sRUFBQyxVQUFVLEVBQUUsVUFBVSxFQUFDO0FBQ3hDLGFBQVMsRUFBRSxFQUFDLEdBQUcsRUFBSCxHQUFHLEVBQUM7QUFDaEIsWUFBUSxFQUFFLEVBQUMsTUFBTSxFQUFOLE1BQU0sRUFBQyxPQUFPLEVBQVAsT0FBTyxFQUFDLFVBQVUsRUFBRSxVQUFVLEVBQUM7R0FDbEQ7OztBQUdELE9BQUssRUFBRSxFQUFDLE1BQU0sRUFBTixNQUFNLEVBQUM7QUFDZixZQUFVLEVBQUUsRUFBQyxPQUFPLEVBQVAsT0FBTyxFQUFDO0FBQ3JCLGdCQUFjLEVBQUUsRUFBQyxNQUFNLEVBQU4sTUFBTSxFQUFDO0FBQ3hCLFlBQVUsRUFBRSxFQUFDLE9BQU8sRUFBUCxPQUFPLEVBQUM7QUFDckIsZ0JBQWMsRUFBRSxFQUFDLE1BQU0s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LEVBQUUsQ0FBQyxTQUFTLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxFQUFFLENBQUM7QUFDN0MsV0FBTyxFQUFFLENBQUMsZUFBZSxFQUFFLEVBQUUsRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDO0FBQ2xELFdBQU8sRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsZUFBZSxFQUFFLENBQUMsQ0FBQztHQUN0QztDQUNGLENBQUM7O1FBRU0sVUFBVSxHQUFWLFVBQVU7UUFBRSxnQkFBZ0IsR0FBaEIsZ0JBQWdCIiwiZmlsZSI6Ii9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvb3B0aW9uc1RpbWVsaW5lLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIG9iamVjdCBjb250YWlucyBhbGwgcG9zc2libGUgb3B0aW9ucy4gSXQgd2lsbCBjaGVjayBpZiB0aGUgdHlwZXMgYXJlIGNvcnJlY3QsIGlmIHJlcXVpcmVkIGlmIHRoZSBvcHRpb24gaXMgb25lXG4gKiBvZiB0aGUgYWxsb3dlZCB2YWx1ZXMuXG4gKlxuICogX19hbnlfXyBtZWFucyB0aGF0IHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBkb2VzIG5vdCBtYXR0ZXIuXG4gKiBfX3R5cGVfXyBpcyBhIHJlcXVpcmVkIGZpZWxkIGZvciBhbGwgb2JqZWN0cyBhbmQgY29udGFpbnMgdGhlIGFsbG93ZWQgdHlwZXMgb2YgYWxsIG9iamVjdHNcbiAqL1xubGV0IHN0cmluZyA9ICdzdHJpbmcnO1xubGV0IGJvb2xlYW4gPSAnYm9vbGVhbic7XG5sZXQgbnVtYmVyID0gJ251bWJlcic7XG5sZXQgYXJyYXkgPSAnYXJyYXknO1xubGV0IGRhdGUgPSAnZGF0ZSc7XG5sZXQgb2JqZWN0ID0gJ29iamVjdCc7IC8vIHNob3VsZCBvbmx5IGJlIGluIGEgX190eXBlX18gcHJvcGVydHlcbmxldCBkb20gPSAnZG9tJztcbmxldCBtb21lbnQgPSAnbW9tZW50JztcbmxldCBhbnkgPSAnYW55JztcblxuXG5sZXQgYWxsT3B0aW9ucyA9IHtcbiAgY29uZmlndXJlOiB7XG4gICAgZW5hYmxlZDoge2Jvb2xlYW59LFxuICAgIGZpbHRlcjoge2Jvb2xlYW4sJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgY29udGFpbmVyOiB7ZG9tfSxcbiAgICBfX3R5cGVfXzoge29iamVjdCxib29sZWFuLCdmdW5jdGlvbic6ICdmdW5jdGlvbid9XG4gIH0sXG5cbiAgLy9nbG9iYWxzIDpcbiAgYWxpZ246IHtzdHJpbmd9LFxuICBhdXRvUmVzaXplOiB7Ym9vbGVhbn0sXG4gIHRocm90dGxlUmVkcmF3OiB7bnVtYmVyfSxcbiAgY2xpY2tUb1VzZToge2Jvb2xlYW59LFxuICBkYXRhQXR0cmlidXRlczoge3N0cmluZywgYXJyYXl9LFxuICBlZGl0YWJsZToge1xuICAgIGFkZDoge2Jvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgcmVtb3ZlOiB7Ym9vbGVhbiwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICB1cGRhdGVHcm91cDoge2Jvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgdXBkYXRlVGltZToge2Jvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgX190eXBlX186IHtib29sZWFuLCBvYmplY3R9XG4gIH0sXG4gIGVuZDoge251bWJlciwgZGF0ZSwgc3RyaW5nLCBtb21lbnR9LFxuICBmb3JtYXQ6IHtcbiAgICBtaW5vckxhYmVsczoge1xuICAgICAgbWlsbGlzZWNvbmQ6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIHNlY29uZDoge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgbWludXRlOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBob3VyOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICB3ZWVrZGF5OiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBkYXk6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIG1vbnRoOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICB5ZWFyOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBfX3R5cGVfXzoge29iamVjdH1cbiAgICB9LFxuICAgIG1ham9yTGFiZWxzOiB7XG4gICAgICBtaWxsaXNlY29uZDoge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgc2Vjb25kOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBtaW51dGU6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIGhvdXI6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIHdlZWtkYXk6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIGRheToge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgbW9udGg6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIHllYXI6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIF9fdHlwZV9fOiB7b2JqZWN0fVxuICAgIH0sXG4gICAgX190eXBlX186IHtvYmplY3R9XG4gIH0sXG4gIG1vbWVudDogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICBncm91cE9yZGVyOiB7c3RyaW5nLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgZ3JvdXBFZGl0YWJsZToge1xuXHQgYWRkOiB7Ym9vbGVhbiwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcblx0IHJlbW92ZToge2Jvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG5cdCBvcmRlcjoge2Jvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG5cdCBfX3R5cGVfXzoge2Jvb2xlYW4sIG9iamVjdH1cbiAgfSxcbiAgZ3JvdXBPcmRlclN3YXA6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgaGVpZ2h0OiB7c3RyaW5nLCBudW1iZXJ9LFxuICBoaWRkZW5EYXRlczoge1xuICAgIHN0YXJ0OiB7ZGF0ZSwgbnVtYmVyLCBzdHJpbmcsIG1vbWVudH0sXG4gICAgZW5kOiB7ZGF0ZSwgbnVtYmVyLCBzdHJpbmcsIG1vbWVudH0sXG4gICAgcmVwZWF0OiB7c3RyaW5nfSxcbiAgICBfX3R5cGVfXzoge29iamVjdCwgYXJyYXl9XG4gIH0sXG4gIGxvY2FsZTp7c3RyaW5nfSxcbiAgbG9jYWxlczp7XG4gICAgX190eXBlX186IHtvYmplY3R9XG4gIH0sXG4gIG1hcmdpbjoge1xuICAgIGF4aXM6IHtudW1iZXJ9LFxuICAgIGl0ZW06IHtcbiAgICAgIGhvcml6b250YWw6IHtudW1iZXIsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIHZlcnRpY2FsOiB7bnVtYmVyLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBfX3R5cGVfXzoge29iamVjdCxudW1iZXJ9XG4gICAgfSxcbiAgICBfX3R5cGVfXzoge29iamVjdCxudW1iZXJ9XG4gIH0sXG4gIG1heDoge2RhdGUsIG51bWJlciwgc3RyaW5nLCBtb21lbnR9LFxuICBtYXhIZWlnaHQ6IHtudW1iZXIsIHN0cmluZ30sXG4gIG1pbjoge2RhdGUsIG51bWJlciwgc3RyaW5nLCBtb21lbnR9LFxuICBtaW5IZWlnaHQ6IHtudW1iZXIsIHN0cmluZ30sXG4gIG1vdmVhYmxlOiB7Ym9vbGVhbn0sXG4gIG11bHRpc2VsZWN0OiB7Ym9vbGVhbn0sXG4gIG9uQWRkOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIG9uVXBkYXRlOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIG9uTW92ZTogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICBvbk1vdmluZzogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICBvblJlbW92ZTogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICBvbkFkZEdyb3VwOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIG9uTW92ZUdyb3VwOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIG9uUmVtb3ZlR3JvdXA6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgb3JkZXI6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgb3JpZW50YXRpb246IHtcbiAgICBheGlzOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgaXRlbToge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgIF9fdHlwZV9fOiB7c3RyaW5nLCBvYmplY3R9XG4gIH0sXG4gIHNlbGVjdGFibGU6IHtib29sZWFufSxcbiAgc2hvd0N1cnJlbnRUaW1lOiB7Ym9vbGVhbn0sXG4gIHNob3dNYWpvckxhYmVsczoge2Jvb2xlYW59LFxuICBzaG93TWlub3JMYWJlbHM6IHtib29sZWFufSxcbiAgc3RhY2s6IHtib29sZWFufSxcbiAgc25hcDogeydmdW5jdGlvbic6ICdmdW5jdGlvbicsICdudWxsJzogJ251bGwnfSxcbiAgc3RhcnQ6IHtkYXRlLCBudW1iZXIsIHN0cmluZywgbW9tZW50fSxcbiAgdGVtcGxhdGU6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgZ3JvdXBUZW1wbGF0ZTogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICB0aW1lQXhpczoge1xuICAgIHNjYWxlOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgc3RlcDoge251bWJlciwndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgIF9fdHlwZV9fOiB7b2JqZWN0fVxuICB9LFxuICB0eXBlOiB7c3RyaW5nfSxcbiAgd2lkdGg6IHtzdHJpbmcsIG51bWJlcn0sXG4gIHpvb21hYmxlOiB7Ym9vbGVhbn0sXG4gIHpvb21LZXk6IHtzdHJpbmc6IFsnY3RybEtleScsICdhbHRLZXknLCAnbWV0YUtleScsICcnXX0sXG4gIHpvb21NYXg6IHtudW1iZXJ9LFxuICB6b29tTWluOiB7bnVtYmVyfSxcblxuICBfX3R5cGVfXzoge29iamVjdH1cbn07XG5cbmxldCBjb25maWd1cmVPcHRpb25zID0ge1xuICBnbG9iYWw6IHtcbiAgICBhbGlnbjogIFsnY2VudGVyJywgJ2xlZnQnLCAncmlnaHQnXSxcbiAgICBhdXRvUmVzaXplOiB0cnVlLFxuICAgIHRocm90dGxlUmVkcmF3OiBbMTAsIDAsIDEwMDAsIDEwXSxcbiAgICBjbGlja1RvVXNlOiBmYWxzZSxcbiAgICAvLyBkYXRhQXR0cmlidXRlczogWydhbGwnXSwgLy8gRklYTUU6IGNhbiBiZSAnYWxsJyBvciBzdHJpbmdbXVxuICAgIGVkaXRhYmxlOiB7XG4gICAgICBhZGQ6IGZhbHNlLFxuICAgICAgcmVtb3ZlOiBmYWxzZSxcbiAgICAgIHVwZGF0ZUdyb3VwOiBmYWxzZSxcbiAgICAgIHVwZGF0ZVRpbWU6IGZhbHNlXG4gICAgfSxcbiAgICBlbmQ6ICcnLFxuICAgIGZvcm1hdDoge1xuICAgICAgbWlub3JMYWJlbHM6IHtcbiAgICAgICAgbWlsbGlzZWNvbmQ6J1NTUycsXG4gICAgICAgIHNlY29uZDogICAgICdzJyxcbiAgICAgICAgbWludXRlOiAgICAgJ0hIOm1tJyxcbiAgICAgICAgaG91cjogICAgICAgJ0hIOm1tJyxcbiAgICAgICAgd2Vla2RheTogICAgJ2RkZCBEJyxcbiAgICAgICAgZGF5OiAgICAgICAgJ0QnLFxuICAgICAgICBtb250aDogICAgICAnTU1NJyxcbiAgICAgICAgeWVhcjogICAgICAgJ1lZWVknXG4gICAgICB9LFxuICAgICAgbWFqb3JMYWJlbHM6IHtcbiAgICAgICAgbWlsbGlzZWNvbmQ6J0hIOm1tOnNzJyxcbiAgICAgICAgc2Vjb25kOiAgICAgJ0QgTU1NTSBISDptbScsXG4gICAgICAgIG1pbnV0ZTogICAgICdkZGQgRCBNTU1NJyxcbiAgICAgICAgaG91cjogICAgICAgJ2RkZCBEIE1NTU0nLFxuICAgICAgICB3ZWVrZGF5OiAgICAnTU1NTSBZWVlZJyxcbiAgICAgICAgZGF5OiAgICAgICAgJ01NTU0gWVlZWScsXG4gICAgICAgIG1vbnRoOiAgICAgICdZWVlZJyxcbiAgICAgICAgeWVhcjogICAgICAgJydcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy9ncm91cE9yZGVyOiB7c3RyaW5nLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICBncm91cHNEcmFnZ2FibGU6IGZhbHNlLFxuICAgIGhlaWdodDogJycsXG4gICAgLy9oaWRkZW5EYXRlczoge29iamVjdCwgYXJyYXl9LFxuICAgIGxvY2FsZTogJycsXG4gICAgbWFyZ2luOiB7XG4gICAgICBheGlzOiBbMjAsIDAsIDEwMCwgMV0sXG4gICAgICBpdGVtOiB7XG4gICAgICAgIGhvcml6b250YWw6IFsxMCwgMCwgMTAwLCAxXSxcbiAgICAgICAgdmVydGljYWw6IFsxMCwgMCwgMTAwLCAxXVxuICAgICAgfVxuICAgIH0sXG4gICAgbWF4OiAnJyxcbiAgICBtYXhIZWlnaHQ6ICcnLFxuICAgIG1pbjogJycsXG4gICAgbWluSGVpZ2h0OiAnJyxcbiAgICBtb3ZlYWJsZTogZmFsc2UsXG4gICAgbXVsdGlzZWxlY3Q6IGZhbHNlLFxuICAgIC8vb25BZGQ6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAvL29uVXBkYXRlOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgLy9vbk1vdmU6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAvL29uTW92aW5nOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgLy9vblJlbmFtZTogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICAgIC8vb3JkZXI6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICBvcmllbnRhdGlvbjoge1xuICAgICAgYXhpczogWydib3RoJywgJ2JvdHRvbScsICd0b3AnXSxcbiAgICAgIGl0ZW06IFsnYm90dG9tJywgJ3RvcCddXG4gICAgfSxcbiAgICBzZWxlY3RhYmxlOiB0cnVlLFxuICAgIHNob3dDdXJyZW50VGltZTogZmFsc2UsXG4gICAgc2hvd01ham9yTGFiZWxzOiB0cnVlLFxuICAgIHNob3dNaW5vckxhYmVsczogdHJ1ZSxcbiAgICBzdGFjazogdHJ1ZSxcbiAgICAvL3NuYXA6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nLCBuYWRhfSxcbiAgICBzdGFydDogJycsXG4gICAgLy90ZW1wbGF0ZTogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICAgIC8vdGltZUF4aXM6IHtcbiAgICAvLyAgc2NhbGU6IFsnbWlsbGlzZWNvbmQnLCAnc2Vjb25kJywgJ21pbnV0ZScsICdob3VyJywgJ3dlZWtkYXknLCAnZGF5JywgJ21vbnRoJywgJ3llYXInXSxcbiAgICAvLyAgc3RlcDogWzEsIDEsIDEwLCAxXVxuICAgIC8vfSxcbiAgICB0eXBlOiBbJ2JveCcsICdwb2ludCcsICdyYW5nZScsICdiYWNrZ3JvdW5kJ10sXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICB6b29tYWJsZTogdHJ1ZSxcbiAgICB6b29tS2V5OiBbJ2N0cmxLZXknLCAnYWx0S2V5JywgJ21ldGFLZXknLCAnJ10sXG4gICAgem9vbU1heDogWzMxNTM2MDAwMDAwMDAwMCwgMTAsIDMxNTM2MDAwMDAwMDAwMCwgMV0sXG4gICAgem9vbU1pbjogWzEwLCAxMCwgMzE1MzYwMDAwMDAwMDAwLCAxXVxuICB9XG59O1xuXG5leHBvcnQge2FsbE9wdGlvbnMsIGNvbmZpZ3VyZU9wdGlvbnN9OyJdfQ==
},{}],46:[function(require,module,exports){
// utility functions

// first check if moment.js is already loaded in the browser window, if so,
// use this instance. Else, load via commonjs.

'use strict';

var moment = require('./module/moment');
var uuid = require('./module/uuid');

/**
 * Test whether given object is a number
 * @param {*} object
 * @return {Boolean} isNumber
 */
exports.isNumber = function (object) {
  return object instanceof Number || typeof object == 'number';
};

/**
 * Remove everything in the DOM object
 * @param DOMobject
 */
exports.recursiveDOMDelete = function (DOMobject) {
  if (DOMobject) {
    while (DOMobject.hasChildNodes() === true) {
      exports.recursiveDOMDelete(DOMobject.firstChild);
      DOMobject.removeChild(DOMobject.firstChild);
    }
  }
};

/**
 * this function gives you a range between 0 and 1 based on the min and max values in the set, the total sum of all values and the current value.
 *
 * @param min
 * @param max
 * @param total
 * @param value
 * @returns {number}
 */
exports.giveRange = function (min, max, total, value) {
  if (max == min) {
    return 0.5;
  } else {
    var scale = 1 / (max - min);
    return Math.max(0, (value - min) * scale);
  }
};

/**
 * Test whether given object is a string
 * @param {*} object
 * @return {Boolean} isString
 */
exports.isString = function (object) {
  return object instanceof String || typeof object == 'string';
};

/**
 * Test whether given object is a Date, or a String containing a Date
 * @param {Date | String} object
 * @return {Boolean} isDate
 */
exports.isDate = function (object) {
  if (object instanceof Date) {
    return true;
  } else if (exports.isString(object)) {
    // test whether this string contains a date
    var match = ASPDateRegex.exec(object);
    if (match) {
      return true;
    } else if (!isNaN(Date.parse(object))) {
      return true;
    }
  }

  return false;
};

/**
 * Create a semi UUID
 * source: http://stackoverflow.com/a/105074/1262753
 * @return {String} uuid
 */
exports.randomUUID = function () {
  return uuid.v4();
};

/**
 * assign all keys of an object that are not nested objects to a certain value (used for color objects).
 * @param obj
 * @param value
 */
exports.assignAllKeys = function (obj, value) {
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      if (typeof obj[prop] !== 'object') {
        obj[prop] = value;
      }
    }
  }
};

/**
 * Fill an object with a possibly partially defined other object. Only copies values if the a object has an object requiring values.
 * That means an object is not created on a property if only the b object has it.
 * @param obj
 * @param value
 */
exports.fillIfDefined = function (a, b) {
  var allowDeletion = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

  for (var prop in a) {
    if (b[prop] !== undefined) {
      if (typeof b[prop] !== 'object') {
        if ((b[prop] === undefined || b[prop] === null) && a[prop] !== undefined && allowDeletion === true) {
          delete a[prop];
        } else {
          a[prop] = b[prop];
        }
      } else {
        if (typeof a[prop] === 'object') {
          exports.fillIfDefined(a[prop], b[prop], allowDeletion);
        }
      }
    }
  }
};

/**
 * Extend object a with the properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Object} a
 * @param {... Object} b
 * @return {Object} a
 */
exports.protoExtend = function (a, b) {
  for (var i = 1; i < arguments.length; i++) {
    var other = arguments[i];
    for (var prop in other) {
      a[prop] = other[prop];
    }
  }
  return a;
};

/**
 * Extend object a with the properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Object} a
 * @param {... Object} b
 * @return {Object} a
 */
exports.extend = function (a, b) {
  for (var i = 1; i < arguments.length; i++) {
    var other = arguments[i];
    for (var prop in other) {
      if (other.hasOwnProperty(prop)) {
        a[prop] = other[prop];
      }
    }
  }
  return a;
};

/**
 * Extend object a with selected properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Array.<String>} props
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 */
exports.selectiveExtend = function (props, a, b) {
  if (!Array.isArray(props)) {
    throw new Error('Array with property names expected as first argument');
  }

  for (var i = 2; i < arguments.length; i++) {
    var other = arguments[i];

    for (var p = 0; p < props.length; p++) {
      var prop = props[p];
      if (other.hasOwnProperty(prop)) {
        a[prop] = other[prop];
      }
    }
  }
  return a;
};

/**
 * Extend object a with selected properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Array.<String>} props
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 */
exports.selectiveDeepExtend = function (props, a, b) {
  var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

  // TODO: add support for Arrays to deepExtend
  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }
  for (var i = 2; i < arguments.length; i++) {
    var other = arguments[i];
    for (var p = 0; p < props.length; p++) {
      var prop = props[p];
      if (other.hasOwnProperty(prop)) {
        if (b[prop] && b[prop].constructor === Object) {
          if (a[prop] === undefined) {
            a[prop] = {};
          }
          if (a[prop].constructor === Object) {
            exports.deepExtend(a[prop], b[prop], false, allowDeletion);
          } else {
            if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
              delete a[prop];
            } else {
              a[prop] = b[prop];
            }
          }
        } else if (Array.isArray(b[prop])) {
          throw new TypeError('Arrays are not supported by deepExtend');
        } else {
          if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        }
      }
    }
  }
  return a;
};

/**
 * Extend object a with selected properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Array.<String>} props
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 */
exports.selectiveNotDeepExtend = function (props, a, b) {
  var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

  // TODO: add support for Arrays to deepExtend
  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }
  for (var prop in b) {
    if (b.hasOwnProperty(prop)) {
      if (props.indexOf(prop) == -1) {
        if (b[prop] && b[prop].constructor === Object) {
          if (a[prop] === undefined) {
            a[prop] = {};
          }
          if (a[prop].constructor === Object) {
            exports.deepExtend(a[prop], b[prop]);
          } else {
            if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
              delete a[prop];
            } else {
              a[prop] = b[prop];
            }
          }
        } else if (Array.isArray(b[prop])) {
          a[prop] = [];
          for (var i = 0; i < b[prop].length; i++) {
            a[prop].push(b[prop][i]);
          }
        } else {
          if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        }
      }
    }
  }
  return a;
};

/**
 * Deep extend an object a with the properties of object b
 * @param {Object} a
 * @param {Object} b
 * @param [Boolean] protoExtend --> optional parameter. If true, the prototype values will also be extended.
 *                                  (ie. the options objects that inherit from others will also get the inherited options)
 * @param [Boolean] global      --> optional parameter. If true, the values of fields that are null will not deleted
 * @returns {Object}
 */
exports.deepExtend = function (a, b, protoExtend, allowDeletion) {
  for (var prop in b) {
    if (b.hasOwnProperty(prop) || protoExtend === true) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a[prop] === undefined) {
          a[prop] = {};
        }
        if (a[prop].constructor === Object) {
          exports.deepExtend(a[prop], b[prop], protoExtend);
        } else {
          if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        }
      } else if (Array.isArray(b[prop])) {
        a[prop] = [];
        for (var i = 0; i < b[prop].length; i++) {
          a[prop].push(b[prop][i]);
        }
      } else {
        if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
          delete a[prop];
        } else {
          a[prop] = b[prop];
        }
      }
    }
  }
  return a;
};

/**
 * Test whether all elements in two arrays are equal.
 * @param {Array} a
 * @param {Array} b
 * @return {boolean} Returns true if both arrays have the same length and same
 *                   elements.
 */
exports.equalArray = function (a, b) {
  if (a.length != b.length) return false;

  for (var i = 0, len = a.length; i < len; i++) {
    if (a[i] != b[i]) return false;
  }

  return true;
};

/**
 * Convert an object to another type
 * @param {Boolean | Number | String | Date | Moment | Null | undefined} object
 * @param {String | undefined} type   Name of the type. Available types:
 *                                    'Boolean', 'Number', 'String',
 *                                    'Date', 'Moment', ISODate', 'ASPDate'.
 * @return {*} object
 * @throws Error
 */
exports.convert = function (object, type) {
  var match;

  if (object === undefined) {
    return undefined;
  }
  if (object === null) {
    return null;
  }

  if (!type) {
    return object;
  }
  if (!(typeof type === 'string') && !(type instanceof String)) {
    throw new Error('Type must be a string');
  }

  //noinspection FallthroughInSwitchStatementJS
  switch (type) {
    case 'boolean':
    case 'Boolean':
      return Boolean(object);

    case 'number':
    case 'Number':
      return Number(object.valueOf());

    case 'string':
    case 'String':
      return String(object);

    case 'Date':
      if (exports.isNumber(object)) {
        return new Date(object);
      }
      if (object instanceof Date) {
        return new Date(object.valueOf());
      } else if (moment.isMoment(object)) {
        return new Date(object.valueOf());
      }
      if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])); // parse number
        } else {
            return moment(object).toDate(); // parse string
          }
      } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');
        }

    case 'Moment':
      if (exports.isNumber(object)) {
        return moment(object);
      }
      if (object instanceof Date) {
        return moment(object.valueOf());
      } else if (moment.isMoment(object)) {
        return moment(object);
      }
      if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return moment(Number(match[1])); // parse number
        } else {
            return moment(object); // parse string
          }
      } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');
        }

    case 'ISODate':
      if (exports.isNumber(object)) {
        return new Date(object);
      } else if (object instanceof Date) {
        return object.toISOString();
      } else if (moment.isMoment(object)) {
        return object.toDate().toISOString();
      } else if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])).toISOString(); // parse number
        } else {
            return new Date(object).toISOString(); // parse string
          }
      } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ISODate');
        }

    case 'ASPDate':
      if (exports.isNumber(object)) {
        return '/Date(' + object + ')/';
      } else if (object instanceof Date) {
        return '/Date(' + object.valueOf() + ')/';
      } else if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        var value;
        if (match) {
          // object is an ASP date
          value = new Date(Number(match[1])).valueOf(); // parse number
        } else {
            value = new Date(object).valueOf(); // parse string
          }
        return '/Date(' + value + ')/';
      } else {
        throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ASPDate');
      }

    default:
      throw new Error('Unknown type "' + type + '"');
  }
};

// parse ASP.Net Date pattern,
// for example '/Date(1198908717056)/' or '/Date(1198908717056-0700)/'
// code from http://momentjs.com/
var ASPDateRegex = /^\/?Date\((\-?\d+)/i;

/**
 * Get the type of an object, for example exports.getType([]) returns 'Array'
 * @param {*} object
 * @return {String} type
 */
exports.getType = function (object) {
  var type = typeof object;

  if (type == 'object') {
    if (object === null) {
      return 'null';
    }
    if (object instanceof Boolean) {
      return 'Boolean';
    }
    if (object instanceof Number) {
      return 'Number';
    }
    if (object instanceof String) {
      return 'String';
    }
    if (Array.isArray(object)) {
      return 'Array';
    }
    if (object instanceof Date) {
      return 'Date';
    }
    return 'Object';
  } else if (type == 'number') {
    return 'Number';
  } else if (type == 'boolean') {
    return 'Boolean';
  } else if (type == 'string') {
    return 'String';
  } else if (type === undefined) {
    return 'undefined';
  }

  return type;
};

/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr
 * @param newValue
 * @returns {Array}
 */
exports.copyAndExtendArray = function (arr, newValue) {
  var newArr = [];
  for (var i = 0; i < arr.length; i++) {
    newArr.push(arr[i]);
  }
  newArr.push(newValue);
  return newArr;
};

/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr
 * @param newValue
 * @returns {Array}
 */
exports.copyArray = function (arr) {
  var newArr = [];
  for (var i = 0; i < arr.length; i++) {
    newArr.push(arr[i]);
  }
  return newArr;
};

/**
 * Retrieve the absolute left value of a DOM element
 * @param {Element} elem        A dom element, for example a div
 * @return {number} left        The absolute left position of this element
 *                              in the browser page.
 */
exports.getAbsoluteLeft = function (elem) {
  return elem.getBoundingClientRect().left;
};

/**
 * Retrieve the absolute top value of a DOM element
 * @param {Element} elem        A dom element, for example a div
 * @return {number} top        The absolute top position of this element
 *                              in the browser page.
 */
exports.getAbsoluteTop = function (elem) {
  return elem.getBoundingClientRect().top;
};

/**
 * add a className to the given elements style
 * @param {Element} elem
 * @param {String} className
 */
exports.addClassName = function (elem, className) {
  var classes = elem.className.split(' ');
  if (classes.indexOf(className) == -1) {
    classes.push(className); // add the class to the array
    elem.className = classes.join(' ');
  }
};

/**
 * add a className to the given elements style
 * @param {Element} elem
 * @param {String} className
 */
exports.removeClassName = function (elem, className) {
  var classes = elem.className.split(' ');
  var index = classes.indexOf(className);
  if (index != -1) {
    classes.splice(index, 1); // remove the class from the array
    elem.className = classes.join(' ');
  }
};

/**
 * For each method for both arrays and objects.
 * In case of an array, the built-in Array.forEach() is applied.
 * In case of an Object, the method loops over all properties of the object.
 * @param {Object | Array} object   An Object or Array
 * @param {function} callback       Callback method, called for each item in
 *                                  the object or array with three parameters:
 *                                  callback(value, index, object)
 */
exports.forEach = function (object, callback) {
  var i, len;
  if (Array.isArray(object)) {
    // array
    for (i = 0, len = object.length; i < len; i++) {
      callback(object[i], i, object);
    }
  } else {
    // object
    for (i in object) {
      if (object.hasOwnProperty(i)) {
        callback(object[i], i, object);
      }
    }
  }
};

/**
 * Convert an object into an array: all objects properties are put into the
 * array. The resulting array is unordered.
 * @param {Object} object
 * @param {Array} array
 */
exports.toArray = function (object) {
  var array = [];

  for (var prop in object) {
    if (object.hasOwnProperty(prop)) array.push(object[prop]);
  }

  return array;
};

/**
 * Update a property in an object
 * @param {Object} object
 * @param {String} key
 * @param {*} value
 * @return {Boolean} changed
 */
exports.updateProperty = function (object, key, value) {
  if (object[key] !== value) {
    object[key] = value;
    return true;
  } else {
    return false;
  }
};

/**
 * Throttle the given function to be only executed once every `wait` milliseconds
 * @param {function} fn
 * @param {number} wait    Time in milliseconds
 * @returns {function} Returns the throttled function
 */
exports.throttle = function (fn, wait) {
  var timeout = null;
  var needExecution = false;

  return function throttled() {
    if (!timeout) {
      needExecution = false;
      fn();

      timeout = setTimeout(function () {
        timeout = null;
        if (needExecution) {
          throttled();
        }
      }, wait);
    } else {
      needExecution = true;
    }
  };
};

/**
 * Add and event listener. Works for all browsers
 * @param {Element}     element    An html element
 * @param {string}      action     The action, for example "click",
 *                                 without the prefix "on"
 * @param {function}    listener   The callback function to be executed
 * @param {boolean}     [useCapture]
 */
exports.addEventListener = function (element, action, listener, useCapture) {
  if (element.addEventListener) {
    if (useCapture === undefined) useCapture = false;

    if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
      action = "DOMMouseScroll"; // For Firefox
    }

    element.addEventListener(action, listener, useCapture);
  } else {
    element.attachEvent("on" + action, listener); // IE browsers
  }
};

/**
 * Remove an event listener from an element
 * @param {Element}     element         An html dom element
 * @param {string}      action          The name of the event, for example "mousedown"
 * @param {function}    listener        The listener function
 * @param {boolean}     [useCapture]
 */
exports.removeEventListener = function (element, action, listener, useCapture) {
  if (element.removeEventListener) {
    // non-IE browsers
    if (useCapture === undefined) useCapture = false;

    if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
      action = "DOMMouseScroll"; // For Firefox
    }

    element.removeEventListener(action, listener, useCapture);
  } else {
    // IE browsers
    element.detachEvent("on" + action, listener);
  }
};

/**
 * Cancels the event if it is cancelable, without stopping further propagation of the event.
 */
exports.preventDefault = function (event) {
  if (!event) event = window.event;

  if (event.preventDefault) {
    event.preventDefault(); // non-IE browsers
  } else {
      event.returnValue = false; // IE browsers
    }
};

/**
 * Get HTML element which is the target of the event
 * @param {Event} event
 * @return {Element} target element
 */
exports.getTarget = function (event) {
  // code from http://www.quirksmode.org/js/events_properties.html
  if (!event) {
    event = window.event;
  }

  var target;

  if (event.target) {
    target = event.target;
  } else if (event.srcElement) {
    target = event.srcElement;
  }

  if (target.nodeType != undefined && target.nodeType == 3) {
    // defeat Safari bug
    target = target.parentNode;
  }

  return target;
};

/**
 * Check if given element contains given parent somewhere in the DOM tree
 * @param {Element} element
 * @param {Element} parent
 */
exports.hasParent = function (element, parent) {
  var e = element;

  while (e) {
    if (e === parent) {
      return true;
    }
    e = e.parentNode;
  }

  return false;
};

exports.option = {};

/**
 * Convert a value into a boolean
 * @param {Boolean | function | undefined} value
 * @param {Boolean} [defaultValue]
 * @returns {Boolean} bool
 */
exports.option.asBoolean = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return value != false;
  }

  return defaultValue || null;
};

/**
 * Convert a value into a number
 * @param {Boolean | function | undefined} value
 * @param {Number} [defaultValue]
 * @returns {Number} number
 */
exports.option.asNumber = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return Number(value) || defaultValue || null;
  }

  return defaultValue || null;
};

/**
 * Convert a value into a string
 * @param {String | function | undefined} value
 * @param {String} [defaultValue]
 * @returns {String} str
 */
exports.option.asString = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return String(value);
  }

  return defaultValue || null;
};

/**
 * Convert a size or location into a string with pixels or a percentage
 * @param {String | Number | function | undefined} value
 * @param {String} [defaultValue]
 * @returns {String} size
 */
exports.option.asSize = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (exports.isString(value)) {
    return value;
  } else if (exports.isNumber(value)) {
    return value + 'px';
  } else {
    return defaultValue || null;
  }
};

/**
 * Convert a value into a DOM element
 * @param {HTMLElement | function | undefined} value
 * @param {HTMLElement} [defaultValue]
 * @returns {HTMLElement | null} dom
 */
exports.option.asElement = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  return value || defaultValue || null;
};

/**
 * http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
 *
 * @param {String} hex
 * @returns {{r: *, g: *, b: *}} | 255 range
 */
exports.hexToRGB = function (hex) {
  // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
  var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  hex = hex.replace(shorthandRegex, function (m, r, g, b) {
    return r + r + g + g + b + b;
  });
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
};

/**
 * This function takes color in hex format or rgb() or rgba() format and overrides the opacity. Returns rgba() string.
 * @param color
 * @param opacity
 * @returns {*}
 */
exports.overrideOpacity = function (color, opacity) {
  if (color.indexOf("rgba") != -1) {
    return color;
  } else if (color.indexOf("rgb") != -1) {
    var rgb = color.substr(color.indexOf("(") + 1).replace(")", "").split(",");
    return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + opacity + ")";
  } else {
    var rgb = exports.hexToRGB(color);
    if (rgb == null) {
      return color;
    } else {
      return "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + opacity + ")";
    }
  }
};

/**
 *
 * @param red     0 -- 255
 * @param green   0 -- 255
 * @param blue    0 -- 255
 * @returns {string}
 * @constructor
 */
exports.RGBToHex = function (red, green, blue) {
  return "#" + ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16).slice(1);
};

/**
 * Parse a color property into an object with border, background, and
 * highlight colors
 * @param {Object | String} color
 * @return {Object} colorObject
 */
exports.parseColor = function (color) {
  var c;
  if (exports.isString(color) === true) {
    if (exports.isValidRGB(color) === true) {
      var rgb = color.substr(4).substr(0, color.length - 5).split(',').map(function (value) {
        return parseInt(value);
      });
      color = exports.RGBToHex(rgb[0], rgb[1], rgb[2]);
    }
    if (exports.isValidHex(color) === true) {
      var hsv = exports.hexToHSV(color);
      var lighterColorHSV = { h: hsv.h, s: hsv.s * 0.8, v: Math.min(1, hsv.v * 1.02) };
      var darkerColorHSV = { h: hsv.h, s: Math.min(1, hsv.s * 1.25), v: hsv.v * 0.8 };
      var darkerColorHex = exports.HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);
      var lighterColorHex = exports.HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);
      c = {
        background: color,
        border: darkerColorHex,
        highlight: {
          background: lighterColorHex,
          border: darkerColorHex
        },
        hover: {
          background: lighterColorHex,
          border: darkerColorHex
        }
      };
    } else {
      c = {
        background: color,
        border: color,
        highlight: {
          background: color,
          border: color
        },
        hover: {
          background: color,
          border: color
        }
      };
    }
  } else {
    c = {};
    c.background = color.background || undefined;
    c.border = color.border || undefined;

    if (exports.isString(color.highlight)) {
      c.highlight = {
        border: color.highlight,
        background: color.highlight
      };
    } else {
      c.highlight = {};
      c.highlight.background = color.highlight && color.highlight.background || undefined;
      c.highlight.border = color.highlight && color.highlight.border || undefined;
    }

    if (exports.isString(color.hover)) {
      c.hover = {
        border: color.hover,
        background: color.hover
      };
    } else {
      c.hover = {};
      c.hover.background = color.hover && color.hover.background || undefined;
      c.hover.border = color.hover && color.hover.border || undefined;
    }
  }

  return c;
};

/**
 * http://www.javascripter.net/faq/rgb2hsv.htm
 *
 * @param red
 * @param green
 * @param blue
 * @returns {*}
 * @constructor
 */
exports.RGBToHSV = function (red, green, blue) {
  red = red / 255;green = green / 255;blue = blue / 255;
  var minRGB = Math.min(red, Math.min(green, blue));
  var maxRGB = Math.max(red, Math.max(green, blue));

  // Black-gray-white
  if (minRGB == maxRGB) {
    return { h: 0, s: 0, v: minRGB };
  }

  // Colors other than black-gray-white:
  var d = red == minRGB ? green - blue : blue == minRGB ? red - green : blue - red;
  var h = red == minRGB ? 3 : blue == minRGB ? 1 : 5;
  var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;
  var saturation = (maxRGB - minRGB) / maxRGB;
  var value = maxRGB;
  return { h: hue, s: saturation, v: value };
};

var cssUtil = {
  // split a string with css styles into an object with key/values
  split: function split(cssText) {
    var styles = {};

    cssText.split(';').forEach(function (style) {
      if (style.trim() != '') {
        var parts = style.split(':');
        var key = parts[0].trim();
        var value = parts[1].trim();
        styles[key] = value;
      }
    });

    return styles;
  },

  // build a css text string from an object with key/values
  join: function join(styles) {
    return Object.keys(styles).map(function (key) {
      return key + ': ' + styles[key];
    }).join('; ');
  }
};

/**
 * Append a string with css styles to an element
 * @param {Element} element
 * @param {String} cssText
 */
exports.addCssText = function (element, cssText) {
  var currentStyles = cssUtil.split(element.style.cssText);
  var newStyles = cssUtil.split(cssText);
  var styles = exports.extend(currentStyles, newStyles);

  element.style.cssText = cssUtil.join(styles);
};

/**
 * Remove a string with css styles from an element
 * @param {Element} element
 * @param {String} cssText
 */
exports.removeCssText = function (element, cssText) {
  var styles = cssUtil.split(element.style.cssText);
  var removeStyles = cssUtil.split(cssText);

  for (var key in removeStyles) {
    if (removeStyles.hasOwnProperty(key)) {
      delete styles[key];
    }
  }

  element.style.cssText = cssUtil.join(styles);
};

/**
 * https://gist.github.com/mjijackson/5311256
 * @param h
 * @param s
 * @param v
 * @returns {{r: number, g: number, b: number}}
 * @constructor
 */
exports.HSVToRGB = function (h, s, v) {
  var r, g, b;

  var i = Math.floor(h * 6);
  var f = h * 6 - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);

  switch (i % 6) {
    case 0:
      r = v, g = t, b = p;break;
    case 1:
      r = q, g = v, b = p;break;
    case 2:
      r = p, g = v, b = t;break;
    case 3:
      r = p, g = q, b = v;break;
    case 4:
      r = t, g = p, b = v;break;
    case 5:
      r = v, g = p, b = q;break;
  }

  return { r: Math.floor(r * 255), g: Math.floor(g * 255), b: Math.floor(b * 255) };
};

exports.HSVToHex = function (h, s, v) {
  var rgb = exports.HSVToRGB(h, s, v);
  return exports.RGBToHex(rgb.r, rgb.g, rgb.b);
};

exports.hexToHSV = function (hex) {
  var rgb = exports.hexToRGB(hex);
  return exports.RGBToHSV(rgb.r, rgb.g, rgb.b);
};

exports.isValidHex = function (hex) {
  var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
  return isOk;
};

exports.isValidRGB = function (rgb) {
  rgb = rgb.replace(" ", "");
  var isOk = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/i.test(rgb);
  return isOk;
};
exports.isValidRGBA = function (rgba) {
  rgba = rgba.replace(" ", "");
  var isOk = /rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),(.{1,3})\)/i.test(rgba);
  return isOk;
};

/**
 * This recursively redirects the prototype of JSON objects to the referenceObject
 * This is used for default options.
 *
 * @param referenceObject
 * @returns {*}
 */
exports.selectiveBridgeObject = function (fields, referenceObject) {
  if (typeof referenceObject == "object") {
    var objectTo = Object.create(referenceObject);
    for (var i = 0; i < fields.length; i++) {
      if (referenceObject.hasOwnProperty(fields[i])) {
        if (typeof referenceObject[fields[i]] == "object") {
          objectTo[fields[i]] = exports.bridgeObject(referenceObject[fields[i]]);
        }
      }
    }
    return objectTo;
  } else {
    return null;
  }
};

/**
 * This recursively redirects the prototype of JSON objects to the referenceObject
 * This is used for default options.
 *
 * @param referenceObject
 * @returns {*}
 */
exports.bridgeObject = function (referenceObject) {
  if (typeof referenceObject == "object") {
    var objectTo = Object.create(referenceObject);
    for (var i in referenceObject) {
      if (referenceObject.hasOwnProperty(i)) {
        if (typeof referenceObject[i] == "object") {
          objectTo[i] = exports.bridgeObject(referenceObject[i]);
        }
      }
    }
    return objectTo;
  } else {
    return null;
  }
};

/**
 * this is used to set the options of subobjects in the options object. A requirement of these subobjects
 * is that they have an 'enabled' element which is optional for the user but mandatory for the program.
 *
 * @param [object] mergeTarget | this is either this.options or the options used for the groups.
 * @param [object] options     | options
 * @param [String] option      | this is the option key in the options argument
 * @private
 */
exports.mergeOptions = function (mergeTarget, options, option) {
  var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
  var globalOptions = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];

  if (options[option] === null) {
    mergeTarget[option] = Object.create(globalOptions[option]);
  } else {
    if (options[option] !== undefined) {
      if (typeof options[option] === 'boolean') {
        mergeTarget[option].enabled = options[option];
      } else {
        if (options[option].enabled === undefined) {
          mergeTarget[option].enabled = true;
        }
        for (var prop in options[option]) {
          if (options[option].hasOwnProperty(prop)) {
            mergeTarget[option][prop] = options[option][prop];
          }
        }
      }
    }
  }
};

/**
 * This function does a binary search for a visible item in a sorted list. If we find a visible item, the code that uses
 * this function will then iterate in both directions over this sorted list to find all visible items.
 *
 * @param {Item[]} orderedItems       | Items ordered by start
 * @param {function} searchFunction   | -1 is lower, 0 is found, 1 is higher
 * @param {String} field
 * @param {String} field2
 * @returns {number}
 * @private
 */
exports.binarySearchCustom = function (orderedItems, searchFunction, field, field2) {
  var maxIterations = 10000;
  var iteration = 0;
  var low = 0;
  var high = orderedItems.length - 1;

  while (low <= high && iteration < maxIterations) {
    var middle = Math.floor((low + high) / 2);

    var item = orderedItems[middle];
    var value = field2 === undefined ? item[field] : item[field][field2];

    var searchResult = searchFunction(value);
    if (searchResult == 0) {
      // jihaa, found a visible item!
      return middle;
    } else if (searchResult == -1) {
      // it is too small --> increase low
      low = middle + 1;
    } else {
      // it is too big --> decrease high
      high = middle - 1;
    }

    iteration++;
  }

  return -1;
};

/**
 * This function does a binary search for a specific value in a sorted array. If it does not exist but is in between of
 * two values, we return either the one before or the one after, depending on user input
 * If it is found, we return the index, else -1.
 *
 * @param {Array} orderedItems
 * @param {{start: number, end: number}} target
 * @param {String} field
 * @param {String} sidePreference   'before' or 'after'
 * @returns {number}
 * @private
 */
exports.binarySearchValue = function (orderedItems, target, field, sidePreference) {
  var maxIterations = 10000;
  var iteration = 0;
  var low = 0;
  var high = orderedItems.length - 1;
  var prevValue, value, nextValue, middle;

  while (low <= high && iteration < maxIterations) {
    // get a new guess
    middle = Math.floor(0.5 * (high + low));
    prevValue = orderedItems[Math.max(0, middle - 1)][field];
    value = orderedItems[middle][field];
    nextValue = orderedItems[Math.min(orderedItems.length - 1, middle + 1)][field];

    if (value == target) {
      // we found the target
      return middle;
    } else if (prevValue < target && value > target) {
      // target is in between of the previous and the current
      return sidePreference == 'before' ? Math.max(0, middle - 1) : middle;
    } else if (value < target && nextValue > target) {
      // target is in between of the current and the next
      return sidePreference == 'before' ? middle : Math.min(orderedItems.length - 1, middle + 1);
    } else {
      // didnt find the target, we need to change our boundaries.
      if (value < target) {
        // it is too small --> increase low
        low = middle + 1;
      } else {
        // it is too big --> decrease high
        high = middle - 1;
      }
    }
    iteration++;
  }

  // didnt find anything. Return -1.
  return -1;
};

/*
 * Easing Functions - inspired from http://gizma.com/easing/
 * only considering the t value for the range [0, 1] => [0, 1]
 * https://gist.github.com/gre/1650294
 */
exports.easingFunctions = {
  // no easing, no acceleration
  linear: function linear(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function easeInQuad(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function easeOutQuad(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function easeInOutQuad(t) {
    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity
  easeInCubic: function easeInCubic(t) {
    return t * t * t;
  },
  // decelerating to zero velocity
  easeOutCubic: function easeOutCubic(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration
  easeInOutCubic: function easeInOutCubic(t) {
    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity
  easeInQuart: function easeInQuart(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuart: function easeOutQuart(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function easeInOutQuart(t) {
    return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function easeInQuint(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function easeOutQuint(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuint: function easeInOutQuint(t) {
    return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBTUEsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUM7QUFDeEMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDOzs7Ozs7O0FBT3BDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsVUFBVSxNQUFNLEVBQUU7QUFDbkMsU0FBUSxNQUFNLFlBQVksTUFBTSxJQUFJLE9BQU8sTUFBTSxJQUFJLFFBQVEsQ0FBRTtDQUNoRSxDQUFDOzs7Ozs7QUFPRixPQUFPLENBQUMsa0JBQWtCLEdBQUcsVUFBVSxTQUFTLEVBQUU7QUFDaEQsTUFBSSxTQUFTLEVBQUU7QUFDYixXQUFPLFNBQVMsQ0FBQyxhQUFhLEVBQUUsS0FBSyxJQUFJLEVBQUU7QUFDekMsYUFBTyxDQUFDLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNqRCxlQUFTLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQztLQUM3QztHQUNGO0NBQ0YsQ0FBQzs7Ozs7Ozs7Ozs7QUFXRixPQUFPLENBQUMsU0FBUyxHQUFHLFVBQVUsR0FBRyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFO0FBQ3BELE1BQUksR0FBRyxJQUFJLEdBQUcsRUFBRTtBQUNkLFdBQU8sR0FBRyxDQUFDO0dBQ1osTUFDSTtBQUNILFFBQUksS0FBSyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxDQUFBLEFBQUMsQ0FBQztBQUM1QixXQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQSxHQUFJLEtBQUssQ0FBQyxDQUFDO0dBQzNDO0NBQ0YsQ0FBQTs7Ozs7OztBQU9ELE9B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Q0FBQSxHQUFJLENBQUMsQ0FBQSxBQUFDLENBQUM7O0FBRTlCLFVBQVEsQ0FBQyxHQUFHLENBQUM7QUFDWCxTQUFLLENBQUM7QUFBRSxPQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUFDLE1BQU07QUFBQSxBQUNuQyxTQUFLLENBQUM7QUFBRSxPQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUFDLE1BQU07QUFBQSxBQUNuQyxTQUFLLENBQUM7QUFBRSxPQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUFDLE1BQU07QUFBQSxBQUNuQyxTQUFLLENBQUM7QUFBRSxPQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUFDLE1BQU07QUFBQSxBQUNuQyxTQUFLLENBQUM7QUFBRSxPQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUFDLE1BQU07QUFBQSxBQUNuQyxTQUFLLENBQUM7QUFBRSxPQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUFDLE1BQU07QUFBQSxHQUNwQzs7QUFFRCxTQUFPLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQztDQUNuRixDQUFDOztBQUVGLE9BQU8sQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUNw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RyxFQUFFLEdBQUksRUFBRSxDQUFDLEFBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUE7R0FDeEU7Q0FDRixDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9kYXJpbi9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy12aWV3ZXIvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdXRpbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHV0aWxpdHkgZnVuY3Rpb25zXG5cbi8vIGZpcnN0IGNoZWNrIGlmIG1vbWVudC5qcyBpcyBhbHJlYWR5IGxvYWRlZCBpbiB0aGUgYnJvd3NlciB3aW5kb3csIGlmIHNvLFxuLy8gdXNlIHRoaXMgaW5zdGFuY2UuIEVsc2UsIGxvYWQgdmlhIGNvbW1vbmpzLlxuXG5cbnZhciBtb21lbnQgPSByZXF1aXJlKCcuL21vZHVsZS9tb21lbnQnKTtcbnZhciB1dWlkID0gcmVxdWlyZSgnLi9tb2R1bGUvdXVpZCcpO1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSBudW1iZXJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSBpc051bWJlclxuICovXG5leHBvcnRzLmlzTnVtYmVyID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gKG9iamVjdCBpbnN0YW5jZW9mIE51bWJlciB8fCB0eXBlb2Ygb2JqZWN0ID09ICdudW1iZXInKTtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmUgZXZlcnl0aGluZyBpbiB0aGUgRE9NIG9iamVjdFxuICogQHBhcmFtIERPTW9iamVjdFxuICovXG5leHBvcnRzLnJlY3Vyc2l2ZURPTURlbGV0ZSA9IGZ1bmN0aW9uIChET01vYmplY3QpIHtcbiAgaWYgKERPTW9iamVjdCkge1xuICAgIHdoaWxlIChET01vYmplY3QuaGFzQ2hpbGROb2RlcygpID09PSB0cnVlKSB7XG4gICAgICBleHBvcnRzLnJlY3Vyc2l2ZURPTURlbGV0ZShET01vYmplY3QuZmlyc3RDaGlsZCk7XG4gICAgICBET01vYmplY3QucmVtb3ZlQ2hpbGQoRE9Nb2JqZWN0LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiB0aGlzIGZ1bmN0aW9uIGdpdmVzIHlvdSBhIHJhbmdlIGJldHdlZW4gMCBhbmQgMSBiYXNlZCBvbiB0aGUgbWluIGFuZCBtYXggdmFsdWVzIGluIHRoZSBzZXQsIHRoZSB0b3RhbCBzdW0gb2YgYWxsIHZhbHVlcyBhbmQgdGhlIGN1cnJlbnQgdmFsdWUuXG4gKlxuICogQHBhcmFtIG1pblxuICogQHBhcmFtIG1heFxuICogQHBhcmFtIHRvdGFsXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMuZ2l2ZVJhbmdlID0gZnVuY3Rpb24gKG1pbiwgbWF4LCB0b3RhbCwgdmFsdWUpIHtcbiAgaWYgKG1heCA9PSBtaW4pIHtcbiAgICByZXR1cm4gMC41O1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBzY2FsZSA9IDEgLyAobWF4IC0gbWluKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgKHZhbHVlIC0gbWluKSAqIHNjYWxlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSBzdHJpbmdcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSBpc1N0cmluZ1xuICovXG5leHBvcnRzLmlzU3RyaW5nID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gKG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2Ygb2JqZWN0ID09ICdzdHJpbmcnKTtcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIERhdGUsIG9yIGEgU3RyaW5nIGNvbnRhaW5pbmcgYSBEYXRlXG4gKiBAcGFyYW0ge0RhdGUgfCBTdHJpbmd9IG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn0gaXNEYXRlXG4gKi9cbmV4cG9ydHMuaXNEYXRlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVsc2UgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgIC8vIHRlc3Qgd2hldGhlciB0aGlzIHN0cmluZyBjb250YWlucyBhIGRhdGVcbiAgICB2YXIgbWF0Y2ggPSBBU1BEYXRlUmVnZXguZXhlYyhvYmplY3QpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc05hTihEYXRlLnBhcnNlKG9iamVjdCkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHNlbWkgVVVJRFxuICogc291cmNlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMDUwNzQvMTI2Mjc1M1xuICogQHJldHVybiB7U3RyaW5nfSB1dWlkXG4gKi9cbmV4cG9ydHMucmFuZG9tVVVJRCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHV1aWQudjQoKTtcbn07XG5cbi8qKlxuICogYXNzaWduIGFsbCBrZXlzIG9mIGFuIG9iamVjdCB0aGF0IGFyZSBub3QgbmVzdGVkIG9iamVjdHMgdG8gYSBjZXJ0YWluIHZhbHVlICh1c2VkIGZvciBjb2xvciBvYmplY3RzKS5cbiAqIEBwYXJhbSBvYmpcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5leHBvcnRzLmFzc2lnbkFsbEtleXMgPSBmdW5jdGlvbiAob2JqLCB2YWx1ZSkge1xuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqW3Byb3BdICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvYmpbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIEZpbGwgYW4gb2JqZWN0IHdpdGggYSBwb3NzaWJseSBwYXJ0aWFsbHkgZGVmaW5lZCBvdGhlciBvYmplY3QuIE9ubHkgY29waWVzIHZhbHVlcyBpZiB0aGUgYSBvYmplY3QgaGFzIGFuIG9iamVjdCByZXF1aXJpbmcgdmFsdWVzLlxuICogVGhhdCBtZWFucyBhbiBvYmplY3QgaXMgbm90IGNyZWF0ZWQgb24gYSBwcm9wZXJ0eSBpZiBvbmx5IHRoZSBiIG9iamVjdCBoYXMgaXQuXG4gKiBAcGFyYW0gb2JqXG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZXhwb3J0cy5maWxsSWZEZWZpbmVkID0gZnVuY3Rpb24gKGEsIGIsIGFsbG93RGVsZXRpb24gPSBmYWxzZSkge1xuICBmb3IgKHZhciBwcm9wIGluIGEpIHtcbiAgICBpZiAoYltwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGJbcHJvcF0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICgoYltwcm9wXSA9PT0gdW5kZWZpbmVkIHx8IGJbcHJvcF0gPT09IG51bGwpICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIGFbcHJvcF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZXhwb3J0cy5maWxsSWZEZWZpbmVkKGFbcHJvcF0sIGJbcHJvcF0sIGFsbG93RGVsZXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG4vKipcbiAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiIG9yIGEgc2VyaWVzIG9mIG9iamVjdHNcbiAqIE9ubHkgcHJvcGVydGllcyB3aXRoIGRlZmluZWQgdmFsdWVzIGFyZSBjb3BpZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0gey4uLiBPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICovXG5leHBvcnRzLnByb3RvRXh0ZW5kID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvdGhlcikge1xuICAgICAgYVtwcm9wXSA9IG90aGVyW3Byb3BdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIG9iamVjdCBhIHdpdGggdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIgb3IgYSBzZXJpZXMgb2Ygb2JqZWN0c1xuICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZFxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7Li4uIE9iamVjdH0gYlxuICogQHJldHVybiB7T2JqZWN0fSBhXG4gKi9cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvdGhlcikge1xuICAgICAgaWYgKG90aGVyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGFbcHJvcF0gPSBvdGhlcltwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHNlbGVjdGVkIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIgb3IgYSBzZXJpZXMgb2Ygb2JqZWN0c1xuICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZFxuICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gcHJvcHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICogQHJldHVybiB7T2JqZWN0fSBhXG4gKi9cbmV4cG9ydHMuc2VsZWN0aXZlRXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzLCBhLCBiKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IHdpdGggcHJvcGVydHkgbmFtZXMgZXhwZWN0ZWQgYXMgZmlyc3QgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG90aGVyID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1twXTtcbiAgICAgIGlmIChvdGhlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBhW3Byb3BdID0gb3RoZXJbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCBzZWxlY3RlZCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiIG9yIGEgc2VyaWVzIG9mIG9iamVjdHNcbiAqIE9ubHkgcHJvcGVydGllcyB3aXRoIGRlZmluZWQgdmFsdWVzIGFyZSBjb3BpZWRcbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IHByb3BzXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICovXG5leHBvcnRzLnNlbGVjdGl2ZURlZXBFeHRlbmQgPSBmdW5jdGlvbiAocHJvcHMsIGEsIGIsIGFsbG93RGVsZXRpb24gPSBmYWxzZSkge1xuICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgQXJyYXlzIHRvIGRlZXBFeHRlbmRcbiAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICB9XG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG90aGVyID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbcF07XG4gICAgICBpZiAob3RoZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgaWYgKGJbcHJvcF0gJiYgYltwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgaWYgKGFbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYVtwcm9wXSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYVtwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICBleHBvcnRzLmRlZXBFeHRlbmQoYVtwcm9wXSwgYltwcm9wXSwgZmFsc2UsIGFsbG93RGVsZXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgoYltwcm9wXSA9PT0gbnVsbCkgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmIGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYltwcm9wXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgoYltwcm9wXSA9PT0gbnVsbCkgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmIGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFbcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCBzZWxlY3RlZCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiIG9yIGEgc2VyaWVzIG9mIG9iamVjdHNcbiAqIE9ubHkgcHJvcGVydGllcyB3aXRoIGRlZmluZWQgdmFsdWVzIGFyZSBjb3BpZWRcbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IHByb3BzXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICovXG5leHBvcnRzLnNlbGVjdGl2ZU5vdERlZXBFeHRlbmQgPSBmdW5jdGlvbiAocHJvcHMsIGEsIGIsIGFsbG93RGVsZXRpb24gPSBmYWxzZSkge1xuICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgQXJyYXlzIHRvIGRlZXBFeHRlbmRcbiAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICB9XG4gIGZvciAodmFyIHByb3AgaW4gYikge1xuICAgIGlmIChiLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBpZiAocHJvcHMuaW5kZXhPZihwcm9wKSA9PSAtMSkge1xuICAgICAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKGJbcHJvcF0gPT09IG51bGwpICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGFbcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJbcHJvcF0pKSB7XG4gICAgICAgICAgYVtwcm9wXSA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYltwcm9wXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYVtwcm9wXS5wdXNoKGJbcHJvcF1baV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoKGJbcHJvcF0gPT09IG51bGwpICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIERlZXAgZXh0ZW5kIGFuIG9iamVjdCBhIHdpdGggdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICogQHBhcmFtIFtCb29sZWFuXSBwcm90b0V4dGVuZCAtLT4gb3B0aW9uYWwgcGFyYW1ldGVyLiBJZiB0cnVlLCB0aGUgcHJvdG90eXBlIHZhbHVlcyB3aWxsIGFsc28gYmUgZXh0ZW5kZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaWUuIHRoZSBvcHRpb25zIG9iamVjdHMgdGhhdCBpbmhlcml0IGZyb20gb3RoZXJzIHdpbGwgYWxzbyBnZXQgdGhlIGluaGVyaXRlZCBvcHRpb25zKVxuICogQHBhcmFtIFtCb29sZWFuXSBnbG9iYWwgICAgICAtLT4gb3B0aW9uYWwgcGFyYW1ldGVyLiBJZiB0cnVlLCB0aGUgdmFsdWVzIG9mIGZpZWxkcyB0aGF0IGFyZSBudWxsIHdpbGwgbm90IGRlbGV0ZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZGVlcEV4dGVuZCA9IGZ1bmN0aW9uIChhLCBiLCBwcm90b0V4dGVuZCwgYWxsb3dEZWxldGlvbikge1xuICBmb3IgKHZhciBwcm9wIGluIGIpIHtcbiAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCBwcm90b0V4dGVuZCA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKGJbcHJvcF0gJiYgYltwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgIGlmIChhW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgIGV4cG9ydHMuZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdLCBwcm90b0V4dGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKChiW3Byb3BdID09PSBudWxsKSAmJiBhW3Byb3BdICE9PSB1bmRlZmluZWQgJiYgYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYltwcm9wXSkpIHtcbiAgICAgICAgYVtwcm9wXSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJbcHJvcF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhW3Byb3BdLnB1c2goYltwcm9wXVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgoYltwcm9wXSA9PT0gbnVsbCkgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmIGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFsbCBlbGVtZW50cyBpbiB0d28gYXJyYXlzIGFyZSBlcXVhbC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFcbiAqIEBwYXJhbSB7QXJyYXl9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBib3RoIGFycmF5cyBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhbmQgc2FtZVxuICogICAgICAgICAgICAgICAgICAgZWxlbWVudHMuXG4gKi9cbmV4cG9ydHMuZXF1YWxBcnJheSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYW4gb2JqZWN0IHRvIGFub3RoZXIgdHlwZVxuICogQHBhcmFtIHtCb29sZWFuIHwgTnVtYmVyIHwgU3RyaW5nIHwgRGF0ZSB8IE1vbWVudCB8IE51bGwgfCB1bmRlZmluZWR9IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmcgfCB1bmRlZmluZWR9IHR5cGUgICBOYW1lIG9mIHRoZSB0eXBlLiBBdmFpbGFibGUgdHlwZXM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdCb29sZWFuJywgJ051bWJlcicsICdTdHJpbmcnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRGF0ZScsICdNb21lbnQnLCBJU09EYXRlJywgJ0FTUERhdGUnLlxuICogQHJldHVybiB7Kn0gb2JqZWN0XG4gKiBAdGhyb3dzIEVycm9yXG4gKi9cbmV4cG9ydHMuY29udmVydCA9IGZ1bmN0aW9uIChvYmplY3QsIHR5cGUpIHtcbiAgdmFyIG1hdGNoO1xuXG4gIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCF0eXBlKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBpZiAoISh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpICYmICEodHlwZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGUgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIEJvb2xlYW4ob2JqZWN0KTtcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIHJldHVybiBOdW1iZXIob2JqZWN0LnZhbHVlT2YoKSk7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICByZXR1cm4gU3RyaW5nKG9iamVjdCk7XG5cbiAgICBjYXNlICdEYXRlJzpcbiAgICAgIGlmIChleHBvcnRzLmlzTnVtYmVyKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdCk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0LnZhbHVlT2YoKSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChtb21lbnQuaXNNb21lbnQob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0LnZhbHVlT2YoKSk7XG4gICAgICB9XG4gICAgICBpZiAoZXhwb3J0cy5pc1N0cmluZyhvYmplY3QpKSB7XG4gICAgICAgIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgLy8gb2JqZWN0IGlzIGFuIEFTUCBkYXRlXG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcihtYXRjaFsxXSkpOyAvLyBwYXJzZSBudW1iZXJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbW9tZW50KG9iamVjdCkudG9EYXRlKCk7IC8vIHBhcnNlIHN0cmluZ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdDYW5ub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnICsgZXhwb3J0cy5nZXRUeXBlKG9iamVjdCkgK1xuICAgICAgICAgICcgdG8gdHlwZSBEYXRlJyk7XG4gICAgICB9XG5cbiAgICBjYXNlICdNb21lbnQnOlxuICAgICAgaWYgKGV4cG9ydHMuaXNOdW1iZXIob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbW9tZW50KG9iamVjdCk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gbW9tZW50KG9iamVjdC52YWx1ZU9mKCkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobW9tZW50LmlzTW9tZW50KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpO1xuICAgICAgfVxuICAgICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgICAgICBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIC8vIG9iamVjdCBpcyBhbiBBU1AgZGF0ZVxuICAgICAgICAgIHJldHVybiBtb21lbnQoTnVtYmVyKG1hdGNoWzFdKSk7IC8vIHBhcnNlIG51bWJlclxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtb21lbnQob2JqZWN0KTsgLy8gcGFyc2Ugc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBjb252ZXJ0IG9iamVjdCBvZiB0eXBlICcgKyBleHBvcnRzLmdldFR5cGUob2JqZWN0KSArXG4gICAgICAgICAgJyB0byB0eXBlIERhdGUnKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ0lTT0RhdGUnOlxuICAgICAgaWYgKGV4cG9ydHMuaXNOdW1iZXIob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdC50b0lTT1N0cmluZygpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobW9tZW50LmlzTW9tZW50KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdC50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZXhwb3J0cy5pc1N0cmluZyhvYmplY3QpKSB7XG4gICAgICAgIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgLy8gb2JqZWN0IGlzIGFuIEFTUCBkYXRlXG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcihtYXRjaFsxXSkpLnRvSVNPU3RyaW5nKCk7IC8vIHBhcnNlIG51bWJlclxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmplY3QpLnRvSVNPU3RyaW5nKCk7IC8vIHBhcnNlIHN0cmluZ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdDYW5ub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnICsgZXhwb3J0cy5nZXRUeXBlKG9iamVjdCkgK1xuICAgICAgICAgICcgdG8gdHlwZSBJU09EYXRlJyk7XG4gICAgICB9XG5cbiAgICBjYXNlICdBU1BEYXRlJzpcbiAgICAgIGlmIChleHBvcnRzLmlzTnVtYmVyKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuICcvRGF0ZSgnICsgb2JqZWN0ICsgJykvJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICcvRGF0ZSgnICsgb2JqZWN0LnZhbHVlT2YoKSArICcpLyc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChleHBvcnRzLmlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAgICAgbWF0Y2ggPSBBU1BEYXRlUmVnZXguZXhlYyhvYmplY3QpO1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIC8vIG9iamVjdCBpcyBhbiBBU1AgZGF0ZVxuICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUoTnVtYmVyKG1hdGNoWzFdKSkudmFsdWVPZigpOyAvLyBwYXJzZSBudW1iZXJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKG9iamVjdCkudmFsdWVPZigpOyAvLyBwYXJzZSBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJy9EYXRlKCcgKyB2YWx1ZSArICcpLyc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdDYW5ub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnICsgZXhwb3J0cy5nZXRUeXBlKG9iamVjdCkgK1xuICAgICAgICAgICcgdG8gdHlwZSBBU1BEYXRlJyk7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGUgXCInICsgdHlwZSArICdcIicpO1xuICB9XG59O1xuXG4vLyBwYXJzZSBBU1AuTmV0IERhdGUgcGF0dGVybixcbi8vIGZvciBleGFtcGxlICcvRGF0ZSgxMTk4OTA4NzE3MDU2KS8nIG9yICcvRGF0ZSgxMTk4OTA4NzE3MDU2LTA3MDApLydcbi8vIGNvZGUgZnJvbSBodHRwOi8vbW9tZW50anMuY29tL1xudmFyIEFTUERhdGVSZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbi8qKlxuICogR2V0IHRoZSB0eXBlIG9mIGFuIG9iamVjdCwgZm9yIGV4YW1wbGUgZXhwb3J0cy5nZXRUeXBlKFtdKSByZXR1cm5zICdBcnJheSdcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAqL1xuZXhwb3J0cy5nZXRUeXBlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBvYmplY3Q7XG5cbiAgaWYgKHR5cGUgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgcmV0dXJuICdCb29sZWFuJztcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICByZXR1cm4gJ1N0cmluZyc7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgIHJldHVybiAnQXJyYXknO1xuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuICdEYXRlJztcbiAgICB9XG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9XG4gIGVsc2UgaWYgKHR5cGUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gJ051bWJlcic7XG4gIH1cbiAgZWxzZSBpZiAodHlwZSA9PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gJ0Jvb2xlYW4nO1xuICB9XG4gIGVsc2UgaWYgKHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gJ1N0cmluZyc7XG4gIH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9XG5cblxuICByZXR1cm4gdHlwZTtcbn07XG5cblxuLyoqXG4gKiBVc2VkIHRvIGV4dGVuZCBhbiBhcnJheSBhbmQgY29weSBpdC4gVGhpcyBpcyB1c2VkIHRvIHByb3BhZ2F0ZSBwYXRocyByZWN1cnNpdmVseS5cbiAqXG4gKiBAcGFyYW0gYXJyXG4gKiBAcGFyYW0gbmV3VmFsdWVcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZXhwb3J0cy5jb3B5QW5kRXh0ZW5kQXJyYXkgPSBmdW5jdGlvbiAoYXJyLCBuZXdWYWx1ZSkge1xuICBsZXQgbmV3QXJyID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgbmV3QXJyLnB1c2goYXJyW2ldKTtcbiAgfVxuICBuZXdBcnIucHVzaChuZXdWYWx1ZSk7XG4gIHJldHVybiBuZXdBcnI7XG59XG5cbi8qKlxuICogVXNlZCB0byBleHRlbmQgYW4gYXJyYXkgYW5kIGNvcHkgaXQuIFRoaXMgaXMgdXNlZCB0byBwcm9wYWdhdGUgcGF0aHMgcmVjdXJzaXZlbHkuXG4gKlxuICogQHBhcmFtIGFyclxuICogQHBhcmFtIG5ld1ZhbHVlXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmV4cG9ydHMuY29weUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICBsZXQgbmV3QXJyID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgbmV3QXJyLnB1c2goYXJyW2ldKTtcbiAgfVxuICByZXR1cm4gbmV3QXJyO1xufVxuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBhYnNvbHV0ZSBsZWZ0IHZhbHVlIG9mIGEgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSAgICAgICAgQSBkb20gZWxlbWVudCwgZm9yIGV4YW1wbGUgYSBkaXZcbiAqIEByZXR1cm4ge251bWJlcn0gbGVmdCAgICAgICAgVGhlIGFic29sdXRlIGxlZnQgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSBicm93c2VyIHBhZ2UuXG4gKi9cbmV4cG9ydHMuZ2V0QWJzb2x1dGVMZWZ0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgcmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGFic29sdXRlIHRvcCB2YWx1ZSBvZiBhIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gICAgICAgIEEgZG9tIGVsZW1lbnQsIGZvciBleGFtcGxlIGEgZGl2XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRvcCAgICAgICAgVGhlIGFic29sdXRlIHRvcCBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGJyb3dzZXIgcGFnZS5cbiAqL1xuZXhwb3J0cy5nZXRBYnNvbHV0ZVRvcCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gIHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbn07XG5cbi8qKlxuICogYWRkIGEgY2xhc3NOYW1lIHRvIHRoZSBnaXZlbiBlbGVtZW50cyBzdHlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gKi9cbmV4cG9ydHMuYWRkQ2xhc3NOYW1lID0gZnVuY3Rpb24gKGVsZW0sIGNsYXNzTmFtZSkge1xuICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gIGlmIChjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA9PSAtMSkge1xuICAgIGNsYXNzZXMucHVzaChjbGFzc05hbWUpOyAvLyBhZGQgdGhlIGNsYXNzIHRvIHRoZSBhcnJheVxuICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XG4gIH1cbn07XG5cbi8qKlxuICogYWRkIGEgY2xhc3NOYW1lIHRvIHRoZSBnaXZlbiBlbGVtZW50cyBzdHlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gKi9cbmV4cG9ydHMucmVtb3ZlQ2xhc3NOYW1lID0gZnVuY3Rpb24gKGVsZW0sIGNsYXNzTmFtZSkge1xuICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gIHZhciBpbmRleCA9IGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpO1xuICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICBjbGFzc2VzLnNwbGljZShpbmRleCwgMSk7IC8vIHJlbW92ZSB0aGUgY2xhc3MgZnJvbSB0aGUgYXJyYXlcbiAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpO1xuICB9XG59O1xuXG4vKipcbiAqIEZvciBlYWNoIG1ldGhvZCBmb3IgYm90aCBhcnJheXMgYW5kIG9iamVjdHMuXG4gKiBJbiBjYXNlIG9mIGFuIGFycmF5LCB0aGUgYnVpbHQtaW4gQXJyYXkuZm9yRWFjaCgpIGlzIGFwcGxpZWQuXG4gKiBJbiBjYXNlIG9mIGFuIE9iamVjdCwgdGhlIG1ldGhvZCBsb29wcyBvdmVyIGFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdCB8IEFycmF5fSBvYmplY3QgICBBbiBPYmplY3Qgb3IgQXJyYXlcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgICAgIENhbGxiYWNrIG1ldGhvZCwgY2FsbGVkIGZvciBlYWNoIGl0ZW0gaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBvYmplY3Qgb3IgYXJyYXkgd2l0aCB0aHJlZSBwYXJhbWV0ZXJzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodmFsdWUsIGluZGV4LCBvYmplY3QpXG4gKi9cbmV4cG9ydHMuZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gIHZhciBpLFxuICAgIGxlbjtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIC8vIGFycmF5XG4gICAgZm9yIChpID0gMCwgbGVuID0gb2JqZWN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYWxsYmFjayhvYmplY3RbaV0sIGksIG9iamVjdCk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIG9iamVjdFxuICAgIGZvciAoaSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgY2FsbGJhY2sob2JqZWN0W2ldLCBpLCBvYmplY3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGFuIGFycmF5OiBhbGwgb2JqZWN0cyBwcm9wZXJ0aWVzIGFyZSBwdXQgaW50byB0aGVcbiAqIGFycmF5LiBUaGUgcmVzdWx0aW5nIGFycmF5IGlzIHVub3JkZXJlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKi9cbmV4cG9ydHMudG9BcnJheSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgdmFyIGFycmF5ID0gW107XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KHByb3ApKSBhcnJheS5wdXNoKG9iamVjdFtwcm9wXSk7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBhIHByb3BlcnR5IGluIGFuIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICovXG5leHBvcnRzLnVwZGF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAob2JqZWN0W2tleV0gIT09IHZhbHVlKSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogVGhyb3R0bGUgdGhlIGdpdmVuIGZ1bmN0aW9uIHRvIGJlIG9ubHkgZXhlY3V0ZWQgb25jZSBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgICAgVGltZSBpbiBtaWxsaXNlY29uZHNcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gUmV0dXJucyB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydHMudGhyb3R0bGUgPSBmdW5jdGlvbiAoZm4sIHdhaXQpIHtcbiAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICB2YXIgbmVlZEV4ZWN1dGlvbiA9IGZhbHNlO1xuXG4gIHJldHVybiBmdW5jdGlvbiB0aHJvdHRsZWQgKCkge1xuICAgIGlmICghdGltZW91dCkge1xuICAgICAgbmVlZEV4ZWN1dGlvbiA9IGZhbHNlO1xuICAgICAgZm4oKTtcblxuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAobmVlZEV4ZWN1dGlvbikge1xuICAgICAgICAgIHRocm90dGxlZCgpO1xuICAgICAgICB9XG4gICAgICB9LCB3YWl0KVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG5lZWRFeGVjdXRpb24gPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBZGQgYW5kIGV2ZW50IGxpc3RlbmVyLiBXb3JrcyBmb3IgYWxsIGJyb3dzZXJzXG4gKiBAcGFyYW0ge0VsZW1lbnR9ICAgICBlbGVtZW50ICAgIEFuIGh0bWwgZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgYWN0aW9uICAgICBUaGUgYWN0aW9uLCBmb3IgZXhhbXBsZSBcImNsaWNrXCIsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhvdXQgdGhlIHByZWZpeCBcIm9uXCJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259ICAgIGxpc3RlbmVyICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBbdXNlQ2FwdHVyZV1cbiAqL1xuZXhwb3J0cy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgaWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGlmICh1c2VDYXB0dXJlID09PSB1bmRlZmluZWQpXG4gICAgICB1c2VDYXB0dXJlID0gZmFsc2U7XG5cbiAgICBpZiAoYWN0aW9uID09PSBcIm1vdXNld2hlZWxcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpID49IDApIHtcbiAgICAgIGFjdGlvbiA9IFwiRE9NTW91c2VTY3JvbGxcIjsgIC8vIEZvciBGaXJlZm94XG4gICAgfVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoXCJvblwiICsgYWN0aW9uLCBsaXN0ZW5lcik7ICAvLyBJRSBicm93c2Vyc1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gICAgIGVsZW1lbnQgICAgICAgICBBbiBodG1sIGRvbSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICBhY3Rpb24gICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LCBmb3IgZXhhbXBsZSBcIm1vdXNlZG93blwiXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSAgICBsaXN0ZW5lciAgICAgICAgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBbdXNlQ2FwdHVyZV1cbiAqL1xuZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgaWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIC8vIG5vbi1JRSBicm93c2Vyc1xuICAgIGlmICh1c2VDYXB0dXJlID09PSB1bmRlZmluZWQpXG4gICAgICB1c2VDYXB0dXJlID0gZmFsc2U7XG5cbiAgICBpZiAoYWN0aW9uID09PSBcIm1vdXNld2hlZWxcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpID49IDApIHtcbiAgICAgIGFjdGlvbiA9IFwiRE9NTW91c2VTY3JvbGxcIjsgIC8vIEZvciBGaXJlZm94XG4gICAgfVxuXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIC8vIElFIGJyb3dzZXJzXG4gICAgZWxlbWVudC5kZXRhY2hFdmVudChcIm9uXCIgKyBhY3Rpb24sIGxpc3RlbmVyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYW5jZWxzIHRoZSBldmVudCBpZiBpdCBpcyBjYW5jZWxhYmxlLCB3aXRob3V0IHN0b3BwaW5nIGZ1cnRoZXIgcHJvcGFnYXRpb24gb2YgdGhlIGV2ZW50LlxuICovXG5leHBvcnRzLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICghZXZlbnQpXG4gICAgZXZlbnQgPSB3aW5kb3cuZXZlbnQ7XG5cbiAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgIC8vIG5vbi1JRSBicm93c2Vyc1xuICB9XG4gIGVsc2Uge1xuICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7ICAvLyBJRSBicm93c2Vyc1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBIVE1MIGVsZW1lbnQgd2hpY2ggaXMgdGhlIHRhcmdldCBvZiB0aGUgZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtFbGVtZW50fSB0YXJnZXQgZWxlbWVudFxuICovXG5leHBvcnRzLmdldFRhcmdldCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBjb2RlIGZyb20gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gIGlmICghZXZlbnQpIHtcbiAgICBldmVudCA9IHdpbmRvdy5ldmVudDtcbiAgfVxuXG4gIHZhciB0YXJnZXQ7XG5cbiAgaWYgKGV2ZW50LnRhcmdldCkge1xuICAgIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgfVxuICBlbHNlIGlmIChldmVudC5zcmNFbGVtZW50KSB7XG4gICAgdGFyZ2V0ID0gZXZlbnQuc3JjRWxlbWVudDtcbiAgfVxuXG4gIGlmICh0YXJnZXQubm9kZVR5cGUgIT0gdW5kZWZpbmVkICYmIHRhcmdldC5ub2RlVHlwZSA9PSAzKSB7XG4gICAgLy8gZGVmZWF0IFNhZmFyaSBidWdcbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGdpdmVuIGVsZW1lbnQgY29udGFpbnMgZ2l2ZW4gcGFyZW50IHNvbWV3aGVyZSBpbiB0aGUgRE9NIHRyZWVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZXhwb3J0cy5oYXNQYXJlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgcGFyZW50KSB7XG4gIHZhciBlID0gZWxlbWVudDtcblxuICB3aGlsZSAoZSkge1xuICAgIGlmIChlID09PSBwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlID0gZS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0cy5vcHRpb24gPSB7fTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIGJvb2xlYW5cbiAqIEBwYXJhbSB7Qm9vbGVhbiB8IGZ1bmN0aW9uIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICogQHBhcmFtIHtCb29sZWFufSBbZGVmYXVsdFZhbHVlXVxuICogQHJldHVybnMge0Jvb2xlYW59IGJvb2xcbiAqL1xuZXhwb3J0cy5vcHRpb24uYXNCb29sZWFuID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSgpO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gKHZhbHVlICE9IGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gYSBudW1iZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbiB8IGZ1bmN0aW9uIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtkZWZhdWx0VmFsdWVdXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBudW1iZXJcbiAqL1xuZXhwb3J0cy5vcHRpb24uYXNOdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gIH1cblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpIHx8IGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmcgfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZGVmYXVsdFZhbHVlXVxuICogQHJldHVybnMge1N0cmluZ30gc3RyXG4gKi9cbmV4cG9ydHMub3B0aW9uLmFzU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSgpO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHNpemUgb3IgbG9jYXRpb24gaW50byBhIHN0cmluZyB3aXRoIHBpeGVscyBvciBhIHBlcmNlbnRhZ2VcbiAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyIHwgZnVuY3Rpb24gfCB1bmRlZmluZWR9IHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gW2RlZmF1bHRWYWx1ZV1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IHNpemVcbiAqL1xuZXhwb3J0cy5vcHRpb24uYXNTaXplID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSgpO1xuICB9XG5cbiAgaWYgKGV4cG9ydHMuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGVsc2UgaWYgKGV4cG9ydHMuaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JztcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlIHx8IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gYSBET00gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IGZ1bmN0aW9uIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2RlZmF1bHRWYWx1ZV1cbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9IGRvbVxuICovXG5leHBvcnRzLm9wdGlvbi5hc0VsZW1lbnQgPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gIH1cblxuICByZXR1cm4gdmFsdWUgfHwgZGVmYXVsdFZhbHVlIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTYyMzgzOC9yZ2ItdG8taGV4LWFuZC1oZXgtdG8tcmdiXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhleFxuICogQHJldHVybnMge3tyOiAqLCBnOiAqLCBiOiAqfX0gfCAyNTUgcmFuZ2VcbiAqL1xuZXhwb3J0cy5oZXhUb1JHQiA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgLy8gRXhwYW5kIHNob3J0aGFuZCBmb3JtIChlLmcuIFwiMDNGXCIpIHRvIGZ1bGwgZm9ybSAoZS5nLiBcIjAwMzNGRlwiKVxuICB2YXIgc2hvcnRoYW5kUmVnZXggPSAvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pO1xuICBoZXggPSBoZXgucmVwbGFjZShzaG9ydGhhbmRSZWdleCwgZnVuY3Rpb24gKG0sIHIsIGcsIGIpIHtcbiAgICByZXR1cm4gciArIHIgKyBnICsgZyArIGIgKyBiO1xuICB9KTtcbiAgdmFyIHJlc3VsdCA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2kuZXhlYyhoZXgpO1xuICByZXR1cm4gcmVzdWx0ID8ge1xuICAgIHI6IHBhcnNlSW50KHJlc3VsdFsxXSwgMTYpLFxuICAgIGc6IHBhcnNlSW50KHJlc3VsdFsyXSwgMTYpLFxuICAgIGI6IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpXG4gIH0gOiBudWxsO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGNvbG9yIGluIGhleCBmb3JtYXQgb3IgcmdiKCkgb3IgcmdiYSgpIGZvcm1hdCBhbmQgb3ZlcnJpZGVzIHRoZSBvcGFjaXR5LiBSZXR1cm5zIHJnYmEoKSBzdHJpbmcuXG4gKiBAcGFyYW0gY29sb3JcbiAqIEBwYXJhbSBvcGFjaXR5XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0cy5vdmVycmlkZU9wYWNpdHkgPSBmdW5jdGlvbiAoY29sb3IsIG9wYWNpdHkpIHtcbiAgaWYgKGNvbG9yLmluZGV4T2YoXCJyZ2JhXCIpICE9IC0xKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG4gIGVsc2UgaWYgKGNvbG9yLmluZGV4T2YoXCJyZ2JcIikgIT0gLTEpIHtcbiAgICB2YXIgcmdiID0gY29sb3Iuc3Vic3RyKGNvbG9yLmluZGV4T2YoXCIoXCIpICsgMSkucmVwbGFjZShcIilcIiwgXCJcIikuc3BsaXQoXCIsXCIpO1xuICAgIHJldHVybiBcInJnYmEoXCIgKyByZ2JbMF0gKyBcIixcIiArIHJnYlsxXSArIFwiLFwiICsgcmdiWzJdICsgXCIsXCIgKyBvcGFjaXR5ICsgXCIpXCJcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgcmdiID0gZXhwb3J0cy5oZXhUb1JHQihjb2xvcik7XG4gICAgaWYgKHJnYiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFwicmdiYShcIiArIHJnYi5yICsgXCIsXCIgKyByZ2IuZyArIFwiLFwiICsgcmdiLmIgKyBcIixcIiArIG9wYWNpdHkgKyBcIilcIlxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gcmVkICAgICAwIC0tIDI1NVxuICogQHBhcmFtIGdyZWVuICAgMCAtLSAyNTVcbiAqIEBwYXJhbSBibHVlICAgIDAgLS0gMjU1XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydHMuUkdCVG9IZXggPSBmdW5jdGlvbiAocmVkLCBncmVlbiwgYmx1ZSkge1xuICByZXR1cm4gXCIjXCIgKyAoKDEgPDwgMjQpICsgKHJlZCA8PCAxNikgKyAoZ3JlZW4gPDwgOCkgKyBibHVlKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgY29sb3IgcHJvcGVydHkgaW50byBhbiBvYmplY3Qgd2l0aCBib3JkZXIsIGJhY2tncm91bmQsIGFuZFxuICogaGlnaGxpZ2h0IGNvbG9yc1xuICogQHBhcmFtIHtPYmplY3QgfCBTdHJpbmd9IGNvbG9yXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNvbG9yT2JqZWN0XG4gKi9cbmV4cG9ydHMucGFyc2VDb2xvciA9IGZ1bmN0aW9uIChjb2xvcikge1xuICB2YXIgYztcbiAgaWYgKGV4cG9ydHMuaXNTdHJpbmcoY29sb3IpID09PSB0cnVlKSB7XG4gICAgaWYgKGV4cG9ydHMuaXNWYWxpZFJHQihjb2xvcikgPT09IHRydWUpIHtcbiAgICAgIHZhciByZ2IgPSBjb2xvci5zdWJzdHIoNCkuc3Vic3RyKDAsIGNvbG9yLmxlbmd0aCAtIDUpLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gcGFyc2VJbnQodmFsdWUpIH0pO1xuICAgICAgY29sb3IgPSBleHBvcnRzLlJHQlRvSGV4KHJnYlswXSwgcmdiWzFdLCByZ2JbMl0pO1xuICAgIH1cbiAgICBpZiAoZXhwb3J0cy5pc1ZhbGlkSGV4KGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIGhzdiA9IGV4cG9ydHMuaGV4VG9IU1YoY29sb3IpO1xuICAgICAgdmFyIGxpZ2h0ZXJDb2xvckhTViA9IHsgaDogaHN2LmgsIHM6IGhzdi5zICogMC44LCB2OiBNYXRoLm1pbigxLCBoc3YudiAqIDEuMDIpIH07XG4gICAgICB2YXIgZGFya2VyQ29sb3JIU1YgPSB7IGg6IGhzdi5oLCBzOiBNYXRoLm1pbigxLCBoc3YucyAqIDEuMjUpLCB2OiBoc3YudiAqIDAuOCB9O1xuICAgICAgdmFyIGRhcmtlckNvbG9ySGV4ID0gZXhwb3J0cy5IU1ZUb0hleChkYXJrZXJDb2xvckhTVi5oLCBkYXJrZXJDb2xvckhTVi5zLCBkYXJrZXJDb2xvckhTVi52KTtcbiAgICAgIHZhciBsaWdodGVyQ29sb3JIZXggPSBleHBvcnRzLkhTVlRvSGV4KGxpZ2h0ZXJDb2xvckhTVi5oLCBsaWdodGVyQ29sb3JIU1YucywgbGlnaHRlckNvbG9ySFNWLnYpO1xuICAgICAgYyA9IHtcbiAgICAgICAgYmFja2dyb3VuZDogY29sb3IsXG4gICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXgsXG4gICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGxpZ2h0ZXJDb2xvckhleCxcbiAgICAgICAgICBib3JkZXI6IGRhcmtlckNvbG9ySGV4XG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogbGlnaHRlckNvbG9ySGV4LFxuICAgICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXhcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjID0ge1xuICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvcixcbiAgICAgICAgYm9yZGVyOiBjb2xvcixcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogY29sb3IsXG4gICAgICAgICAgYm9yZGVyOiBjb2xvclxuICAgICAgICB9LFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9yLFxuICAgICAgICAgIGJvcmRlcjogY29sb3JcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgYyA9IHt9O1xuICAgIGMuYmFja2dyb3VuZCA9IGNvbG9yLmJhY2tncm91bmQgfHwgdW5kZWZpbmVkO1xuICAgIGMuYm9yZGVyID0gY29sb3IuYm9yZGVyIHx8IHVuZGVmaW5lZDtcblxuICAgIGlmIChleHBvcnRzLmlzU3RyaW5nKGNvbG9yLmhpZ2hsaWdodCkpIHtcbiAgICAgIGMuaGlnaGxpZ2h0ID0ge1xuICAgICAgICBib3JkZXI6IGNvbG9yLmhpZ2hsaWdodCxcbiAgICAgICAgYmFja2dyb3VuZDogY29sb3IuaGlnaGxpZ2h0XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYy5oaWdobGlnaHQgPSB7fTtcbiAgICAgIGMuaGlnaGxpZ2h0LmJhY2tncm91bmQgPSBjb2xvci5oaWdobGlnaHQgJiYgY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgfHwgdW5kZWZpbmVkO1xuICAgICAgYy5oaWdobGlnaHQuYm9yZGVyID0gY29sb3IuaGlnaGxpZ2h0ICYmIGNvbG9yLmhpZ2hsaWdodC5ib3JkZXIgfHwgdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChleHBvcnRzLmlzU3RyaW5nKGNvbG9yLmhvdmVyKSkge1xuICAgICAgYy5ob3ZlciA9IHtcbiAgICAgICAgYm9yZGVyOiBjb2xvci5ob3ZlcixcbiAgICAgICAgYmFja2dyb3VuZDogY29sb3IuaG92ZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjLmhvdmVyID0ge307XG4gICAgICBjLmhvdmVyLmJhY2tncm91bmQgPSBjb2xvci5ob3ZlciAmJiBjb2xvci5ob3Zlci5iYWNrZ3JvdW5kIHx8IHVuZGVmaW5lZDtcbiAgICAgIGMuaG92ZXIuYm9yZGVyID0gY29sb3IuaG92ZXIgJiYgY29sb3IuaG92ZXIuYm9yZGVyIHx8IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYztcbn07XG5cblxuXG4vKipcbiAqIGh0dHA6Ly93d3cuamF2YXNjcmlwdGVyLm5ldC9mYXEvcmdiMmhzdi5odG1cbiAqXG4gKiBAcGFyYW0gcmVkXG4gKiBAcGFyYW0gZ3JlZW5cbiAqIEBwYXJhbSBibHVlXG4gKiBAcmV0dXJucyB7Kn1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnRzLlJHQlRvSFNWID0gZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgcmVkID0gcmVkIC8gMjU1OyBncmVlbiA9IGdyZWVuIC8gMjU1OyBibHVlID0gYmx1ZSAvIDI1NTtcbiAgdmFyIG1pblJHQiA9IE1hdGgubWluKHJlZCwgTWF0aC5taW4oZ3JlZW4sIGJsdWUpKTtcbiAgdmFyIG1heFJHQiA9IE1hdGgubWF4KHJlZCwgTWF0aC5tYXgoZ3JlZW4sIGJsdWUpKTtcblxuICAvLyBCbGFjay1ncmF5LXdoaXRlXG4gIGlmIChtaW5SR0IgPT0gbWF4UkdCKSB7XG4gICAgcmV0dXJuIHsgaDogMCwgczogMCwgdjogbWluUkdCIH07XG4gIH1cblxuICAvLyBDb2xvcnMgb3RoZXIgdGhhbiBibGFjay1ncmF5LXdoaXRlOlxuICB2YXIgZCA9IChyZWQgPT0gbWluUkdCKSA/IGdyZWVuIC0gYmx1ZSA6ICgoYmx1ZSA9PSBtaW5SR0IpID8gcmVkIC0gZ3JlZW4gOiBibHVlIC0gcmVkKTtcbiAgdmFyIGggPSAocmVkID09IG1pblJHQikgPyAzIDogKChibHVlID09IG1pblJHQikgPyAxIDogNSk7XG4gIHZhciBodWUgPSA2MCAqIChoIC0gZCAvIChtYXhSR0IgLSBtaW5SR0IpKSAvIDM2MDtcbiAgdmFyIHNhdHVyYXRpb24gPSAobWF4UkdCIC0gbWluUkdCKSAvIG1heFJHQjtcbiAgdmFyIHZhbHVlID0gbWF4UkdCO1xuICByZXR1cm4geyBoOiBodWUsIHM6IHNhdHVyYXRpb24sIHY6IHZhbHVlIH07XG59O1xuXG52YXIgY3NzVXRpbCA9IHtcbiAgLy8gc3BsaXQgYSBzdHJpbmcgd2l0aCBjc3Mgc3R5bGVzIGludG8gYW4gb2JqZWN0IHdpdGgga2V5L3ZhbHVlc1xuICBzcGxpdDogZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICB2YXIgc3R5bGVzID0ge307XG5cbiAgICBjc3NUZXh0LnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIGlmIChzdHlsZS50cmltKCkgIT0gJycpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gc3R5bGUuc3BsaXQoJzonKTtcbiAgICAgICAgdmFyIGtleSA9IHBhcnRzWzBdLnRyaW0oKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHNbMV0udHJpbSgpO1xuICAgICAgICBzdHlsZXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfSxcblxuICAvLyBidWlsZCBhIGNzcyB0ZXh0IHN0cmluZyBmcm9tIGFuIG9iamVjdCB3aXRoIGtleS92YWx1ZXNcbiAgam9pbjogZnVuY3Rpb24gKHN0eWxlcykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdHlsZXMpXG4gICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSArICc6ICcgKyBzdHlsZXNba2V5XTtcbiAgICAgIH0pXG4gICAgICAuam9pbignOyAnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBcHBlbmQgYSBzdHJpbmcgd2l0aCBjc3Mgc3R5bGVzIHRvIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGNzc1RleHRcbiAqL1xuZXhwb3J0cy5hZGRDc3NUZXh0ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNzc1RleHQpIHtcbiAgdmFyIGN1cnJlbnRTdHlsZXMgPSBjc3NVdGlsLnNwbGl0KGVsZW1lbnQuc3R5bGUuY3NzVGV4dCk7XG4gIHZhciBuZXdTdHlsZXMgPSBjc3NVdGlsLnNwbGl0KGNzc1RleHQpO1xuICB2YXIgc3R5bGVzID0gZXhwb3J0cy5leHRlbmQoY3VycmVudFN0eWxlcywgbmV3U3R5bGVzKTtcblxuICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBjc3NVdGlsLmpvaW4oc3R5bGVzKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgc3RyaW5nIHdpdGggY3NzIHN0eWxlcyBmcm9tIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGNzc1RleHRcbiAqL1xuZXhwb3J0cy5yZW1vdmVDc3NUZXh0ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNzc1RleHQpIHtcbiAgdmFyIHN0eWxlcyA9IGNzc1V0aWwuc3BsaXQoZWxlbWVudC5zdHlsZS5jc3NUZXh0KTtcbiAgdmFyIHJlbW92ZVN0eWxlcyA9IGNzc1V0aWwuc3BsaXQoY3NzVGV4dCk7XG5cbiAgZm9yICh2YXIga2V5IGluIHJlbW92ZVN0eWxlcykge1xuICAgIGlmIChyZW1vdmVTdHlsZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgZGVsZXRlIHN0eWxlc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGNzc1V0aWwuam9pbihzdHlsZXMpO1xufTtcblxuLyoqXG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tamlqYWNrc29uLzUzMTEyNTZcbiAqIEBwYXJhbSBoXG4gKiBAcGFyYW0gc1xuICogQHBhcmFtIHZcbiAqIEByZXR1cm5zIHt7cjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcn19XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0cy5IU1ZUb1JHQiA9IGZ1bmN0aW9uIChoLCBzLCB2KSB7XG4gIHZhciByLCBnLCBiO1xuXG4gIHZhciBpID0gTWF0aC5mbG9vcihoICogNik7XG4gIHZhciBmID0gaCAqIDYgLSBpO1xuICB2YXIgcCA9IHYgKiAoMSAtIHMpO1xuICB2YXIgcSA9IHYgKiAoMSAtIGYgKiBzKTtcbiAgdmFyIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG5cbiAgc3dpdGNoIChpICUgNikge1xuICAgIGNhc2UgMDogciA9IHYsIGcgPSB0LCBiID0gcDsgYnJlYWs7XG4gICAgY2FzZSAxOiByID0gcSwgZyA9IHYsIGIgPSBwOyBicmVhaztcbiAgICBjYXNlIDI6IHIgPSBwLCBnID0gdiwgYiA9IHQ7IGJyZWFrO1xuICAgIGNhc2UgMzogciA9IHAsIGcgPSBxLCBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA0OiByID0gdCwgZyA9IHAsIGIgPSB2OyBicmVhaztcbiAgICBjYXNlIDU6IHIgPSB2LCBnID0gcCwgYiA9IHE7IGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHsgcjogTWF0aC5mbG9vcihyICogMjU1KSwgZzogTWF0aC5mbG9vcihnICogMjU1KSwgYjogTWF0aC5mbG9vcihiICogMjU1KSB9O1xufTtcblxuZXhwb3J0cy5IU1ZUb0hleCA9IGZ1bmN0aW9uIChoLCBzLCB2KSB7XG4gIHZhciByZ2IgPSBleHBvcnRzLkhTVlRvUkdCKGgsIHMsIHYpO1xuICByZXR1cm4gZXhwb3J0cy5SR0JUb0hleChyZ2IuciwgcmdiLmcsIHJnYi5iKTtcbn07XG5cbmV4cG9ydHMuaGV4VG9IU1YgPSBmdW5jdGlvbiAoaGV4KSB7XG4gIHZhciByZ2IgPSBleHBvcnRzLmhleFRvUkdCKGhleCk7XG4gIHJldHVybiBleHBvcnRzLlJHQlRvSFNWKHJnYi5yLCByZ2IuZywgcmdiLmIpO1xufTtcblxuZXhwb3J0cy5pc1ZhbGlkSGV4ID0gZnVuY3Rpb24gKGhleCkge1xuICB2YXIgaXNPayA9IC8oXiNbMC05QS1GXXs2fSQpfCheI1swLTlBLUZdezN9JCkvaS50ZXN0KGhleCk7XG4gIHJldHVybiBpc09rO1xufTtcblxuZXhwb3J0cy5pc1ZhbGlkUkdCID0gZnVuY3Rpb24gKHJnYikge1xuICByZ2IgPSByZ2IucmVwbGFjZShcIiBcIiwgXCJcIik7XG4gIHZhciBpc09rID0gL3JnYlxcKChcXGR7MSwzfSksKFxcZHsxLDN9KSwoXFxkezEsM30pXFwpL2kudGVzdChyZ2IpO1xuICByZXR1cm4gaXNPaztcbn1cbmV4cG9ydHMuaXNWYWxpZFJHQkEgPSBmdW5jdGlvbiAocmdiYSkge1xuICByZ2JhID0gcmdiYS5yZXBsYWNlKFwiIFwiLCBcIlwiKTtcbiAgdmFyIGlzT2sgPSAvcmdiYVxcKChcXGR7MSwzfSksKFxcZHsxLDN9KSwoXFxkezEsM30pLCguezEsM30pXFwpL2kudGVzdChyZ2JhKTtcbiAgcmV0dXJuIGlzT2s7XG59XG5cbi8qKlxuICogVGhpcyByZWN1cnNpdmVseSByZWRpcmVjdHMgdGhlIHByb3RvdHlwZSBvZiBKU09OIG9iamVjdHMgdG8gdGhlIHJlZmVyZW5jZU9iamVjdFxuICogVGhpcyBpcyB1c2VkIGZvciBkZWZhdWx0IG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHJlZmVyZW5jZU9iamVjdFxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMuc2VsZWN0aXZlQnJpZGdlT2JqZWN0ID0gZnVuY3Rpb24gKGZpZWxkcywgcmVmZXJlbmNlT2JqZWN0KSB7XG4gIGlmICh0eXBlb2YgcmVmZXJlbmNlT2JqZWN0ID09IFwib2JqZWN0XCIpIHtcbiAgICB2YXIgb2JqZWN0VG8gPSBPYmplY3QuY3JlYXRlKHJlZmVyZW5jZU9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWZlcmVuY2VPYmplY3QuaGFzT3duUHJvcGVydHkoZmllbGRzW2ldKSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlZmVyZW5jZU9iamVjdFtmaWVsZHNbaV1dID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBvYmplY3RUb1tmaWVsZHNbaV1dID0gZXhwb3J0cy5icmlkZ2VPYmplY3QocmVmZXJlbmNlT2JqZWN0W2ZpZWxkc1tpXV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RUbztcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIHJlY3Vyc2l2ZWx5IHJlZGlyZWN0cyB0aGUgcHJvdG90eXBlIG9mIEpTT04gb2JqZWN0cyB0byB0aGUgcmVmZXJlbmNlT2JqZWN0XG4gKiBUaGlzIGlzIHVzZWQgZm9yIGRlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gcmVmZXJlbmNlT2JqZWN0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0cy5icmlkZ2VPYmplY3QgPSBmdW5jdGlvbiAocmVmZXJlbmNlT2JqZWN0KSB7XG4gIGlmICh0eXBlb2YgcmVmZXJlbmNlT2JqZWN0ID09IFwib2JqZWN0XCIpIHtcbiAgICB2YXIgb2JqZWN0VG8gPSBPYmplY3QuY3JlYXRlKHJlZmVyZW5jZU9iamVjdCk7XG4gICAgZm9yICh2YXIgaSBpbiByZWZlcmVuY2VPYmplY3QpIHtcbiAgICAgIGlmIChyZWZlcmVuY2VPYmplY3QuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWZlcmVuY2VPYmplY3RbaV0gPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIG9iamVjdFRvW2ldID0gZXhwb3J0cy5icmlkZ2VPYmplY3QocmVmZXJlbmNlT2JqZWN0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0VG87XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cblxuLyoqXG4gKiB0aGlzIGlzIHVzZWQgdG8gc2V0IHRoZSBvcHRpb25zIG9mIHN1Ym9iamVjdHMgaW4gdGhlIG9wdGlvbnMgb2JqZWN0LiBBIHJlcXVpcmVtZW50IG9mIHRoZXNlIHN1Ym9iamVjdHNcbiAqIGlzIHRoYXQgdGhleSBoYXZlIGFuICdlbmFibGVkJyBlbGVtZW50IHdoaWNoIGlzIG9wdGlvbmFsIGZvciB0aGUgdXNlciBidXQgbWFuZGF0b3J5IGZvciB0aGUgcHJvZ3JhbS5cbiAqXG4gKiBAcGFyYW0gW29iamVjdF0gbWVyZ2VUYXJnZXQgfCB0aGlzIGlzIGVpdGhlciB0aGlzLm9wdGlvbnMgb3IgdGhlIG9wdGlvbnMgdXNlZCBmb3IgdGhlIGdyb3Vwcy5cbiAqIEBwYXJhbSBbb2JqZWN0XSBvcHRpb25zICAgICB8IG9wdGlvbnNcbiAqIEBwYXJhbSBbU3RyaW5nXSBvcHRpb24gICAgICB8IHRoaXMgaXMgdGhlIG9wdGlvbiBrZXkgaW4gdGhlIG9wdGlvbnMgYXJndW1lbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG1lcmdlVGFyZ2V0LCBvcHRpb25zLCBvcHRpb24sIGFsbG93RGVsZXRpb24gPSBmYWxzZSwgZ2xvYmFsT3B0aW9ucyA9IHt9KSB7XG4gIGlmIChvcHRpb25zW29wdGlvbl0gPT09IG51bGwpIHtcbiAgICBtZXJnZVRhcmdldFtvcHRpb25dID0gT2JqZWN0LmNyZWF0ZShnbG9iYWxPcHRpb25zW29wdGlvbl0pO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmIChvcHRpb25zW29wdGlvbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zW29wdGlvbl0gPT09ICdib29sZWFuJykge1xuICAgICAgICBtZXJnZVRhcmdldFtvcHRpb25dLmVuYWJsZWQgPSBvcHRpb25zW29wdGlvbl07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbnNbb3B0aW9uXS5lbmFibGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBtZXJnZVRhcmdldFtvcHRpb25dLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9uc1tvcHRpb25dKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnNbb3B0aW9uXS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgbWVyZ2VUYXJnZXRbb3B0aW9uXVtwcm9wXSA9IG9wdGlvbnNbb3B0aW9uXVtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBhIGJpbmFyeSBzZWFyY2ggZm9yIGEgdmlzaWJsZSBpdGVtIGluIGEgc29ydGVkIGxpc3QuIElmIHdlIGZpbmQgYSB2aXNpYmxlIGl0ZW0sIHRoZSBjb2RlIHRoYXQgdXNlc1xuICogdGhpcyBmdW5jdGlvbiB3aWxsIHRoZW4gaXRlcmF0ZSBpbiBib3RoIGRpcmVjdGlvbnMgb3ZlciB0aGlzIHNvcnRlZCBsaXN0IHRvIGZpbmQgYWxsIHZpc2libGUgaXRlbXMuXG4gKlxuICogQHBhcmFtIHtJdGVtW119IG9yZGVyZWRJdGVtcyAgICAgICB8IEl0ZW1zIG9yZGVyZWQgYnkgc3RhcnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHNlYXJjaEZ1bmN0aW9uICAgfCAtMSBpcyBsb3dlciwgMCBpcyBmb3VuZCwgMSBpcyBoaWdoZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkMlxuICogQHJldHVybnMge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYmluYXJ5U2VhcmNoQ3VzdG9tID0gZnVuY3Rpb24gKG9yZGVyZWRJdGVtcywgc2VhcmNoRnVuY3Rpb24sIGZpZWxkLCBmaWVsZDIpIHtcbiAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDAwMDtcbiAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gIHZhciBsb3cgPSAwO1xuICB2YXIgaGlnaCA9IG9yZGVyZWRJdGVtcy5sZW5ndGggLSAxO1xuXG4gIHdoaWxlIChsb3cgPD0gaGlnaCAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG5cbiAgICB2YXIgaXRlbSA9IG9yZGVyZWRJdGVtc1ttaWRkbGVdO1xuICAgIHZhciB2YWx1ZSA9IChmaWVsZDIgPT09IHVuZGVmaW5lZCkgPyBpdGVtW2ZpZWxkXSA6IGl0ZW1bZmllbGRdW2ZpZWxkMl07XG5cbiAgICB2YXIgc2VhcmNoUmVzdWx0ID0gc2VhcmNoRnVuY3Rpb24odmFsdWUpO1xuICAgIGlmIChzZWFyY2hSZXN1bHQgPT0gMCkgeyAvLyBqaWhhYSwgZm91bmQgYSB2aXNpYmxlIGl0ZW0hXG4gICAgICByZXR1cm4gbWlkZGxlO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWFyY2hSZXN1bHQgPT0gLTEpIHsgIC8vIGl0IGlzIHRvbyBzbWFsbCAtLT4gaW5jcmVhc2UgbG93XG4gICAgICBsb3cgPSBtaWRkbGUgKyAxO1xuICAgIH1cbiAgICBlbHNlIHsgIC8vIGl0IGlzIHRvbyBiaWcgLS0+IGRlY3JlYXNlIGhpZ2hcbiAgICAgIGhpZ2ggPSBtaWRkbGUgLSAxO1xuICAgIH1cblxuICAgIGl0ZXJhdGlvbisrO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgYSBiaW5hcnkgc2VhcmNoIGZvciBhIHNwZWNpZmljIHZhbHVlIGluIGEgc29ydGVkIGFycmF5LiBJZiBpdCBkb2VzIG5vdCBleGlzdCBidXQgaXMgaW4gYmV0d2VlbiBvZlxuICogdHdvIHZhbHVlcywgd2UgcmV0dXJuIGVpdGhlciB0aGUgb25lIGJlZm9yZSBvciB0aGUgb25lIGFmdGVyLCBkZXBlbmRpbmcgb24gdXNlciBpbnB1dFxuICogSWYgaXQgaXMgZm91bmQsIHdlIHJldHVybiB0aGUgaW5kZXgsIGVsc2UgLTEuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gb3JkZXJlZEl0ZW1zXG4gKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lkZVByZWZlcmVuY2UgICAnYmVmb3JlJyBvciAnYWZ0ZXInXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5iaW5hcnlTZWFyY2hWYWx1ZSA9IGZ1bmN0aW9uIChvcmRlcmVkSXRlbXMsIHRhcmdldCwgZmllbGQsIHNpZGVQcmVmZXJlbmNlKSB7XG4gIHZhciBtYXhJdGVyYXRpb25zID0gMTAwMDA7XG4gIHZhciBpdGVyYXRpb24gPSAwO1xuICB2YXIgbG93ID0gMDtcbiAgdmFyIGhpZ2ggPSBvcmRlcmVkSXRlbXMubGVuZ3RoIC0gMTtcbiAgdmFyIHByZXZWYWx1ZSwgdmFsdWUsIG5leHRWYWx1ZSwgbWlkZGxlO1xuXG4gIHdoaWxlIChsb3cgPD0gaGlnaCAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgLy8gZ2V0IGEgbmV3IGd1ZXNzXG4gICAgbWlkZGxlID0gTWF0aC5mbG9vcigwLjUgKiAoaGlnaCArIGxvdykpO1xuICAgIHByZXZWYWx1ZSA9IG9yZGVyZWRJdGVtc1tNYXRoLm1heCgwLCBtaWRkbGUgLSAxKV1bZmllbGRdO1xuICAgIHZhbHVlID0gb3JkZXJlZEl0ZW1zW21pZGRsZV1bZmllbGRdO1xuICAgIG5leHRWYWx1ZSA9IG9yZGVyZWRJdGVtc1tNYXRoLm1pbihvcmRlcmVkSXRlbXMubGVuZ3RoIC0gMSwgbWlkZGxlICsgMSldW2ZpZWxkXTtcblxuICAgIGlmICh2YWx1ZSA9PSB0YXJnZXQpIHsgLy8gd2UgZm91bmQgdGhlIHRhcmdldFxuICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJldlZhbHVlIDwgdGFyZ2V0ICYmIHZhbHVlID4gdGFyZ2V0KSB7ICAvLyB0YXJnZXQgaXMgaW4gYmV0d2VlbiBvZiB0aGUgcHJldmlvdXMgYW5kIHRoZSBjdXJyZW50XG4gICAgICByZXR1cm4gc2lkZVByZWZlcmVuY2UgPT0gJ2JlZm9yZScgPyBNYXRoLm1heCgwLCBtaWRkbGUgLSAxKSA6IG1pZGRsZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgPCB0YXJnZXQgJiYgbmV4dFZhbHVlID4gdGFyZ2V0KSB7IC8vIHRhcmdldCBpcyBpbiBiZXR3ZWVuIG9mIHRoZSBjdXJyZW50IGFuZCB0aGUgbmV4dFxuICAgICAgcmV0dXJuIHNpZGVQcmVmZXJlbmNlID09ICdiZWZvcmUnID8gbWlkZGxlIDogTWF0aC5taW4ob3JkZXJlZEl0ZW1zLmxlbmd0aCAtIDEsIG1pZGRsZSArIDEpO1xuICAgIH1cbiAgICBlbHNlIHsgIC8vIGRpZG50IGZpbmQgdGhlIHRhcmdldCwgd2UgbmVlZCB0byBjaGFuZ2Ugb3VyIGJvdW5kYXJpZXMuXG4gICAgICBpZiAodmFsdWUgPCB0YXJnZXQpIHsgLy8gaXQgaXMgdG9vIHNtYWxsIC0tPiBpbmNyZWFzZSBsb3dcbiAgICAgICAgbG93ID0gbWlkZGxlICsgMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgeyAgLy8gaXQgaXMgdG9vIGJpZyAtLT4gZGVjcmVhc2UgaGlnaFxuICAgICAgICBoaWdoID0gbWlkZGxlIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaXRlcmF0aW9uKys7XG4gIH1cblxuICAvLyBkaWRudCBmaW5kIGFueXRoaW5nLiBSZXR1cm4gLTEuXG4gIHJldHVybiAtMTtcbn07XG5cbi8qXG4gKiBFYXNpbmcgRnVuY3Rpb25zIC0gaW5zcGlyZWQgZnJvbSBodHRwOi8vZ2l6bWEuY29tL2Vhc2luZy9cbiAqIG9ubHkgY29uc2lkZXJpbmcgdGhlIHQgdmFsdWUgZm9yIHRoZSByYW5nZSBbMCwgMV0gPT4gWzAsIDFdXG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ncmUvMTY1MDI5NFxuICovXG5leHBvcnRzLmVhc2luZ0Z1bmN0aW9ucyA9IHtcbiAgLy8gbm8gZWFzaW5nLCBubyBhY2NlbGVyYXRpb25cbiAgbGluZWFyOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0XG4gIH0sXG4gIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgZWFzZUluUXVhZDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCAqIHRcbiAgfSxcbiAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgZWFzZU91dFF1YWQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgKiAoMiAtIHQpXG4gIH0sXG4gIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0IDwgLjUgPyAyICogdCAqIHQgOiAtMSArICg0IC0gMiAqIHQpICogdFxuICB9LFxuICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VJbkN1YmljOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0ICogdCAqIHRcbiAgfSxcbiAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgZWFzZU91dEN1YmljOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiAoLS10KSAqIHQgKiB0ICsgMVxuICB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgPCAuNSA/IDQgKiB0ICogdCAqIHQgOiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDFcbiAgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5RdWFydDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdFxuICB9LFxuICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICBlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIDEgLSAoLS10KSAqIHQgKiB0ICogdFxuICB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgPCAuNSA/IDggKiB0ICogdCAqIHQgKiB0IDogMSAtIDggKiAoLS10KSAqIHQgKiB0ICogdFxuICB9LFxuICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VJblF1aW50OiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0ICogdCAqIHQgKiB0ICogdFxuICB9LFxuICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICBlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIDEgKyAoLS10KSAqIHQgKiB0ICogdCAqIHRcbiAgfSxcbiAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gIGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0IDwgLjUgPyAxNiAqIHQgKiB0ICogdCAqIHQgKiB0IDogMSArIDE2ICogKC0tdCkgKiB0ICogdCAqIHQgKiB0XG4gIH1cbn07XG4iXX0=
},{"./module/moment":20,"./module/uuid":21}]},{},[1])(1)
});